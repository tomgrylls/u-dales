var tipuesearch = {"pages":[{"title":" uDALES ","text":"uDALES Developer Info The uDALES Team","tags":"home","loc":"index.html"},{"title":"modstatsdump.f90 – uDALES","text":"This file depends on sourcefile~~modstatsdump.f90~~EfferentGraph sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~modstatsdump.f90->sourcefile~modsubgrid.f90 sourcefile~modstat_nc.f90 modstat_nc.f90 sourcefile~modstatsdump.f90->sourcefile~modstat_nc.f90 sourcefile~modsurfdata.f90 modsurfdata.f90 sourcefile~modstatsdump.f90->sourcefile~modsurfdata.f90 sourcefile~modstatistics.f90 modstatistics.f90 sourcefile~modstatsdump.f90->sourcefile~modstatistics.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modstatsdump.f90->sourcefile~modfields.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modstatsdump.f90->sourcefile~modglobal.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modstatsdump.f90->sourcefile~modmpi.f90 sourcefile~modsubgrid.f90->sourcefile~modsurfdata.f90 sourcefile~modsubgrid.f90->sourcefile~modfields.f90 sourcefile~modsubgrid.f90->sourcefile~modglobal.f90 sourcefile~modsubgrid.f90->sourcefile~modmpi.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~modsubgrid.f90->sourcefile~modsubgriddata.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~modsubgrid.f90->sourcefile~modboundary.f90 sourcefile~modinletdata.f90 modinletdata.f90 sourcefile~modsubgrid.f90->sourcefile~modinletdata.f90 sourcefile~modstat_nc.f90->sourcefile~modglobal.f90 sourcefile~modstat_nc.f90->sourcefile~modmpi.f90 sourcefile~modstatistics.f90->sourcefile~modstat_nc.f90 sourcefile~modstatistics.f90->sourcefile~modsurfdata.f90 sourcefile~modstatistics.f90->sourcefile~modfields.f90 sourcefile~modstatistics.f90->sourcefile~modglobal.f90 sourcefile~modstatistics.f90->sourcefile~modmpi.f90 sourcefile~modstatistics.f90->sourcefile~modsubgriddata.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 sourcefile~modboundary.f90->sourcefile~modsurfdata.f90 sourcefile~modboundary.f90->sourcefile~modfields.f90 sourcefile~modboundary.f90->sourcefile~modglobal.f90 sourcefile~modboundary.f90->sourcefile~modmpi.f90 sourcefile~modboundary.f90->sourcefile~modsubgriddata.f90 sourcefile~modboundary.f90->sourcefile~modinletdata.f90 sourcefile~moddriver.f90 moddriver.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~modinlet.f90 modinlet.f90 sourcefile~modboundary.f90->sourcefile~modinlet.f90 sourcefile~moddriver.f90->sourcefile~modfields.f90 sourcefile~moddriver.f90->sourcefile~modglobal.f90 sourcefile~moddriver.f90->sourcefile~modmpi.f90 sourcefile~moddriver.f90->sourcefile~modinletdata.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~modinlet.f90->sourcefile~modsurfdata.f90 sourcefile~modinlet.f90->sourcefile~modfields.f90 sourcefile~modinlet.f90->sourcefile~modglobal.f90 sourcefile~modinlet.f90->sourcefile~modmpi.f90 sourcefile~modinlet.f90->sourcefile~modinletdata.f90 sourcefile~modinlet.f90->sourcefile~modsave.f90 sourcefile~modsave.f90->sourcefile~modsurfdata.f90 sourcefile~modsave.f90->sourcefile~modfields.f90 sourcefile~modsave.f90->sourcefile~modglobal.f90 sourcefile~modsave.f90->sourcefile~modmpi.f90 sourcefile~modsave.f90->sourcefile~modsubgriddata.f90 sourcefile~modsave.f90->sourcefile~modinletdata.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~modsave.f90->sourcefile~modibmdata.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~modsave.f90->sourcefile~initfac.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~modstatsdump.f90~~AfferentGraph sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules modstatsdump Source Code modstatsdump.f90 Source Code !> \\file modstatsdump.f90 !!  Dumps statistics of various fields !> !!  \\author Tom Grylls, ICL May 25 2016 ! !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! module modstatsdump use modglobal , only : dt , lydump , lytdump , ltkedump , lxydump , lxytdump , ltdump , ifoutput !,nstat use modmpi , only : myid implicit none private PUBLIC :: initstatsdump , statsdump , exitstatsdump save !NetCDF variables integer :: ncidy , ncidyt , ncidtke , ncidxy , ncidslice , ncidxyt , nrecy = 0 , nrecyt = 0 , nrectke = 0 , nrecxy = 0 ,& nrecslice = 0 , nrecxyt = 0 , nstatyt = 34 , nstaty = 14 , nstattke = 8 , nstatxy = 15 , nstatslice = 8 ,& nstatxyt = 23 , ncidt , nrect = 0 , nstatt = 32 character ( 80 ) :: yname = 'ydump.xxx.nc' character ( 80 ) :: ytname = 'ytdump.xxx.nc' character ( 80 ) :: tkename = 'tkedump.xxx.nc' character ( 80 ) :: xyname = 'xydump.xxx.nc' character ( 80 ) :: xytname = 'xytdump.xxx.nc' character ( 80 ) :: tname = 'tdump.xxx.xxx.nc' character ( 80 ) :: slicename = 'slicedump.xxx.xxx.nc' character ( 80 ), dimension ( 1 , 4 ) :: tncstaty character ( 80 ), dimension ( 1 , 4 ) :: tncstatyt character ( 80 ), dimension ( 1 , 4 ) :: tncstattke character ( 80 ), dimension ( 1 , 4 ) :: tncstatxy character ( 80 ), dimension ( 1 , 4 ) :: tncstatslice character ( 80 ), dimension ( 1 , 4 ) :: tncstatxyt character ( 80 ), dimension ( 1 , 4 ) :: tncstatt integer :: klow , khigh , i , j , k real :: tsamplep , tstatsdumpp , tsample , tstatsdump contains !-------------------------- !> Initializing statsdump. Read out the namelist, initializing the variables !------------------------- subroutine initstatsdump use modmpi , only : my_real , mpierr , comm3d , mpi_logical , mpi_integer , mpi_character , cmyid use modglobal , only : imax , jmax , kmax , cexpnr , ifnamopt , fname_options , kb , ke , ladaptive , btime ,& nsv , lslicedump , lxytdump use modstat_nc , only : open_nc , define_nc , ncinfo , writestat_dims_nc use modfields , only : ncstaty , ncstatyt , ncstattke , ncstatxy , ncstatslice , ncstatxyt , ncstatt implicit none integer :: ierr namelist / NAMSTATSDUMP / & lydump , tsample , klow , khigh , tstatsdump , lytdump , ltkedump , lxydump , lxytdump , ltdump allocate ( ncstaty ( nstaty , 4 )) allocate ( ncstatyt ( nstatyt , 4 )) allocate ( ncstattke ( nstattke , 4 )) allocate ( ncstatxy ( nstatxy , 4 )) allocate ( ncstatslice ( nstatslice , 4 )) allocate ( ncstatxyt ( nstatxyt , 4 )) allocate ( ncstatt ( nstatt , 4 )) klow = kb khigh = ke if ( myid == 0 ) then open ( ifnamopt , file = fname_options , status = 'old' , iostat = ierr ) read ( ifnamopt , NAMSTATSDUMP , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions NAMSTATSDUMP' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif write ( 6 , NAMSTATSDUMP ) close ( ifnamopt ) end if call MPI_BCAST ( klow , 1 , MPI_INTEGER , 0 , comm3d , ierr ) !have to do this? just want nc for first CPU call MPI_BCAST ( khigh , 1 , MPI_INTEGER , 0 , comm3d , ierr ) call MPI_BCAST ( nstatt , 1 , MPI_INTEGER , 0 , comm3d , ierr ) ! call MPI_BCAST(nstaty      ,1,MPI_INTEGER,0,comm3d,ierr) call MPI_BCAST ( ncstatyt , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( ncstaty , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( ncstattke , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( ncstatxy , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( ncstatxyt , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( ncstatt , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( ltdump , 1 , MPI_LOGICAL , 0 , comm3d , ierr ) !> Generate y-averaged NetCDF: ydump.xxx.nc if ( lydump ) then yname ( 7 : 9 ) = cexpnr call ncinfo ( tncstaty ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) call ncinfo ( ncstaty ( 1 ,:), 'uy' , 'Streamwise velocity' , 'm/s' , 'm0tt' ) call ncinfo ( ncstaty ( 2 ,:), 'vy' , 'Spanwise velocity' , 'm/s' , 't0tt' ) call ncinfo ( ncstaty ( 3 ,:), 'wy' , 'Vertical velocity' , 'm/s' , 't0mt' ) call ncinfo ( ncstaty ( 4 ,:), 'thly' , 'Temperature' , 'K' , 't0tt' ) call ncinfo ( ncstaty ( 5 ,:), 'qty' , 'Moisture' , 'kg/kg' , 't0tt' ) call ncinfo ( ncstaty ( 6 ,:), 'sca1y' , 'Scalar field 1' , 'kg/m&#94;3' , 't0tt' ) call ncinfo ( ncstaty ( 7 ,:), 'sca2y' , 'Scalar field 2' , 'kg/m&#94;3' , 't0tt' ) call ncinfo ( ncstaty ( 8 ,:), 'sca3y' , 'Scalar field 3' , 'kg/m&#94;3' , 't0tt' ) call ncinfo ( ncstaty ( 9 ,:), 'upwpy' , 'Turbulent mom. flux' , 'm&#94;2/s&#94;2' , 'm0mt' ) call ncinfo ( ncstaty ( 10 ,:), 'wpthlpy' , 'Turbulent heat flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstaty ( 11 ,:), 'usgsy' , 'SGS mom. flux' , 'm&#94;2/s&#94;2' , 'm0mt' ) call ncinfo ( ncstaty ( 12 ,:), 'thlsgsy' , 'SGS heat flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstaty ( 13 ,:), 'uwyik' , 'Advective mom. flux' , 'm&#94;2/s&#94;2' , 'm0mt' ) call ncinfo ( ncstaty ( 14 ,:), 'wthlyk' , 'Advective heat flux' , 'K m/s' , 't0mt' ) if ( myid == 0 ) then call open_nc ( yname , ncidy , nrecy , n1 = imax , n3 = khigh - klow + 1 ) if ( nrecy == 0 ) then call define_nc ( ncidy , 1 , tncstaty ) call writestat_dims_nc ( ncidy ) end if call define_nc ( ncidy , nstaty , ncstaty ) endif !myid==0 endif !> Generate time and y averaged NetCDF: ytdump.xxx.nc if ( lytdump ) then ytname ( 8 : 10 ) = cexpnr call ncinfo ( tncstatyt ( 1 ,:), 'time' , 'Sampling time' , 's' , 'time' ) call ncinfo ( ncstatyt ( 1 ,:), 'uyt' , 'Streamwise velocity' , 'm/s' , 'm0tt' ) call ncinfo ( ncstatyt ( 2 ,:), 'vyt' , 'Spanwise velocity' , 'm/s' , 't0tt' ) call ncinfo ( ncstatyt ( 3 ,:), 'wyt' , 'Vertical velocity' , 'm/s' , 't0mt' ) call ncinfo ( ncstatyt ( 4 ,:), 'thlyt' , 'Temperature' , 'K' , 't0tt' ) call ncinfo ( ncstatyt ( 5 ,:), 'qtyt' , 'Moisture' , 'kg/kg' , 't0tt' ) call ncinfo ( ncstatyt ( 6 ,:), 'sca1yt' , 'Scalar field 1' , 'kg/m&#94;3' , 't0tt' ) call ncinfo ( ncstatyt ( 7 ,:), 'sca2yt' , 'Scalar field 2' , 'kg/m&#94;3' , 't0tt' ) call ncinfo ( ncstatyt ( 8 ,:), 'sca3yt' , 'Scalar field 3' , 'kg/m&#94;3' , 't0tt' ) call ncinfo ( ncstatyt ( 9 ,:), 'upwpyt' , 'Turbulent mom. flux' , 'm&#94;2/s&#94;2' , 'm0mt' ) call ncinfo ( ncstatyt ( 10 ,:), 'wpthlpyt' , 'Turbulent heat flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 11 ,:), 'wpqtpyt' , 'Turbulent moisture flux' , 'kg/kg m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 12 ,:), 'wpsca1tpyt' , 'Turbulent scalar flux' , 'M m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 13 ,:), 'wpsca2tpyt' , 'Turbulent scalar flux' , 'M m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 14 ,:), 'wpsca3tpyt' , 'Turbulent scalar flux' , 'M m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 15 ,:), 'uwyt' , 'Kinematic mom. flux' , 'm&#94;2/s&#94;2' , 'm0mt' ) call ncinfo ( ncstatyt ( 16 ,:), 'wthlyt' , 'Kinematic heat flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 17 ,:), 'wqtyt' , 'Kinematic moisture flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 18 ,:), 'wsca1yt' , 'Kinematic scalar flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 19 ,:), 'wsca2yt' , 'Kinematic scalar flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 20 ,:), 'wsca3yt' , 'Kinematic scalar flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 21 ,:), 'upupyt' , 'mom. variance' , 'm&#94;2/s&#94;2' , 'm0tt' ) call ncinfo ( ncstatyt ( 22 ,:), 'wpwpyt' , 'mom. variance' , 'm&#94;2/s&#94;2' , 't0mt' ) call ncinfo ( ncstatyt ( 23 ,:), 'thlpthlpyt' , 'temp. variance' , 'K&#94;2' , 't0tt' ) call ncinfo ( ncstatyt ( 24 ,:), 'qtpqtpyt' , 'moisture. variance' , 'kg&#94;2/kg&#94;2' , 't0tt' ) call ncinfo ( ncstatyt ( 25 ,:), 'sca1tpsca1pyt' , 'scalar. variance' , 'M&#94;2' , 't0tt' ) call ncinfo ( ncstatyt ( 26 ,:), 'sca2tpsca2pyt' , 'scalar. variance' , 'M&#94;2' , 't0tt' ) call ncinfo ( ncstatyt ( 27 ,:), 'sca3tpsca3pyt' , 'scalar. variance' , 'M&#94;2' , 't0tt' ) call ncinfo ( ncstatyt ( 28 ,:), 'usgsyt' , 'SGS mom. flux' , 'm&#94;2/s&#94;2' , 'm0mt' ) call ncinfo ( ncstatyt ( 29 ,:), 'wsgsyt' , 'SGS mom. flux' , 'm&#94;2/s&#94;2' , 't0mt' ) call ncinfo ( ncstatyt ( 30 ,:), 'thlsgsyt' , 'SGS heat flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 31 ,:), 'qtsgsyt' , 'SGS moisture flux' , 'kg/kg m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 32 ,:), 'sca1sgsyt' , 'SGS scalar flux' , 'M m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 33 ,:), 'sca2sgsyt' , 'SGS scalar flux' , 'M m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 34 ,:), 'sca3sgsyt' , 'SGS scalar flux' , 'M m/s' , 't0mt' ) if ( myid == 0 ) then call open_nc ( ytname , ncidyt , nrecyt , n1 = imax , n3 = khigh - klow + 1 ) if ( nrecyt == 0 ) then call define_nc ( ncidyt , 1 , tncstatyt ) call writestat_dims_nc ( ncidyt ) end if call define_nc ( ncidyt , nstatyt , ncstatyt ) endif !myid==0 endif !> Generate y and x averaged NetCDF: xydump.xxx.nc if ( lxydump ) then xyname ( 8 : 10 ) = cexpnr call ncinfo ( tncstatxy ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) call ncinfo ( ncstatxy ( 1 ,:), 'uxy' , 'Streamwise velocity' , 'm/s' , 'tt' ) call ncinfo ( ncstatxy ( 2 ,:), 'vxy' , 'Spanwise velocity' , 'm/s' , 'tt' ) call ncinfo ( ncstatxy ( 3 ,:), 'wxy' , 'Vertical velocity' , 'm/s' , 'mt' ) call ncinfo ( ncstatxy ( 4 ,:), 'thlxy' , 'Temperature' , 'K' , 'tt' ) call ncinfo ( ncstatxy ( 5 ,:), 'qtxy' , 'Moisture' , 'kg/kg' , 'tt' ) call ncinfo ( ncstatxy ( 6 ,:), 'pxy' , 'Pressure' , 'kgm/s&#94;2' , 'tt' ) call ncinfo ( ncstatxy ( 7 ,:), 'upwpxy' , 'Mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxy ( 8 ,:), 'wpthlpxy' , 'Heat flux' , 'Km/s' , 'mt' ) call ncinfo ( ncstatxy ( 9 ,:), 'vpwpxy' , 'Mom. flux' , 'Km/s' , 'mt' ) call ncinfo ( ncstatxy ( 10 ,:), 'usgsxy' , 'SGS mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxy ( 11 ,:), 'thlsgsxy' , 'SGS heat flux' , 'Km/s' , 'mt' ) call ncinfo ( ncstatxy ( 12 ,:), 'vsgsxy' , 'SGS mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxy ( 13 ,:), 'uwxyik' , 'Advective mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxy ( 14 ,:), 'wthlxy' , 'Advective heat flux' , 'K m/s' , 'mt' ) call ncinfo ( ncstatxy ( 15 ,:), 'vwxy' , 'Advective mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) if ( myid == 0 ) then call open_nc ( xyname , ncidxy , nrecxy , n3 = khigh - klow + 1 ) if ( nrecxy == 0 ) then call define_nc ( ncidxy , 1 , tncstatxy ) call writestat_dims_nc ( ncidxy ) end if call define_nc ( ncidxy , nstatxy , ncstatxy ) end if end if !> Generate time, y and x averaged NetCDF: xytdump.xxx.nc if ( lxytdump ) then xytname ( 9 : 11 ) = cexpnr call ncinfo ( tncstatxyt ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) call ncinfo ( ncstatxyt ( 1 ,:), 'uxyt' , 'Streamwise velocity' , 'm/s' , 'tt' ) call ncinfo ( ncstatxyt ( 2 ,:), 'vxyt' , 'Spanwise velocity' , 'm/s' , 'tt' ) call ncinfo ( ncstatxyt ( 3 ,:), 'wxyt' , 'Vertical velocity' , 'm/s' , 'mt' ) call ncinfo ( ncstatxyt ( 4 ,:), 'thlxyt' , 'Temperature' , 'K' , 'tt' ) call ncinfo ( ncstatxyt ( 5 ,:), 'qtxyt' , 'Moisture' , 'kg/kg' , 'tt' ) call ncinfo ( ncstatxyt ( 6 ,:), 'pxyt' , 'Pressure' , 'kgm/s&#94;2' , 'tt' ) call ncinfo ( ncstatxyt ( 7 ,:), 'upwpxyt' , 'Turbulent mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxyt ( 8 ,:), 'wpthlpxyt' , 'Turbulent heat flux' , 'K m/s' , 'mt' ) call ncinfo ( ncstatxyt ( 9 ,:), 'vpwpxyt' , 'Turbulent mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxyt ( 10 ,:), 'upvpxyt' , 'Turbulent mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxyt ( 11 ,:), 'uwxyt' , 'Kinematic mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxyt ( 12 ,:), 'wthlxyt' , 'Kinematic heat flux' , 'K m/s' , 'mt' ) call ncinfo ( ncstatxyt ( 13 ,:), 'uvxyt' , 'Kinematic mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxyt ( 14 ,:), 'vwxyt' , 'Kinematic mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxyt ( 15 ,:), 'wwxyt' , 'Kinematic mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxyt ( 16 ,:), 'usgsxyt' , 'SGS mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxyt ( 17 ,:), 'thlsgsxyt' , 'SGS heat flux' , 'K m/s' , 'mt' ) call ncinfo ( ncstatxyt ( 18 ,:), 'vsgsxyt' , 'SGS mom. flux' , 'K m/s' , 'mt' ) call ncinfo ( ncstatxyt ( 19 ,:), 'thlpthlptxy' , 'Temp. variance' , 'K&#94;2' , 'tt' ) call ncinfo ( ncstatxyt ( 20 ,:), 'upuptxyc' , 'u variance' , 'm&#94;2/s&#94;2' , 'tt' ) call ncinfo ( ncstatxyt ( 21 ,:), 'vpvptxyc' , 'v variance' , 'm&#94;2/s&#94;2' , 'tt' ) call ncinfo ( ncstatxyt ( 22 ,:), 'wpwptxyc' , 'w variance' , 'm&#94;2/s&#94;2' , 'tt' ) call ncinfo ( ncstatxyt ( 23 ,:), 'tketxyc' , 'tke' , 'm&#94;2/s&#94;2' , 'tt' ) if ( myid == 0 ) then call open_nc ( xytname , ncidxyt , nrecxyt , n3 = khigh - klow + 1 ) if ( nrecxyt == 0 ) then call define_nc ( ncidxyt , 1 , tncstatxyt ) call writestat_dims_nc ( ncidxyt ) end if call define_nc ( ncidxyt , nstatxyt , ncstatxyt ) end if end if !> Generate time averaged NetCDF: tdump.xxx.nc if ( ltdump ) then tname ( 7 : 9 ) = cmyid tname ( 11 : 13 ) = cexpnr call ncinfo ( tncstatt ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) call ncinfo ( ncstatt ( 1 ,:), 'ut' , 'Streamwise velocity' , 'm/s' , 'mttt' ) call ncinfo ( ncstatt ( 2 ,:), 'vt' , 'Spanwise velocity' , 'm/s' , 'tmtt' ) call ncinfo ( ncstatt ( 3 ,:), 'wt' , 'Vertical velocity' , 'm/s' , 'ttmt' ) call ncinfo ( ncstatt ( 4 ,:), 'thlt' , 'Temperature' , 'K' , 'tttt' ) call ncinfo ( ncstatt ( 5 ,:), 'qtt' , 'Moisture' , 'kg/kg' , 'tttt' ) call ncinfo ( ncstatt ( 6 ,:), 'pt' , 'Pressure' , 'kgm/s&#94;2' , 'tttt' ) call ncinfo ( ncstatt ( 7 ,:), 'sca1t' , 'Concentration field 1' , 'g/m&#94;3' , 'tttt' ) call ncinfo ( ncstatt ( 8 ,:), 'sca2t' , 'Concentration field 2' , 'g/m&#94;3' , 'tttt' ) call ncinfo ( ncstatt ( 9 ,:), 'sca3t' , 'Concentration field 3' , 'g/m&#94;3' , 'tttt' ) call ncinfo ( ncstatt ( 10 ,:), 'sca4t' , 'Concentration field 4' , 'g/m&#94;3' , 'tttt' ) call ncinfo ( ncstatt ( 11 ,:), 'PSS' , 'PSS defect' , 'gm/s' , 'tttt' ) call ncinfo ( ncstatt ( 12 ,:), 'upwpt' , 'Turbulent momentum flux' , 'm&#94;2/s&#94;2' , 'mtmt' ) call ncinfo ( ncstatt ( 13 ,:), 'vpwpt' , 'Turbulent momentum flux' , 'm&#94;2/s&#94;2' , 'tmmt' ) call ncinfo ( ncstatt ( 14 ,:), 'upvpt' , 'Turbulent momentum flux' , 'm&#94;2/s&#94;2' , 'mmtt' ) call ncinfo ( ncstatt ( 15 ,:), 'wpthlpt' , 'Turbulent heat flux' , 'K m/s' , 'ttmt' ) call ncinfo ( ncstatt ( 16 ,:), 'wpsca1pt' , 'Turbulent flux 1' , 'gm/s' , 'ttmt' ) call ncinfo ( ncstatt ( 17 ,:), 'wpsca2pt' , 'Turbulent flux 2' , 'gm/s' , 'ttmt' ) call ncinfo ( ncstatt ( 18 ,:), 'wpsca3pt' , 'Turbulent flux 3' , 'gm/s' , 'ttmt' ) call ncinfo ( ncstatt ( 19 ,:), 'wpsca4pt' , 'Turbulent flux 4' , 'gm/s' , 'ttmt' ) call ncinfo ( ncstatt ( 20 ,:), 'thlpthlpt' , 'Temperature variance' , 'K&#94;2' , 'tttt' ) call ncinfo ( ncstatt ( 21 ,:), 'upuptc' , 'u variance' , 'm&#94;2/s&#94;2' , 'tttt' ) call ncinfo ( ncstatt ( 22 ,:), 'vpvptc' , 'v variance' , 'm&#94;2/s&#94;2' , 'tttt' ) call ncinfo ( ncstatt ( 23 ,:), 'wpwptc' , 'w variance' , 'm&#94;2/s&#94;2' , 'tttt' ) call ncinfo ( ncstatt ( 24 ,:), 'tketc' , 'TKE' , 'm&#94;2/s&#94;2' , 'tttt' ) call ncinfo ( ncstatt ( 25 ,:), 'sca1psca1pt' , 'Concentration variance 1' , 'g&#94;2/m&#94;6' , 'tttt' ) call ncinfo ( ncstatt ( 26 ,:), 'sca2psca2pt' , 'Concentration variance 2' , 'g&#94;2/m&#94;6' , 'tttt' ) call ncinfo ( ncstatt ( 27 ,:), 'sca3psca3pt' , 'Concentration variance 3' , 'g&#94;2/m&#94;6' , 'tttt' ) call ncinfo ( ncstatt ( 28 ,:), 'sca4psca4pt' , 'Concentration variance 4' , 'g&#94;2/m&#94;6' , 'tttt' ) call ncinfo ( ncstatt ( 29 ,:), 'sv1sgs' , 'SGS flux 1' , 'gm/s' , 'ttmt' ) call ncinfo ( ncstatt ( 30 ,:), 'sv2sgs' , 'SGS flux 2' , 'gm/s' , 'ttmt' ) call ncinfo ( ncstatt ( 31 ,:), 'sv3sgs' , 'SGS flux 3' , 'gm/s' , 'ttmt' ) call ncinfo ( ncstatt ( 32 ,:), 'sv4sgs' , 'SGS flux 4' , 'gm/s' , 'ttmt' ) ! call ncinfo(ncstatt(33,:),'sca1t_max','Max concentration field 1'   ,'g/m&#94;3'  ,'tttt'  ) ! call ncinfo(ncstatt(34,:),'sca2t_max','Max concentration field 2'   ,'g/m&#94;3'  ,'tttt'  ) ! call ncinfo(ncstatt(35,:),'sca3t_max','Max concentration field 3'   ,'g/m&#94;3'  ,'tttt'  ) ! call ncinfo(ncstatt(36,:),'sca4t_max','Max concentration field 4'   ,'g/m&#94;3'  ,'tttt'  ) !      if (myid==0) then call open_nc ( tname , ncidt , nrect , n1 = imax , n2 = jmax , n3 = khigh - klow + 1 ) if ( nrect == 0 ) then call define_nc ( ncidt , 1 , tncstatt ) call writestat_dims_nc ( ncidt ) end if call define_nc ( ncidt , nstatt , ncstatt ) !      end if end if !> Generate time, y and x averaged NetCDF for tke budget: tkedump.xxx.nc if ( ltkedump ) then tkename ( 9 : 11 ) = cexpnr call ncinfo ( tncstattke ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) call ncinfo ( ncstattke ( 1 ,:), 'p_b' , 'p_bant production or consumption term' , 'm&#94;2/s&#94;3' , 'tt' ) call ncinfo ( ncstattke ( 2 ,:), 't_p' , 'total viscous transport (?)' , 'm&#94;2/s&#94;3' , 'tt' ) call ncinfo ( ncstattke ( 3 ,:), 'adv' , 'Advection by mean wind' , 'm&#94;2/s&#94;3' , 'tt' ) call ncinfo ( ncstattke ( 4 ,:), 't_t' , 'Total turb???' , 'm&#94;2/s&#94;3' , 'tt' ) call ncinfo ( ncstattke ( 5 ,:), 't_sgs' , 'total SGS  term' , 'm&#94;2/s&#94;3' , 'tt' ) call ncinfo ( ncstattke ( 6 ,:), 'p_t' , 'Shear production term' , 'm&#94;2/s&#94;3' , 'tt' ) call ncinfo ( ncstattke ( 7 ,:), 't_v' , 'Resolved viscous dissipation term' , 'm&#94;2/s&#94;3' , 'tt' ) call ncinfo ( ncstattke ( 8 ,:), 'd_sgs' , 'SGS dissipation term' , 'm&#94;2/s&#94;3' , 'tt' ) if ( myid == 0 ) then call open_nc ( tkename , ncidtke , nrectke , n3 = khigh - klow + 1 ) if ( nrectke == 0 ) then call define_nc ( ncidtke , 1 , tncstattke ) call writestat_dims_nc ( ncidtke ) end if call define_nc ( ncidtke , nstattke , ncstattke ) endif !myid==0 endif !> Generate sliced NetCDF: slicedump.xxx.xxx.nc if ( lslicedump ) then slicename ( 11 : 13 ) = cmyid slicename ( 15 : 17 ) = cexpnr call ncinfo ( tncstatslice ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) call ncinfo ( ncstatslice ( 1 ,:), 'sca_kb1' , 'Scalar field at kb' , '-' , 'tt0t' ) call ncinfo ( ncstatslice ( 2 ,:), 'sca_ave1' , 'Averaged scalar field over canyon' , '-' , 'tt0t' ) call ncinfo ( ncstatslice ( 3 ,:), 'sca_kb2' , 'Scalar field at kb+1' , '-' , 'tt0t' ) call ncinfo ( ncstatslice ( 4 ,:), 'sca_ave2' , 'Averaged scalar field over canyon' , '-' , 'tt0t' ) call ncinfo ( ncstatslice ( 5 ,:), 'sca_kb3' , 'Scalar field at kb+1' , '-' , 'tt0t' ) call ncinfo ( ncstatslice ( 6 ,:), 'sca_ave3' , 'Averaged scalar field over canyon' , '-' , 'tt0t' ) call ncinfo ( ncstatslice ( 7 ,:), 'u_kb' , 'Streamwise velocity at kb' , '-' , 'mt0t' ) call ncinfo ( ncstatslice ( 8 ,:), 'v_kb' , 'Spanwise velocity at kb' , '-' , 'tm0t' ) call open_nc ( slicename , ncidslice , nrecslice , n1 = imax , n2 = jmax ) if ( nrecslice == 0 ) then call define_nc ( ncidslice , 1 , tncstatslice ) call writestat_dims_nc ( ncidslice ) end if call define_nc ( ncidslice , nstatslice , ncstatslice ) end if !> Set times to zero so works for warm starts... could have issues with warmstarts here... tsamplep = 0. tstatsdumpp = 0. end subroutine initstatsdump !------------------------- !> Generate and write statistics into NetCDF file format !------------------------- subroutine statsdump use modfields , only : um , up , vm , wm , svm , qtm , thlm , pres0 , ncstaty , ncstatxy , ncstatyt , ncstattke ,& ncstatslice , t_t , t_v , t_p , t_sgs , d_sgs , p_b , p_t , adv ,& IIc , IIu , IIv , IIw , IIuw , IIvw , IIct , IIwt , IIut , IIvt , IIuwt , IIuv ,& IIcs , IIws , IIus , IIvs , IIuws , IIvws , IIuvs ,& slice , slice2 , slice3 , slice4 , slice5 , slice6 , slice7 , slice8 ,& vyt , uyt , wyt , thlyt , qtyt ,& sca1yt , sca2yt , sca3yt , thlsgsyt , qtsgsyt , sv1sgsyt , sv2sgsyt , sv3sgsyt , usgsyt , wsgsyt ,& usgsxyt , thlsgsxyt , vsgsxyt , uwtik , vwtjk , uvtij , utik , wtik , wtjk , vtjk , utij , vtij ,& wthltk , wqttk , thlthlt , qtqtt , sv1sv1t , sv2sv2t , sv3sv3t , sv4sv4t , wmt , thltk , qttk , thlt , uxyt , vxyt , wxyt , thlxyt ,& ncstatxyt , qtxyt , pxyt , ncstatt , uutc , vvtc , wwtc , utc , vtc , wtc ,& umt , vmt , sv1t , sv2t , sv3t , sv4t , sv1tk , sv2tk , sv3tk , sv4tk , wsv1tk , wsv2tk , wsv3tk , wsv4tk ,& sv1sgst , sv2sgst , sv3sgst , sv4sgst , qtt , pt , PSSt !,sv1max,sv2max,sv3max,sv4max use modglobal , only : ib , ie , ih , ihc , xf , xh , jb , je , jhc , jgb , jge , dy , dyi , jh , ke , kb , kh , khc , rk3step ,& timee , cexpnr , tsample , tstatsdump , jtot , imax , jmax , dzf ,& ltempeq , zh , dxf , dzf , dzh2i , lprofforc , lscasrcl ,& lslicedump , lchem , dzhi , dzfi , dzhiq , dxhi , lmoist , nsv ,& k1 , JNO2 , lchem !  use modsubgriddata,   only : ekm,sbshr use modstat_nc , only : writestat_nc , writestat_1D_nc use modmpi , only : myid , cmyid , my_real , mpi_sum , avey_ibm , mpierr ,& comm3d , avexy_ibm , nprocs use modsurfdata , only : thls use modsubgrid , only : ekh , ekm use modstatistics , only : genstats , tkestats implicit none !> Create fields to be used in statistics ! interpolated fields !  real, dimension(ib:ie,jb:je,kb:ke)     :: umc !  real, dimension(ib:ie,jb:je,kb:ke)     :: vmc !  real, dimension(ib:ie,jb:je,kb:ke)     :: wmc ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: thlk ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: qtk ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: uik ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: wik ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: vjk ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: wjk ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: uij ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: vij ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: uc ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: vc ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: wc real , allocatable :: thlk (:,:,:) real , allocatable :: qtk (:,:,:) real , allocatable :: uik (:,:,:) real , allocatable :: wik (:,:,:) real , allocatable :: vjk (:,:,:) real , allocatable :: wjk (:,:,:) real , allocatable :: uij (:,:,:) real , allocatable :: vij (:,:,:) real , allocatable :: uc (:,:,:) real , allocatable :: vc (:,:,:) real , allocatable :: wc (:,:,:) ! SGS fluxes ! real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh)     :: thlsgs ! real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh)     :: qtsgs ! real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh)     :: usgs ! real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh)     :: vsgs ! real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh)     :: wsgs real , allocatable :: thlsgs (:,:,:) real , allocatable :: qtsgs (:,:,:) real , allocatable :: usgs (:,:,:) real , allocatable :: vsgs (:,:,:) real , allocatable :: wsgs (:,:,:) ! t-averaged fields ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: sv1k ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: sv2k ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: sv3k ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: sv4k ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: wpsv1p ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: wpsv2p ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: wpsv3p ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: wpsv4p ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: sv1sgs ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: sv2sgs ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: sv3sgs ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: sv4sgs real , allocatable :: sv1k (:,:,:) real , allocatable :: sv2k (:,:,:) real , allocatable :: sv3k (:,:,:) real , allocatable :: sv4k (:,:,:) real , allocatable :: sv1sgs (:,:,:) real , allocatable :: sv2sgs (:,:,:) real , allocatable :: sv3sgs (:,:,:) real , allocatable :: sv4sgs (:,:,:) real , allocatable :: wpsv1p (:,:,:) real , allocatable :: wpsv2p (:,:,:) real , allocatable :: wpsv3p (:,:,:) real , allocatable :: wpsv4p (:,:,:) real , allocatable :: sv1psv1pt (:,:,:) real , allocatable :: sv2psv2pt (:,:,:) real , allocatable :: sv3psv3pt (:,:,:) real , allocatable :: sv4psv4pt (:,:,:) real , allocatable :: PSS (:,:,:) ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: upwptik ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: vpwptjk ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: upvptij ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: wpthlptk ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: thlpthlpt ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: upuptc ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: vpvptc ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: wpwptc ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: tketc real , allocatable :: upwptik (:,:,:) real , allocatable :: vpwptjk (:,:,:) real , allocatable :: upvptij (:,:,:) real , allocatable :: wpthlptk (:,:,:) real , allocatable :: thlpthlpt (:,:,:) real , allocatable :: upuptc (:,:,:) real , allocatable :: vpvptc (:,:,:) real , allocatable :: wpwptc (:,:,:) real , allocatable :: tketc (:,:,:) ! y-averaged fields real , dimension ( ib : ie , kb : ke ) :: uy real , dimension ( ib : ie , kb : ke ) :: vy real , dimension ( ib : ie , kb : ke ) :: wy real , dimension ( ib : ie , kb : ke ) :: thly real , dimension ( ib : ie , kb : ke ) :: qty real , dimension ( ib : ie , kb : ke ) :: sca1y real , dimension ( ib : ie , kb : ke ) :: sca2y real , dimension ( ib : ie , kb : ke ) :: sca3y real , dimension ( ib : ie , kb : ke ) :: usgsy real , dimension ( ib : ie , kb : ke ) :: wsgsy real , dimension ( ib : ie , kb : ke ) :: thlsgsy real , dimension ( ib : ie , kb : ke ) :: qtsgsy real , dimension ( ib : ie , kb : ke ) :: sv1sgsy real , dimension ( ib : ie , kb : ke ) :: sv2sgsy real , dimension ( ib : ie , kb : ke ) :: sv3sgsy real , dimension ( ib : ie , kb : ke ) :: uwyik real , dimension ( ib : ie , kb : ke ) :: wthlyk real , dimension ( ib : ie , kb : ke ) :: wqtyk ! real, dimension(ib:ie,kb:ke)                 :: wsv1yk ! real, dimension(ib:ie,kb:ke)                 :: wsv2yk real , dimension ( ib : ie , kb : ke ) :: wyik real , dimension ( ib : ie , kb : ke ) :: uyik real , dimension ( ib : ie , kb : ke ) :: thlyk real , dimension ( ib : ie , kb : ke ) :: upwpyik real , dimension ( ib : ie , kb : ke ) :: wpthlpyk ! ty-averaged fluxes real , dimension ( ib : ie , kb : ke ) :: upwptyik real , dimension ( ib : ie , kb : ke ) :: wpthlptyk real , dimension ( ib : ie , kb : ke ) :: wpqtptyk real , dimension ( ib : ie , kb : ke ) :: wpsv1ptyk real , dimension ( ib : ie , kb : ke ) :: wpsv2ptyk real , dimension ( ib : ie , kb : ke ) :: wpsv3ptyk real , dimension ( ib : ie , kb : ke ) :: upuptyc real , dimension ( ib : ie , kb : ke ) :: vpvptyc real , dimension ( ib : ie , kb : ke ) :: wpwptyc real , dimension ( ib : ie , kb : ke ) :: qtpqtpty real , dimension ( ib : ie , kb : ke ) :: thlpthlpty real , dimension ( ib : ie , kb : ke ) :: sv1psv1pty real , dimension ( ib : ie , kb : ke ) :: sv2psv2pty real , dimension ( ib : ie , kb : ke ) :: sv3psv3pty real , dimension ( ib : ie , kb : ke ) :: uwtyik real , dimension ( ib : ie , kb : ke ) :: wthltyk real , dimension ( ib : ie , kb : ke ) :: wqttyk real , dimension ( ib : ie , kb : ke ) :: wsv1tyk real , dimension ( ib : ie , kb : ke ) :: wsv2tyk real , dimension ( ib : ie , kb : ke ) :: wsv3tyk ! xy-averaged fields real , dimension ( kb : ke + kh ) :: uxy real , dimension ( kb : ke + kh ) :: vxy real , dimension ( kb : ke + kh ) :: wxy real , dimension ( kb : ke + kh ) :: thlxy real , dimension ( kb : ke + kh ) :: qtxy real , dimension ( kb : ke + kh ) :: pxy real , dimension ( kb : ke + kh ) :: usgsxy real , dimension ( kb : ke + kh ) :: thlsgsxy real , dimension ( kb : ke + kh ) :: vsgsxy real , dimension ( kb : ke + kh ) :: sca1xy real , dimension ( kb : ke + kh ) :: uwxyik real , dimension ( kb : ke + kh ) :: vwxyjk real , dimension ( kb : ke + kh ) :: wthlxyk real , dimension ( kb : ke + kh ) :: thlxyk real , dimension ( kb : ke + kh ) :: wxyik real , dimension ( kb : ke + kh ) :: uxyik real , dimension ( kb : ke + kh ) :: vxyjk real , dimension ( kb : ke + kh ) :: wxyjk real , dimension ( kb : ke + kh ) :: upwpxyik real , dimension ( kb : ke + kh ) :: wpthlpxyk real , dimension ( kb : ke + kh ) :: vpwpxyjk ! txy-averaged fields real , dimension ( kb : ke + kh ) :: upwptxyik real , dimension ( kb : ke + kh ) :: wpthlptxyk real , dimension ( kb : ke + kh ) :: thlpthlptxy real , dimension ( kb : ke + kh ) :: upuptxyc real , dimension ( kb : ke + kh ) :: vpvptxyc real , dimension ( kb : ke + kh ) :: wpwptxyc real , dimension ( kb : ke + kh ) :: tketxyc real , dimension ( kb : ke + kh ) :: vpwptxyjk real , dimension ( kb : ke + kh ) :: upvptxyij real , dimension ( kb : ke + kh ) :: uwtxyik real , dimension ( kb : ke + kh ) :: wthltxyk real , dimension ( kb : ke + kh ) :: vwtxyjk real , dimension ( kb : ke + kh ) :: wwtxyk real , dimension ( kb : ke + kh ) :: uvtxyij real , allocatable :: field (:,:), varsy (:,:,:), varsyt (:,:,:), varstke (:,:), varsxy (:,:),& varslice (:,:,:), varsxyt (:,:), varst (:,:,:,:) real :: tstatsdumppi , emom integer :: i , j , k , ip , im , jp , jm , kp , km integer :: writecounter = 1 integer :: reclength allocate ( thlk ( ib : ie , jb : je , kb : ke + kh )) allocate ( qtk ( ib : ie , jb : je , kb : ke + kh )) allocate ( uik ( ib : ie , jb : je , kb : ke + kh )) allocate ( wik ( ib : ie , jb : je , kb : ke + kh )) allocate ( vjk ( ib : ie , jb : je , kb : ke + kh )) allocate ( wjk ( ib : ie , jb : je , kb : ke + kh )) allocate ( uij ( ib : ie , jb : je , kb : ke + kh )) allocate ( vij ( ib : ie , jb : je , kb : ke + kh )) allocate ( uc ( ib : ie , jb : je , kb : ke + kh )) allocate ( vc ( ib : ie , jb : je , kb : ke + kh )) allocate ( wc ( ib : ie , jb : je , kb : ke + kh )) allocate ( thlsgs ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( qtsgs ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( usgs ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( vsgs ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( wsgs ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( sv1k ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv2k ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv3k ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv4k ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv1sgs ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv2sgs ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv3sgs ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv4sgs ( ib : ie , jb : je , kb : ke + kh )) allocate ( wpsv1p ( ib : ie , jb : je , kb : ke + kh )) allocate ( wpsv2p ( ib : ie , jb : je , kb : ke + kh )) allocate ( wpsv3p ( ib : ie , jb : je , kb : ke + kh )) allocate ( wpsv4p ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv1psv1pt ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv2psv2pt ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv3psv3pt ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv4psv4pt ( ib : ie , jb : je , kb : ke + kh )) allocate ( PSS ( ib : ie , jb : je , kb : ke + kh )) allocate ( upwptik ( ib : ie , jb : je , kb : ke + kh )) allocate ( vpwptjk ( ib : ie , jb : je , kb : ke + kh )) allocate ( upvptij ( ib : ie , jb : je , kb : ke + kh )) allocate ( wpthlptk ( ib : ie , jb : je , kb : ke + kh )) allocate ( thlpthlpt ( ib : ie , jb : je , kb : ke + kh )) allocate ( upuptc ( ib : ie , jb : je , kb : ke + kh )) allocate ( vpvptc ( ib : ie , jb : je , kb : ke + kh )) allocate ( wpwptc ( ib : ie , jb : je , kb : ke + kh )) allocate ( tketc ( ib : ie , jb : je , kb : ke + kh )) thlk = 0. ; qtk = 0. ; uik = 0. ; wik = 0. ; vjk = 0. ; wjk = 0. ; uij = 0. ; vij = 0. ; uc = 0. ; vc = 0. ; wc = 0. ; thlsgs = 0. ; qtsgs = 0. ; usgs = 0. ; vsgs = 0. ; wsgs = 0. ; sv1k = 0. ; sv2k = 0. ; sv3k = 0. ; sv4k = 0. ; sv1sgs = 0. ; sv2sgs = 0. ; sv3sgs = 0. ; sv4sgs = 0. ; wpsv1p = 0. ; wpsv2p = 0. wpsv3p = 0. ; wpsv4p = 0. ; sv1psv1pt = 0. ; sv2psv2pt = 0. ; sv3psv3pt = 0. ; sv4psv4pt = 0. ; PSS = 0. ; upwptik = 0. ; vpwptjk = 0. ; upvptij = 0. ; wpthlptk = 0. ; thlpthlpt = 0. ; upuptc = 0. ; vpvptc = 0. ; wpwptc = 0. ; tketc = 0. upwptyik = 0. ; wpthlptyk = 0. ; wpqtptyk = 0. ; wpsv1ptyk = 0. ; wpsv2ptyk = 0. ; wpsv3ptyk = 0. ; uwtyik = 0. ; wthltyk = 0. ; wqttyk = 0. ; wsv1tyk = 0. ; wsv2tyk = 0. ; wsv3tyk = 0. ; upuptyc = 0. ; wpwptyc = 0. ; thlpthlpty = 0. qtpqtpty = 0. ; sv1psv1pty = 0. ; sv2psv2pty = 0. ; sv3psv3pty = 0. if (. not . rk3step == 3 ) return if ( tsamplep > tsample ) then if ( lytdump . or . lydump . or . lxydump . or . lxytdump . or . ltdump ) then ! wpthlptyk=0.;wpqtptyk=0.;wpsv1ptyk=0.;wpsv2ptyk=0. tstatsdumppi = 1. / tstatsdumpp !> Perform required interpolations for flux calculations !  tg3315 for non-equidistant x and z-grids this needs to change do k = kb , ke + kh do j = jb , je do i = ib , ie uik ( i , j , k ) = 0.5 * dzhi ( k ) * ( um ( i , j , k ) * dzf ( k - 1 ) + um ( i , j , k - 1 ) * dzf ( k )) wik ( i , j , k ) = 0.5 * dxhi ( i ) * ( wm ( i , j , k ) * dxf ( i - 1 ) + wm ( i - 1 , j , k ) * dxf ( i )) vjk ( i , j , k ) = 0.5 * dzhi ( k ) * ( vm ( i , j , k ) * dzf ( k - 1 ) + vm ( i , j , k - 1 ) * dzf ( k )) wjk ( i , j , k ) = 0.5 * ( wm ( i , j , k ) + wm ( i , j - 1 , k )) uij ( i , j , k ) = 0.5 * ( um ( i , j , k ) + um ( i , j - 1 , k )) vij ( i , j , k ) = 0.5 * dxhi ( i ) * ( vm ( i , j , k ) * dxf ( i - 1 ) + vm ( i - 1 , j , k ) * dxf ( i )) uc ( i , j , k ) = 0.5 * dxhi ( i ) * ( um ( i , j , k ) * dxf ( i - 1 ) + um ( i - 1 , j , k ) * dxf ( i )) vc ( i , j , k ) = 0.5 * ( vm ( i , j , k ) + vm ( i , j - 1 , k )) wc ( i , j , k ) = 0.5 * dzhi ( k ) * ( wm ( i , j , k ) * dzf ( k - 1 ) + wm ( i , j , k - 1 ) * dzf ( k )) ! SGS fluxes ! interps ekm to cell corner (uw) emom = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k ) * dxf ( i ) ) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k - 1 ) * dxf ( i ) ) ) * dxhi ( i ) * dzhiq ( k ) usgs ( i , j , k ) = emom * ( ( um ( i , j , k ) - um ( i , j , k - 1 )) * dzhi ( k ) & + ( wm ( i , j , k ) - wm ( i - 1 , j , k )) * dxhi ( i )) ! interps ekm to cell corner (vw) emom = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k ) ) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , j - 1 , k - 1 ) ) ) * dzhiq ( k ) vsgs ( i , j , k ) = emom * ( ( vm ( i , j , k ) - vm ( i , j , k - 1 )) * dzhi ( k ) & + ( wm ( i , j , k ) - wm ( i , j - 1 , k )) * dyi ) end do end do end do do k = kb , ke do j = jb , je do i = ib , ie wsgs ( i , j , k ) = ( ekm ( i , j , k ) * ( wm ( i , j , k + 1 ) - wm ( i , j , k )) * dzfi ( k ) & - ekm ( i , j , k - 1 ) * ( wm ( i , j , k ) - wm ( i , j , k - 1 )) * dzfi ( k - 1 ) ) * 2. & * dzhi ( k ) ! tg3315 check this end do end do end do if ( ltempeq ) then do k = kb , ke + kh do j = jb , je do i = ib , ie thlk ( i , j , k ) = 0.5 * dzhi ( k ) * ( thlm ( i , j , k ) * dzf ( k - 1 ) + thlm ( i , j , k - 1 ) * dzf ( k )) end do end do end do do k = kb , ke !> SGS fluxes thlsgs (:,:, k ) = 0.5 * ( dzf ( k - 1 ) * ekh (:,:, k ) + dzf ( k ) * ekh (:,:, k - 1 )) & * ( thlm (:,:, k ) - thlm (:,:, k - 1 )) * dzh2i ( k ) end do end if if ( lmoist ) then do k = kb , ke + kh do j = jb , je do i = ib , ie qtk ( i , j , k ) = 0.5 * dzhi ( k ) * ( qtm ( i , j , k ) * dzf ( k - 1 ) + qtm ( i , j , k - 1 ) * dzf ( k )) end do end do end do do k = kb , ke !> SGS fluxes qtsgs (:,:, k ) = 0.5 * ( dzf ( k - 1 ) * ekh (:,:, k ) + dzf ( k ) * ekh (:,:, k - 1 )) & * ( qtm (:,:, k ) - qtm (:,:, k - 1 )) * dzh2i ( k ) end do end if if ( nsv > 0 ) then do k = kb , ke do j = jb , je do i = ib , ie sv1k ( i , j , k ) = 0.5 * dzhi ( k ) * ( svm ( i , j , k , 1 ) * dzf ( k - 1 ) + svm ( i , j , k - 1 , 1 ) * dzf ( k )) end do end do end do do k = kb , ke sv1sgs ( ib : ie , jb : je , k ) = 0.5 * ( dzf ( k - 1 ) * ekh ( ib : ie , jb : je , k ) + dzf ( k ) * ekh ( ib : ie , jb : je , k - 1 )) & * ( svm ( ib : ie , jb : je , k , 1 ) - svm ( ib : ie , jb : je , k - 1 , 1 )) * dzh2i ( k ) end do end if if ( nsv > 1 ) then do k = kb , ke + kh do j = jb , je do i = ib , ie sv2k ( i , j , k ) = 0.5 * dzhi ( k ) * ( svm ( i , j , k , 2 ) * dzf ( k - 1 ) + svm ( i , j , k - 1 , 2 ) * dzf ( k )) end do end do end do do k = kb , ke sv2sgs ( ib : ie , jb : je , k ) = 0.5 * ( dzf ( k - 1 ) * ekh ( ib : ie , jb : je , k ) + dzf ( k ) * ekh ( ib : ie , jb : je , k - 1 )) & * ( svm ( ib : ie , jb : je , k , 2 ) - svm ( ib : ie , jb : je , k - 1 , 2 )) * dzh2i ( k ) end do end if if ( nsv > 2 ) then do k = kb , ke + kh do j = jb , je do i = ib , ie sv3k ( i , j , k ) = 0.5 * dzhi ( k ) * ( svm ( i , j , k , 3 ) * dzf ( k - 1 ) + svm ( i , j , k - 1 , 3 ) * dzf ( k )) end do end do end do do k = kb , ke sv3sgs ( ib : ie , jb : je , k ) = 0.5 * ( dzf ( k - 1 ) * ekh ( ib : ie , jb : je , k ) + dzf ( k ) * ekh ( ib : ie , jb : je , k - 1 )) & * ( svm ( ib : ie , jb : je , k , 3 ) - svm ( ib : ie , jb : je , k - 1 , 3 )) * dzh2i ( k ) end do end if if ( nsv > 3 ) then do k = kb , ke + kh do j = jb , je do i = ib , ie sv4k ( i , j , k ) = 0.5 * dzhi ( k ) * ( svm ( i , j , k , 4 ) * dzf ( k - 1 ) + svm ( i , j , k - 1 , 4 ) * dzf ( k )) end do end do end do do k = kb , ke sv4sgs ( ib : ie , jb : je , k ) = 0.5 * ( dzf ( k - 1 ) * ekh ( ib : ie , jb : je , k ) + dzf ( k ) * ekh ( ib : ie , jb : je , k - 1 )) & * ( svm ( ib : ie , jb : je , k , 4 ) - svm ( ib : ie , jb : je , k - 1 , 4 )) * dzh2i ( k ) end do end if if (( nsv > 2 ) . and . ( lchem . eqv . . true .)) then do k = kb , ke do j = jb , je do i = ib , ie if (( ABS ( svm ( i , j , k , 2 )) . gt . 1.e-40 ) . and . ( IIc ( i , j , k ) == 1 )) then PSS ( i , j , k ) = ( ( ( k1 * ( svm ( i , j , k , 1 ) / 3 0. ) * ( svm ( i , j , k , 3 ) / 4 8. )) / ( JNO2 * ( svm ( i , j , k , 2 ) / 4 6. )) ) - 1 ) * 100 end if end do end do end do end if !!>> CALCS FOR INST. STATS !> Note: More computationally efficient to spatially average mean quantities first & !        for time dependant stats, hence the .or.s. Assuming homogeneity in y. !> Average in y-direction if ( lydump . or . lytdump ) then uy = 0. ; vy = 0. ; wy = 0. ; uwyik = 0. ; usgsy = 0. ; wsgsy = 0. ; thly = 0. ; wthlyk = 0. ; thlsgsy = 0. qty = 0. ; wqtyk = 0. ; qtsgsy = 0. ; sca1y = 0. ; sv1sgsy = 0. ; sv2sgsy = 0. ; sca2y = 0. ; sca3y = 0. ; sv3sgsy = 0. call avey_ibm ( uy , um ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIu ( ib : ie , jb : je , kb : ke ), IIut ( ib : ie , kb : ke )) call avey_ibm ( vy , vm ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIv ( ib : ie , jb : je , kb : ke ), IIvt ( ib : ie , kb : ke )) call avey_ibm ( wy , wm ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( uwyik , uik ( ib : ie , jb : je , kb : ke ) * wik ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIuw ( ib : ie , jb : je , kb : ke ), IIuwt ( ib : ie , kb : ke )) call avey_ibm ( usgsy , usgs ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIuw ( ib : ie , jb : je , kb : ke ), IIuwt ( ib : ie , kb : ke )) call avey_ibm ( wsgsy , wsgs ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) if ( ltempeq ) then call avey_ibm ( thly , thlm ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) call avey_ibm ( wthlyk , wm ( ib : ie , jb : je , kb : ke ) * thlk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( thlsgsy , thlsgs ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) end if if ( lmoist ) then call avey_ibm ( qty , qtm ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) call avey_ibm ( wqtyk , wm ( ib : ie , jb : je , kb : ke ) * qtk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( qtsgsy , qtsgs ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) end if if ( nsv > 0 ) then call avey_ibm ( sca1y , svm ( ib : ie , jb : je , kb : ke , 1 ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) ! call avey_ibm(wsv1yk,wm(ib:ie,jb:je,kb:ke)*sv1k(ib:ie,jb:je,kb:ke),ib,ie,jb,je,kb,ke,IIw(ib:ie,jb:je,kb:ke),IIwt(ib:ie,kb:ke)) call avey_ibm ( sv1sgsy , sv1sgs ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) end if if ( nsv > 1 ) then call avey_ibm ( sca2y , svm ( ib : ie , jb : je , kb : ke , 2 ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) ! call avey_ibm(wsv2yk,wm(ib:ie,jb:je,kb:ke)*sv2k(ib:ie,jb:je,kb:ke),ib,ie,jb,je,kb,ke,IIw(ib:ie,jb:je,kb:ke),IIwt(ib:ie,kb:ke)) call avey_ibm ( sv2sgsy , sv2sgs ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) end if if ( nsv > 2 ) then call avey_ibm ( sca3y , svm ( ib : ie , jb : je , kb : ke , 3 ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) call avey_ibm ( sv3sgsy , sv3sgs ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) end if end if ! lydump .or. lytdump if ( lydump ) then uwyik = 0. ; wthlyk = 0. ; uyik = 0. ; wyik = 0. ; thlyk = 0. ; wpthlpyk = 0. call avey_ibm ( uwyik , uik ( ib : ie , jb : je , kb : ke ) * wik ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIuw ( ib : ie , jb : je , kb : ke ), IIuwt ( ib : ie , kb : ke )) call avey_ibm ( uyik , uik ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIuw ( ib : ie , jb : je , kb : ke ), IIuwt ( ib : ie , kb : ke )) call avey_ibm ( wyik , wik ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIuw ( ib : ie , jb : je , kb : ke ), IIuwt ( ib : ie , kb : ke )) if ( ltempeq ) then call avey_ibm ( wthlyk , wm ( ib : ie , jb : je , kb : ke ) * thlk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( thlyk , thlk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) end if upwpyik = uwyik - uyik * wyik if ( ltempeq ) then wpthlpyk = wthlyk - wy * thlyk where ( IIwt == 0 ) wpthlpyk = - 99 9.0 endwhere end if where ( IIuwt == 0 ) upwpyik = - 99 9.0 endwhere end if ! lydump !> tg3315 10.07.18 - in any case where averaging spatially can assume homogeneity and therefore average !  spatially first? Perhaps not due to UCL...? Would save space but goes against triple decomposition !  definition !> Average in x and y-direction if ( lxydump . or . lxytdump ) then uxy = 0. ; vxy = 0. ; wxy = 0. ; thlxy = 0. ; qtxy = 0. ; pxy = 0. ; usgsxy = 0. ; thlsgsxy = 0. ; sca1xy = 0. ; vsgsxy = 0. !> Spatial averages of mean quantities call avexy_ibm ( uxy ( kb : ke + kh ), um ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIu ( ib : ie , jb : je , kb : ke + kh ), IIus ( kb : ke + kh ),. true .) call avexy_ibm ( vxy ( kb : ke + kh ), vm ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIv ( ib : ie , jb : je , kb : ke + kh ), IIvs ( kb : ke + kh ),. true .) call avexy_ibm ( wxy ( kb : ke + kh ), wm ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. true .) if ( ltempeq ) then call avexy_ibm ( thlxy ( kb : ke + kh ), thlm ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. true .) call avexy_ibm ( thlsgsxy ( kb : ke + kh ), thlsgs ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. true .) end if if ( lmoist ) then call avexy_ibm ( qtxy ( kb : ke + kh ), qtm ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. true .) end if call avexy_ibm ( pxy ( kb : ke + kh ), pres0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. true .) call avexy_ibm ( usgsxy ( kb : ke + kh ), usgs ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIuw ( ib : ie , jb : je , kb : ke + kh ), IIuws ( kb : ke + kh ),. true .) call avexy_ibm ( vsgsxy ( kb : ke + kh ), vsgs ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIvw ( ib : ie , jb : je , kb : ke + kh ), IIvws ( kb : ke + kh ),. true .) end if ! lxydump .or. lxytdump if ( lxydump ) then uwxyik = 0. ; vwxyjk = 0. ; uxyik = 0. ; wxyik = 0. ; vxyjk = 0. ; wxyjk = 0. ; wthlxyk = 0. ; thlxyk = 0. ; wpthlpxyk = 0. call avexy_ibm ( uwxyik ( kb : ke + kh ), uik ( ib : ie , jb : je , kb : ke + kh ) * wik ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIuw ( ib : ie , jb : je , kb : ke + kh ), IIuws ( kb : ke + kh ),. true .) call avexy_ibm ( vwxyjk ( kb : ke + kh ), vjk ( ib : ie , jb : je , kb : ke + kh ) * wjk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIvw ( ib : ie , jb : je , kb : ke + kh ), IIvws ( kb : ke + kh ),. true .) call avexy_ibm ( uxyik ( kb : ke + kh ), uik ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIuw ( ib : ie , jb : je , kb : ke + kh ), IIuws ( kb : ke + kh ),. true .) call avexy_ibm ( wxyik ( kb : ke + kh ), wik ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIuw ( ib : ie , jb : je , kb : ke + kh ), IIuws ( kb : ke + kh ),. true .) call avexy_ibm ( wxyjk ( kb : ke + kh ), wjk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIvw ( ib : ie , jb : je , kb : ke + kh ), IIvws ( kb : ke + kh ),. true .) call avexy_ibm ( vxyjk ( kb : ke + kh ), vjk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIvw ( ib : ie , jb : je , kb : ke + kh ), IIvws ( kb : ke + kh ),. true .) if ( ltempeq ) then call avexy_ibm ( wthlxyk ( kb : ke + kh ), wm ( ib : ie , jb : je , kb : ke + kh ) * thlk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. true .) call avexy_ibm ( thlxyk ( kb : ke + kh ), thlk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. true .) end if upwpxyik = uwxyik - uxyik * wxyik vpwpxyjk = vwxyjk - vxyjk * wxyjk if ( ltempeq ) then wpthlpxyk = wthlxyk - wxy * thlxyk end if end if ! lxydump !!>> CALCS FOR TIME DEPENDANT (AVERAGED) STATS !> Average 1-D fields in time if ( lxytdump ) then uxyt ( kb : ke + kh ) = ( uxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + uxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi vxyt ( kb : ke + kh ) = ( vxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + vxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi wxyt ( kb : ke + kh ) = ( wxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi qtxyt ( kb : ke + kh ) = ( qtxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + qtxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi pxyt ( kb : ke + kh ) = ( pxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + pxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi usgsxyt ( kb : ke + kh ) = ( usgsxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + usgsxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi vsgsxyt ( kb : ke + kh ) = ( vsgsxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + vsgsxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi if ( ltempeq ) then thlsgsxyt ( kb : ke + kh ) = ( thlsgsxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + thlsgsxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi thlxyt ( kb : ke + kh ) = ( thlxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + thlxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi end if end if ! lxytdump !> Average 2-D fields in time if ( lytdump ) then if ( myid == 0 ) then vyt ( ib : ie , kb : ke ) = ( vyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + vy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi uyt ( ib : ie , kb : ke ) = ( uyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + uy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi wyt ( ib : ie , kb : ke ) = ( wyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + wy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi usgsyt ( ib : ie , kb : ke ) = ( usgsyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + usgsy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi wsgsyt ( ib : ie , kb : ke ) = ( wsgsyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + wsgsy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi if ( ltempeq ) then thlyt ( ib : ie , kb : ke ) = ( thlyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + thly ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi thlsgsyt ( ib : ie , kb : ke ) = ( thlsgsyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + thlsgsy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi end if if ( lmoist ) then qtyt ( ib : ie , kb : ke ) = ( qtyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + qty ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi qtsgsyt ( ib : ie , kb : ke ) = ( qtsgsyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + qtsgsy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi end if if ( nsv > 0 ) then sca1yt ( ib : ie , kb : ke ) = ( sca1yt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + sca1y ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi sv1sgsyt ( ib : ie , kb : ke ) = ( sv1sgsyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + sv1sgsy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi end if if ( nsv > 1 ) then sca2yt ( ib : ie , kb : ke ) = ( sca2yt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + sca2y ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi sv2sgsyt ( ib : ie , kb : ke ) = ( sv2sgsyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + sv2sgsy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi end if if ( nsv > 2 ) then sca3yt ( ib : ie , kb : ke ) = ( sca3yt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + sca3y ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi sv3sgsyt ( ib : ie , kb : ke ) = ( sv3sgsyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + sv3sgsy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi end if end if ! myid end if !lytdump ! Average 3-D fields in time ! tg3315 may be possible to do less calculations by splitting up ! some calcs not necessary for xyt or yt... if ( lxytdump . or . lytdump . or . ltdump ) then uwtik (:,:, kb : ke + kh ) = ( uwtik (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wik (:,:, kb : ke + kh ) * uik (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi vwtjk (:,:, kb : ke + kh ) = ( vwtjk (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wjk (:,:, kb : ke + kh ) * vjk (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi uvtij (:,:, kb : ke + kh ) = ( uvtij (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + uij (:,:, kb : ke + kh ) * vij (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi uutc ( ib : ie , jb : je , kb : ke + kh ) = ( uutc ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + uc ( ib : ie , jb : je , kb : ke + kh ) * uc ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi vvtc ( ib : ie , jb : je , kb : ke + kh ) = ( vvtc ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + vc ( ib : ie , jb : je , kb : ke + kh ) * vc ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi wwtc ( ib : ie , jb : je , kb : ke + kh ) = ( wwtc ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wc ( ib : ie , jb : je , kb : ke + kh ) * wc ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi utik (:,:, kb : ke + kh ) = ( utik (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + uik (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi wtik (:,:, kb : ke + kh ) = ( wtik (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wik (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi vtjk (:,:, kb : ke + kh ) = ( vtjk (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + vjk (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi wtjk (:,:, kb : ke + kh ) = ( wtjk (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wjk (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi utij (:,:, kb : ke + kh ) = ( utij (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + uij (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi vtij (:,:, kb : ke + kh ) = ( vtij (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + vij (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi umt ( ib : ie , jb : je , kb : ke + kh ) = ( umt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + um ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi vmt ( ib : ie , jb : je , kb : ke + kh ) = ( vmt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + vm ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi wmt ( ib : ie , jb : je , kb : ke + kh ) = ( wmt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wm ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi utc ( ib : ie , jb : je , kb : ke + kh ) = ( utc ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + uc ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi vtc ( ib : ie , jb : je , kb : ke + kh ) = ( vtc ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + vc ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi wtc ( ib : ie , jb : je , kb : ke + kh ) = ( wtc ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wc ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi pt ( ib : ie , jb : je , kb : ke + kh ) = ( pt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + pres0 ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi if ( ltempeq ) then wthltk ( ib : ie , jb : je , kb : ke + kh ) = ( wthltk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + thlk ( ib : ie , jb : je , kb : ke + kh ) * wm ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi thlthlt ( ib : ie , jb : je , kb : ke + kh ) = ( thlthlt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + thlm ( ib : ie , jb : je , kb : ke + kh ) * thlm ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi thltk ( ib : ie , jb : je , kb : ke + kh ) = ( thltk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + thlk ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi thlt ( ib : ie , jb : je , kb : ke + kh ) = ( thlt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + thlm ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi end if if ( lmoist ) then wqttk ( ib : ie , jb : je , kb : ke + kh ) = ( wqttk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + qtk ( ib : ie , jb : je , kb : ke + kh ) * wm ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi qtqtt ( ib : ie , jb : je , kb : ke + kh ) = ( qtqtt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + qtm ( ib : ie , jb : je , kb : ke + kh ) * qtm ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi qttk ( ib : ie , jb : je , kb : ke + kh ) = ( qttk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + qtk ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi qtt ( ib : ie , jb : je , kb : ke + kh ) = ( qtt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + qtm ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi end if if ( nsv > 0 ) then sv1t ( ib : ie , jb : je , kb : ke + kh ) = ( sv1t ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + svm ( ib : ie , jb : je , kb : ke + kh , 1 ) * tsamplep ) * tstatsdumppi sv1tk ( ib : ie , jb : je , kb : ke + kh ) = ( sv1tk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + sv1k ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi wsv1tk ( ib : ie , jb : je , kb : ke + kh ) = ( wsv1tk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wm ( ib : ie , jb : je , kb : ke + kh ) * sv1k ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi sv1sgst ( ib : ie , jb : je , kb : ke + kh ) = ( sv1sgst ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + sv1sgs ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi sv1sv1t ( ib : ie , jb : je , kb : ke + kh ) = ( sv1sv1t ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + svm ( ib : ie , jb : je , kb : ke + kh , 1 ) * svm ( ib : ie , jb : je , kb : ke + kh , 1 ) * tsamplep ) * tstatsdumppi ! sv1max(ib:ie,jb:je,kb:ke) = max(sv1max(ib:ie,jb:je,kb:ke),svm(ib:ie,jb:je,kb:ke,1)) end if if (( lchem . eqv . . true .) . and . ( nsv > 2 )) then PSSt ( ib : ie , jb : je , kb : ke + kh ) = ( PSSt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + PSS ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi end if if ( nsv > 1 ) then sv2t ( ib : ie , jb : je , kb : ke + kh ) = ( sv2t ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + svm ( ib : ie , jb : je , kb : ke + kh , 2 ) * tsamplep ) * tstatsdumppi sv2tk ( ib : ie , jb : je , kb : ke + kh ) = ( sv2tk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + sv2k ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi wsv2tk ( ib : ie , jb : je , kb : ke + kh ) = ( wsv2tk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wm ( ib : ie , jb : je , kb : ke + kh ) * sv2k ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi sv2sgst ( ib : ie , jb : je , kb : ke + kh ) = ( sv2sgst ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + sv2sgs ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi sv2sv2t ( ib : ie , jb : je , kb : ke + kh ) = ( sv2sv2t ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + svm ( ib : ie , jb : je , kb : ke + kh , 2 ) * svm ( ib : ie , jb : je , kb : ke + kh , 2 ) * tsamplep ) * tstatsdumppi ! sv2max(ib:ie,jb:je,kb:ke) = max(sv2max(ib:ie,jb:je,kb:ke),svm(ib:ie,jb:je,kb:ke,2)) end if if ( nsv > 2 ) then sv3t ( ib : ie , jb : je , kb : ke + kh ) = ( sv3t ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + svm ( ib : ie , jb : je , kb : ke + kh , 3 ) * tsamplep ) * tstatsdumppi sv3tk ( ib : ie , jb : je , kb : ke + kh ) = ( sv3tk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + sv3k ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi wsv3tk ( ib : ie , jb : je , kb : ke + kh ) = ( wsv3tk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wm ( ib : ie , jb : je , kb : ke + kh ) * sv3k ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi sv3sgst ( ib : ie , jb : je , kb : ke + kh ) = ( sv3sgst ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + sv3sgs ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi sv3sv3t ( ib : ie , jb : je , kb : ke + kh ) = ( sv3sv3t ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + svm ( ib : ie , jb : je , kb : ke + kh , 3 ) * svm ( ib : ie , jb : je , kb : ke + kh , 3 ) * tsamplep ) * tstatsdumppi ! sv3max(ib:ie,jb:je,kb:ke) = max(sv3max(ib:ie,jb:je,kb:ke),svm(ib:ie,jb:je,kb:ke,3)) end if if ( nsv > 3 ) then sv4t ( ib : ie , jb : je , kb : ke + kh ) = ( sv4t ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + svm ( ib : ie , jb : je , kb : ke + kh , 4 ) * tsamplep ) * tstatsdumppi sv4tk ( ib : ie , jb : je , kb : ke + kh ) = ( sv4tk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + sv4k ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi wsv4tk ( ib : ie , jb : je , kb : ke + kh ) = ( wsv4tk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wm ( ib : ie , jb : je , kb : ke + kh ) * sv4k ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi sv4sgst ( ib : ie , jb : je , kb : ke + kh ) = ( sv4sgst ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + sv4sgs ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi sv4sv4t ( ib : ie , jb : je , kb : ke + kh ) = ( sv4sv4t ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + svm ( ib : ie , jb : je , kb : ke + kh , 4 ) * svm ( ib : ie , jb : je , kb : ke + kh , 4 ) * tsamplep ) * tstatsdumppi ! sv4max(ib:ie,jb:je,kb:ke) = max(sv4max(ib:ie,jb:je,kb:ke),svm(ib:ie,jb:je,kb:ke,4)) end if end if !lxytdump .or. lytdump .or. ltdump ! Other 3-D fields specifically for tdump !if (ltdump) then ! bss116 already calculated above ! wmt(ib:ie,jb:je,kb:ke+kh) = (wmt(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + wm(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! sv1t(ib:ie,jb:je,kb:ke+kh) = (sv1t(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + svm(ib:ie,jb:je,kb:ke+kh,1)*tsamplep)*tstatsdumppi ! sv2t(ib:ie,jb:je,kb:ke+kh) = (sv2t(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + svm(ib:ie,jb:je,kb:ke+kh,2)*tsamplep)*tstatsdumppi ! sv3t(ib:ie,jb:je,kb:ke+kh) = (sv3t(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + svm(ib:ie,jb:je,kb:ke+kh,3)*tsamplep)*tstatsdumppi ! ! sv4t(ib:ie,jb:je,kb:ke+kh) = (sv4t(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + svm(ib:ie,jb:je,kb:ke+kh,4)*tsamplep)*tstatsdumppi ! sv1tk(ib:ie,jb:je,kb:ke+kh) = (sv1tk(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + sv1k(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! sv2tk(ib:ie,jb:je,kb:ke+kh) = (sv2tk(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + sv2k(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! sv3tk(ib:ie,jb:je,kb:ke+kh) = (sv3tk(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + sv3k(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! sv4tk(ib:ie,jb:je,kb:ke+kh) = (sv4tk(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + sv4k(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! wsv1tk(ib:ie,jb:je,kb:ke+kh) = (wsv1tk(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + wm(ib:ie,jb:je,kb:ke+kh)*sv1k(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! wsv2tk(ib:ie,jb:je,kb:ke+kh) = (wsv2tk(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + wm(ib:ie,jb:je,kb:ke+kh)*sv2k(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! wsv3tk(ib:ie,jb:je,kb:ke+kh) = (wsv3tk(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + wm(ib:ie,jb:je,kb:ke+kh)*sv3k(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! wsv4tk(ib:ie,jb:je,kb:ke+kh) = (wsv4tk(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + wm(ib:ie,jb:je,kb:ke+kh)*sv4k(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! sv1sgst(ib:ie,jb:je,kb:ke+kh) = (sv1sgst(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + sv1sgs(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! sv2sgst(ib:ie,jb:je,kb:ke+kh) = (sv2sgst(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + sv2sgs(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! sv3sgst(ib:ie,jb:je,kb:ke+kh) = (sv3sgst(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + sv3sgs(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! sv4sgst(ib:ie,jb:je,kb:ke+kh) = (sv4sgst(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + sv4sgs(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi !end if ! ltdump !      where (IIuwt==0) !        upwpyik    = -999 !        upwpytik   = -999 !      endwhere ! EXAMPLE FOR OTHER SLICE PLANES !> slice over purifier !      if (nprocs>7) then !      if (myid==7) then !        sca1y(ib:ie,kb:ke) = (sca1y(ib:ie,kb:ke)*(tstatsdumpp-tsamplep) + svm(ib:ie,2,kb:ke,1)*tsamplep)*tstatsdumppi !      end if !      end if end if ! lytdump .or. lydump .or. lxydump .or. lxytdump ! slicedump fields are generalised so can define what is required here if ( lslicedump ) then slice = ( slice * ( tstatsdumpp - tsamplep ) + ( 0.5 * ( svm ( ib : ie , jb : je , kb , 1 ) + svm ( ib : ie , jb : je , kb + 1 , 1 ))) * tsamplep ) * tstatsdumppi slice2 = ( slice2 * ( tstatsdumpp - tsamplep ) + ( sum ( svm ( ib : ie , jb : je , kb : kb + 8 , 1 ), 3 ) / 9. ) * tsamplep ) * tstatsdumppi slice3 = ( slice3 * ( tstatsdumpp - tsamplep ) + ( 0.5 * ( svm ( ib : ie , jb : je , kb , 2 ) + svm ( ib : ie , jb : je , kb + 1 , 2 ))) * tsamplep ) * tstatsdumppi slice4 = ( slice4 * ( tstatsdumpp - tsamplep ) + ( sum ( svm ( ib : ie , jb : je , kb : kb + 8 , 2 ), 3 ) / 9. ) * tsamplep ) * tstatsdumppi slice5 = ( slice5 * ( tstatsdumpp - tsamplep ) + ( 0.5 * ( svm ( ib : ie , jb : je , kb , 3 ) + svm ( ib : ie , jb : je , kb + 1 , 3 ))) * tsamplep ) * tstatsdumppi slice6 = ( slice6 * ( tstatsdumpp - tsamplep ) + ( sum ( svm ( ib : ie , jb : je , kb : kb + 8 , 3 ), 3 ) / 9. ) * tsamplep ) * tstatsdumppi slice7 = ( slice7 * ( tstatsdumpp - tsamplep ) + ( um ( ib : ie , jb : je , kb ) + um ( ib : ie , jb : je , kb + 1 )) * tsamplep ) * tstatsdumppi slice8 = ( slice8 * ( tstatsdumpp - tsamplep ) + ( vm ( ib : ie , jb : je , kb ) + vm ( ib : ie , jb : je , kb + 1 )) * tsamplep ) * tstatsdumppi endif !lslicedump ! Write y-averaged statistics every tsample if ( lydump ) then if ( myid == 0 ) then allocate ( field ( ib : ie , kb : ke )) allocate ( varsy ( imax , khigh - klow + 1 , nstaty )) varsy = 0. varsy (:,:, 1 ) = uy ( ib : ie , kb : ke ) varsy (:,:, 2 ) = vy ( ib : ie , kb : ke ) varsy (:,:, 3 ) = wy ( ib : ie , kb : ke ) varsy (:,:, 4 ) = thly ( ib : ie , kb : ke ) varsy (:,:, 5 ) = qty ( ib : ie , kb : ke ) varsy (:,:, 6 ) = sca1y ( ib : ie , kb : ke ) varsy (:,:, 7 ) = sca2y ( ib : ie , kb : ke ) varsy (:,:, 8 ) = sca3y ( ib : ie , kb : ke ) varsy (:,:, 9 ) = upwpyik ( ib : ie , kb : ke ) varsy (:,:, 10 ) = wpthlpyk ( ib : ie , kb : ke ) varsy (:,:, 11 ) = usgsy ( ib : ie , kb : ke ) varsy (:,:, 12 ) = thlsgsy ( ib : ie , kb : ke ) varsy (:,:, 13 ) = uwyik ( ib : ie , kb : ke ) varsy (:,:, 14 ) = wthlyk ( ib : ie , kb : ke ) call writestat_nc ( ncidy , 1 , tncstaty ,( / timee / ), nrecy ,. true .) call writestat_nc ( ncidy , nstaty , ncstaty , varsy , nrecy , imax , khigh - klow + 1 ) deallocate ( field , varsy ) endif !myid endif !lydump ! Write xy-averaged statistics every tsample if ( lxydump ) then if ( myid == 0 ) then call writestat_nc ( ncidxy , 1 , tncstatxy ,( / timee / ), nrecxy ,. true .) allocate ( varsxy ( khigh - klow + 1 , nstatxy )) varsxy (:, 1 ) = uxy ( kb : ke ) varsxy (:, 2 ) = vxy ( kb : ke ) varsxy (:, 3 ) = wxy ( kb : ke ) varsxy (:, 4 ) = thlxy ( kb : ke ) varsxy (:, 5 ) = qtxy ( kb : ke ) varsxy (:, 6 ) = pxy ( kb : ke ) varsxy (:, 7 ) = upwpxyik ( kb : ke ) varsxy (:, 8 ) = wpthlpxyk ( kb : ke ) varsxy (:, 9 ) = vpwpxyjk ( kb : ke ) varsxy (:, 10 ) = usgsxy ( kb : ke ) varsxy (:, 11 ) = thlsgsxy ( kb : ke ) !wdthldtc(kb:ke) varsxy (:, 12 ) = vsgsxy ( kb : ke ) varsxy (:, 13 ) = uwxyik ( kb : ke ) varsxy (:, 14 ) = wthlxyk ( kb : ke ) varsxy (:, 15 ) = vwxyjk ( kb : ke ) call writestat_1D_nc ( ncidxy , nstatxy , ncstatxy , varsxy , nrecxy , khigh - klow + 1 ) end if !myid end if !lxydump if ( ltkedump ) then !call genstats(tsamplep,tstatsdumpp,umc,vmc,wmc) endif tsamplep = dt else !timestatsdumpp < tsample tsamplep = tsamplep + dt endif if ( tstatsdumpp > tstatsdump ) then ! Final calculations and write xyt-averaged statistics every tsample if ( lxytdump ) then wthltxyk = 0. ; uwtxyik = 0. ; vwtxyjk = 0. ; wwtxyk = 0. ; uvtxyij = 0. ; wpthlptxyk = 0. ; upwptxyik = 0. ; vpwptxyjk = 0. ; upvptxyij = 0. ; thlpthlptxy = 0. ; upuptxyc = 0. ; vpvptxyc = 0. ; wpwptxyc = 0. ; tketxyc = 0. !> Advective flux if ( ltempeq ) then call avexy_ibm ( wthltxyk ( kb : ke + kh ), wmt ( ib : ie , jb : je , kb : ke + kh ) * thltk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. true .) end if call avexy_ibm ( uwtxyik ( kb : ke + kh ), utik ( ib : ie , jb : je , kb : ke + kh ) * wtik ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIuw ( ib : ie , jb : je , kb : ke + kh ), IIuws ( kb : ke + kh ),. true .) call avexy_ibm ( vwtxyjk ( kb : ke + kh ), vtjk ( ib : ie , jb : je , kb : ke + kh ) * wtjk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIvw ( ib : ie , jb : je , kb : ke + kh ), IIvws ( kb : ke + kh ),. true .) call avexy_ibm ( wwtxyk ( kb : ke + kh ), wmt ( ib : ie , jb : je , kb : ke + kh ) * wmt ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. true .) call avexy_ibm ( uvtxyij ( kb : ke + kh ), utij ( ib : ie , jb : je , kb : ke + kh ) * vtij ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIuv ( ib : ie , jb : je , kb : ke + kh ), IIuvs ( kb : ke + kh ),. true .) !> Turbulent fluxes if ( ltempeq ) then call avexy_ibm ( wpthlptxyk ( kb : ke + kh ), wthltk ( ib : ie , jb : je , kb : ke + kh ) - wmt ( ib : ie , jb : je , kb : ke + kh ) * thltk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. true .) end if call avexy_ibm ( upwptxyik ( kb : ke + kh ), uwtik ( ib : ie , jb : je , kb : ke + kh ) - utik ( ib : ie , jb : je , kb : ke + kh ) * wtik ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIuw ( ib : ie , jb : je , kb : ke + kh ), IIuws ( kb : ke + kh ),. true .) call avexy_ibm ( vpwptxyjk ( kb : ke + kh ), vwtjk ( ib : ie , jb : je , kb : ke + kh ) - vtjk ( ib : ie , jb : je , kb : ke + kh ) * wtjk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIvw ( ib : ie , jb : je , kb : ke + kh ), IIvws ( kb : ke + kh ),. true .) call avexy_ibm ( upvptxyij ( kb : ke + kh ), uvtij ( ib : ie , jb : je , kb : ke + kh ) - utij ( ib : ie , jb : je , kb : ke + kh ) * vtij ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIuv ( ib : ie , jb : je , kb : ke + kh ), IIuvs ( kb : ke + kh ),. true .) !> Variances and TKE if ( ltempeq ) then call avexy_ibm ( thlpthlptxy ( kb : ke + kh ), thlthlt ( ib : ie , jb : je , kb : ke + kh ) - thlt ( ib : ie , jb : je , kb : ke + kh ) * thlt ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. true .) end if call avexy_ibm ( upuptxyc ( kb : ke + kh ), uutc ( ib : ie , jb : je , kb : ke + kh ) - utc ( ib : ie , jb : je , kb : ke + kh ) * utc ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. true .) call avexy_ibm ( vpvptxyc ( kb : ke + kh ), vvtc ( ib : ie , jb : je , kb : ke + kh ) - vtc ( ib : ie , jb : je , kb : ke + kh ) * vtc ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. true .) call avexy_ibm ( wpwptxyc ( kb : ke + kh ), wwtc ( ib : ie , jb : je , kb : ke + kh ) - wtc ( ib : ie , jb : je , kb : ke + kh ) * wtc ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. true .) call avexy_ibm ( tketxyc ( kb : ke + kh ), 0.5 * (( wwtc ( ib : ie , jb : je , kb : ke + kh ) - wtc ( ib : ie , jb : je , kb : ke + kh ) * wtc ( ib : ie , jb : je , kb : ke + kh )) + ( vvtc ( ib : ie , jb : je , kb : ke + kh ) - vtc ( ib : ie , jb : je , kb : ke + kh ) * vtc ( ib : ie , jb : je , kb : ke + kh )) + ( uutc ( ib : ie , jb : je , kb : ke + kh ) - utc ( ib : ie , jb : je , kb : ke + kh ) * utc ( ib : ie , jb : je , kb : ke + kh ))), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. true .) if ( myid == 0 ) then call writestat_nc ( ncidxyt , 1 , tncstatxyt ,( / timee / ), nrecxyt ,. true .) allocate ( varsxyt ( khigh - klow + 1 , nstatxyt )) varsxyt (:, 1 ) = uxyt ( kb : ke ) varsxyt (:, 2 ) = vxyt ( kb : ke ) varsxyt (:, 3 ) = wxyt ( kb : ke ) varsxyt (:, 4 ) = thlxyt ( kb : ke ) varsxyt (:, 5 ) = qtxyt ( kb : ke ) varsxyt (:, 6 ) = pxyt ( kb : ke ) varsxyt (:, 7 ) = upwptxyik ( kb : ke ) varsxyt (:, 8 ) = wpthlptxyk ( kb : ke ) varsxyt (:, 9 ) = vpwptxyjk ( kb : ke ) varsxyt (:, 10 ) = upvptxyij ( kb : ke ) varsxyt (:, 11 ) = uwtxyik ( kb : ke ) varsxyt (:, 12 ) = wthltxyk ( kb : ke ) !wdthldtc(kb:ke) varsxyt (:, 13 ) = uvtxyij ( kb : ke ) varsxyt (:, 14 ) = vwtxyjk ( kb : ke ) varsxyt (:, 15 ) = wwtxyk ( kb : ke ) varsxyt (:, 16 ) = usgsxyt ( kb : ke ) !wdthldtw(kb:ke) varsxyt (:, 17 ) = thlsgsxyt ( kb : ke ) varsxyt (:, 18 ) = vsgsxyt ( kb : ke ) varsxyt (:, 19 ) = thlpthlptxy ( kb : ke ) varsxyt (:, 20 ) = upuptxyc ( kb : ke ) varsxyt (:, 21 ) = vpvptxyc ( kb : ke ) varsxyt (:, 22 ) = wpwptxyc ( kb : ke ) varsxyt (:, 23 ) = tketxyc ( kb : ke ) call writestat_1D_nc ( ncidxyt , nstatxyt , ncstatxyt , varsxyt , nrecxyt , khigh - klow + 1 ) end if !myid end if !lxytdump ! Final calculations and write yt-averaged statistics every tsample if ( lytdump ) then !    call MPI_BCAST(sca1yt ,(ke+kh-(kb-kh))*(ie+ih-(ib-ih)),MY_REAL   ,7,comm3d,mpierr) ! Turbulent flux call avey_ibm ( upwptyik , uwtik ( ib : ie , jb : je , kb : ke ) - utik ( ib : ie , jb : je , kb : ke ) * wtik ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIuw ( ib : ie , jb : je , kb : ke ), IIuwt ( ib : ie , kb : ke )) call avey_ibm ( uwtyik , utik ( ib : ie , jb : je , kb : ke ) * wtik ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIuw ( ib : ie , jb : je , kb : ke ), IIuwt ( ib : ie , kb : ke )) call avey_ibm ( upuptyc , uutc ( ib : ie , jb : je , kb : ke ) - utc ( ib : ie , jb : je , kb : ke ) * utc ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) call avey_ibm ( vpvptyc , vvtc ( ib : ie , jb : je , kb : ke ) - vtc ( ib : ie , jb : je , kb : ke ) * vtc ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) call avey_ibm ( wpwptyc , wwtc ( ib : ie , jb : je , kb : ke ) - wtc ( ib : ie , jb : je , kb : ke ) * wtc ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) if ( ltempeq ) then call avey_ibm ( wpthlptyk , wthltk ( ib : ie , jb : je , kb : ke ) - wmt ( ib : ie , jb : je , kb : ke ) * thltk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( wthltyk , wmt ( ib : ie , jb : je , kb : ke ) * thltk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( thlpthlpty , thlthlt ( ib : ie , jb : je , kb : ke ) - thlt ( ib : ie , jb : je , kb : ke ) * thlt ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) end if if ( lmoist ) then call avey_ibm ( wpqtptyk , wqttk ( ib : ie , jb : je , kb : ke ) - wmt ( ib : ie , jb : je , kb : ke ) * qttk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( wqttyk , wmt ( ib : ie , jb : je , kb : ke ) * qttk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( qtpqtpty , qtqtt ( ib : ie , jb : je , kb : ke ) - qtt ( ib : ie , jb : je , kb : ke ) * qtt ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) end if if ( nsv > 0 ) then call avey_ibm ( wpsv1ptyk , wsv1tk ( ib : ie , jb : je , kb : ke ) - wmt ( ib : ie , jb : je , kb : ke ) * sv1tk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( wsv1tyk , wmt ( ib : ie , jb : je , kb : ke ) * sv1tk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( sv1psv1pty , sv1sv1t ( ib : ie , jb : je , kb : ke ) - sv1t ( ib : ie , jb : je , kb : ke ) * sv1t ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) end if if ( nsv > 1 ) then call avey_ibm ( wpsv2ptyk , wsv2tk ( ib : ie , jb : je , kb : ke ) - wmt ( ib : ie , jb : je , kb : ke ) * sv2tk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( wsv2tyk , wmt ( ib : ie , jb : je , kb : ke ) * sv2tk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( sv2psv2pty , sv2sv2t ( ib : ie , jb : je , kb : ke ) - sv2t ( ib : ie , jb : je , kb : ke ) * sv2t ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) end if if ( nsv > 2 ) then call avey_ibm ( wpsv3ptyk , wsv3tk ( ib : ie , jb : je , kb : ke ) - wmt ( ib : ie , jb : je , kb : ke ) * sv3tk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( wsv3tyk , wmt ( ib : ie , jb : je , kb : ke ) * sv3tk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( sv3psv3pty , sv3sv3t ( ib : ie , jb : je , kb : ke ) - sv3t ( ib : ie , jb : je , kb : ke ) * sv3t ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) end if if ( myid == 0 ) then allocate ( varsyt ( imax , khigh - klow + 1 , nstatyt )) varsyt = 0. call writestat_nc ( ncidyt , 1 , tncstatyt ,( / timee / ), nrecyt ,. true .) varsyt (:,:, 1 ) = uyt ( ib : ie , kb : ke ) varsyt (:,:, 2 ) = vyt ( ib : ie , kb : ke ) varsyt (:,:, 3 ) = wyt ( ib : ie , kb : ke ) varsyt (:,:, 4 ) = thlyt ( ib : ie , kb : ke ) varsyt (:,:, 5 ) = qtyt ( ib : ie , kb : ke ) varsyt (:,:, 6 ) = sca1yt ( ib : ie , kb : ke ) varsyt (:,:, 7 ) = sca2yt ( ib : ie , kb : ke ) varsyt (:,:, 8 ) = sca3yt ( ib : ie , kb : ke ) varsyt (:,:, 9 ) = upwptyik ( ib : ie , kb : ke ) varsyt (:,:, 10 ) = wpthlptyk ( ib : ie , kb : ke ) varsyt (:,:, 11 ) = wpqtptyk ( ib : ie , kb : ke ) varsyt (:,:, 12 ) = wpsv1ptyk ( ib : ie , kb : ke ) varsyt (:,:, 13 ) = wpsv2ptyk ( ib : ie , kb : ke ) varsyt (:,:, 14 ) = wpsv3ptyk ( ib : ie , kb : ke ) varsyt (:,:, 15 ) = uwtyik ( ib : ie , kb : ke ) varsyt (:,:, 16 ) = wthltyk ( ib : ie , kb : ke ) varsyt (:,:, 17 ) = wqttyk ( ib : ie , kb : ke ) varsyt (:,:, 18 ) = wsv1tyk ( ib : ie , kb : ke ) varsyt (:,:, 19 ) = wsv2tyk ( ib : ie , kb : ke ) varsyt (:,:, 20 ) = wsv3tyk ( ib : ie , kb : ke ) varsyt (:,:, 21 ) = upuptyc ( ib : ie , kb : ke ) varsyt (:,:, 22 ) = wpwptyc ( ib : ie , kb : ke ) varsyt (:,:, 23 ) = thlpthlpty ( ib : ie , kb : ke ) varsyt (:,:, 24 ) = qtpqtpty ( ib : ie , kb : ke ) varsyt (:,:, 25 ) = sv1psv1pty ( ib : ie , kb : ke ) varsyt (:,:, 26 ) = sv2psv2pty ( ib : ie , kb : ke ) varsyt (:,:, 27 ) = sv3psv3pty ( ib : ie , kb : ke ) varsyt (:,:, 28 ) = usgsyt ( ib : ie , kb : ke ) varsyt (:,:, 29 ) = wsgsyt ( ib : ie , kb : ke ) varsyt (:,:, 30 ) = thlsgsyt ( ib : ie , kb : ke ) varsyt (:,:, 31 ) = qtsgsyt ( ib : ie , kb : ke ) varsyt (:,:, 32 ) = sv1sgsyt ( ib : ie , kb : ke ) varsyt (:,:, 33 ) = sv2sgsyt ( ib : ie , kb : ke ) varsyt (:,:, 34 ) = sv3sgsyt ( ib : ie , kb : ke ) call writestat_nc ( ncidyt , nstatyt , ncstatyt , varsyt , nrecyt , imax , khigh - klow + 1 ) end if !myid end if !lytdump ! Final calculations and write t-averaged statistics every tsample if ( ltdump ) then ! wpsv1p = wsv1tk - wmt*sv1tk ! wpsv2p = wsv2tk - wmt*sv2tk ! wpsv3p = wsv3tk - wmt*sv3tk ! wpsv4p = wsv4tk - wmt*sv4tk wpthlptk = 0. ; thlpthlpt = 0. !> Turbulent fluxes upwptik = uwtik - utik * wtik vpwptjk = vwtjk - vtjk * wtjk upvptij = uvtij - utij * vtij if ( ltempeq ) then wpthlptk = wthltk - wmt * thlk end if if ( nsv > 0 ) then wpsv1p = wsv1tk - wmt * sv1tk end if if ( nsv > 1 ) then wpsv2p = wsv2tk - wmt * sv2tk end if if ( nsv > 2 ) then wpsv3p = wsv3tk - wmt * sv3tk end if if ( nsv > 3 ) then wpsv4p = wsv4tk - wmt * sv4tk end if !> Variances and TKE if ( ltempeq ) then thlpthlpt = thlthlt - thlt * thlt end if upuptc = uutc - utc * utc vpvptc = vvtc - vtc * vtc wpwptc = wwtc - wtc * wtc tketc = 0.5 * ( upuptc + vpvptc + wpwptc ) if ( nsv > 0 ) then sv1psv1pt = sv1sv1t - sv1t * sv1t end if if ( nsv > 1 ) then sv2psv2pt = sv2sv2t - sv2t * sv2t end if if ( nsv > 2 ) then sv3psv3pt = sv3sv3t - sv3t * sv3t end if if ( nsv > 3 ) then sv4psv4pt = sv4sv4t - sv4t * sv4t end if !      if (myid == 0) then allocate ( varst ( imax , jmax , khigh - klow + 1 , nstatt )) call writestat_nc ( ncidt , 1 , tncstatt ,( / timee / ), nrect ,. true .) varst (:,:,:, 1 ) = umt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 2 ) = vmt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 3 ) = wmt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 4 ) = thlt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 5 ) = qtt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 6 ) = pt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 7 ) = sv1t ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 8 ) = sv2t ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 9 ) = sv3t ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 10 ) = sv4t ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 11 ) = PSSt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 12 ) = upwptik ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 13 ) = vpwptjk ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 14 ) = upvptij ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 15 ) = wpthlptk ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 16 ) = wpsv1p ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 17 ) = wpsv2p ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 18 ) = wpsv3p ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 19 ) = wpsv4p ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 20 ) = thlpthlpt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 21 ) = upuptc ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 22 ) = vpvptc ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 23 ) = wpwptc ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 24 ) = tketc ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 25 ) = sv1psv1pt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 26 ) = sv2psv2pt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 27 ) = sv3psv3pt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 28 ) = sv4psv4pt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 29 ) = sv1sgst ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 30 ) = sv2sgst ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 31 ) = sv3sgst ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 32 ) = sv4sgst ( ib : ie , jb : je , kb : ke ) ! varst(:,:,:,33) = sv1max(ib:ie,jb:je,kb:ke) ! varst(:,:,:,34) = sv2max(ib:ie,jb:je,kb:ke) ! varst(:,:,:,35) = sv3max(ib:ie,jb:je,kb:ke) ! varst(:,:,:,36) = sv4max(ib:ie,jb:je,kb:ke) call writestat_nc ( ncidt , nstatt , ncstatt , varst , nrect , imax , jmax , khigh - klow + 1 ) !        end if !myid deallocate ( varst ) end if !ltdump if ( ltkedump ) then call tkestatsdump if ( myid == 0 ) then call writestat_nc ( ncidtke , 1 , tncstattke ,( / timee / ), nrectke ,. true .) allocate ( varstke ( khigh - klow + 1 , nstattke )) varstke (:, 1 ) = p_b ( kb : ke + kh ) varstke (:, 2 ) = t_p ( kb : ke + kh ) varstke (:, 3 ) = adv ( kb : ke + kh ) varstke (:, 4 ) = t_t ( kb : ke + kh ) varstke (:, 5 ) = t_sgs ( kb : ke + kh ) varstke (:, 6 ) = p_t ( kb : ke + kh ) varstke (:, 7 ) = t_v ( kb : ke + kh ) varstke (:, 8 ) = d_sgs ( kb : ke + kh ) call writestat_1D_nc ( ncidtke , nstattke , ncstattke , varstke , nrectke , khigh - klow + 1 ) end if !myid endif !ltkedump if ( lslicedump ) then allocate ( varslice ( imax , jmax , nstatslice )) call writestat_nc ( ncidslice , 1 , tncstatslice ,( / timee / ), nrecslice ,. true .) varslice (:,:, 1 ) = slice varslice (:,:, 2 ) = slice2 varslice (:,:, 3 ) = slice3 varslice (:,:, 4 ) = slice4 varslice (:,:, 5 ) = slice5 varslice (:,:, 6 ) = slice6 varslice (:,:, 7 ) = slice7 varslice (:,:, 8 ) = slice8 ! write(*,*) myid ! write(*,*) 'ncidslice,1,tncstatslice,(/timee/),nrecslice,.true.', ncidslice,1,tncstatslice,(/timee/),nrecslice call writestat_nc ( ncidslice , nstatslice , ncstatslice , varslice , nrecslice , imax , jmax ) ! deallocate(varslice) endif tstatsdumpp = dt else !tstatsdumpp < tstatsdump tstatsdumpp = tstatsdumpp + dt endif deallocate ( thlk , qtk , uik , wik , vjk , wjk , uij , vij , uc , vc , wc ) deallocate ( thlsgs , qtsgs , usgs , vsgs , wsgs ) deallocate ( sv1k , sv2k , sv3k , sv4k , sv1sgs , sv2sgs , sv3sgs , sv4sgs , PSS , wpsv1p , wpsv2p , wpsv3p , wpsv4p , sv1psv1pt , sv2psv2pt , sv3psv3pt , sv4psv4pt ) deallocate ( upwptik , vpwptjk , upvptij , wpthlptk , thlpthlpt , upuptc , vpvptc , wpwptc , tketc ) end subroutine statsdump !> tg3315 still under going work to be completed subroutine tkestatsdump use modfields , only : u0 , v0 , w0 , thl0 , uav , vav , wav , uuav , vvav , wwav , uvav , uwav , vwav , thlav , thlthlav , pres0 , thluav , thlvav , thlwav ,& upupav , vpvpav , wpwpav , thlpthlpav , upvpav , upwpav , vpwpav , thlpupav , thlpvpav , thlpwpav , presav ,& strain2av , disssgsav , t_vav , tvmx , tvmy , tvmz , tsgsmx1 , tsgsmx2 , tsgsmy1 , tsgsmy2 , tsgsmz1 , t_sgsav , nusgsav ,& tpm , t_pav , ttmx , ttmy , ttmz , t_tav , p_bav , d_sgsav , p_tav , tkeadv , tsgsmz1 , tsgsmz2 , t_t , t_v , t_p , t_sgs , d_sgs ,& p_b , p_t , adv , IIc , IIcs use modglobal , only : ib , ie , ih , jb , je , jgb , jge , dy , jh , ke , kb , kh , rk3step , timee , cexpnr , tsample , tstatsdump , jtot , imax , dzf ,& dzf , dzfi , dzhi , dxf , dxfi , dyi , dxhi , dy2i , grav , numol use modmpi , only : myid , cmyid , my_real , mpi_sum , avey_ibm , mpierr , comm3d , excjs , avexy_ibm use modsurfdata , only : thls use modsubgrid , only : ekh implicit none real , dimension ( ib : ie , jb : je , kb : ke ) :: disssgsfl ! average subgrid visc. * average rate of strain squared : 2*<nu_t>*<Sij>*<Sij> real , dimension ( ib : ie , jb : je , kb : ke ) :: dissresav ! average resolved dissipation: 2*nu*<Sij'*Sij'> = 2*nu*( <Sij*Sij> - <Sij>*<Sij> ) real , dimension ( ib : ie , jb : je , kb : ke ) :: tke ! tke = 0.5*<ui'ui'> real , dimension ( ib : ie , jb : je , kb : ke ) :: mke ! = <ui>d/dxj(<ui><uj>) + <ui>d/dxj(<ui'uj'>) = <ui>d/dxj(<ui*uj>) real , dimension ( ib : ie + 1 , jb : je , kb : ke ) :: dummyx real , dimension ( ib : ie , jb - 1 : je + 1 , kb : ke ) :: dummyy real , dimension ( ib : ie , jb : je , kb : ke + 1 ) :: dummyz integer i , j , k , ip , im , jp , jm , kp , km real strainav2 real dummy ! Tvav = (Tvm - <ui>*d/dxj(<Sij>)  ) + 2*nu*<Sij'Sij'> ! Tvm = Tvmx + Tvmy + Tvmz -> therefore: subtraction, then interpolation, ! then addition of 2*nu*<Sij'Sij'> do k = kb , ke km = k - 1 kp = k + 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie im = i - 1 ip = i + 1 !            t_vav(i,j,k) =  0.5*( (tvmx(i,j,k) - (                      & dummyx ( i , j , k ) = ( & ( numol * ( uav ( i + 1 , j , k ) - uav ( i , j , k )) * dxfi ( i ) & - numol * ( uav ( i , j , k ) - uav ( i - 1 , j , k )) * dxfi ( i - 1 ) ) * 2. * dxhi ( i ) & + & ( numol * ( ( uav ( i , jp , k ) - uav ( i , j , k )) * dyi & + ( vav ( i , jp , k ) - vav ( i - 1 , jp , k )) * dxhi ( i )) & - numol * ( ( uav ( i , j , k ) - uav ( i , jm , k )) * dyi & + ( vav ( i , j , k ) - vav ( i - 1 , j , k )) * dxhi ( i )) & ) * dyi & + & ( numol * ( ( uav ( i , j , kp ) - uav ( i , j , k )) * dzhi ( kp ) & + ( wav ( i , j , kp ) - wav ( i - 1 , j , kp )) * dxhi ( i )) & - numol * ( ( uav ( i , j , k ) - uav ( i , j , km )) * dzhi ( k ) & + ( wav ( i , j , k ) - wav ( i - 1 , j , k )) * dxhi ( i )) & ) * dzfi ( k ) ) ! y-direction dummyy ( i , j , k ) = ( & ( numol * ( ( vav ( i + 1 , j , k ) - vav ( i , j , k )) * dxhi ( i + 1 ) & + ( uav ( i + 1 , j , k ) - uav ( i + 1 , jm , k )) * dyi ) & - numol * ( ( vav ( i , j , k ) - vav ( i - 1 , j , k )) * dxhi ( i ) & + ( uav ( i , j , k ) - uav ( i , jm , k )) * dyi ) & ) * dxfi ( i ) & ! = d/dx( Km*(dv/dx + du/dy) ) + & ( numol * ( vav ( i , jp , k ) - vav ( i , j , k )) & - numol * ( vav ( i , j , k ) - vav ( i , jm , k )) ) * 2. * dy2i & ! =d/dy( 2*Km*(dv/dy) ) + & ( numol * ( ( vav ( i , j , kp ) - vav ( i , j , k )) * dzhi ( kp ) & + ( wav ( i , j , kp ) - wav ( i , jm , kp )) * dyi ) & - numol * ( ( vav ( i , j , k ) - vav ( i , j , km )) * dzhi ( k ) & + ( wav ( i , j , k ) - wav ( i , jm , k )) * dyi ) & ) * dzfi ( k ) ) ! = d/dz( Km*(dv/dz + dw/dy) ) ! z-direction dummyz ( i , j , k ) = ( & ( numol * ( ( wav ( i + 1 , j , k ) - wav ( i , j , k )) * dxhi ( i + 1 ) & + ( uav ( i + 1 , j , k ) - uav ( i + 1 , j , km )) * dzhi ( k ) ) & - numol * ( ( wav ( i , j , k ) - wav ( i - 1 , j , k )) * dxhi ( i ) & + ( uav ( i , j , k ) - uav ( i , j , km )) * dzhi ( k ) ) & ) * dxfi ( i ) & + & ( numol * ( ( wav ( i , jp , k ) - wav ( i , j , k )) * dyi & + ( vav ( i , jp , k ) - vav ( i , jp , km )) * dzhi ( k ) ) & - numol * ( ( wav ( i , j , k ) - wav ( i , jm , k )) * dyi & + ( vav ( i , j , k ) - vav ( i , j , km )) * dzhi ( k ) ) & ) * dyi & + & ( numol * ( wav ( i , j , kp ) - wav ( i , j , k )) * dzfi ( k ) & - numol * ( wav ( i , j , k ) - wav ( i , j , km )) * dzfi ( km ) ) * 2. & * dzhi ( k )) strainav2 = ( & (( uav ( ip , j , k ) - uav ( i , j , k )) * dxfi ( i ) ) ** 2 + & (( vav ( i , jp , k ) - vav ( i , j , k )) * dyi ) ** 2 + & (( wav ( i , j , kp ) - wav ( i , j , k )) * dzfi ( k ) ) ** 2 ) strainav2 = strainav2 + 0.125 * ( & (( wav ( i , j , kp ) - wav ( im , j , kp )) * dxhi ( i ) + & ( uav ( i , j , kp ) - uav ( i , j , k )) * dzhi ( kp ) ) ** 2 + & (( wav ( i , j , k ) - wav ( im , j , k )) * dxhi ( i ) + & ( uav ( i , j , k ) - uav ( i , j , km )) * dzhi ( k ) ) ** 2 + & (( wav ( ip , j , k ) - wav ( i , j , k )) * dxhi ( ip ) + & ( uav ( ip , j , k ) - uav ( ip , j , km )) * dzhi ( k ) ) ** 2 + & (( wav ( ip , j , kp ) - wav ( i , j , kp )) * dxhi ( ip ) + & ( uav ( ip , j , kp ) - uav ( ip , j , k )) * dzhi ( kp ) ) ** 2 ) strainav2 = strainav2 + 0.125 * ( & (( uav ( i , jp , k ) - uav ( i , j , k )) * dyi + & ( vav ( i , jp , k ) - vav ( im , jp , k )) * dxhi ( i ) ) ** 2 + & (( uav ( i , j , k ) - uav ( i , jm , k )) * dyi + & ( vav ( i , j , k ) - vav ( im , j , k )) * dxhi ( i ) ) ** 2 + & (( uav ( ip , j , k ) - uav ( ip , jm , k )) * dyi + & ( vav ( ip , j , k ) - vav ( i , j , k )) * dxhi ( ip ) ) ** 2 + & (( uav ( ip , jp , k ) - uav ( ip , j , k )) * dyi + & ( vav ( ip , jp , k ) - vav ( i , jp , k )) * dxhi ( ip ) ) ** 2 ) strainav2 = strainav2 + 0.125 * ( & (( vav ( i , j , kp ) - vav ( i , j , k )) * dzhi ( kp ) + & ( wav ( i , j , kp ) - wav ( i , jm , kp )) * dyi ) ** 2 + & (( vav ( i , j , k ) - vav ( i , j , km )) * dzhi ( k ) + & ( wav ( i , j , k ) - wav ( i , jm , k )) * dyi ) ** 2 + & (( vav ( i , jp , k ) - vav ( i , jp , km )) * dzhi ( k ) + & ( wav ( i , jp , k ) - wav ( i , j , k )) * dyi ) ** 2 + & (( vav ( i , jp , kp ) - vav ( i , jp , k )) * dzhi ( kp ) + & ( wav ( i , jp , kp ) - wav ( i , j , kp )) * dyi ) ** 2 ) dissresav ( i , j , k ) = 2. * numol * ( strain2av ( i , j , k ) - strainav2 ) !resolved dissipation end do end do end do ! BC's tvmx ( ie + 1 ,:,:) = tvmx ( ie ,:,:) tsgsmx1 ( ie + 1 ,:,:) = tsgsmx1 ( ie ,:,:) tsgsmx2 ( ie + 1 ,:,:) = tsgsmx2 ( ie ,:,:) dummyx ( ie + 1 ,:,:) = dummyx ( ie ,:,:) ttmx ( ie + 1 ,:,:) = ttmx ( ie ,:,:) call excjs ( tvmy , ib , ie , jb , je , kb , ke , 0 , 1 ) ! jb-1 is not used call excjs ( tsgsmy1 , ib , ie , jb , je , kb , ke , 0 , 1 ) ! jb-1 is not used call excjs ( tsgsmy2 , ib , ie , jb , je , kb , ke , 0 , 1 ) ! jb-1 is not used call excjs ( dummyy , ib , ie , jb , je , kb , ke , 0 , 1 ) ! jb-1 is not used call excjs ( ttmy , ib , ie , jb , je , kb , ke , 0 , 1 ) ! jb-1 is not used tvmz (:,:, ke + 1 ) = tvmz (:,:, ke ) tsgsmz1 (:,:, ke + 1 ) = tsgsmz1 (:,:, ke ) tsgsmz2 (:,:, ke + 1 ) = tsgsmz2 (:,:, ke ) dummyz (:,:, ke + 1 ) = dummyz (:,:, ke ) ttmz (:,:, ke + 1 ) = ttmz (:,:, ke ) do k = kb , ke km = k - 1 kp = k + 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie im = i - 1 ip = i + 1 ! Total viscous dissipation t_vav ( i , j , k ) = 0.5 * ( ( tvmx ( i , j , k ) - dummyx ( i , j , k ) * uav ( i , j , k )) + & ( tvmx ( ip , j , k ) - dummyx ( ip , j , k ) * uav ( ip , j , k ))) & + 0.5 * ( ( tvmy ( i , j , k ) - dummyy ( i , j , k ) * vav ( i , j , k )) + & ( tvmy ( i , jp , k ) - dummyy ( i , jp , k ) * vav ( i , jp , k ))) & + 0.5 * ( ( tvmz ( i , j , k ) - dummyz ( i , j , k ) * wav ( i , j , k )) + & ( tvmz ( i , j , kp ) - dummyz ( i , j , kp ) * wav ( i , j , kp ))) & + dissresav ( i , j , k ) ! d/dxj(2*nu*<ui'Sij'>) = <u_i*d/dxj(2*nu*Sij')> +2*nu*<Sij'Sij'> !      Now the same for subgrid stress !      <d/dxj(2*u_i'*nu_t*Sij)'> = <u_i'*d/dxj(2*nu_t*Sij)'> + <(2*nu_t*Sij)'*Sij'> !                                = <u_i*d/dxj(2*nu_t*Sij)> - !                                  <u_i>*<d/dxj(2*nu_t*Sij)>   + <2*nu_t*Sij*Sij> - !                                  <(2*nu_t*Sij)>*<Sij> !                                = <u_i*d/dxj(2*nu_t*Sij)> - !                                  <u_i>*<d/dxj(2*nu_t*Sij)>   + <2*nu_t*Sij*Sij> - !                                  2*<nu_t>*<Sij>*<Sij> - 2*<nu_t'*Sij'>*<Sij> !--------------------------------------- !Total subgrid TKE !--------------------------------------- ! Mean SGS dissipation disssgsfl ( i , j , k ) = 2. * nusgsav ( i , j , k ) * strainav2 ! = 2*<nu_sgs>*<sij>*<sij> ! TKE tke ( i , j , k ) = 0.5 * ( 0.5 * ( upupav ( ip , j , k ) + upupav ( i , j , k )) + & 0.5 * ( vpvpav ( i , jp , k ) + vpvpav ( i , j , k )) + & 0.5 * ( wpwpav ( i , j , kp ) + wpwpav ( i , j , k ))) ! total SGS t_sgsav ( i , j , k ) = 0.5 * ( ( tsgsmx1 ( i , j , k ) - uav ( i , j , k ) * tsgsmx2 ( i , j , k )) + & ( tsgsmx1 ( ip , j , k ) - uav ( ip , j , k ) * tsgsmx2 ( ip , j , k ))) & + & ! = <2*nu_t*SijSij> - <2*nu_t*Sij>*<Sij> 0.5 * ( ( tsgsmy1 ( i , j , k ) - vav ( i , j , k ) * tsgsmy2 ( i , j , k )) + & ( tsgsmy1 ( i , jp , k ) - vav ( i , jp , k ) * tsgsmy2 ( i , jp , k ))) & + & ! = <2*nu_t*SijSij> - <2*nu_t*Sij>*<Sij> 0.5 * ( ( tsgsmz1 ( i , j , k ) - vav ( i , j , k ) * tsgsmz2 ( i , j , k )) + & ( tsgsmz1 ( i , j , kp ) - vav ( i , j , kp ) * tsgsmz2 ( i , j , kp ))) & + disssgsav ( i , j , k ) - disssgsfl ( i , j , k ) ! -2*<nu_t'Sij'>*<Sij>  should still be added! ! SGS dissipation d_sgsav ( i , j , k ) = - disssgsav ( i , j , k ) + disssgsfl ( i , j , k ) ! +2*<nu_t'Sij'>*<Sij>  should still be added! (is compensated with above) !--------------------------------------- !Total pressure TKE !--------------------------------------- ! Pressure correlation term ! - <uj'*dp'/dxj> = - <uj*dp/dxj> + <uj>*d<p>/dxj t_pav ( i , j , k ) = tpm ( i , j , k ) + & 0.5 * ( uav ( i , j , k ) * ( presav ( i , j , k ) - presav ( i - 1 , j , k )) * dxhi ( i ) + & uav ( i + 1 , j , k ) * ( presav ( i + 1 , j , k ) - presav ( i , j , k )) * dxhi ( i + 1 )) & + & 0.5 * ( vav ( i , j , k ) * ( presav ( i , j , k ) - presav ( i , j - 1 , k )) * dyi + & vav ( i , j + 1 , k ) * ( presav ( i , j + 1 , k ) - presav ( i , j , k )) * dyi ) & + & 0.5 * ( wav ( i , j , k ) * ( presav ( i , j , k ) - presav ( i , j , k - 1 )) * dzhi ( k ) + & wav ( i , j , k + 1 ) * ( presav ( i , j , k + 1 ) - presav ( i , j , k )) * dzhi ( k + 1 )) ! - d/dxj(<0.5*ui'ui'uj'>) = -<uj'd/dxj(<0.5*ui'ui'>) + <ui'uj'><Sij> !                             = -<uj*d/dxj(0.5*ui'ui')> + <uj>*d/dxj(<0.5*ui'ui'> + !                             <ui'uj'><Sij>) !            ttav(i,j,k)   = ttm(i,j,k) - !--------------------------------------- !Total advection TKE !--------------------------------------- !            <advection term N.S. times ui> = MKE + A - Pshear - Tt !            Tt = -<ui'd/dxj(ui'uj')> = -<d/dxj(0.5*ui'ui'uj')> = A + MKE - Pshear - Total !Pshear =Ptav = -<ui'uj'>d/dxj(<Sij>) = -<ui'uj'>d<ui>/dxj ! mechanical or shear production p_tav ( i , j , k ) = - ( & 0.5 * ( upupav ( i , j , k ) + upupav ( ip , j , k )) * ( uav ( ip , j , k ) - uav ( i , j , k )) * dxfi ( i ) + & ! <u'u'>*d<u>/dx 0.25 * ( upvpav ( i , j , k ) * ( uav ( i , j , k ) - uav ( i , jm , k ) ) * dyi + & upvpav ( i , jp , k ) * ( uav ( i , jp , k ) - uav ( i , j , k ) ) * dyi + & upvpav ( ip , j , k ) * ( uav ( ip , j , k ) - uav ( ip , jm , k ) ) * dyi + & upvpav ( ip , jp , k ) * ( uav ( ip , jp , k ) - uav ( ip , j , k ) ) * dyi ) + & ! <u'v'>*d<u>/dy 0.25 * ( upwpav ( i , j , k ) * ( uav ( i , j , k ) - uav ( i , j , km )) * dzhi ( k ) + & upwpav ( i , j , kp ) * ( uav ( i , j , kp ) - uav ( i , j , k )) * dzhi ( kp ) + & upwpav ( ip , j , k ) * ( uav ( ip , j , k ) - uav ( ip , j , km )) * dzhi ( k ) + & upwpav ( ip , j , kp ) * ( uav ( ip , j , kp ) - uav ( ip , j , k )) * dzhi ( kp )) + & ! <u'w'>*d<u>/dz 0.25 * ( upvpav ( i , j , k ) * ( vav ( i , j , k ) - vav ( im , j , k )) * dxhi ( i ) + & upvpav ( ip , j , k ) * ( vav ( ip , j , k ) - vav ( i , j , k )) * dxhi ( ip ) + & upvpav ( i , jp , k ) * ( vav ( i , jp , k ) - vav ( im , jp , k )) * dxhi ( i ) + & upvpav ( ip , jp , k ) * ( vav ( ip , jp , k ) - vav ( i , jp , k )) * dxhi ( ip )) + & ! <u'v'>*d<v>/dx 0.5 * ( vpvpav ( i , j , k ) + vpvpav ( i , jp , k )) * ( vav ( i , jp , k ) - vav ( i , j , k )) * dyi + & ! <v'v'>*d<v>/dy 0.5 * ( vpvpav ( i , j , k ) + vpvpav ( i , jp , k )) * ( vav ( i , jp , k ) - vav ( i , j , k )) * dyi + & ! <v'v'>*d<v>/dy 0.25 * ( vpwpav ( i , j , k ) * ( vav ( i , j , k ) - vav ( i , j , km )) * dzhi ( k ) + & vpwpav ( i , j , kp ) * ( vav ( i , j , kp ) - vav ( i , j , k )) * dzhi ( kp ) + & vpwpav ( i , jp , k ) * ( vav ( i , jp , k ) - vav ( i , jp , km )) * dzhi ( k ) + & vpwpav ( i , jp , kp ) * ( vav ( i , jp , kp ) - vav ( i , jp , k )) * dzhi ( kp )) + & ! <v'w'>*d<v>/dz 0.25 * ( upwpav ( i , j , k ) * ( wav ( i , j , k ) - wav ( im , j , k )) * dxhi ( i ) + & upwpav ( ip , j , k ) * ( wav ( ip , j , k ) - wav ( i , j , k )) * dxhi ( ip ) + & upwpav ( i , j , kp ) * ( wav ( i , j , kp ) - wav ( im , j , kp )) * dxhi ( i ) + & upwpav ( ip , j , kp ) * ( wav ( ip , j , kp ) - wav ( i , j , kp )) * dxhi ( ip )) + & ! <u'w'>*d<w>/dx 0.25 * ( vpwpav ( i , j , k ) * ( wav ( i , j , k ) - wav ( i , jm , k ) ) * dyi + & vpwpav ( i , jp , k ) * ( wav ( i , jp , k ) - wav ( i , j , k ) ) * dyi + & vpwpav ( ip , j , k ) * ( wav ( i , j , kp ) - wav ( i , jm , kp ) ) * dyi + & vpwpav ( ip , jp , k ) * ( wav ( i , jp , kp ) - wav ( i , j , kp ) ) * dyi ) + & ! <v'w'>*d<w>/dy 0.5 * ( wpwpav ( i , j , k ) + wpwpav ( i , j , kp )) * ( wav ( i , j , kp ) - wav ( i , j , k )) * dzfi ( k ) ) ! <w'w'>*d<w>/dz ! Mean kinetic energy term (expected to be small). mke ( i , j , k ) = 0.5 * ( uav ( ip , j , k ) + uav ( i , j , k )) * ( uuav ( ip , j , k ) - uuav ( i , j , k )) * dxfi ( i ) + & !<u>*d<uu>/dx 0.5 * ( uav ( i , j , k ) * ( uvav ( i , jp , k ) - uvav ( i , j , k )) * dyi + & ! <u>*d<uv>/dy uav ( ip , j , k ) * ( uvav ( ip , jp , k ) - uvav ( ip , j , k )) * dyi ) + & 0.5 * ( uav ( i , j , k ) * ( uwav ( i , j , kp ) - uwav ( i , j , k )) * dzfi ( k ) + & ! <u>*d<uw>/dz uav ( ip , j , k ) * ( uwav ( ip , j , kp ) - uwav ( ip , j , k )) * dzfi ( k )) + & 0.5 * ( vav ( i , j , k ) * ( uvav ( ip , j , k ) - uvav ( i , j , k )) * dxfi ( i ) + & ! <v>*d<uv>/dx vav ( i , jp , k ) * ( uvav ( ip , jp , k ) - uvav ( i , jp , k )) * dxfi ( i )) + & 0.5 * ( vav ( i , jp , k ) + vav ( i , j , k )) * ( vvav ( i , jp , k ) - vvav ( i , j , k )) * dyi + & ! <v>*d<vv>/dy 0.5 * ( vav ( i , j , k ) * ( vwav ( i , j , kp ) - vwav ( i , j , k )) * dzfi ( k ) + & ! <v>*d<vw>/dz vav ( i , jp , k ) * ( vwav ( i , jp , kp ) - vwav ( i , jp , k )) * dzfi ( k )) + & 0.5 * ( wav ( i , j , k ) * ( uwav ( ip , j , k ) - uwav ( i , j , k )) * dxfi ( i ) + & ! <w>*d<uw>/dx wav ( i , j , kp ) * ( uwav ( ip , j , kp ) - uwav ( i , j , kp )) * dxfi ( i )) + & 0.5 * ( wav ( i , j , k ) * ( vwav ( i , jp , k ) - vwav ( i , j , k )) * dyi + & ! <w>*d<vw>/dy wav ( i , j , kp ) * ( vwav ( i , jp , kp ) - vwav ( i , j , kp )) * dyi ) + & 0.5 * ( wav ( i , j , kp ) + wav ( i , j , k )) * ( wwav ( i , j , kp ) - wwav ( i , j , k )) * dzfi ( k ) ! <w>*d<ww>/dz ! Advection of TKE tkeadv ( i , j , k ) = 0.5 * ( uav ( i , j , k ) * ( tke ( i , j , k ) - tke ( im , j , k )) * dxhi ( i ) + & ! <u>*de/dx uav ( ip , j , k ) * ( tke ( ip , j , k ) - tke ( i , j , k )) * dxhi ( ip )) + & ! 0.5 * ( vav ( i , j , k ) * ( tke ( i , j , k ) - tke ( i , jm , k )) * dyi + & ! <v>*de/dy vav ( i , jp , k ) * ( tke ( i , jp , k ) - tke ( i , j , k )) * dyi ) + & 0.5 * ( wav ( i , j , k ) * ( tke ( i , j , k ) - tke ( i , j , km )) * dzhi ( k ) + & ! <w>*de/dz wav ( i , j , kp ) * ( tke ( i , j , kp ) - tke ( i , j , k )) * dzhi ( kp )) ! <advection term N.S. times ui> = MKE + A - Pshear - Tt ! Tt = -<ui'd/dxj(ui'uj')> = -<d/dxj(0.5*ui'ui'uj')> = A      +    MKE   - ! Pshear  -   Total !                                                    = tkeadv +    mke   - !                                                    p_tav   -   ttm !        t_tav(i,j,k)   = tkeadv(i,j,k) + mke(i,j,k) - p_tav(i,j,k) - ttm(i,j,k) t_tav ( i , j , k ) = tkeadv ( i , j , k ) + mke ( i , j , k ) - p_tav ( i , j , k ) & - 0.5 * ( ttmx ( i , j , k ) + ttmx ( ip , j , k )) & - 0.5 * ( ttmy ( i , j , k ) + ttmy ( i , jp , k )) & - 0.5 * ( ttmz ( i , j , k ) + ttmz ( i , j , kp )) p_bav ( i , j , k ) = ( grav / thls ) * 0.5 * ( thlpwpav ( i , j , k ) + thlpwpav ( i , j , kp )) !use of thls here...???? end do end do end do ! need updating tg3315 call avexy_ibm ( p_b ( kb : ke + kh ), p_bav (:,:, kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc , IIcs ,. true .) call avexy_ibm ( t_p ( kb : ke + kh ), t_pav (:,:, kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc , IIcs ,. true .) call avexy_ibm ( adv ( kb : ke + kh ), tkeadv (:,:, kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc , IIcs ,. true .) call avexy_ibm ( t_t ( kb : ke + kh ), t_tav (:,:, kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc , IIcs ,. true .) call avexy_ibm ( t_sgs ( kb : ke + kh ), t_sgsav (:,:, kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc , IIcs ,. true .) call avexy_ibm ( p_t ( kb : ke + kh ), p_tav (:,:, kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc , IIcs ,. true .) call avexy_ibm ( d_sgs ( kb : ke + kh ), d_sgsav (:,:, kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc , IIcs ,. true .) call avexy_ibm ( t_v ( kb : ke + kh ), t_vav (:,:, kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc , IIcs ,. true .) end subroutine tkestatsdump !------------------------- !> Clean up when leaving the run !------------------------ subroutine exitstatsdump use modstat_nc , only : exitstat_nc use modglobal , only : lslicedump , ltdump implicit none !       if (lydump) then !         call exitstat_nc(ncid) !       endif ! will doing this ruin the averaging? ... try tg3315 !       if (lytdump) then !         call exitstat_nc(ncidt) !       endif !      if (ltkedump) then !        call exitstat_nc(ncidtke) !      endif !      if (lslicedump) then !        call exitstat_nc(ncidslice) !      endif !       if (ltdump) then !         call exitstat_nc(ncidt) !       endif end subroutine exitstatsdump end module modstatsdump","tags":"","loc":"sourcefile/modstatsdump.f90.html"},{"title":"modinletdata.f90 – uDALES","text":"Files dependent on this one sourcefile~~modinletdata.f90~~AfferentGraph sourcefile~modinletdata.f90 modinletdata.f90 sourcefile~modinlet.f90 modinlet.f90 sourcefile~modinlet.f90->sourcefile~modinletdata.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~modinlet.f90->sourcefile~modsave.f90 sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~modsubgrid.f90->sourcefile~modinletdata.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~modsubgrid.f90->sourcefile~modboundary.f90 sourcefile~tstep.f90 tstep.f90 sourcefile~tstep.f90->sourcefile~modinletdata.f90 sourcefile~modboundary.f90->sourcefile~modinletdata.f90 sourcefile~modboundary.f90->sourcefile~modinlet.f90 sourcefile~moddriver.f90 moddriver.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~modsave.f90->sourcefile~modinletdata.f90 sourcefile~moddriver.f90->sourcefile~modinletdata.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~modstartup.f90->sourcefile~modinletdata.f90 sourcefile~modstartup.f90->sourcefile~modinlet.f90 sourcefile~modstartup.f90->sourcefile~modsubgrid.f90 sourcefile~modstartup.f90->sourcefile~modboundary.f90 sourcefile~modstartup.f90->sourcefile~moddriver.f90 sourcefile~modpois.f90 modpois.f90 sourcefile~modstartup.f90->sourcefile~modpois.f90 sourcefile~modpois.f90->sourcefile~modboundary.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modsubgrid.f90 sourcefile~program.f90->sourcefile~modboundary.f90 sourcefile~program.f90->sourcefile~modsave.f90 sourcefile~program.f90->sourcefile~modstartup.f90 sourcefile~program.f90->sourcefile~modpois.f90 sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 sourcefile~modstatsdump.f90->sourcefile~modsubgrid.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules modinletdata Source Code modinletdata.f90 Source Code !! !!  \\author Jasper Tomas,TU Delft, 31 March 2014 !!  \\par Revision list !!  \\todo Documentation ! module modinletdata implicit none save real , allocatable :: storeu0inletbc (:,:,:) real , allocatable :: storev0inletbc (:,:,:) real , allocatable :: storew0inletbc (:,:,:) real , allocatable :: storet0inletbc (:,:,:) real , allocatable :: u0rot (:,:,:) ! dummy variable to eventually rotate u0 in horizontal plane real , allocatable :: v0rot (:,:,:) ! dummy variable to eventually rotate v0 in horizontal plane real , allocatable :: Utav (:,:) !< j-averaged and time averaged mean velocity real , allocatable :: QLtav (:,:) !< j-averaged and time averaged mean velocity real , allocatable :: QTtav (:,:) !< j-averaged and time averaged mean velocity real , allocatable :: Ttav (:,:) !< j-averaged and time averaged mean temperature real , allocatable :: uaver (:,:) !< j-averaged  mean velocity real , allocatable :: taver (:,:) !< j-averaged  mean temperature real , allocatable :: u0inletbc (:,:) !< final computed inlet bc for u real , allocatable :: v0inletbc (:,:) !< final computed inlet bc for v real , allocatable :: w0inletbc (:,:) !< final computed inlet bc for t real , allocatable :: t0inletbc (:,:) !< final computed inlet bc for w real , allocatable :: u0inletbcold (:,:) !< old final computed inlet bc for u real , allocatable :: v0inletbcold (:,:) !< old final computed inlet bc for v real , allocatable :: w0inletbcold (:,:) !< old final computed inlet bc for w real , allocatable :: t0inletbcold (:,:) !< old final computed inlet bc for t real , allocatable :: uminletbc (:,:) !< final computed inlet bc for u real , allocatable :: vminletbc (:,:) !< final computed inlet bc for v real , allocatable :: wminletbc (:,:) !< final computed inlet bc for w real , allocatable :: tminletbc (:,:) !< final computed inlet bc for t real , allocatable :: Uinl (:) !< mean inlet u-velocity (time-averaged and y-averaged) real , allocatable :: QLinl (:) !< mean inlet u-velocity (time-averaged and y-averaged) real , allocatable :: QTinl (:) !< mean inlet u-velocity (time-averaged and y-averaged) real , allocatable :: Winl (:) !< mean inlet w-velocity  (time-averaged and y-averaged) real , allocatable :: Tinl (:) !< mean inlet temperature  (time-averaged and y-averaged) real , allocatable :: Urec (:) !< mean recycle u-velocity (time-averaged and y-averaged) real , allocatable :: QLrec (:) !< mean recycle u-velocity (time-averaged and y-averaged) real , allocatable :: QTrec (:) !< mean recycle u-velocity (time-averaged and y-averaged) real , allocatable :: Wrec (:) !< mean recycle w-velocity  (time-averaged and y-averaged) real , allocatable :: Trec (:) !< mean recycle temperature  (time-averaged and y-averaged) real , allocatable :: zirf (:) !< zf-coordinate at recycle station (inner scaling) real , allocatable :: ziif (:) !< zf-coordinate at inlet station (inner scaling) real , allocatable :: zirh (:) !< zh-coordinate at recycle station (inner scaling) real , allocatable :: ziih (:) !< zh-coordinate at inlet station (inner scaling) real , allocatable :: zorf (:) !< zf-coordinate at recycle station (outer scaling) real , allocatable :: zoif (:) !< zf-coordinate at inlet station (outer scaling) real , allocatable :: zorh (:) !< zh-coordinate at recycle station (outer scaling) real , allocatable :: zoih (:) !< zh-coordinate at inlet station (outer scaling) real , allocatable :: zotr (:) !< zf-coordinate at recycle station (temperature outer scaling) real , allocatable :: zoti (:) !< zf-coordinate at inlet station (temperature outer scaling) real , allocatable :: displ (:) !< displacement thickness real , allocatable :: displold (:) !< old displacement thickness real , allocatable :: upupavinl (:) !< j-averaged time-averaged u'u' at the inlet real , allocatable :: vpvpavinl (:) !< j-averaged time-averaged v'v' at the inlet real , allocatable :: wpwpavinl (:) !< j-averaged time-averaged w'w' at the inlet real , allocatable :: upwpavinl (:) !< j-averaged time-averaged u'w' at the inlet real , allocatable :: thlpthlpavinl (:) !< j-averaged time-averaged thl'thl' at the inlet real , allocatable :: thlpupavinl (:) !< j-averaged time-averaged thl'u' at the inlet real , allocatable :: thlpwpavinl (:) !< j-averaged time-averaged thl'w' at the inlet real , allocatable :: qlpqlpavinl (:) !< j-averaged time-averaged thl'thl' at the inlet real , allocatable :: qlpupavinl (:) !< j-averaged time-averaged thl'u' at the inlet real , allocatable :: qlpwpavinl (:) !< j-averaged time-averaged thl'w' at the inlet real , allocatable :: qtpqtpavinl (:) !< j-averaged time-averaged thl'thl' at the inlet real , allocatable :: qtpupavinl (:) !< j-averaged time-averaged thl'u' at the inlet real , allocatable :: qtpwpavinl (:) !< j-averaged time-averaged thl'w' at the inlet real , allocatable :: zfin (:) ! zf from inlet simulation real , allocatable :: zhin (:) ! zh from inlet simulation real , allocatable :: dzfin (:) ! dzf from inlet simulation real , allocatable :: dzhin (:) ! dzh from inlet simulation real , allocatable :: heavif (:) !< Heaviside function for u,v real , allocatable :: heavih (:) !< Heaviside function for w real , allocatable :: heavit (:) !< Heaviside function for t integer , allocatable :: loclowif (:) !< index of lower zir at full level integer , allocatable :: locupif (:) !< index of upper zir at full level integer , allocatable :: loclowih (:) !< index of lower zir at half level integer , allocatable :: locupih (:) !< index of upper zir at half level integer , allocatable :: loclowof (:) !< index of lower zor at full level integer , allocatable :: locupof (:) !< index of upper zor at full level integer , allocatable :: loclowoh (:) !< index of lower zor at half level integer , allocatable :: locupoh (:) !< index of upper zor at half level integer , allocatable :: loclowot (:) !< index of lower zot at full level integer , allocatable :: locupot (:) !< index of upper zot at full level integer , allocatable :: linlf (:) !< index of lower zfin integer , allocatable :: linuf (:) !< index of upper zfin integer , allocatable :: linlh (:) !< index of lower zhin integer , allocatable :: linuh (:) !< index of upper zhin real :: di = 0.09 !< delta at inlet  (should be prescribed in namoptions!)  corresponds to critertion 0.99 !    real :: di=0.12        !< delta at inlet  (should be prescribed in namoptions!)  corresponds to critertion 1.0 !    real :: di=0.0645        !< delta at inlet  (should be prescribed in namoptions!) corresponds to criterion 0.95 !    real :: di=0.100       !< delta at inlet  (should be prescribed in namoptions!) real :: di_test !< measured delta at the inlet real :: dti_test !< measured deltat at the inlet real :: dr !< delta at recycle station real :: dti !< delta_t at inlet real :: dtr !< delta_t at recycle real :: thetai !< momentum thickness at inlet real :: thetar !< momentum thickness at recycle real :: thetati !< enthalpy thickness at inlet real :: thetatr !< enthalpy thickness at recycle real :: utaui !< u_tau at inlet real :: utaur !< u_tau at recycle real :: ttaui !< t_tau at inlet real :: ttaur !< t_tau at recycle real :: lmoi !< Obukhov length at inlet real :: lmor !< Obukhov length at recycle real :: q0 !< wall heat flux at recycle real :: deltat = 0. !< full time step (set to zero at start of sim) real :: ubulk = 0. !< Bulk velocity (to be determined at first time step) real :: totalu = 0. !< Bulk velocity inlet real :: totaluold = 0. !< old bulk velocity inlet real :: ddispdx = 0. !< spatial variation of displacement thickness (d/dx(delta*)) real :: ddispdxold = 0. !< old ddispdx real :: wtop = 0. !< mean vertical velocity at top read from zgrid.inf real :: xfm !< mean (xf) real :: xf2m !< mean (xf&#94;2) !    real :: dtin=0.0055  !< time step used in inletgenerator real :: dtin !< time step used in inletgenerator real :: elapstep = 0. !< elapsed time in this time step. (used in time interpolation whe reading inletfiles) real :: totalreadu !< bulk velocity of inlet data (computed once at first time step) real :: iangle !< inflow angle in radians (change with respect to inlet velocity that is read in) real :: iangledeg = 0. !< inflow angle in degrees (change with respect to inlet velocity that is read in) ! Needed for interpolation in y-direction integer :: jgbin integer :: jgein integer :: jgtotinl !< total number of cells in y-direction of inlet files (all procs together) integer :: jbin integer :: jein integer :: jtotin integer :: jbdum integer :: jedum integer :: jtotdum integer :: filenumstart integer :: filenumend integer :: filestoread integer :: procinlo integer :: procinup integer :: jend integer :: jgend integer :: jbeg integer :: jgbeg real , allocatable :: yh (:) real , allocatable :: yf (:) real , allocatable :: yhin (:) real , allocatable :: yfin (:) real , allocatable :: yhdum (:) real , allocatable :: yfdum (:) integer , allocatable :: ylocupf (:) integer , allocatable :: yloclowf (:) integer , allocatable :: ylocuph (:) integer , allocatable :: yloclowh (:) real :: dyin integer :: irecy !< ib + irecy is the i-index of recycle station integer :: nfile = 0 !< file number to be read or written integer :: nstepread = 1 !< time step number in file containing inlet plane integer :: rk3stepin = 1 !< rk3step in inlet plane data integer :: kbin integer :: kein integer :: nprocsinl !< number of procs at used in inletdata files (only used for inletgen==2) integer :: inlfactor !< ratio of number of processors in this sim and in inlet data files (only used for inletgen==2) logical :: lzinzsim = . true . ! lzinzsim is .true. when inlet zgrid equals sim zgrid ! Inlet driver simulation variables - idriver - ae1212 real , allocatable :: storeu0driver (:,:,:) real , allocatable :: storev0driver (:,:,:) real , allocatable :: storew0driver (:,:,:) real , allocatable :: storethl0driver (:,:,:) real , allocatable :: storee120driver (:,:,:) real , allocatable :: storeqt0driver (:,:,:) real , allocatable :: storesv0driver (:,:,:,:) real , allocatable :: storetdriver (:) real , allocatable :: u0driver (:,:) real , allocatable :: v0driver (:,:) real , allocatable :: w0driver (:,:) real , allocatable :: e120driver (:,:) real , allocatable :: tdriver (:) real , allocatable :: thl0driver (:,:) real , allocatable :: qt0driver (:,:) real , allocatable :: sv0driver (:,:,:) real , allocatable :: storeumdriver (:,:,:) real , allocatable :: umdriver (:,:) real , allocatable :: storevmdriver (:,:,:) real , allocatable :: vmdriver (:,:) real , allocatable :: storewmdriver (:,:,:) real , allocatable :: wmdriver (:,:) real , allocatable :: storee12mdriver (:,:,:) real , allocatable :: e12mdriver (:,:) real , allocatable :: storethlmdriver (:,:,:) real , allocatable :: thlmdriver (:,:) real , allocatable :: storeqtmdriver (:,:,:) real , allocatable :: qtmdriver (:,:) real , allocatable :: storesvmdriver (:,:,:,:) real , allocatable :: svmdriver (:,:,:) integer :: irecydriver integer :: nstepreaddriver = 0 end module","tags":"","loc":"sourcefile/modinletdata.f90.html"},{"title":"advec_2nd.f90 – uDALES","text":"This file depends on sourcefile~~advec_2nd.f90~~EfferentGraph sourcefile~advec_2nd.f90 advec_2nd.f90 sourcefile~modibm.f90 modibm.f90 sourcefile~advec_2nd.f90->sourcefile~modibm.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~advec_2nd.f90->sourcefile~modmpi.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~advec_2nd.f90->sourcefile~modfields.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~advec_2nd.f90->sourcefile~initfac.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~advec_2nd.f90->sourcefile~modglobal.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~advec_2nd.f90->sourcefile~modibmdata.f90 sourcefile~modibm.f90->sourcefile~modmpi.f90 sourcefile~modibm.f90->sourcefile~modfields.f90 sourcefile~modibm.f90->sourcefile~initfac.f90 sourcefile~modibm.f90->sourcefile~modglobal.f90 sourcefile~modibm.f90->sourcefile~modibmdata.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~modibm.f90->sourcefile~modsubgriddata.f90 sourcefile~modsurfdata.f90 modsurfdata.f90 sourcefile~modibm.f90->sourcefile~modsurfdata.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines advecc_2nd advecu_2nd advecv_2nd advecw_2nd Source Code advec_2nd.f90 Source Code !> \\file advec_2nd.f90 !!  Does advection with a 2nd order central differencing scheme. !! !! Second order central differencing can be used for variables where neither very !! high accuracy nor strict monotonicity is necessary. !! \\latexonly !!\\begin{eqnarray} !! F_{i-\\frac{1}{2}}&#94;{2nd} &=& !!\\fav{u}_{i-\\frac{1}{2}}\\frac{\\phi_{i}+\\phi_{i-1}}{2}, !!\\end{eqnarray} !! \\endlatexonly !! ! !> Advection at cell center subroutine advecc_2nd ( hi , hj , hk , putin , putout ) use modglobal , only : ih , jh , kh , kb , ke , ib , ie , jb , je , dxf , dxhi , dxfi5 , dyi5 , dzf , dzfi5 , dzhi , libm , jmax , dxfi , dzfi , dyi use modfields , only : u0 , v0 , w0 use modibm , only : nxwallsnorm , nzwallsnorm , nywallsm , nywallsp , ywallsm , ywallsp , & xwallsnorm , zwallsnorm , iypluswall , iyminwall , nyminwall , nypluswall use modibmdata , only : nxwall , ixwall use initfac , only : block use modmpi , only : myid implicit none integer , intent ( in ) :: hi !< size of halo in i integer , intent ( in ) :: hj !< size of halo in j integer , intent ( in ) :: hk !< size of halo in k real , dimension ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ), intent ( in ) :: putin !< Input: the cell centered field real , dimension ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ), intent ( inout ) :: putout !< Output: the tendency integer :: i , j , k , ip , im , jp , jm , kp , km , il , iu , jl , ju , kl , ku , n do k = kb , ke km = k - 1 kp = k + 1 do j = jb , je jm = j - 1 jp = j + 1 do i = ib , ie im = i - 1 ip = i + 1 putout ( i , j , k ) = putout ( i , j , k ) - ( & ( & u0 ( ip , j , k ) * ( putin ( ip , j , k ) * dxf ( i ) + putin ( i , j , k ) * dxf ( ip )) * dxhi ( ip ) & - u0 ( i , j , k ) * ( putin ( im , j , k ) * dxf ( i ) + putin ( i , j , k ) * dxf ( im )) * dxhi ( i ) & ! d(uc)/dx ) * dxfi5 ( i ) & + ( & ! v0 ( i , jp , k ) * ( putin ( i , jp , k ) + putin ( i , j , k )) & - v0 ( i , j , k ) * ( putin ( i , jm , k ) + putin ( i , j , k )) & ! d(vc)/dy ) * dyi5 ) end do end do end do do j = jb , je jm = j - 1 jp = j + 1 do i = ib , ie im = i - 1 ip = i + 1 do k = kb , ke km = k - 1 kp = k + 1 putout ( i , j , k ) = putout ( i , j , k ) - ( & w0 ( i , j , kp ) * ( putin ( i , j , kp ) * dzf ( k ) + putin ( i , j , k ) * dzf ( kp )) * dzhi ( kp ) & - w0 ( i , j , k ) * ( putin ( i , j , km ) * dzf ( k ) + putin ( i , j , k ) * dzf ( km )) * dzhi ( k ) & ) * dzfi5 ( k ) end do end do end do end subroutine advecc_2nd !> Advection at the u point. subroutine advecu_2nd ( putin , putout ) use modglobal , only : ih , ib , ie , jb , je , jh , kb , ke , kh , dxhiq , dyiq , dzf , dzfi5 , dzhi , dxhi , libm use modfields , only : u0 , v0 , w0 , pres0 use modibm , only : nxwallsnorm , nzwallsnorm , nywallsm , nywallsp , ywallsm , ywallsp , & xwallsnorm , zwallsnorm use modmpi , only : myid implicit none real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ), intent ( in ) :: putin !< Input: the u-field real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ), intent ( inout ) :: putout !< Output: the tendency integer :: i , j , k , ip , im , jp , jm , kp , km , il , iu , jl , ju , kl , ku , n do k = kb , ke km = k - 1 kp = k + 1 do j = jb , je jm = j - 1 jp = j + 1 do i = ib , ie im = i - 1 ip = i + 1 putout ( i , j , k ) = putout ( i , j , k ) - ( & ( & ( putin ( i , j , k ) + putin ( ip , j , k )) * ( u0 ( i , j , k ) + u0 ( ip , j , k )) & - ( putin ( i , j , k ) + putin ( im , j , k )) * ( u0 ( i , j , k ) + u0 ( im , j , k )) & ! d(uu)/dx ) * dxhiq ( i ) & + ( & ( putin ( i , j , k ) + putin ( i , jp , k )) * ( v0 ( i , jp , k ) + v0 ( im , jp , k )) & - ( putin ( i , j , k ) + putin ( i , jm , k )) * ( v0 ( i , j , k ) + v0 ( im , j , k )) & ! d(vu)/dy ) * dyiq ) & - (( pres0 ( i , j , k ) - pres0 ( i - 1 , j , k )) * dxhi ( i )) ! - dp/dx end do end do end do do j = jb , je jm = j - 1 jp = j + 1 do i = ib , ie im = i - 1 ip = i + 1 do k = kb , ke km = k - 1 kp = k + 1 putout ( i , j , k ) = putout ( i , j , k ) - ( & ( putin ( i , j , kp ) * dzf ( k ) + putin ( i , j , k ) * dzf ( kp )) * dzhi ( kp ) & * ( w0 ( i , j , kp ) + w0 ( im , j , kp )) & - ( putin ( i , j , k ) * dzf ( km ) + putin ( i , j , km ) * dzf ( k )) * dzhi ( k ) & * ( w0 ( i , j , k ) + w0 ( im , j , k )) & ) * 0.5 * dzfi5 ( k ) end do end do end do end subroutine advecu_2nd !> Advection at the v point. subroutine advecv_2nd ( putin , putout ) use modglobal , only : ih , ib , ie , jh , jb , je , kb , ke , kh , dxf , dxhi , dxfiq , dyiq , dzf , dzfi5 , dzhi , dyi use modfields , only : u0 , v0 , w0 , pres0 implicit none real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ), intent ( in ) :: putin !< Input: the v-field real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ), intent ( inout ) :: putout !< Output: the tendency integer :: i , j , k , ip , im , jp , jm , kp , km do k = kb , ke km = k - 1 kp = k + 1 do j = jb , je jm = j - 1 jp = j + 1 do i = ib , ie im = i - 1 ip = i + 1 putout ( i , j , k ) = putout ( i , j , k ) - ( & ( & ( u0 ( ip , j , k ) + u0 ( ip , jm , k )) & * ( putin ( i , j , k ) * dxf ( ip ) + putin ( ip , j , k ) * dxf ( i )) * dxhi ( ip ) & - ( u0 ( i , j , k ) + u0 ( i , jm , k )) & * ( putin ( i , j , k ) * dxf ( im ) + putin ( im , j , k ) * dxf ( i )) * dxhi ( i ) & ! d(uv)/dx ) * dxfiq ( i ) & + ( & ( v0 ( i , jp , k ) + v0 ( i , j , k )) * ( putin ( i , j , k ) + putin ( i , jp , k )) & - ( v0 ( i , jm , k ) + v0 ( i , j , k )) * ( putin ( i , j , k ) + putin ( i , jm , k )) & ! d(vv)/dy ) * dyiq ) & - (( pres0 ( i , j , k ) - pres0 ( i , j - 1 , k )) * dyi ) ! - dp/dy end do end do end do do j = jb , je jm = j - 1 jp = j + 1 do i = ib , ie im = i - 1 ip = i + 1 do k = kb , ke km = k - 1 kp = k + 1 putout ( i , j , k ) = putout ( i , j , k ) - ( & ( w0 ( i , j , kp ) + w0 ( i , jm , kp )) & * ( putin ( i , j , kp ) * dzf ( k ) + putin ( i , j , k ) * dzf ( kp )) * dzhi ( kp ) & - ( w0 ( i , j , k ) + w0 ( i , jm , k )) & * ( putin ( i , j , km ) * dzf ( k ) + putin ( i , j , k ) * dzf ( km )) * dzhi ( k ) & ) * 0.5 * dzfi5 ( k ) end do end do end do end subroutine advecv_2nd !> Advection at the w point. subroutine advecw_2nd ( putin , putout ) use modglobal , only : ih , ib , ie , jh , jb , je , kb , ke , kh , dxf , dxhi , dxfiq , dyiq , dzf , dzhi , dzhiq use modfields , only : u0 , v0 , w0 , pres0 ! use modmpi, only : myid implicit none real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ), intent ( in ) :: putin !< Input: the w-field real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ), intent ( inout ) :: putout !< Output: the tendency integer :: i , j , k , ip , im , jp , jm , kp , km do k = kb + 1 , ke km = k - 1 kp = k + 1 do j = jb , je jm = j - 1 jp = j + 1 do i = ib , ie im = i - 1 ip = i + 1 putout ( i , j , k ) = - ( & ( & ( putin ( ip , j , k ) * dxf ( i ) + putin ( i , j , k ) * dxf ( ip )) * dxhi ( ip ) & ! d(uw)/dx * ( dzf ( km ) * u0 ( ip , j , k ) + dzf ( k ) * u0 ( ip , j , km )) & - ( putin ( i , j , k ) * dxf ( im ) + putin ( im , j , k ) * dxf ( i )) * dxhi ( i ) & * ( dzf ( km ) * u0 ( i , j , k ) + dzf ( k ) * u0 ( i , j , km )) & ) * dxfiq ( i ) * dzhi ( k ) & + & ( & ( putin ( i , jp , k ) + putin ( i , j , k )) & ! d(vw)/dy * ( dzf ( km ) * v0 ( i , jp , k ) + dzf ( k ) * v0 ( i , jp , km )) & - ( putin ( i , j , k ) + putin ( i , j - 1 , k )) & * ( dzf ( km ) * v0 ( i , j , k ) + dzf ( k ) * v0 ( i , j , km )) & ) * dyiq * dzhi ( k ) & + & ( & ( putin ( i , j , k ) + putin ( i , j , kp )) * ( w0 ( i , j , k ) + w0 ( i , j , kp )) & ! d(ww)/dz - ( putin ( i , j , k ) + putin ( i , j , km )) * ( w0 ( i , j , k ) + w0 ( i , j , km )) & ) * dzhiq ( k ) & ) & - (( pres0 ( i , j , k ) - pres0 ( i , j , k - 1 )) * dzhi ( k )) ! - dp/dz end do end do end do end subroutine advecw_2nd","tags":"","loc":"sourcefile/advec_2nd.f90.html"},{"title":"modglobal.f90 – uDALES","text":"This file depends on sourcefile~~modglobal.f90~~EfferentGraph sourcefile~modglobal.f90 modglobal.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~modglobal.f90~~AfferentGraph sourcefile~modglobal.f90 modglobal.f90 sourcefile~modpois.f90 modpois.f90 sourcefile~modpois.f90->sourcefile~modglobal.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~modpois.f90->sourcefile~modboundary.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modpois.f90->sourcefile~modfields.f90 sourcefile~modibm.f90 modibm.f90 sourcefile~modibm.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~modibm.f90->sourcefile~initfac.f90 sourcefile~modibm.f90->sourcefile~modfields.f90 sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~modsubgrid.f90->sourcefile~modglobal.f90 sourcefile~modsubgrid.f90->sourcefile~modboundary.f90 sourcefile~modsubgrid.f90->sourcefile~modfields.f90 sourcefile~advection.f90 advection.f90 sourcefile~advection.f90->sourcefile~modglobal.f90 sourcefile~advection.f90->sourcefile~modfields.f90 sourcefile~advec_2nd.f90 advec_2nd.f90 sourcefile~advec_2nd.f90->sourcefile~modglobal.f90 sourcefile~advec_2nd.f90->sourcefile~modibm.f90 sourcefile~advec_2nd.f90->sourcefile~initfac.f90 sourcefile~advec_2nd.f90->sourcefile~modfields.f90 sourcefile~modboundary.f90->sourcefile~modglobal.f90 sourcefile~moddriver.f90 moddriver.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~modinlet.f90 modinlet.f90 sourcefile~modboundary.f90->sourcefile~modinlet.f90 sourcefile~modboundary.f90->sourcefile~modfields.f90 sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~modstatsdump.f90->sourcefile~modglobal.f90 sourcefile~modstatsdump.f90->sourcefile~modsubgrid.f90 sourcefile~modstat_nc.f90 modstat_nc.f90 sourcefile~modstatsdump.f90->sourcefile~modstat_nc.f90 sourcefile~modstatistics.f90 modstatistics.f90 sourcefile~modstatsdump.f90->sourcefile~modstatistics.f90 sourcefile~modstatsdump.f90->sourcefile~modfields.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~modsave.f90->sourcefile~modglobal.f90 sourcefile~modsave.f90->sourcefile~initfac.f90 sourcefile~modsave.f90->sourcefile~modfields.f90 sourcefile~modchem.f90 modchem.f90 sourcefile~modchem.f90->sourcefile~modglobal.f90 sourcefile~modchem.f90->sourcefile~modfields.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~modstartup.f90->sourcefile~modglobal.f90 sourcefile~modstartup.f90->sourcefile~modpois.f90 sourcefile~modstartup.f90->sourcefile~modsubgrid.f90 sourcefile~modstartup.f90->sourcefile~modboundary.f90 sourcefile~modstartup.f90->sourcefile~moddriver.f90 sourcefile~modforces.f90 modforces.f90 sourcefile~modstartup.f90->sourcefile~modforces.f90 sourcefile~modstartup.f90->sourcefile~modinlet.f90 sourcefile~modthermodynamics.f90 modthermodynamics.f90 sourcefile~modstartup.f90->sourcefile~modthermodynamics.f90 sourcefile~modstartup.f90->sourcefile~modfields.f90 sourcefile~modchecksim.f90 modchecksim.f90 sourcefile~modchecksim.f90->sourcefile~modglobal.f90 sourcefile~modchecksim.f90->sourcefile~modfields.f90 sourcefile~wf_uno.f90 wf_uno.f90 sourcefile~wf_uno.f90->sourcefile~modglobal.f90 sourcefile~wf_uno.f90->sourcefile~initfac.f90 sourcefile~modeb.f90 modEB.f90 sourcefile~modeb.f90->sourcefile~modglobal.f90 sourcefile~modeb.f90->sourcefile~initfac.f90 sourcefile~modeb.f90->sourcefile~modstat_nc.f90 sourcefile~moddriver.f90->sourcefile~modglobal.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~moddriver.f90->sourcefile~modfields.f90 sourcefile~modforces.f90->sourcefile~modglobal.f90 sourcefile~modforces.f90->sourcefile~modfields.f90 sourcefile~modinlet.f90->sourcefile~modglobal.f90 sourcefile~modinlet.f90->sourcefile~modsave.f90 sourcefile~modinlet.f90->sourcefile~modfields.f90 sourcefile~tstep.f90 tstep.f90 sourcefile~tstep.f90->sourcefile~modglobal.f90 sourcefile~tstep.f90->sourcefile~modchem.f90 sourcefile~tstep.f90->sourcefile~modfields.f90 sourcefile~wfmneutral.f90 wfmneutral.f90 sourcefile~wfmneutral.f90->sourcefile~modglobal.f90 sourcefile~wfmneutral.f90->sourcefile~initfac.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~scalsource.f90 scalsource.f90 sourcefile~scalsource.f90->sourcefile~modglobal.f90 sourcefile~scalsource.f90->sourcefile~initfac.f90 sourcefile~scalsource.f90->sourcefile~modfields.f90 sourcefile~wf_gr.f90 wf_gr.f90 sourcefile~wf_gr.f90->sourcefile~modglobal.f90 sourcefile~wf_gr.f90->sourcefile~initfac.f90 sourcefile~advec_upw.f90 advec_upw.f90 sourcefile~advec_upw.f90->sourcefile~modglobal.f90 sourcefile~advec_upw.f90->sourcefile~modfields.f90 sourcefile~modfielddump.f90 modfielddump.f90 sourcefile~modfielddump.f90->sourcefile~modglobal.f90 sourcefile~modfielddump.f90->sourcefile~modstat_nc.f90 sourcefile~modfielddump.f90->sourcefile~modfields.f90 sourcefile~modstat_nc.f90->sourcefile~modglobal.f90 sourcefile~advec_kappa.f90 advec_kappa.f90 sourcefile~advec_kappa.f90->sourcefile~modglobal.f90 sourcefile~advec_kappa.f90->sourcefile~modfields.f90 sourcefile~modthermodynamics.f90->sourcefile~modglobal.f90 sourcefile~modthermodynamics.f90->sourcefile~modfields.f90 sourcefile~modstatistics.f90->sourcefile~modglobal.f90 sourcefile~modstatistics.f90->sourcefile~modstat_nc.f90 sourcefile~modstatistics.f90->sourcefile~modfields.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modglobal.f90 sourcefile~program.f90->sourcefile~modpois.f90 sourcefile~program.f90->sourcefile~modibm.f90 sourcefile~program.f90->sourcefile~modsubgrid.f90 sourcefile~program.f90->sourcefile~modboundary.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 sourcefile~program.f90->sourcefile~modsave.f90 sourcefile~program.f90->sourcefile~modstartup.f90 sourcefile~program.f90->sourcefile~modchecksim.f90 sourcefile~program.f90->sourcefile~modeb.f90 sourcefile~program.f90->sourcefile~modforces.f90 sourcefile~program.f90->sourcefile~initfac.f90 sourcefile~program.f90->sourcefile~modfielddump.f90 sourcefile~program.f90->sourcefile~modstat_nc.f90 sourcefile~program.f90->sourcefile~modthermodynamics.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules modglobal Source Code modglobal.f90 Source Code !> \\file modglobal.f90 !!  Declares the global constants !> !! \\author Jasper Tomas, TU Delft 31 March 2014 !!  Declares the global constants !> !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! module modglobal implicit none save integer :: poisrcheck = 0 ! switch to check if it is the first (RK) time step ! Simulation dimensions (parconst.f90) integer :: imax = 64 integer :: jtot = 64 integer :: jmax integer :: jsen integer :: kmax = 96 integer :: isen integer :: ib integer :: ie integer :: jb integer :: je integer :: jgb ! global j range integer :: jge ! global j range integer :: offset integer :: kb integer :: ke integer :: nsv = 0 !< Number of additional scalar fields integer :: nvar = 0 character ( 50 ) :: fieldvars = '' integer :: ih = 3 integer :: jh = 3 integer :: kh = 1 integer :: ihc = 2 ! used in k-scheme integer :: jhc = 2 ! used in k-scheme integer :: khc = 2 ! used in k-scheme integer :: nblocks = 0 ! no. of blocks in IBM integer , allocatable :: block (:,:) integer :: nfcts = - 1 ! no. of wall facets integer :: iplane ! ib+iplane is the plane that is stored when lstoreplane=.true. integer :: nstore = 1002 ! number of rk steps in inletfile. This should be a multiple of three! character ( 90 ) :: fname_options = 'namoptions' integer , parameter :: longint = 8 logical :: lwarmstart = . false . !<   flag for \"cold\" or \"warm\" start logical :: lstratstart = . false . logical :: lfielddump = . false . !< switch to enable the fielddump logical :: lreadscal = . false . !<   flag for reading scalar pollutant field (warm start) !Switches for boundary conditions !momentum (m), temperature (T), humidity (q) and scalars (s) !lateral in x/i direction (x), in y/j direction (y) at the top (top) and at the bottom (bot) !1 = periodic, >1 special in/outflow conditions integer :: BCxm = 1 integer :: BCxT = 1 integer :: BCxq = 1 integer :: BCxs = 1 !y direction is currently alway periodic integer :: BCym = 1 integer :: BCyT = 1 integer :: BCyq = 1 integer :: BCys = 1 !at the top (top) !1 = freeslip, 2 = noslip, 3 = determined by inflow conditions integer :: BCtopm = 1 integer :: BCtopT = 1 integer :: BCtopq = 1 integer :: BCtops = 1 !at the bottom (bot) !the bottom BC are defacto useless, since they will be covered by a road facet !1 = flux, 2 = wall function integer :: BCbotm = 2 integer :: BCbotT = 1 integer :: BCbotq = 1 integer :: BCbots = 1 integer :: iinletgen = 0 !<  0: no inletgen, 1: turb. inlet generator (Lund (1998)), 2: read inlet from file integer :: idriver = 0 !<  0: no inlet driver store, 1: Save inlet driver data, 2: read inlet driver data from file logical :: linoutflow = . false . !<  switch for periodic BC in both horizontal directions (false) or inflow/outflow in i and periodic in j. logical :: lzerogradtop = . false . !<  switch for zero gradient BC's at top wall (iinletgen 1 and 2 are seperate). logical :: lzerogradtopscal = . false . ! logical :: lbuoyancy = . false . !<  switch for buoyancy force in modforces logical :: ltempeq = . false . !<  switch for solving temperature equation (either with or without buoyancy term) logical :: lscalrec = . false . !< logical :: lSIRANEinout = . false . !< logical :: ltempinout = . false . !<  seperate switch for inflow/outflow BC for temperature (only necessary when linoutflow.eqv..false.). logical :: lmoistinout = . false . !<  seperate switch for inflow/outflow BC for moisture (only necessary when linoutflow.eqv..false.). logical :: lper2inout = . false . !<  switch that determines type of restart: .true. means switching from periodic to in/outflow: inlet profile is read from prof.inp logical :: libm = . true . !<  switch that determines whether the Immersed Boundary Method is turned on logical :: lwalldist = . false . !<  switch that determines whether the wall distances should be computed logical :: lles = . true . !<  switch that determines whether the subgrid model is turned on or constant ekm and ekh are used (DNS) logical :: linletRA = . false . !<  switch that determines whether a Running Average should be used (.true.) in inlet generator logical :: lfixinlet = . false . !<  switch that determines whether the average inlet profiles can evolve or not (only used when iinletgen=1,2) logical :: lfixutauin = . false . !<  switch that determines whether the utau is kept fixed at the inlet (only used when iinletgen=1,2) logical :: lscasrc = . false . ! logical :: lscasrcl = . false . !tg3315 logical :: lydump = . false . !<  switch to output y-averaged statistics every tsample logical :: lytdump = . false . !<  switch to output y- and time- averaged statistics every tstatsdump logical :: lxydump = . false . !<  switch to output x- and y-avewraged statistics every tsample logical :: lxytdump = . false . !<  switch to output x-, y- and time-averaged statistics every tstatsdump logical :: lscasrcr = . false . !<  switch for network of point sources at lowest level logical :: ltkedump = . false . !tg3315 logical :: lslicedump = . false . !<  switch to output slices in the xy-plane every tstatsdump logical :: ltdump = . false . !<  switch to output time-averaged statistics every tstatsdump logical :: lreadminl = . false . !<  switch for reading mean inlet/recycle plane profiles (used in inletgenerator) logical :: lwallfunc = . true . !<  switch that determines whether wall functions are used to compute the wall-shear stress logical :: luoutflowr = . false . !<  switch that determines whether u-velocity is corrected to get a fixed outflow rate logical :: lvoutflowr = . false . !<  switch that determines whether u-velocity is corrected to get a fixed outflow rate logical :: luvolflowr = . false . !<  switch that determines whether u-velocity is corrected to get a fixed volume flow rate logical :: lvvolflowr = . false . !<  switch that determines whether u-velocity is corrected to get a fixed volume flow rate logical :: lstoreplane = . false . !<  switch that determines whether i-plane data is stored. logical :: lstorexy = . false . !xy files stored logical :: lreadmean = . false . !<  switch that determines whether mean variables should be read from means#myid#.#expnr# logical :: lstat = . false . logical :: lEB = . false . logical :: lwriteEBfiles = . false . logical :: lconstW = . false . ! The evaporated water can be removed from the soil (lconstW=false) or the soil moisture can be assumed as constant in time (lconstW=true) !  logical :: ifixuinf   = .true. !dpdxl relaxed to have Uinf 1. dpdx = (1/dt)*(Uh-Uinf)2. d/dt(dpdx) = 1/tau*(Uh-Uinf) integer :: ifixuinf = 0 logical :: lvinf = . false . !use Vinf instead of Uinf for the fixed velocity at infinity real :: freestreamav = 0. ! real :: freestrtmpav = 0. ! !<  Global constants modconst.f90 !< File numbers integer , parameter :: ifinput = 1 integer , parameter :: ifoutput = 2 integer , parameter :: ifnamopt = 3 real , parameter :: pi = 3.141592653589793116 real , parameter :: grav = 9.81 !<    *gravity acceleration. real , parameter :: rd = 28 7.04 !<    *gas constant for dry air. real , parameter :: rv = 46 1.5 !<    *gas constant for water vapor. real , parameter :: cp = 100 4. !<    *specific heat at constant pressure (dry air). real , parameter :: rlv = 2.26e6 !<    *latent heat for vaporisation. real , parameter :: rlvi = 1 / rlv !inverse real , parameter :: ep = rd / rv !<    0.622 real , parameter :: ep2 = rv / rd - 1. !<    0.61 !< real,parameter :: cv       = cp-rd            !<    716.96 real , parameter :: rcp = rd / cp !<    0.286 real , parameter :: cpr = cp / rd !<    3.50 real , parameter :: rlvocp = rlv / cp !<    2.49 real , parameter :: mair = 2 8.967 !< Molar mass of air real , parameter :: rhoa = 1.2 !density of air used in some calculations real :: wfc = 31 3. !water content at field capacity (kg/m3) real :: wwilt = 17 1. !water ocntent at wilting point (kg/m3) real :: wgrmax = 45 0. !maximum water content (kg/m3) real :: rsmin = 11 0. !minimum resistance of soil/plant real :: rsmax = 500 0. !maximum resistance of soil/plant real :: GRLAI = 2. !Leave area index of green roof real :: wsoil = 0. !water content of soil (kg/m3) real :: bldT = 0. !building internal temperature, currently also ground temperature at a depth equal to floor facet thickness real :: skyLW = 0. !longwave radiation from the sky real :: gres = 0. !saturation vapour pressure of green roof real :: grqs = 0. !saturation humidity of green roof real :: grdqdt = 0. !gradient of saturation humidity for green roof real , parameter :: numol = 1.5e-5 !< kinematic viscosity for couette flow Re=5000 (Re=Uinf*H/(2*nu)) H=1, Uinf=1 real , parameter :: numoli = 1. / numol !< 1/numol real , parameter :: prandtlmol = 0.71 !< Prandtl number (for air at 300K). Fluid property! real , parameter :: prandtlmoli = 1. / prandtlmol !< Inverse of Prandtl number integer :: iwallmom = 2 , iwalltemp = 1 , iwallmoist = 1 , iwallscal = 1 real , parameter :: rhow = 0.998e3 !<    * Density of water real , parameter :: pref0 = 1.e5 !<    *standard pressure used in exner function. real , parameter :: tmelt = 27 3.16 !<    *temperature of melting of ice. real , parameter :: es0 = 61 0.78 !<    * constants used for computation real , parameter :: at = 1 7.27 !<    * of saturation mixing ratio real , parameter :: bt = 3 5.86 !<    * using Tetens Formula. !      real,parameter :: ekmin    = 1.e-6            !<    *minimum value for k-coefficient. real , parameter :: ekmin = 1.e-12 !<    *minimum value for k-coefficient. real , parameter :: e12min = 5.e-5 !<    *minimum value for TKE. real , parameter :: fkar = 0.41 !<  0.41   *Von Karman constant real , parameter :: eps1 = 1.e-10 !<    *very small number* real , parameter :: epscloud = 1.e-5 !<    *limit for cloud calculation 0.01 g/kg real , parameter :: boltz = 5.67e-8 !<    *Stefan-Boltzmann constant logical :: lprofforc = . false . !<  nudge flow to a profile ! logical :: lcoriol = . false . !<  switch for coriolis force integer :: igrw_damp = 2 !< switch to enable gravity wave damping real :: geodamptime = 720 0. !< time scale for nudging to geowind in sponge layer, prevents oscillations real :: uflowrate = 1. !< fixed flow rate used for u-velocity correction real :: vflowrate = 1. !< fixed flow rate used for v-velocity correction real :: Uinf = 0. !< fixed U_inf (used in inlet generator), also in conjunction with ifixuinf real :: Vinf = 0. !fixed V_inf real :: inletav = 0. !< averaging interval for inlet generator real :: totinletav = 0. !< averaging interval for inlet generator (used in Running Average) real :: om22 !<    *2.*omega_earth*cos(lat) real :: om23 !<    *2.*omega_earth*sin(lat) real :: om22_gs !<    *2.*omega_earth*cos(lat) real :: om23_gs !<    *2.*omega_earth*sin(lat) real :: xlat = 5 2. !<    *latitude  in degrees. real :: xlon = 0. !<    *longitude in degrees. !scalar source in fluid domain real , allocatable :: xSa (:) real , allocatable :: ySa (:) real , allocatable :: zSa (:) real :: xS = 0. , yS = 0. , zS = 0. real :: SS = 0. real :: sigS = 0. logical :: lnudge = . false . !< switch for applying nudging at the top of the domain real :: tnudge = 5 0. !< time scale for nudging integer :: nnudge = 10 !chemistry logical :: lchem = . false . ! switch for basic chemistry real :: k1 = 0. , JNO2 = 0. ! k1 = rate constant (O3 + NO -> NO2 + 02 ), JNO2 = NO2 photolysis rate ! Poisson solver integer , parameter :: POISS_FFT = 0 , & POISS_CYC = 1 integer :: ipoiss = POISS_CYC !Advection scheme integer , parameter :: iadv_upw = 1 !< first order upwind scheme integer , parameter :: iadv_cd2 = 2 !< second order central difference scheme integer , parameter :: iadv_kappa = 7 !< Kappa scheme integer :: iadv_mom = 2 , iadv_tke = - 1 , iadv_thl = - 1 , iadv_qt = - 1 , iadv_sv ( 100 ) = - 1 logical :: lmoist = . false . !<   switch to calculate moisture fields ! Global variables (modvar.f90) real :: xday = 1. !<     * day number real :: xtime = 0. !<     * GMT time real :: runtime = 30 0. !<     * simulation time in secs real :: dtmax = 2 0. !<     * maximum time integration interval real :: trestart = 1000 0. !<     * each trestart sec. a restart file is written to disk. bss116: per default do not write restart files real :: tfielddump = 1000 0. !< Time step for field outputs real :: tsample = 5. !<    Sample time steps for statistics real :: tstatsdump = 1000 0. !< Time step for statistics outputs tg3315 real :: tnextrestart !<     * each trestart sec. a restart file is written to disk real :: tscale !       timescale: domain height*Uinf/utau**2 real :: tnextfielddump !< character ( 90 ) :: startfile = '' !<    * name of the restart file real :: totavtime = 0. !<    * the total time over which the values are averaged in meansXXX.XXX real :: dtEB = 1 0. !time interval between calculations of facet energy balance real :: tEB = 0. !time of last calculation of facet energy balance real :: tnextEB = 0. !time for next calculation of facet energy balance real :: thres = 5.e-3 !<     * threshold value for inversion height calculations real :: dqt !<     * applied gradient of qt at top of model real :: dtheta !<     * applied gradient of theta at top of model real , allocatable :: dsv (:) !<     * applied gradient of sv(n) at top of model real :: dt !<     * time integration interval !      integer(kind=longint) :: timee             !<     * elapsed time since the \"cold\" start real :: timee !<     * elapsed time since the \"cold\" start !      integer(kind=longint) :: btime             !<     * time of (re)start real :: btime !<     * time of (re)start real :: runavtime !<     * time of starting running average integer :: ntimee !<     * number of timesteps since the cold start integer :: ntrun !<     * number of timesteps since the start of the run real :: timeleft logical :: ladaptive = . false . !<    * adaptive timestepping on or off real :: tdriverstart = 0. !<     * time at which to start recording inlet driver file (only necessary if idriver == 1) real :: tdriverdump !<     * time in inlet driver simulation at which data dumps are made (idriver == 1) real :: dtdriver = 0.1 !<     * time frequency at which inlet driver data dumps are made (idriver == 1) integer :: driverstore !<     * number of stored driver steps for inlet (automatically calculated) integer :: driverjobnr !<     * Job number of the driver inlet generation run (idriver == 2) real :: courant = - 1. real :: diffnr = 0.25 real :: dt_lim integer :: rk3step = 0 integer :: iexpnr = 0 !<     * number of the experiment character ( 3 ) cexpnr real :: thlsrc = 0. ! modphsgrd.f90 real :: dy !<  grid spacing in y-direction real :: dy2 !<  grid spacing in y-direction squared real :: dz !<  grid spacing in z-direction real :: dyi !<  1/dy real :: dyiq !<  1/(dy*4) real :: dyi5 !<  1/(dy*2) real :: dy2i !<  (1/dy)**2 integer :: nwalllayers = 3 real , allocatable :: AM (:,:), BM (:,:), CM (:,:), DM (:,:), EM (:,:), FM (:,:), GM (:,:), HM (:,:), inAM (:,:), IDM (:,:) !matrices for the facet energy balance real , allocatable :: bb (:), w (:), dumv (:), Tdash (:) !vector for the facet energy balance real :: rslabs real , allocatable :: dzf (:) !<  thickness of full level real , allocatable :: dzfc (:) !<  thickness of full level (extra ghost nodes (used in k-scheme) real , allocatable :: dzfci (:) !<  1/dzfc real , allocatable :: dzf2 (:) !<  thickness of full level squared real , allocatable :: dzh (:) !<  thickness of half level real , allocatable :: zh (:) !<  height of half level [m] real , allocatable :: zf (:) !<  height of full level [m] real , allocatable :: dzfi (:) !<  1/dzf real , allocatable :: dzfiq (:) !<  0.25*(1/dzf) real , allocatable :: dzfi5 (:) !<  0.5*(1/dzf) real , allocatable :: dzhi (:) !<  1/dzh real , allocatable :: dzhci (:) !<  1/dzh (extra ghost nodes (used in k-scheme) real , allocatable :: dzhiq (:) !<  0.25*(1/dzh) real , allocatable :: dzh2i (:) !<  1/dzh&#94;2 real , allocatable :: zhi (:) !<  1/zh real , allocatable :: zfi (:) !<  1/zf real , allocatable :: dxf (:) !<  thickness of full level real , allocatable :: dxfc (:) !<  thickness of full level (extra ghost nodes (used in k-scheme) real , allocatable :: dxfci (:) !<  1/dxfc real , allocatable :: dxf2 (:) !<  thickness of full level squared real , allocatable :: dxfi (:) !<  = 1/dxf real , allocatable :: dxfiq (:) !<  = 0.25*(1/dxf) real , allocatable :: dxfi5 (:) !<  = 0.5*(1/dxf) real , allocatable :: dxh (:) !<  thickness of half level real , allocatable :: dxhi (:) !<  = 1/dxh real , allocatable :: dxhci (:) !<  = 1/dxh (with extra ghost nodes (used in k-scheme)) real , allocatable :: dxhiq (:) !<  = 0.25*(1/dxh) real , allocatable :: dxh2i (:) !<  = 1/dxh&#94;2 real , allocatable :: xh (:) !<  height of half level [m] real , allocatable :: xf (:) !<  height of full level [m] real :: xsize = - 1. !<  domain size in x-direction real :: ysize = - 1. !<  domain size in y-direction real , allocatable :: delta (:, :) !<  (dx*dy*dz)**(1/3) logical :: lmomsubs = . false . !<  switch to apply subsidence on the momentum or not character ( 80 ) :: author = '' , version = 'DALES U' contains !> Initialize global settings. !! !! Set courant number, calculate the grid sizes (both computational and physical), and set the coriolis parameter subroutine initglobal use modmpi , only : nprocs , myid , comm3d , my_real , mpierr implicit none integer :: advarr ( 4 ) real phi , colat , silat , omega , omega_gs integer :: i , k , n character ( 80 ) chmess !timestepping if ( courant < 0 ) then select case ( iadv_mom ) case ( iadv_cd2 ) courant = 1.5 case default courant = 1.4 end select if ( any ( iadv_sv ( 1 : nsv ) == iadv_kappa ) . or . any (( / iadv_thl , iadv_qt , iadv_tke / ) == iadv_kappa )) then courant = min ( courant , 1.1 ) elseif ( any ( iadv_sv ( 1 : nsv ) == iadv_upw ) . or . any (( / iadv_thl , iadv_qt , iadv_tke / ) == iadv_upw )) then courant = min ( courant , 1.1 ) elseif ( any ( iadv_sv ( 1 : nsv ) == iadv_cd2 ) . or . any (( / iadv_thl , iadv_qt , iadv_tke / ) == iadv_cd2 )) then courant = min ( courant , 1.5 ) end if end if ! phsgrid jmax = jtot / nprocs isen = imax / nprocs jsen = jmax !set the number of ghost cells. NB: This switch has to run in order of required ghost cells advarr = ( / iadv_mom , iadv_tke , iadv_thl , iadv_qt / ) if ( any ( advarr == iadv_kappa )) then ih = 2 jh = 2 ! ih = 1 ! jh = 1 kh = 1 elseif ( any ( advarr == iadv_cd2 ) . or . any ( iadv_sv ( 1 : nsv ) == iadv_cd2 )) then ih = 1 jh = 1 kh = 1 ihc = 1 jhc = 1 khc = 1 end if ! J. Tomas added this for using only kappa scheme for sv(:) if ( any ( iadv_sv ( 1 : nsv ) == iadv_kappa )) then ihc = 2 jhc = 2 khc = 2 end if offset = 1 ib = 2 - offset ie = imax + 1 - offset jb = 2 - offset je = jmax + 1 - offset jgb = jb ! global j range (starting at the same as j as the processor j range) jge = jtot + 1 - offset ! global j range kb = 1 - offset ke = kmax - offset ! Global constants ! Select advection scheme for scalars. If not set in the options file, the momentum scheme is used if ( iadv_tke < 0 ) iadv_tke = iadv_mom if ( iadv_thl < 0 ) iadv_thl = iadv_mom if ( iadv_qt < 0 ) iadv_qt = iadv_mom !CvH remove where !where (iadv_sv<0)  iadv_sv  = iadv_mom !tg3315 added - only uses kappa advection scheme... do n = 1 , nsv iadv_sv ( n ) = iadv_kappa end do !ends here phi = xlat * pi / 18 0. colat = cos ( phi ) silat = sin ( phi ) omega = 7.292e-5 omega_gs = 7.292e-5 om22 = 2. * omega * colat om23 = 2. * omega * silat om22_gs = 2. * omega_gs * colat om23_gs = 2. * omega_gs * silat ! Variables allocate ( dsv ( nsv )) write ( cexpnr , '(i3.3)' ) iexpnr ! Create the physical grid variables allocate ( dzf ( kb - kh : ke + kh )) allocate ( dzf2 ( kb - kh : ke + kh )) allocate ( dzfi ( kb - kh : ke + kh )) allocate ( dzfiq ( kb - kh : ke + kh )) allocate ( dzfi5 ( kb - kh : ke + kh )) allocate ( dzh ( kb : ke + kh )) allocate ( dzhi ( kb : ke + kh )) allocate ( dzhiq ( kb : ke + kh )) allocate ( dzh2i ( kb : ke + kh )) allocate ( zh ( kb : ke + kh )) allocate ( zf ( kb : ke + kh )) allocate ( dxf ( ib - ih : ie + ih )) allocate ( dxf2 ( ib - ih : ie + ih )) allocate ( dxfi ( ib - ih : ie + ih )) allocate ( dxfiq ( ib - ih : ie + ih )) allocate ( dxfi5 ( ib - ih : ie + ih )) allocate ( dxh ( ib : ie + ih )) allocate ( dxhi ( ib : ie + ih )) allocate ( dxhiq ( ib : ie + ih )) allocate ( dxh2i ( ib : ie + ih )) allocate ( xh ( ib : ie + ih )) allocate ( xf ( ib : ie + ih )) allocate ( delta ( ib - ih : ie + ih , kb : ke + kh )) rslabs = real ( imax * jtot ) dy = ysize / float ( jtot ) ! MPI ! Note, that the loop for reading zf and calculating zh ! has been split so that reading is only done on PE 1 if ( myid == 0 ) then open ( ifinput , file = 'prof.inp.' // cexpnr ) read ( ifinput , '(a72)' ) chmess read ( ifinput , '(a72)' ) chmess do k = kb , ke read ( ifinput , * ) zf ( k ) end do close ( ifinput ) ! J. Tomas: Read the x-coordinates of the cell centers from xgrid.inp.XXX open ( ifinput , file = 'xgrid.inp.' // cexpnr ) read ( ifinput , '(a72)' ) chmess read ( ifinput , '(a72)' ) chmess do i = ib , ie read ( ifinput , * ) xf ( i ) end do close ( ifinput ) end if ! end if myid==0 ! MPI broadcast kmax elements from zf call MPI_BCAST ( zf , kmax , MY_REAL , 0 , comm3d , mpierr ) ! MPI broadcast imax elements from xf call MPI_BCAST ( xf , imax , MY_REAL , 0 , comm3d , mpierr ) zh ( kb ) = 0.0 do k = kb , ke zh ( k + 1 ) = zh ( k ) + 2.0 * ( zf ( k ) - zh ( k )) end do zf ( ke + kh ) = zf ( ke ) + 2.0 * ( zh ( ke + kh ) - zf ( ke )) do k = kb , ke dzf ( k ) = zh ( k + 1 ) - zh ( k ) end do dzf ( ke + 1 ) = dzf ( ke ) dzf ( kb - 1 ) = dzf ( kb ) dzh ( kb ) = 2 * zf ( kb ) do k = kb + 1 , ke + kh dzh ( k ) = zf ( k ) - zf ( k - 1 ) end do ! j. tomas: same trick for x-direction... xh ( ib ) = 0.0 do i = ib , ie xh ( i + 1 ) = xh ( i ) + 2.0 * ( xf ( i ) - xh ( i )) end do xf ( ie + ih ) = xf ( ie ) + 2.0 * ( xh ( ie + ih ) - xf ( ie )) do i = ib , ie dxf ( i ) = xh ( i + 1 ) - xh ( i ) end do dxf ( ie + 1 ) = dxf ( ie ) dxf ( ib - 1 ) = dxf ( ib ) dxh ( ib ) = 2 * xf ( ib ) do i = ib + 1 , ie + ih dxh ( i ) = xf ( i ) - xf ( i - 1 ) end do do k = kb , ke + kh do i = ib - ih , ie + ih delta ( i , k ) = ( dxf ( i ) * dy * dzf ( k )) ** ( 1. / 3. ) end do end do !-------------------------------------------------- ! *** Check whether the grid is equidistant ***** !-------------------------------------------------- !if (myid == 0) then !do k=kb,ke+kh !if (.not.(dzf(k).eq.dzf(1))) !      write (6, *) & !      'WARNING, You are working with a non-equidistant grid!!!!' !end if !end do !end if ! end if myid==0 dzhi = 1. / dzh dzfi = 1. / dzf dzf2 = dzf * dzf dxhi = 1. / dxh dxfi = 1. / dxf dxf2 = dxf * dxf dyi = 1. / dy dy2 = dy * dy dzhiq = 0.25 * dzhi dzfiq = 0.25 * dzfi dxhiq = 0.25 * dxhi dxfiq = 0.25 * dxfi dyiq = 0.25 * dyi dzh2i = dzhi * dzhi dxh2i = dxhi * dxhi dy2i = dyi * dyi dzfi5 = 0.5 * dzfi dxfi5 = 0.5 * dxfi dyi5 = 0.5 * dyi ! Grid used in kappa scheme advection (extra ghost nodes) if ( any ( iadv_sv ( 1 : nsv ) == iadv_kappa )) then allocate ( dzfc ( kb - khc : ke + khc )) allocate ( dxfc ( ib - ihc : ie + ihc )) allocate ( dzfci ( kb - khc : ke + khc )) allocate ( dxfci ( ib - ihc : ie + ihc )) allocate ( dzhci ( kb - 1 : ke + khc )) allocate ( dxhci ( ib - 1 : ie + ihc )) dzfc ( kb - kh : ke + kh ) = dzf ( kb - kh : ke + kh ) dzfc ( kb - khc ) = dzfc ( kb - kh ) dzfc ( ke + khc ) = dzfc ( ke + kh ) dxfc ( ib - ih : ie + ih ) = dxf ( ib - ih : ie + ih ) dxfc ( ib - ihc ) = dxfc ( ib - ih ) dxfc ( ie + ihc ) = dxfc ( ie + ih ) dzhci ( kb : ke + kh ) = dzhi ( kb : ke + kh ) dzhci ( kb - 1 ) = dzhci ( kb ) dzhci ( ke + khc ) = dzhci ( ke + kh ) dxhci ( ib : ie + ih ) = dxhi ( ib : ie + ih ) dxhci ( ib - 1 ) = dxhci ( ib ) dxhci ( ie + ihc ) = dxhci ( ie + ih ) dzfci = 1. / dzfc dxfci = 1. / dxfc end if if ( myid == 0 ) then write ( 6 , * ) 'lev    dz     zf      zh       dzh    delta(ib,k)' do k = ke + 1 , kb , - 1 write ( 6 , '(i4,5f8.5)' ) k , dzf ( k ), zf ( k ), zh ( k ), dzh ( k ), delta ( ib , k ) end do ! same for x: write ( 6 , * ) 'lev    dxf     xf      xh       dxh    delta(i,kb)' do i = ie + 1 , ib , - 1 write ( 6 , '(i4,5f9.5)' ) i , dxf ( i ), xf ( i ), xh ( i ), dxh ( i ), delta ( i , kb ) end do end if tnextrestart = trestart tnextfielddump = tfielddump !    tnextstatsdump = tstatsdump timeleft = runtime ! tg3315 previously btime + runtime end subroutine initglobal !> Clean up when leaving the run subroutine exitglobal deallocate ( dsv , dzf , dzh , zh , zf , delta ) end subroutine exitglobal end module modglobal","tags":"","loc":"sourcefile/modglobal.f90.html"},{"title":"modibm.f90 – uDALES","text":"This file depends on sourcefile~~modibm.f90~~EfferentGraph sourcefile~modibm.f90 modibm.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~modibm.f90->sourcefile~modibmdata.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~modibm.f90->sourcefile~modsubgriddata.f90 sourcefile~modsurfdata.f90 modsurfdata.f90 sourcefile~modibm.f90->sourcefile~modsurfdata.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modibm.f90->sourcefile~modfields.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~modibm.f90->sourcefile~initfac.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modibm.f90->sourcefile~modglobal.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modibm.f90->sourcefile~modmpi.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~modibm.f90~~AfferentGraph sourcefile~modibm.f90 modibm.f90 sourcefile~advec_2nd.f90 advec_2nd.f90 sourcefile~advec_2nd.f90->sourcefile~modibm.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modibm.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules modibm Source Code modibm.f90 Source Code !!> \\file modibm.f90 !!!  adds forcing terms for immersed boundaries ! !> !!  \\author Jasper Thomas TU Delft / Ivo Suter Imperial College London ! ! module modibm use modibmdata !use wf_uno implicit none save public :: createwalls , ibmwallfun , xwallfun , ywallfunplus , ywallfunmin , & zwallfun , ibmnorm , nearwall , bottom contains subroutine createwalls use modglobal , only : ib , ie , jb , je , jgb , jge , kb , ke , jmax , nblocks , & nsv , cexpnr , ifinput , libm , ih , kh , iwallmom , iwalltemp , iwallmoist , rslabs , bldT use modsurfdata , only : thls , z0h , z0 , thvs use modfields , only : sv0 , svm , thl0 , thlm , qtp , qt0 , IIc , IIu , IIv , IIw , IIct , IIwt , IIcs , IIus , IIvs , IIws use modmpi , only : myid , comm3d , mpierr , MPI_INTEGER , MPI_DOUBLE_PRECISION , MY_REAL , nprocs , cmyid , & MPI_REAL8 , MPI_REAL4 , MPI_SUM use initfac , only : block integer n , nn , pn , mn , jbeg , jend , nxn , nxs , nyn , nzn , nzs , iu , il , ju , jl , ku , kl , sc , & i , k , dbi , dbj , dbk integer :: IIcl ( kb : ke + kh ), IIul ( kb : ke + kh ), IIvl ( kb : ke + kh ), IIwl ( kb : ke + kh ) integer :: IIcd ( ib - ih : ie + ih , kb : ke + kh ) integer :: IIwd ( ib - ih : ie + ih , kb : ke + kh ) character ( 80 ) chmess , name2 if (. not . libm ) return ! check if walls are at least 2 cells in each dimension do n = 1 , nblocks dbi = block ( n , 2 ) - block ( n , 1 ) dbj = block ( n , 4 ) - block ( n , 3 ) dbk = block ( n , 6 ) - block ( n , 5 ) if ( any (( / dbi , dbj , dbk / ) < 1 )) then write ( 6 , * ) \"blocks not at least 2 cells in each dimension, or upper limit < lower limit\" !stop  !ils13 19.07.17, don't stop for now end if end do ! For all blocks set the internal concentrations to zero and internal ! temperature to building temperature do n = 1 , nblocks il = block ( n , 1 ) iu = block ( n , 2 ) kl = block ( n , 5 ) ku = block ( n , 6 ) jl = block ( n , 3 ) - myid * jmax ju = block ( n , 4 ) - myid * jmax if (( ju < jb - 1 ) . or . ( jl > je + 1 )) then ! The block is entirely out of this partition cycle end if if ( ju > je ) ju = je !tg3315 and bss116 added 23.10.18 as bad allocation otherwise. if ( jl < jb ) jl = jb do sc = 1 , nsv !sv0(il:iu, jl:ju, kl:ku, sc) = svprof(kl:ku)  !internal ! tg3315 commented to avoid flux at startup !svm(il:iu, jl:ju, kl:ku, sc) = svprof(kl:ku)  !internal end do thl0 ( il : iu , jl : ju , kl : ku ) = bldT !internal ! make sure bldT is equal to init thl prof thlm ( il : iu , jl : ju , kl : ku ) = bldT !internal end do nxwall = 0 do n = 1 , nblocks ! first x and z walls if ( block ( n , 4 ) < jb + myid * jmax ) then ! no x-wall/z-wall in the range of this proc cycle elseif ( block ( n , 3 ) > je + myid * jmax ) then ! no x-wall/z-wall in the range of this proc cycle else ! x-wall/z-wall found on this proc nxwall = nxwall + 1 end if end do allocate ( ixwall ( nxwall )) !allocate the list that stores the indeces of the blocks on this cpu k = 1 do n = 1 , nblocks ! save indeces of the found x/z-walls by re-iterating if ( block ( n , 4 ) < jb + myid * jmax ) then ! no x-wall/z-wall in the range of this proc cycle elseif ( block ( n , 3 ) > je + myid * jmax ) then ! no x-wall/z-wall in the range of this proc cycle else ixwall ( k ) = n ! save index of block which is on this processor k = k + 1 end if end do !!new approach both y walls################################################# !!store index of block and index of the wall (since block might not be on this cpu, but is needed for x and z coords) !!check if wall is on next cpu but not on this !!check if wall is on last cpu but not on first (periodicity in y) !check if wall is on first cpu but not on last (periodicity in y) !!check if wall is on this cpu and another one on the next (i.e. both blocks end at cpu boundary, but touch each other) nyminwall = 0 nypluswall = 0 do n = 1 , nblocks jl = block ( n , 3 ) - myid * jmax ju = block ( n , 4 ) - myid * jmax !IMPORTANT: THESE LINES OF CODE SHOULD BE HERE BUT CAUSE TROUBLE! MAKE SURE BLOCK DOES NOT TOUCH BOUNDARY (EXCECPT ALL FLOORS) !SEE ALSO BELOW! (Like 40 lines or so) if (( myid == 0 ) . and . ( block ( n , 4 ) == jge )) then ! periodicity! nypluswall = nypluswall + 1 else if (( block ( n , 3 ) == jgb ) . and . ( myid == ( nprocs - 1 ))) then ! periodicity! nyminwall = nyminwall + 1 end if if (( ju < ( jb - 1 )) . or . ( jl > ( je + 1 ))) then cycle end if if ( ju == ( jb - 1 )) then !block on previous cpu, north wall on this nypluswall = nypluswall + 1 ! cycle end if if ( jl == ( je + 1 )) then nyminwall = nyminwall + 1 !block on next cpu, southwall on this cycle end if if (( ju < je ) . and . ( ju >= jb )) then !block & northwall on this cpu nypluswall = nypluswall + 1 end if if (( jl > jb ) . and . ( jl <= je )) then !block & southwall on this cpu nyminwall = nyminwall + 1 end if end do allocate ( iyminwall ( 1 : nyminwall , 1 : 2 )) !two indeces to store wall index and block index allocate ( iypluswall ( 1 : nypluswall , 1 : 2 )) iyminwall (:, 1 ) = 0 iyminwall (:, 2 ) = 0 iypluswall (:, 1 ) = 0 iypluswall (:, 2 ) = 0 pn = 1 mn = 1 do n = 1 , nblocks jl = block ( n , 3 ) - myid * jmax ju = block ( n , 4 ) - myid * jmax !IMPORTANT: THESE LINES OF CODE SHOULD BE HERE BUT CAUSE TROUBLE! MAKE SURE BLOCK DOES NOT TOUCH BOUNDARY (EXCECPT ALL FLOORS) if (( myid == 0 ) . and . ( block ( n , 4 ) == jge )) then ! periodicity! iypluswall ( pn , 1 ) = n iypluswall ( pn , 2 ) = jb pn = pn + 1 else if (( block ( n , 3 ) == jgb ) . and . ( myid == ( nprocs - 1 ))) then ! periodicity! iyminwall ( mn , 1 ) = n iyminwall ( mn , 2 ) = je mn = mn + 1 end if if (( ju < ( jb - 1 )) . or . ( jl > ( je + 1 ))) then cycle end if if ( ju == ( jb - 1 )) then !block on previous cpu, north wall on this iypluswall ( pn , 1 ) = n iypluswall ( pn , 2 ) = jb pn = pn + 1 cycle end if if ( jl == ( je + 1 )) then !block on next cpu, south wall on this iyminwall ( mn , 1 ) = n iyminwall ( mn , 2 ) = je mn = mn + 1 cycle end if if (( ju < je ) . and . ( ju >= jb )) then !block & northwall on this cpu   !ILS13, 5.12.17 following Tom iypluswall ( pn , 1 ) = n iypluswall ( pn , 2 ) = ju + 1 pn = pn + 1 end if if (( jl > jb ) . and . ( jl <= je )) then !block & southwall on this cpu iyminwall ( mn , 1 ) = n iyminwall ( mn , 2 ) = jl - 1 mn = mn + 1 end if end do end subroutine createwalls subroutine ibmwallfun use modglobal , only : libm use modfields , only : momfluxb , tfluxb , qfluxb if ( libm ) then ! compute fluxes at IBM momfluxb = 0. tfluxb = 0. qfluxb = 0. call xwallfun call ywallfunplus ! due to parallellisation differentiation between + and - side call ywallfunmin ! due to parallellisation differentiation between + and - side call zwallfun end if end subroutine ibmwallfun subroutine xwallfun use modglobal , only : dzf , dzhiq , dzhi , dxf , dxfi , dxhi , dyi , lles , nsv , numol , ltempeq , lmoist , & ih , jh , kh , ihc , jhc , khc , dxh , dy , dt , totavtime , rk3step , ib , ie , kb , ke , iwallmom , iwalltemp , iwallmoist , iwallscal , nblocks use modfields , only : um , up , v0 , w0 , vp , wp , shear , thl0 , thlp , qt0 , qtp , sv0 , svp , momfluxb , tfluxb , exnf , cth , qfluxb use initfac , only : fachf , block , faclGR , facef , facqsat , fachurel , facf , facT , facz0 , facz0h integer i , j , k , n , nc , jl , ju , kl , ku , im , jm , jp , km , m if ( iwallmom == 1 ) then !fixed flux !not implemented else if ( iwallmom == 2 ) then !wall function do n = 1 , nxwall k = block ( ixwall ( n ), 8 ) !west side call wfuno ( ih , jh , kh , vp , wp , thlp , momfluxb , tfluxb , cth , bcTfluxA , v0 , w0 , thl0 , facT ( k , 1 ), facz0 ( k ), facz0h ( k ), ixwall ( n ), 1 , 11 ) k = block ( ixwall ( n ), 9 ) !east side call wfuno ( ih , jh , kh , vp , wp , thlp , momfluxb , tfluxb , cth , bcTfluxA , v0 , w0 , thl0 , facT ( k , 1 ), facz0 ( k ), facz0h ( k ), ixwall ( n ), 1 , 21 ) end do else if ( iwallmom == 3 ) then do n = 1 , nxwall k = block ( ixwall ( n ), 8 ) !west side call wfmneutral ( ih , jh , kh , vp , wp , momfluxb , v0 , w0 , facz0 ( k ), ixwall ( n ), 1 , 11 ) k = block ( ixwall ( n ), 9 ) !east side call wfmneutral ( ih , jh , kh , vp , wp , momfluxb , v0 , w0 , facz0 ( k ), ixwall ( n ), 1 , 21 ) end do end if if ( ltempeq ) then if ( iwalltemp == 1 ) then !fixed flux do n = 1 , nxwall call xwallscalar ( ih , jh , kh , thl0 , thlp , bctfxm , bctfxp , ixwall ( n )) end do else if ( iwalltemp == 2 ) then do n = 1 , nxwall k = block ( ixwall ( n ), 8 ) !west side call wfuno ( ih , jh , kh , vp , wp , thlp , momfluxb , tfluxb , cth , bcTfluxA , v0 , w0 , thl0 , facT ( k , 1 ), facz0 ( k ), facz0h ( k ), ixwall ( n ), 1 , 12 ) !left wall fachf ( k ) = fachf ( k ) + bcTfluxA !accumulate flux from that facet (can be on multiple processors, will be MPI_ALLREDUCEd in modEB) k = block ( ixwall ( n ), 9 ) !east side call wfuno ( ih , jh , kh , vp , wp , thlp , momfluxb , tfluxb , cth , bcTfluxA , v0 , w0 , thl0 , facT ( k , 1 ), facz0 ( k ), facz0h ( k ), ixwall ( n ), 1 , 22 ) !right wall fachf ( k ) = fachf ( k ) + bcTfluxA end do end if end if if ( lmoist ) then if ( iwallmoist == 1 ) then !fixed flux do n = 1 , nxwall call xwallscalar ( ih , jh , kh , qt0 , qtp , bcqfxm , bcqfxp , ixwall ( n )) end do end if if (( ltempeq ) . and . ( iwallmoist == 2 )) then do n = 1 , nxwall k = block ( ixwall ( n ), 8 ) if ( faclGR ( k )) then !only if it is a vegetated surface call wfGR ( ih , jh , kh , qtp , qfluxb , cth , bcqfluxA , qt0 (:, :, :), facqsat ( k ), fachurel ( k ), facf ( k , 4 ), facf ( k , 5 ), ixwall ( n ), 1 , 12 ) !left wall facef ( k ) = facef ( k ) + bcqfluxA end if k = block ( ixwall ( n ), 9 ) if ( faclGR ( k )) then call wfGR ( ih , jh , kh , qtp , qfluxb , cth , bcqfluxA , qt0 (:, :, :), facqsat ( k ), fachurel ( k ), facf ( k , 4 ), facf ( k , 5 ), ixwall ( n ), 1 , 22 ) !right wall facef ( k ) = facef ( k ) + bcqfluxA end if end do end if end if if ( nsv > 0 ) then if ( iwallscal == 1 ) then !fixed flux do n = 1 , nxwall do m = 1 , nsv call xwallscalar ( ihc , jhc , khc , sv0 (:,:,:, m ), svp (:,:,:, m ), 0. , 0. , ixwall ( n )) end do end do end if end if end subroutine xwallfun subroutine xwallscalar ( hi , hj , hk , putin , putout , bcvaluem , bcvaluep , n ) use modglobal , only : jmax , dxf , dxfi , dxfi5 , dxhi , dxh2i , nsv , ib , ie , jb , je , kb , ke , prandtlmoli , numol use modfields , only : u0 use modmpi , only : myid use modsubgriddata , only : ekh use initfac , only : block integer i , j , k , jl , ju , kl , ku , iww , iee integer , intent ( in ) :: hi !<size of halo in i integer , intent ( in ) :: hj !<size of halo in j integer , intent ( in ) :: hk !<size of halo in k real , intent ( in ) :: putin ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) real , intent ( inout ) :: putout ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) real , intent ( in ) :: bcvaluem , bcvaluep integer , intent ( in ) :: n iww = block ( n , 1 ) - 1 iee = block ( n , 2 ) + 1 jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ! starting j-index ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) ! ending j-index kl = block ( n , 5 ) ! starting k-index ku = block ( n , 6 ) ! ending k-index !fixed flux !remove standard diffusion term, add flux=bcvalue do k = kl , ku do j = jl , ju putout ( iee , j , k ) = putout ( iee , j , k ) + ( & 0.5 * ( ekh ( iee , j , k ) * dxf ( iee - 1 ) + ekh ( iee - 1 , j , k ) * dxf ( iee )) * & ( putin ( iee , j , k ) - putin ( iee - 1 , j , k )) * dxh2i ( iee ) - & bcvaluep ) * dxfi ( iee ) ! putout ( iww , j , k ) = putout ( iww , j , k ) + ( & - 0.5 * ( ekh ( iww + 1 , j , k ) * dxf ( iww ) + ekh ( iww , j , k ) * dxf ( iww + 1 )) * & ( putin ( iww + 1 , j , k ) - putin ( iww , j , k )) * dxh2i ( iww + 1 ) - & bcvaluem ) * dxfi ( iww ) ! end do end do end subroutine xwallscalar subroutine ywallfunplus use modglobal , only : dzf , dzhiq , dzhi , dxf , dxhi , dy , dyi , nsv , lles , numol , ltempeq , lmoist , & je , jb , ih , jh , kh , ihc , jhc , khc , iwallmom , iwallmoist , iwalltemp , iwallscal , nblocks use modfields , only : u0 , w0 , up , wp , shear , thlp , thl0 , qtp , qt0 , sv0 , svp , tfluxb , momfluxb , exnf , cth , qfluxb use modsubgriddata , only : ekm use modmpi , only : myid use initfac , only : fachf , block , faclGR , facqsat , facef , fachurel , facf , facT , facz0 , facz0h integer i , j , k , n , nc , il , iu , kl , ku , im , jm , km , m if ( iwallmom == 1 ) then !fixed flux !not implemented else if ( iwallmom == 2 ) then do n = 1 , nypluswall k = block ( iypluswall ( n , 1 ), 10 ) !upper y wall = north wall call wfuno ( ih , jh , kh , up , wp , thlp , momfluxb , tfluxb , cth , bcTfluxA , u0 , w0 , thl0 , facT ( k , 1 ), facz0 ( k ), facz0h ( k ), iypluswall ( n , 1 ), iypluswall ( n , 2 ), 31 ) end do else if ( iwallmom == 3 ) then do n = 1 , nypluswall k = block ( iypluswall ( n , 1 ), 10 ) !upper y wall = north wall call wfmneutral ( ih , jh , kh , up , wp , momfluxb , u0 , w0 , facz0 ( k ), iypluswall ( n , 1 ), iypluswall ( n , 2 ), 31 ) end do end if if ( ltempeq ) then if ( iwalltemp == 1 ) then do n = 1 , nypluswall ! loop over all shear x-walls !write(*,*) 'shape(iypluswall), nypluswall', shape(iypluswall), nypluswall call ywallscalarplus ( ih , jh , kh , thl0 , thlp , bctfyp , n ) end do else if ( iwalltemp == 2 ) then do n = 1 , nypluswall k = block ( iypluswall ( n , 1 ), 10 ) call wfuno ( ih , jh , kh , up , wp , thlp , momfluxb , tfluxb , cth , bcTfluxA , u0 , w0 , thl0 , facT ( k , 1 ), facz0 ( k ), facz0h ( k ), iypluswall ( n , 1 ), iypluswall ( n , 2 ), 32 ) fachf ( k ) = fachf ( k ) + bcTfluxA end do end if end if if ( lmoist ) then if ( iwallmoist == 1 ) then do n = 1 , nypluswall ! loop over all shear x-walls call ywallscalarplus ( ih , jh , kh , qt0 , qtp , bcqfyp , n ) end do end if if (( ltempeq ) . and . ( iwallmoist == 2 )) then do n = 1 , nypluswall k = block ( iypluswall ( n , 1 ), 10 ) if ( faclGR ( k )) then call wfGR ( ih , jh , kh , qtp , qfluxb , cth , bcqfluxA , qt0 , facqsat ( k ), fachurel ( k ), facf ( k , 4 ), facf ( k , 5 ), iypluswall ( n , 1 ), iypluswall ( n , 2 ), 32 ) facef ( k ) = facef ( k ) + bcqfluxA end if end do end if end if if ( nsv > 0 ) then if ( iwallscal == 1 ) then do n = 1 , nypluswall ! loop over all shear x-walls do m = 1 , nsv call ywallscalarplus ( ihc , jhc , khc , sv0 (:,:,:, m ), svp (:,:,:, m ), 0. , n ) end do end do end if end if end subroutine ywallfunplus subroutine ywallscalarplus ( hi , hj , hk , putin , putout , bcvaluep , n ) use modglobal , only : dyi , ib , ie , jb , je , kb , ke , numol , prandtlmoli use modsubgriddata , only : ekh use modmpi , only : myid use initfac , only : block integer i , j , k , il , iu , kl , ku , m integer , intent ( in ) :: hi !<size of halo in i integer , intent ( in ) :: hj !<size of halo in j integer , intent ( in ) :: hk !<size of halo in k real , intent ( in ) :: putin ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) real , intent ( inout ) :: putout ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) real , intent ( in ) :: bcvaluep integer , intent ( in ) :: n m = iypluswall ( n , 1 ) j = iypluswall ( n , 2 ) il = block ( m , 1 ) iu = block ( m , 2 ) kl = block ( m , 5 ) ku = block ( m , 6 ) !fixed flux do k = kl , ku do i = il , iu putout ( i , j , k ) = putout ( i , j , k ) + ( 0.5 * ( ekh ( i , j , k ) + ekh ( i , j - 1 , k )) * ( putin ( i , j , k ) - putin ( i , j - 1 , k )) * dyi - bcvaluep ) * dyi end do end do end subroutine ywallscalarplus subroutine ywallfunmin use modglobal , only : dxf , dxhi , dy , dyi , dzhiq , dzf , dzhi , lles , nsv , numol , ltempeq , lmoist , & ih , jh , kh , ihc , jhc , khc , iwallmom , iwalltemp , iwallmoist , iwallscal , nblocks use modfields , only : u0 , w0 , up , wp , shear , thl0 , thlp , qt0 , qtp , sv0 , svp , tfluxb , momfluxb , exnf , cth , qfluxb use initfac , only : fachf , block , faclGR , facqsat , facef , fachurel , facf , facT , facz0 , facz0h !      use modsurfdata,     only : wtsurf integer i , j , k , n , nc , il , iu , kl , ku , im , jp , km , m if ( iwallmom == 1 ) then !fixed flux, not implemented else if ( iwallmom == 2 ) then do n = 1 , nyminwall k = block ( iyminwall ( n , 1 ), 11 ) call wfuno ( ih , jh , kh , up , wp , thlp , momfluxb , tfluxb , cth , bcTfluxA , u0 , w0 , thl0 , facT ( k , 1 ), facz0 ( k ), facz0h ( k ), iyminwall ( n , 1 ), iyminwall ( n , 2 ), 41 ) end do else if ( iwallmom == 3 ) then do n = 1 , nyminwall k = block ( iyminwall ( n , 1 ), 11 ) call wfmneutral ( ih , jh , kh , up , wp , momfluxb , u0 , w0 , facz0 ( k ), iyminwall ( n , 1 ), iyminwall ( n , 2 ), 41 ) end do end if ! if ( ltempeq ) then if ( iwalltemp == 1 ) then do n = 1 , nyminwall ! call ywallscalarmin ( ih , jh , kh , thl0 , thlp , bctfym , n ) end do else if ( iwalltemp == 2 ) then do n = 1 , nyminwall k = block ( iyminwall ( n , 1 ), 11 ) call wfuno ( ih , jh , kh , up , wp , thlp , momfluxb , tfluxb , cth , bcTfluxA , u0 , w0 , thl0 , facT ( k , 1 ), facz0 ( k ), facz0h ( k ), iyminwall ( n , 1 ), iyminwall ( n , 2 ), 42 ) fachf ( k ) = fachf ( k ) + bcTfluxA end do end if end if if ( lmoist ) then if ( iwallmoist == 1 ) then do n = 1 , nyminwall ! call ywallscalarmin ( ih , jh , kh , qt0 , qtp , bcqfym , n ) end do end if if (( ltempeq ) . and . ( iwallmoist == 2 )) then do n = 1 , nyminwall k = block ( iyminwall ( n , 1 ), 11 ) if ( faclGR ( k )) then call wfGR ( ih , jh , kh , qtp , qfluxb , cth , bcqfluxA , qt0 , facqsat ( k ), fachurel ( k ), facf ( k , 4 ), facf ( k , 5 ), iyminwall ( n , 1 ), iyminwall ( n , 2 ), 42 ) facef ( k ) = facef ( k ) + bcqfluxA end if end do end if end if if ( nsv > 0 ) then if ( iwallscal == 1 ) then do n = 1 , nyminwall ! do m = 1 , nsv call ywallscalarmin ( ihc , jhc , khc , sv0 (:,:,:, m ), svp (:,:,:, m ), 0. , n ) end do end do end if end if end subroutine ywallfunmin subroutine ywallscalarmin ( hi , hj , hk , putin , putout , bcvaluem , n ) use modglobal , only : dyi , ib , ie , jb , je , kb , ke , prandtlmoli , numol use modsubgriddata , only : ekh use modmpi , only : myid use initfac , only : block integer i , j , k , il , iu , kl , ku , m integer , intent ( in ) :: hi !<size of halo in i integer , intent ( in ) :: hj !<size of halo in j integer , intent ( in ) :: hk !<size of halo in k real , intent ( in ) :: putin ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) real , intent ( inout ) :: putout ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) real , intent ( in ) :: bcvaluem integer , intent ( in ) :: n j = iyminwall ( n , 2 ) m = iyminwall ( n , 1 ) il = block ( m , 1 ) iu = block ( m , 2 ) kl = block ( m , 5 ) ku = block ( m , 6 ) do k = kl , ku do i = il , iu putout ( i , j , k ) = putout ( i , j , k ) + ( & - 0.5 * ( ekh ( i , j , k ) + ekh ( i , j + 1 , k )) * ( putin ( i , j + 1 , k ) - putin ( i , j , k )) * dyi & - bcvaluem ) * dyi end do end do end subroutine ywallscalarmin subroutine zwallfun use modglobal , only : dzf , dzfi , dzhi , dzhiq , dxf , dxfi , dxhi , dyi , nsv , lles , numol , ltempeq , lmoist , & ih , jh , kh , ihc , jhc , khc , iwallmom , iwalltemp , iwallmoist , iwallscal use modfields , only : u0 , v0 , up , vp , shear , thl0 , thlp , qt0 , qtp , sv0 , svp , tfluxb , momfluxb , exnf , cth , qfluxb use modmpi , only : myid use initfac , only : fachf , block , faclGR , facef , facqsat , fachurel , facf , facT , facz0 , facz0h integer i , j , k , n , nc , il , iu , jl , ju , im , jm , km , m if ( iwallmom == 1 ) then !fixed flux else if ( iwallmom == 2 ) then do n = 1 , nxwall k = block ( ixwall ( n ), 7 ) call wfuno ( ih , jh , kh , up , vp , thlp , momfluxb , tfluxb , cth , bcTfluxA , u0 , v0 , thl0 , facT ( k , 1 ), facz0 ( k ), facz0h ( k ), ixwall ( n ), 1 , 51 ) end do else if ( iwallmom == 3 ) then do n = 1 , nxwall k = block ( ixwall ( n ), 7 ) call wfmneutral ( ih , jh , kh , up , vp , momfluxb , u0 , v0 , facz0 ( k ), ixwall ( n ), 1 , 51 ) end do end if if ( ltempeq ) then if ( iwalltemp == 1 ) then do n = 1 , nxwall ! loop over all shear x-walls call zwallscalar ( ih , jh , kh , thl0 , thlp , bctfz , ixwall ( n )) end do else if ( iwalltemp == 2 ) then do n = 1 , nxwall k = block ( ixwall ( n ), 7 ) call wfuno ( ih , jh , kh , up , vp , thlp , momfluxb , tfluxb , cth , bcTfluxA , u0 , v0 , thl0 , facT ( k , 1 ), facz0 ( k ), facz0h ( k ), ixwall ( n ), 1 , 52 ) fachf ( k ) = fachf ( k ) + bcTfluxA end do end if end if if ( lmoist ) then if ( iwallmoist == 1 ) then do n = 1 , nxwall ! loop over all shear x-walls call zwallscalar ( ih , jh , kh , qt0 , qtp , bcqfz , ixwall ( n )) end do end if if (( ltempeq ) . and . ( iwallmoist == 2 )) then do n = 1 , nxwall k = block ( ixwall ( n ), 7 ) if ( faclGR ( k )) then call wfGR ( ih , jh , kh , qtp , qfluxb , cth , bcqfluxA , qt0 , facqsat ( k ), fachurel ( k ), facf ( k , 4 ), facf ( k , 5 ), ixwall ( n ), 1 , 52 ) facef ( k ) = facef ( k ) + bcqfluxA end if end do end if end if if ( nsv > 0 ) then if ( iwallscal == 1 ) then do n = 1 , nxwall ! loop over all shear x-walls do m = 1 , nsv call zwallscalar ( ihc , jhc , khc , sv0 (:,:,:, m ), svp (:,:,:, m ), 0. , ixwall ( n )) end do end do end if end if end subroutine zwallfun subroutine zwallscalar ( hi , hj , hk , putin , putout , bcvalue , n ) use modglobal , only : jmax , dzf , dzfi , dzhi , dzh2i , ib , ie , jb , je , kb , ke , prandtlmoli , numol use modsubgriddata , only : ekh use modmpi , only : myid use initfac , only : block integer i , j , k , il , iu , jl , ju , km integer , intent ( in ) :: hi !<size of halo in i integer , intent ( in ) :: hj !<size of halo in j integer , intent ( in ) :: hk !<size of halo in k real , intent ( in ) :: putin ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) real , intent ( inout ) :: putout ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) real , intent ( in ) :: bcvalue integer , intent ( in ) :: n k = block ( n , 6 ) + 1 !block location km = k - 1 ! il = block ( n , 1 ) iu = block ( n , 2 ) jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) !  delta=putout(3,1,2) do j = jl , ju do i = il , iu putout ( i , j , k ) = putout ( i , j , k ) + ( & 0.5 * ( dzf ( km ) * ekh ( i , j , k ) + dzf ( k ) * ekh ( i , j , km )) * & ! zero flux ( putin ( i , j , k ) - putin ( i , j , km )) * dzh2i ( k ) - & bcvalue ) * dzfi ( k ) end do end do end subroutine zwallscalar subroutine ibmnorm use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , rk3step , dt , libm , jmax , & nblocks , nsv , ltempeq , lmoist , rk3step , ih , kh , dt , totavtime , & dxh , dzf , dy , ih , kh , jh , jge use modfields , only : up , vp , wp , um , vm , wm , u0 , v0 , w0 , thl0 , thlm , svp , svm , thlp , qtp , qt0 , qtm use modmpi , only : myid , nprocs use initfac , only : block real , dimension ( ib - ih : ie + ih , kb - kh : ke + kh ) :: dummy real rk3coef , rk3coefi , timecomplibm , timecomplibmplusdti integer n , i , j , k , il , iu , jl , ju , kl , ku , sc if ( libm ) then rk3coef = dt / ( 4. - dble ( rk3step )) rk3coefi = 1. / rk3coef do n = 1 , nxwall il = block ( ixwall ( n ), 1 ) iu = block ( ixwall ( n ), 2 ) + 1 jl = max ( block ( ixwall ( n ), 3 ) - myid * jmax , 1 ) ! ju = min ( block ( ixwall ( n ), 4 ) - myid * jmax , jmax ) ! !kl = block(ixwall(n), 5) kl = kb ! tg3315 18.03.19 - use kb because for lEB buildings block starts at kb+1 but this leaves area underneath the buildings and horizontally between the roads where we have no block. Only leads to small velocities in these areas but this negates this issue. WARNING - for modelling overhangs this should be changed but this would also require another facade type etc. Similarly applied to y and z directions below. ku = block ( ixwall ( n ), 6 ) !up(il:iu, jl:ju, kl:ku) = -um(il:iu, jl:ju, kl:ku)*rk3coefi up ( iu , jl : ju , kl : ku ) = - um ( iu , jl : ju , kl : ku ) * rk3coefi up ( il , jl : ju , kl : ku ) = - um ( il , jl : ju , kl : ku ) * rk3coefi up ( il + 1 : iu - 1 , jl : ju , kl : ku ) = 0. !internal velocity don't change or um ( il + 1 : iu - 1 , jl : ju , kl : ku ) = 0. !internal velocity = 0    or both? end do ! 1,nxwallsnorm do n = 1 , nyminwall if (( myid == nprocs - 1 . and . block ( iyminwall ( n , 1 ), 3 ) == 1 )) then jl = jmax + 1 ju = jmax + 1 else jl = max ( block ( iyminwall ( n , 1 ), 3 ) - myid * jmax , 1 ) ju = min ( block ( iyminwall ( n , 1 ), 4 ) - myid * jmax , jmax ) + 1 end if il = block ( iyminwall ( n , 1 ), 1 ) iu = block ( iyminwall ( n , 1 ), 2 ) !kl = block(iyminwall(n, 1), 5) kl = kb ! tg3315 see comment for x-direction above ku = block ( iyminwall ( n , 1 ), 6 ) ! write(*,*) 'jl, ju, jmax, iyminwall(n,1)', jl, ju, jmax, iyminwall(n,1) ! vp(il:iu, jl:ju, kl:ku) = -vm(il:iu, jl:ju, kl:ku)*rk3coefi vp ( il : iu , jl , kl : ku ) = - vm ( il : iu , jl , kl : ku ) * rk3coefi vp ( il : iu , ju , kl : ku ) = - vm ( il : iu , ju , kl : ku ) * rk3coefi vp ( il : iu , jl + 1 : ju - 1 , kl : ku ) = 0.0 vm ( il : iu , jl + 1 : ju - 1 , kl : ku ) = 0.0 end do !1,nyminwall do n = 1 , nypluswall if ( myid == 0 . and . block ( iypluswall ( n , 1 ), 4 ) == jge ) then jl = 1 ju = 1 else jl = max ( block ( iypluswall ( n , 1 ), 3 ) - myid * jmax , 1 ) ! should this not be able to be zero? ju = min ( block ( iypluswall ( n , 1 ), 4 ) - myid * jmax , jmax ) + 1 end if il = block ( iypluswall ( n , 1 ), 1 ) iu = block ( iypluswall ( n , 1 ), 2 ) !kl = block(iypluswall(n, 1), 5) kl = kb ! tg3315 see comment for x-direction above ku = block ( iypluswall ( n , 1 ), 6 ) !write(*,*) 'jl, ju, jmax, iypluswall(n,1)', jl, ju, jmax, iypluswall(n,1) !vp(il:iu, jl:ju, kl:ku) = -vm(il:iu, jl:ju, kl:ku)*rk3coefi vp ( il : iu , jl , kl : ku ) = - vm ( il : iu , jl , kl : ku ) * rk3coefi vp ( il : iu , ju , kl : ku ) = - vm ( il : iu , ju , kl : ku ) * rk3coefi vp ( il : iu , jl + 1 : ju - 1 , kl : ku ) = 0.0 vm ( il : iu , jl + 1 : ju - 1 , kl : ku ) = 0.0 end do !1,nypluswall do n = 1 , nxwall !kl = block(ixwall(n), 5) kl = kb ! tg3315 see comment for x-direction above ku = block ( ixwall ( n ), 6 ) + 1 il = block ( ixwall ( n ), 1 ) iu = block ( ixwall ( n ), 2 ) jl = max ( block ( ixwall ( n ), 3 ) - myid * jmax , 1 ) ju = min ( block ( ixwall ( n ), 4 ) - myid * jmax , jmax ) !wp(il:iu, jl:ju, kl:ku) = -wm(il:iu, jl:ju, kl:ku)*rk3coefi wp ( il : iu , jl : ju , kl ) = - wm ( il : iu , jl : ju , kl ) * rk3coefi wp ( il : iu , jl : ju , ku ) = - wm ( il : iu , jl : ju , ku ) * rk3coefi wp ( il : iu , jl : ju , kl + 1 : ku - 1 ) = 0. wm ( il : iu , jl : ju , kl + 1 : ku - 1 ) = 0. end do !1,nxwall if ( ltempeq ) then do n = 1 , nblocks il = block ( n , 1 ) iu = block ( n , 2 ) !kl = block(n, 5) kl = kb ! tg3315 see comment for x-direction above ku = block ( n , 6 ) jl = block ( n , 3 ) - myid * jmax ju = block ( n , 4 ) - myid * jmax if (( ju < jb ) . or . ( jl > je )) then cycle else if ( ju > je ) ju = je if ( jl < jb ) jl = jb thlp ( il : iu , jl : ju , kl : ku ) = 0. !try setting internal T to fluid T thlm ( il , jl : ju , kl : ku ) = thlm ( il - 1 , jl : ju , kl : ku ) thlm ( iu , jl : ju , kl : ku ) = thlm ( iu + 1 , jl : ju , kl : ku ) thlm ( il : iu , jl , kl : ku ) = thlm ( il : iu , jl - 1 , kl : ku ) thlm ( il : iu , ju , kl : ku ) = thlm ( il : iu , ju + 1 , kl : ku ) thlm ( il : iu , jl : ju , ku ) = thlm ( il : iu , jl : ju , ku + 1 ) end if end do end if if ( lmoist ) then do n = 1 , nblocks il = block ( n , 1 ) iu = block ( n , 2 ) !kl = block(n, 5) kl = kb ! tg3315 see comment for x-direction above ku = block ( n , 6 ) jl = block ( n , 3 ) - myid * jmax ju = block ( n , 4 ) - myid * jmax if (( ju < jb ) . or . ( jl > je )) then cycle else if ( ju > je ) ju = je if ( jl < jb ) jl = jb qtp ( il : iu , jl : ju , kl : ku ) = 0. qtm ( il , jl : ju , kl : ku ) = qtm ( il - 1 , jl : ju , kl : ku ) qtm ( iu , jl : ju , kl : ku ) = qtm ( iu + 1 , jl : ju , kl : ku ) qtm ( il : iu , jl , kl : ku ) = qtm ( il : iu , jl - 1 , kl : ku ) qtm ( il : iu , ju , kl : ku ) = qtm ( il : iu , ju + 1 , kl : ku ) qtm ( il : iu , jl : ju , ku ) = qtm ( il : iu , jl : ju , ku + 1 ) end if end do end if if ( nsv > 0 ) then do n = 1 , nblocks il = block ( n , 1 ) iu = block ( n , 2 ) !kl = block(n, 5) kl = kb ! tg3315 see comment for x-direction above ku = block ( n , 6 ) jl = block ( n , 3 ) - myid * jmax ju = block ( n , 4 ) - myid * jmax if (( ju < jb ) . or . ( jl > je )) then cycle else if ( ju > je ) ju = je if ( jl < jb ) jl = jb svp ( il : iu , jl : ju , kl : ku , :) = 0. svp ( il : iu , jl : ju , kl : ku ,:) = 0. svm ( il , jl : ju , kl : ku , :) = svm ( il - 1 , jl : ju , kl : ku ,:) ! tg3315 swapped these around with jl, ju as was getting values in buildings as blovks are split along x in real topology svm ( iu , jl : ju , kl : ku , :) = svm ( iu + 1 , jl : ju , kl : ku ,:) svm ( il : iu , jl , kl : ku , :) = svm ( il : iu , jl - 1 , kl : ku ,:) svm ( il : iu , ju , kl : ku , :) = svm ( il : iu , ju + 1 , kl : ku ,:) svm ( il : iu , jl : ju , ku , :) = svm ( il : iu , jl : ju , ku + 1 ,:) end if end do end if end if ! libm end subroutine ibmnorm !> Determines the distance to the nearest wall for each cell center (used in v. Driest damping function) !> Output is a field with minimal distance to wall for each cell center !ILS13,10.07.17, not being called anymore !only for smagorinsky !indeces of walls are wrong (xwallsglobal etc don't exist anymore) subroutine nearwall use modglobal , only : ib , ie , jb , je , jgb , jge , jmax , kb , ke , xh , xf , dy , zh , zf , lwarmstart , nblocks , libm , lzerogradtop , lwalldist use modsubgriddata , only : lsmagorinsky , loneeqn use modfields , only : mindist , wall use modibmdata , only : xwallsglobal , ywallsglobal , zwallsglobal use modmpi , only : myid use initfac , only : block implicit none integer , allocatable :: ux0all (:, :, :), vy0all (:, :, :), wz0all (:, :, :) real , allocatable :: distxf (:, :), distxh (:, :), distyf (:, :), distyh (:, :), distzf (:, :), distzh (:, :), & distxf2 (:, :), distxh2 (:, :), distyf2 (:, :), distyh2 (:, :), distzf2 (:, :), distzh2 (:, :), distance (:) real distx , disty , distz ! distx is the distance to nearest x-wall, etc. ! integer, allocatable :: optie(:) integer ic , jc , kc , i , j , k , optie , il , iu , jl , ju , kl , ku , n ! if (lwarmstart .or. lles.eqv..false. .or. lvreman) then if ((( lsmagorinsky ) . or . ( loneeqn )) . and . ( lwalldist )) then if ( myid == 0 ) then write ( 6 , * ) 'Computing wall distances' end if ! if (lles.eqv..false. .or. lvreman) then mindist = 1.0e10 allocate ( ux0all ( ib - 1 : ie + 1 , jgb - 1 : jge + 1 , kb - 1 : ke + 1 )) ! This contains ux0 + the lower and (possibly) the upper wall allocate ( vy0all ( ib - 1 : ie + 1 , jgb - 1 : jge + 1 , kb - 1 : ke + 1 )) ! This contains ux0 + the lower and (possibly) the upper wall allocate ( wz0all ( ib - 1 : ie + 1 , jgb - 1 : jge + 1 , kb - 1 : ke + 1 )) ! This contains ux0 + the lower and (possibly) the upper wall allocate ( distxh ( ib : ie , ib : ie + 1 )) allocate ( distxf ( ib : ie , ib : ie + 1 )) allocate ( distyh ( jb : je , jgb : jge + 1 )) allocate ( distyf ( jb : je , jgb : jge + 1 )) allocate ( distzh ( kb : ke , kb : ke + 1 )) allocate ( distzf ( kb : ke , kb : ke + 1 )) allocate ( distxh2 ( ib : ie , ib : ie + 1 )) allocate ( distxf2 ( ib : ie , ib : ie + 1 )) allocate ( distyh2 ( jb : je , jgb : jge + 1 )) allocate ( distyf2 ( jb : je , jgb : jge + 1 )) allocate ( distzh2 ( kb : ke , kb : ke + 1 )) allocate ( distzf2 ( kb : ke , kb : ke + 1 )) allocate ( distance ( 4 )) ! initialize wall indicators ux0all = 0 vy0all = 0 wz0all = 0 ! Determine for each cell face if an x/y/z-wall is present ! from immersed boundaries if ( libm ) then ! do loop over blocks do n = 1 , nblocks il = block ( n , 1 ) iu = block ( n , 2 ) jl = block ( n , 3 ) ju = block ( n , 4 ) kl = block ( n , 5 ) ku = block ( n , 6 ) do k = kl , ku do j = jl , ju ux0all ( il , j , k ) = 1 ! lower x-wall ux0all ( iu + 1 , j , k ) = 1 ! upper x-wall end do end do do k = kl , ku do i = il , iu vy0all ( i , jl , k ) = 1 ! lower y-wall vy0all ( i , ju + 1 , k ) = 1 ! upper y-wall end do end do do j = jl , ju do i = il , iu wz0all ( i , j , kl ) = 1 ! lower z-wall wz0all ( i , j , ku + 1 ) = 1 ! upper z-wall end do end do end do ! loop over nblocks end if ! libm = .true. ! add the global walls (probably upper and lower wall, or only lower wall) if ( lzerogradtop ) then do i = ib , ie do j = jgb , jge wz0all ( i , j , kb ) = 1 ! ground wall end do end do else do i = ib , ie do j = jgb , jge wz0all ( i , j , kb ) = 1 ! ground wall wz0all ( i , j , ke + 1 ) = 1 ; ! top wall end do end do end if write ( 6 , * ) 'Determing distance matrices, proc=' , myid ! Determine x-distance matrices: do ic = ib , ie ! cell-center index do i = ib , ie + 1 ! vertex-index (1 more than cell centers) distxh ( ic , i ) = xf ( ic ) - xh ( i ) end do end do do ic = ib , ie ! cell-center index do i = ib , ie + 1 ! center -index distxf ( ic , i ) = xf ( ic ) - xf ( i ) end do end do ! Determine y-distance matrices: do jc = jb , je ! cell-center index do j = jgb , jge + 1 ! vertex-index (1 more than cell centers) (global index to make sure distance to all cells is determined) distyh ( jc , j ) = ( jc + myid * jmax - j ) * dy + 0.5 * dy end do end do do jc = jb , je ! cell-center index do j = jgb , jge + 1 ! center-index  (global index to make sure distance to all cells is determined) distyf ( jc , j ) = ( jc + myid * jmax - j ) * dy end do end do ! Determine z-distance matrices: do kc = kb , ke ! cell-center index do k = kb , ke + 1 ! vertex-index (1 more than cell centers) distzh ( kc , k ) = zf ( kc ) - zh ( k ) end do end do do kc = kb , ke ! cell-center index do k = kb , ke + 1 ! vertex-index (1 more than cell centers) distzf ( kc , k ) = zf ( kc ) - zf ( k ) end do end do distxh2 = distxh ** 2 distyh2 = distyh ** 2 distzh2 = distzh ** 2 distxf2 = distxf ** 2 distyf2 = distyf ** 2 distzf2 = distzf ** 2 write ( 6 , * ) 'Finished determing distance matrices, proc=' , myid write ( 6 , * ) 'determing distance to nearest wall for each cell center, proc=' , myid ! Loop over cells (ic,jc,kc) for which minimal wall-to-cell-center-distance needs to be determined !  do jc=jgb,jge do kc = kb , ke do jc = jb , je do ic = ib , ie ! Determine distance between cc of cell (ic,jc,kc) and faces of all cells (i,j,k) do k = kb , ke + 1 ! Level ke+1 is computed in a separate loop (only necessary with upper wall-> global approach=faster) do j = jgb , jge + 1 ! loop goes up to jge+1 because jge+1 contains the last vy0-wall do i = ib , ie + 1 ! loop goes up to ie+1 because ie+1 contains the last ux0-wall if ( ux0all ( i , j , k ) == 1 . OR . vy0all ( i , j , k ) == 1 . OR . wz0all ( i , j , k ) == 1 ) then distx = 1.0e10 ! make sure distx is very large when no x-wall is present disty = 1.0e10 ! make sure disty is very large when no y-wall is present distz = 1.0e10 ! make sure distz is very large when no z-wall is present if ( ux0all ( i , j , k ) == 1 ) then distx = sqrt ( distxh2 ( ic , i ) + distyf2 ( jc , j ) + distzf2 ( kc , k )) end if if ( vy0all ( i , j , k ) == 1 ) then disty = sqrt ( distxf2 ( ic , i ) + distyh2 ( jc , j ) + distzf2 ( kc , k )) end if if ( wz0all ( i , j , k ) == 1 ) then distz = sqrt ( distxf2 ( ic , i ) + distyf2 ( jc , j ) + distzh2 ( kc , k )) end if else ! no walls are present in cell (i,j,k) -> distance does not need to be determined for this cell cycle ! go to next cell (i,j,k) end if ! determine minimal wall distance between cc of (ic,jc,kc) and faces of cell (i,j,k) distance = ( / mindist ( ic , jc , kc ), distx , disty , distz / ) optie = minloc ( distance , 1 ) ! write(6,*) 'optie=', optie if ( optie == 1 ) then cycle else if ( optie == 2 ) then mindist ( ic , jc , kc ) = distx wall ( ic , jc , kc , 2 ) = j wall ( ic , jc , kc , 3 ) = k ! wall(ic,jc,kc,4) = 1     ! This means the wall closest to the cc of (ic,jc,kc) is at an x-wall at (i,j,k) if ( ic >= i ) then wall ( ic , jc , kc , 1 ) = i wall ( ic , jc , kc , 4 ) = 5 ! shear component index (variable: shear) wall ( ic , jc , kc , 5 ) = 9 ! shear component index (variable: shear) else wall ( ic , jc , kc , 1 ) = i - 1 ! in the subgrid this stress is computed in the cell i-1 wall ( ic , jc , kc , 4 ) = 6 ! shear component index (variable: shear) wall ( ic , jc , kc , 5 ) = 10 ! shear component index (variable: shear) end if else if ( optie == 3 ) then mindist ( ic , jc , kc ) = disty wall ( ic , jc , kc , 1 ) = i wall ( ic , jc , kc , 3 ) = k ! wall(ic,jc,kc,4) = 2     ! This means the wall closest to the cc of (ic,jc,kc) is at a y-wall at (i,j,k) if ( jc + myid * jmax >= j ) then wall ( ic , jc , kc , 2 ) = j wall ( ic , jc , kc , 4 ) = 1 ! shear component index (variable: shear) wall ( ic , jc , kc , 5 ) = 11 ! shear component index (variable: shear) else wall ( ic , jc , kc , 2 ) = j - 1 ! in the subgrid this stress is computed in the cell j-1 wall ( ic , jc , kc , 4 ) = 2 ! shear component index (variable: shear) wall ( ic , jc , kc , 5 ) = 12 ! shear component index (variable: shear) end if else if ( optie == 4 ) then mindist ( ic , jc , kc ) = distz wall ( ic , jc , kc , 1 ) = i wall ( ic , jc , kc , 2 ) = j ! wall(ic,jc,kc,4) = 3     ! This means the wall closest to the cc of (ic,jc,kc) is at a z-wall at (i,j,k) if ( kc >= k ) then wall ( ic , jc , kc , 3 ) = k wall ( ic , jc , kc , 4 ) = 3 ! shear component index (variable: shear) wall ( ic , jc , kc , 5 ) = 7 ! shear component index (variable: shear) else wall ( ic , jc , kc , 3 ) = k - 1 ! in the subgrid this stress is computed in the cel k-1 wall ( ic , jc , kc , 4 ) = 4 ! shear component index (variable: shear) wall ( ic , jc , kc , 5 ) = 8 ! shear component index (variable: shear) end if end if ! mindist(ic,jc+myid*jmax,kc)=min(mindist(ic,jc+myid*jmax,kc),distx,disty,distz)   ! global j index end do end do end do ! if (myid==0) write(6,*) 'finished for cell (ic,jc,kc)=',ic,jc,kc end do end do end do write ( 6 , * ) 'Finished determing distance to nearest wall for each cell center, proc=' , myid ! write(6,*) 'mindist(ib,jb+myid*jmax,kb),mindist(ib,je+myid*jmax,kb)',mindist(ib,jb+myid*jmax,kb),mindist(ib,je+myid*jmax,kb) else return end if !(lwarmstart) deallocate ( ux0all , vy0all , wz0all ) deallocate ( xwallsglobal , ywallsglobal , zwallsglobal , block ) ! used for determining boundaries return end subroutine nearwall subroutine bottom !kind of obsolete when road facets are being used !vegetated floor not added (could simply be copied from vegetated horizontal facets) use modglobal , only : ib , ie , ih , jh , kh , jb , je , kb , numol , prandtlmol , dzh , nsv , & dxf , dxhi , dzf , dzfi , numoli , ltempeq , khc , lmoist , BCbotT , BCbotq , BCbotm , BCbots , dzh2i use modfields , only : u0 , v0 , e120 , um , vm , w0 , wm , e12m , thl0 , qt0 , sv0 , thlm , qtm , svm , up , vp , thlp , qtp , svp , shear , momfluxb , tfluxb , cth use modsurfdata , only : thlflux , qtflux , svflux , ustar , thvs , wtsurf , wqsurf , thls , z0 , z0h use modsubgriddata , only : ekm , ekh use modmpi , only : myid implicit none integer :: i , j , jp , jm , m !momentum if ( BCbotm . eq . 2 ) then call wfuno ( ih , jh , kh , up , vp , thlp , momfluxb , tfluxb , cth , bcTfluxA , u0 , v0 , thl0 , thls , z0 , z0h , 0 , 1 , 91 ) elseif ( BCbotm . eq . 3 ) then call wfmneutral ( ih , jh , kh , up , vp , momfluxb , u0 , v0 , z0 , 0 , 1 , 91 ) else write ( 0 , * ) \"ERROR: bottom boundary type for momentum undefined\" stop 1 end if if ( ltempeq ) then if ( BCbotT . eq . 1 ) then !neumann/fixed flux bc for temperature do j = jb , je do i = ib , ie thlp ( i , j , kb ) = thlp ( i , j , kb ) & + ( & 0.5 * ( dzf ( kb - 1 ) * ekh ( i , j , kb ) + dzf ( kb ) * ekh ( i , j , kb - 1 )) & * ( thl0 ( i , j , kb ) - thl0 ( i , j , kb - 1 )) & * dzh2i ( kb ) & - wtsurf & ) * dzfi ( kb ) end do end do else if ( BCbotT . eq . 2 ) then !wall function bc for temperature (fixed temperature) call wfuno ( ih , jh , kh , up , vp , thlp , momfluxb , tfluxb , cth , bcTfluxA , u0 , v0 , thl0 , thls , z0 , z0h , 0 , 1 , 92 ) else write ( 0 , * ) \"ERROR: bottom boundary type for temperature undefined\" stop 1 end if end if ! ltempeq if ( lmoist ) then if ( BCbotq . eq . 1 ) then !neumann/fixed flux bc for moisture do j = jb , je do i = ib , ie qtp ( i , j , kb ) = qtp ( i , j , kb ) + ( & 0.5 * ( dzf ( kb - 1 ) * ekh ( i , j , kb ) + dzf ( kb ) * ekh ( i , j , kb - 1 )) & * ( qt0 ( i , j , kb ) - qt0 ( i , j , kb - 1 )) & * dzh2i ( kb ) & + wqsurf & ) * dzfi ( kb ) end do end do else write ( 0 , * ) \"ERROR: bottom boundary type for moisture undefined\" stop 1 end if ! end if !lmoist if ( nsv > 0 ) then if ( BCbots . eq . 1 ) then !neumann/fixed flux bc for moisture do j = jb , je do i = ib , ie do m = 1 , nsv svp ( i , j , kb , m ) = svp ( i , j , kb , m ) + ( & 0.5 * ( dzf ( kb - 1 ) * ekh ( i , j , kb ) + dzf ( kb ) * ekh ( i , j , kb - 1 )) & * ( sv0 ( i , j , kb , m ) - sv0 ( i , j , kb - 1 , m )) & * dzh2i ( kb ) & + 0. & ) * dzfi ( kb ) end do end do end do else write ( 0 , * ) \"ERROR: bottom boundary type for scalars undefined\" stop 1 end if ! end if e120 (:, :, kb - 1 ) = e120 (:, :, kb ) e12m (:, :, kb - 1 ) = e12m (:, :, kb ) wm (:, :, kb ) = 0. w0 (:, :, kb ) = 0. return end subroutine bottom end module modibm","tags":"","loc":"sourcefile/modibm.f90.html"},{"title":"modstat_nc.f90 – uDALES","text":"This file depends on sourcefile~~modstat_nc.f90~~EfferentGraph sourcefile~modstat_nc.f90 modstat_nc.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modstat_nc.f90->sourcefile~modglobal.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modstat_nc.f90->sourcefile~modmpi.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~modstat_nc.f90~~AfferentGraph sourcefile~modstat_nc.f90 modstat_nc.f90 sourcefile~modfielddump.f90 modfielddump.f90 sourcefile~modfielddump.f90->sourcefile~modstat_nc.f90 sourcefile~modstatistics.f90 modstatistics.f90 sourcefile~modstatistics.f90->sourcefile~modstat_nc.f90 sourcefile~modeb.f90 modEB.f90 sourcefile~modeb.f90->sourcefile~modstat_nc.f90 sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~modstatsdump.f90->sourcefile~modstat_nc.f90 sourcefile~modstatsdump.f90->sourcefile~modstatistics.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modstat_nc.f90 sourcefile~program.f90->sourcefile~modfielddump.f90 sourcefile~program.f90->sourcefile~modeb.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules modstat_nc Source Code modstat_nc.f90 Source Code !> \\file modstat_nc.f90 !!  Background routines to write NetCDF output !> !!  Background routines to write NetCDF output. !> !! All calls to the netcdf library should be directed through here. !! Inspired on the UCLA-LES routine by Bjorn Stevens. !!  \\author Thijs Heus,MPI-M !!  \\par Revision list !!  \\todo documentation !!   \\todo restartfiles in NetCDF? !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! module modstat_nc use netcdf use modmpi , only : myid implicit none integer , save :: timeID = 0 , ztID = 0 , zmID = 0 , xtID = 0 , xmID = 0 , ytID = 0 , ymID = 0 , ztsID = 0 , fctID = 0 , lyrID = 0 real ( kind = 4 ) :: nc_fillvalue = - 99 9. !> The only interface necessary to write data to netcdf, regardless of the dimensions. interface writestat_nc module procedure writestat_time_nc module procedure writestat_1D_nc module procedure writestat_2D_nc module procedure writestat_3D_nc module procedure writestat_3D_short_nc end interface writestat_nc contains subroutine initstat_nc use modglobal , only : kmax , ifnamopt , fname_options , iexpnr use modmpi , only : mpierr , mpi_logical , comm3d , myid implicit none integer :: ierr end subroutine initstat_nc ! ! ---------------------------------------------------------------------- !> Subroutine Open_NC: Opens a NetCDF File and identifies starting record ! subroutine open_nc ( fname , ncid , nrec , n1 , n2 , n3 , ns , nfcts , nlyrs ) use modglobal , only : author , version , timee implicit none integer , intent ( out ) :: ncid , nrec integer , optional , intent ( in ) :: n1 , n2 , n3 , ns , nfcts , nlyrs character ( len = 40 ), intent ( in ) :: fname character ( len = 12 ) :: date = '' , time = '' integer :: iret , varid , ncall , RecordDimID real , allocatable :: xtimes (:) logical :: exans inquire ( file = trim ( fname ), exist = exans ) !write(*,*) 'opennc' ncall = 0 if (. not . exans ) then call date_and_time ( date , time ) iret = nf90_create ( fname , NF90_SHARE , ncid ) iret = nf90_put_att ( ncid , NF90_GLOBAL , 'title' , fname ) iret = nf90_put_att ( ncid , NF90_GLOBAL , 'history' , 'Created on ' // trim ( date ) // ' at ' // trim ( time )) iret = nf90_put_att ( ncid , NF90_GLOBAL , 'Source' , trim ( version )) iret = nf90_put_att ( ncid , NF90_GLOBAL , 'Author' , trim ( author )) iret = nf90_def_dim ( ncID , 'time' , NF90_UNLIMITED , timeID ) if ( present ( n1 )) then iret = nf90_def_dim ( ncID , 'xt' , n1 , xtID ) iret = nf90_def_dim ( ncID , 'xm' , n1 , xmID ) iret = nf90_def_var ( ncID , 'xt' , NF90_FLOAT ,( / xtID / ) , VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'West-East displacement of cell centers' ) iret = nf90_put_att ( ncID , VarID , 'units' , 'm' ) iret = nf90_def_var ( ncID , 'xm' , NF90_FLOAT ,( / xmID / ), VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'West-East displacement of cell edges' ) iret = nf90_put_att ( ncID , VarID , 'units' , 'm' ) end if if ( present ( n2 )) then iret = nf90_def_dim ( ncID , 'yt' , n2 , ytID ) iret = nf90_def_dim ( ncID , 'ym' , n2 , ymID ) iret = nf90_def_var ( ncID , 'yt' , NF90_FLOAT , ytID , VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'South-North displacement of cell centers' ) iret = nf90_put_att ( ncID , VarID , 'units' , 'm' ) iret = nf90_def_var ( ncID , 'ym' , NF90_FLOAT , ymID , VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'South-North displacement of cell edges' ) iret = nf90_put_att ( ncID , VarID , 'units' , 'm' ) end if if ( present ( n3 )) then iret = nf90_def_dim ( ncID , 'zt' , n3 , ztID ) iret = nf90_def_dim ( ncID , 'zm' , n3 , zmID ) iret = nf90_def_var ( ncID , 'zt' , NF90_FLOAT ,( / ztID / ) , VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'Vertical displacement of cell centers' ) iret = nf90_put_att ( ncID , VarID , 'units' , 'm' ) iret = nf90_def_var ( ncID , 'zm' , NF90_FLOAT ,( / zmID / ), VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'Vertical displacement of cell edges' ) iret = nf90_put_att ( ncID , VarID , 'units' , 'm' ) end if if ( present ( ns )) then iret = nf90_def_dim ( ncID , 'zts' , ns , ztsID ) iret = nf90_def_var ( ncID , 'zts' , NF90_FLOAT ,( / ztsID / ) , VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'Soil level depth of cell centers' ) iret = nf90_put_att ( ncID , VarID , 'units' , 'm' ) end if if ( present ( nfcts )) then iret = nf90_def_dim ( ncID , 'fct' , nfcts , fctID ) iret = nf90_def_var ( ncID , 'fct' , NF90_INT ,( / fctID / ) , VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'Facet number' ) end if if ( present ( nlyrs )) then iret = nf90_def_dim ( ncID , 'lyr' , nlyrs , lyrID ) iret = nf90_def_var ( ncID , 'lyr' , NF90_INT ,( / lyrID / ) , VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'Number of wall layers' ) end if else nrec = 0 ncall = 0 iret = nf90_open ( trim ( fname ), NF90_WRITE , ncid ) iret = nf90_inquire ( ncid , unlimitedDimId = RecordDimID ) iret = nf90_inquire_dimension ( ncid , RecordDimID , len = nrec ) if ( nrec > 0 ) then iret = nf90_inq_varid ( ncid , 'time' , timeID ) allocate ( xtimes ( nrec )) iret = nf90_get_var ( ncid , timeId , xtimes ( 1 : nrec )) do while ( xtimes ( ncall + 1 ) < timee - spacing ( 1. )) ncall = ncall + 1 if ( ncall >= nrec ) exit end do deallocate ( xtimes ) end if if ( present ( n1 )) then iret = nf90_inq_dimid ( ncid , 'xt' , xtId ) iret = nf90_inq_dimid ( ncid , 'xm' , xmId ) end if if ( present ( n2 )) then iret = nf90_inq_dimid ( ncid , 'yt' , ytId ) iret = nf90_inq_dimid ( ncid , 'ym' , ymId ) end if if ( present ( n3 )) then iret = nf90_inq_dimid ( ncid , 'zt' , ztId ) iret = nf90_inq_dimid ( ncid , 'zm' , zmId ) end if if ( present ( ns )) then iret = nf90_inq_dimid ( ncid , 'zts' , ztsId ) end if if ( present ( nfcts )) then iret = nf90_inq_dimid ( ncid , 'fct' , fctId ) end if end if nrec = ncall iret = nf90_sync ( ncid ) iret = nf90_enddef ( ncID ) end subroutine open_nc ! ! ---------------------------------------------------------------------- !> Subroutine Define_NC: Defines the structure of the nc file (if not !! already open) ! subroutine define_nc ( ncID , nVar , sx ) implicit none integer , intent ( in ) :: nVar , ncID character ( * ), intent ( in ) :: sx ( nVar , 4 ) integer , save :: dim_mttt ( 4 ) = 0 , dim_tmtt ( 4 ) = 0 , dim_ttmt ( 4 ) = 0 , dim_tttt ( 4 ) = 0 , & dim_tt ( 2 ) = 0 , dim_mt ( 2 ) = 0 , dim_t0tt ( 3 ) = 0 , dim_m0tt ( 3 ) = 0 , dim_t0mt ( 3 ) = 0 ,& dim_m0mt ( 3 ) = 0 , dim_tt0t ( 3 ) = 0 , & dim_mt0t ( 3 ) = 0 , dim_tm0t ( 3 ) = 0 , dim_0ttt ( 3 ) = 0 , dim_0mtt ( 3 ) = 0 , dim_0tmt ( 3 ) = 0 ,& dim_tts ( 2 ) = 0 , dim_t0tts ( 3 ) = 0 , dim_0ttts ( 3 ) = 0 , dim_tttts ( 4 ) = 0 , dim_ttt0 ( 3 ) = 0 ,& !tg3315 added last one dim_mtmt ( 4 ), dim_tmmt ( 4 ), dim_mmtt ( 4 ),& !bss116 dim_ft ( 2 ), dim_flt ( 3 ) !SO integer :: iret , n , VarID !write(*,*) 'definenc' iret = nf90_inq_dimid ( ncid , 'time' , timeId ) iret = nf90_inq_dimid ( ncid , 'xt' , xtId ) iret = nf90_inq_dimid ( ncid , 'xm' , xmId ) iret = nf90_inq_dimid ( ncid , 'yt' , ytId ) iret = nf90_inq_dimid ( ncid , 'ym' , ymId ) iret = nf90_inq_dimid ( ncid , 'zt' , ztId ) iret = nf90_inq_dimid ( ncid , 'zm' , zmId ) iret = nf90_inq_dimid ( ncid , 'zts' , ztsId ) iret = nf90_inq_dimid ( ncid , 'fct' , fctId ) ! so4718 for energy balance output iret = nf90_inq_dimid ( ncid , 'lyr' , lyrId ) ! so4718 for energy balance output iret = nf90_redef ( ncid ) dim_tt = ( / ztId , timeId / ) dim_mt = ( / zmId , timeId / ) dim_t0tt = ( / xtID , ztID , timeId / ) ! thermo point dim_t0mt = ( / xtID , zmID , timeId / ) ! zpoint dim_m0tt = ( / xmID , ztID , timeId / ) ! upoint dim_m0mt = ( / xmID , ztID , timeId / ) ! uw stats point dim_tt0t = ( / xtID , ytID , timeId / ) ! thermo point dim_tm0t = ( / xtID , ymID , timeId / ) ! vpoint dim_mt0t = ( / xmID , ytID , timeId / ) ! upoint dim_0ttt = ( / ytID , ztID , timeId / ) ! thermo point dim_0tmt = ( / ytID , zmID , timeId / ) ! wpoint dim_0mtt = ( / ymID , ztID , timeId / ) ! vpoint dim_tttt = ( / xtID , ytID , ztID , timeId / ) ! thermo point dim_ttmt = ( / xtID , ytID , zmID , timeId / ) ! zpoint dim_mttt = ( / xmID , ytID , ztID , timeId / ) ! upoint dim_tmtt = ( / xtID , ymID , ztId , timeId / ) ! ypoint dim_mtmt = ( / xmID , ytID , zmId , timeId / ) ! uw stats point bss116 dim_tmmt = ( / xtID , ymID , zmId , timeId / ) ! vw stats point bss116 dim_mmtt = ( / xmID , ymID , ztId , timeId / ) ! uv stats point bss116 dim_ttt0 = ( / xtID , ytID , ztID / ) ! stats point tg3315 dim_tts = ( / ztsId , timeId / ) dim_t0tts = ( / xtID , ztsID , timeId / ) ! thermo soil point dim_0ttts = ( / ytID , ztsID , timeId / ) ! thermo point dim_tttts = ( / xtID , ytID , ztsID , timeId / ) ! thermo point dim_ft = ( / fctID , timeId / ) dim_flt = ( / fctID , lyrID , timeId / ) do n = 1 , nVar !      write(*,*) 'n', n !      write(*,*) \"dummyline1\" !      write(*,*) 'sx1', sx(1,:) !      write(*,*) 'sx2', sx(2,:) !      write(*,*) \"dummyline2\" !      write(*,*) 'trim(sx(n,1))', trim(sx(n,1)) !      write(*,*) 'trim(sx(n,2))', trim(sx(n,2)) !      write(*,*) 'trim(sx(n,3))', trim(sx(n,3)) !      write(*,*) 'trim(sx(n,4))', trim(sx(n,4)) !      write (*,*) 'ncID', ncID iret = nf90_inq_varid ( ncid , trim ( sx ( n , 1 )), VarID ) if ( iret == 0 ) cycle select case ( trim ( sx ( n , 4 ))) case ( 'time' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT ,( / timeID / ) , VarID ) case ( 'tt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_tt , VarID ) case ( 'mt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_mt , VarID ) !2D Fields case ( 't0tt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_t0tt , VarID ) case ( 't0mt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_t0mt , VarID ) case ( 'm0tt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_m0tt , VarID ) case ( 'm0mt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_m0mt , VarID ) case ( 'tt0t' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_tt0t , VarID ) case ( 'tm0t' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_tm0t , VarID ) case ( 'mt0t' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_mt0t , VarID ) case ( '0ttt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_0ttt , VarID ) case ( '0tmt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_0tmt , VarID ) case ( '0mtt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_0mtt , VarID ) case ( 'ttt0' ) !tg3315 for uav,vav,wav etc. iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_ttt0 , VarID ) !3D Fields case ( 'tttt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_tttt , VarID ) case ( 'mttt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_mttt , VarID ) case ( 'tmtt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_tmtt , VarID ) case ( 'ttmt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_ttmt , VarID ) case ( 'mtmt' ) ! bss116 iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_mtmt , VarID ) case ( 'tmmt' ) ! bss116 iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_tmmt , VarID ) case ( 'mmtt' ) ! bss116 iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_mmtt , VarID ) !Soil fields case ( 'tts' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_tts , VarID ) case ( 't0tts' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_t0tts , VarID ) case ( '0ttts' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_0ttts , VarID ) case ( 'tttts' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_tttts , VarID ) !Facet information case ( 'ft' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_ft , VarID ) case ( 'flt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_flt , VarID ) case default write ( 0 , * ) 'nvar' , nvar , sx ( n ,:) write ( 0 , * ) 'ERROR: Bad dimensional information ' , sx ( n ,:) stop 1 ! call appl_abort(0) end select if ( iret /= 0 ) then !        write (*,*) 'nvar', nvar, sx(n,:) !        write (*,*) 'ncID', ncID call nchandle_error ( iret ) end if iret = nf90_put_att ( ncID , VarID , 'longname' , sx ( n , 2 )) iret = nf90_put_att ( ncID , VarID , 'units' , sx ( n , 3 )) iret = nf90_put_att ( ncid , VarID , '_FillValue' , nc_fillvalue ) end do iret = nf90_enddef ( ncID ) end subroutine define_nc subroutine redefine_nc ( ncid ) implicit none integer , intent ( in ) :: ncid integer :: iret iret = nf90_redef ( ncid ) end subroutine redefine_nc subroutine exitstat_nc ( ncid ) implicit none integer , intent ( in ) :: ncid integer status status = nf90_close ( ncid ) if ( status /= nf90_noerr ) call nchandle_error ( status ) end subroutine exitstat_nc subroutine writestat_dims_nc ( ncid ) use modglobal , only : xf , xh , dy , zf , zh , jmax use modmpi , only : myid implicit none integer , intent ( in ) :: ncid integer :: i = 0 , iret , length , varid write ( * , * ) 'writestat_dims_nc' iret = nf90_inq_varid ( ncid , 'xt' , VarID ) if ( iret == 0 ) iret = nf90_inquire_dimension ( ncid , xtID , len = length ) !if (iret==0) iret = nf90_put_var(ncid, varID, zf(1:length),(/1/)) if ( iret == 0 ) iret = nf90_put_var ( ncid , varID , xf ( 1 : length ),( / 1 / )) iret = nf90_inq_varid ( ncid , 'xm' , VarID ) if ( iret == 0 ) iret = nf90_inquire_dimension ( ncid , xmID , len = length ) if ( iret == 0 ) iret = nf90_put_var ( ncid , varID , xh ( 1 : length ),( / 1 / )) iret = nf90_inq_varid ( ncid , 'yt' , VarID ) if ( iret == 0 ) iret = nf90_inquire_dimension ( ncid , ytID , len = length ) if ( iret == 0 ) iret = nf90_put_var ( ncid , varID , ( / ( dy * ( 0.5 + i ) + myid * jmax * dy , i = 0 , length - 1 ) / ),( / 1 / )) iret = nf90_inq_varid ( ncid , 'ym' , VarID ) if ( iret == 0 ) iret = nf90_inquire_dimension ( ncid , ymID , len = length ) if ( iret == 0 ) iret = nf90_put_var ( ncid , varID , ( / ( dy * i + myid * jmax * dy , i = 0 , length - 1 ) / ),( / 1 / )) iret = nf90_inq_varid ( ncid , 'zt' , VarID ) if ( iret == 0 ) iret = nf90_inquire_dimension ( ncid , ztID , len = length ) if ( iret == 0 ) iret = nf90_put_var ( ncid , varID , zf ( 0 : length - 1 ),( / 1 / )) !ils13, 29.06.2017 zf starts at 0, not at 1 iret = nf90_inq_varid ( ncid , 'zm' , VarID ) if ( iret == 0 ) iret = nf90_inquire_dimension ( ncid , zmID , len = length ) if ( iret == 0 ) iret = nf90_put_var ( ncid , varID , zh ( 0 : length - 1 ),( / 1 / )) !same for zh !if (isurf==1) then !iret = nf90_inq_varid(ncid, 'zts', VarID) !if (iret==0) iret = nf90_inquire_dimension(ncid, ztsID, len=length) !if (iret==0) iret = nf90_put_var(ncid, varID, zsoilc(1:length),(/1/)) !end if end subroutine writestat_dims_nc subroutine writestat_time_nc ( ncid , nvar , ncname , vars , nrec , lraise ) implicit none integer , intent ( in ) :: ncid , nvar integer , intent ( inout ) :: nrec real , dimension ( nvar ), intent ( in ) :: vars character ( * ), dimension (:,:), intent ( in ) :: ncname logical , intent ( in ) :: lraise integer :: iret , n , varid !write(*,*) 'time-nc' if ( lraise ) then nrec = nrec + 1 end if do n = 1 , nvar iret = nf90_inq_varid ( ncid , ncname ( n , 1 ), VarID ) iret = nf90_put_var ( ncid , VarID , vars ( n ), start = ( / nrec / )) end do iret = nf90_sync ( ncid ) end subroutine writestat_time_nc subroutine writestat_1D_nc ( ncid , nvar , ncname , vars , nrec , dim1 ) implicit none integer , intent ( in ) :: ncid , nvar , dim1 integer , intent ( in ) :: nrec real , dimension ( dim1 , nvar ), intent ( in ) :: vars character ( * ), dimension (:,:), intent ( in ) :: ncname integer :: iret , n , varid do n = 1 , nvar iret = nf90_inq_varid ( ncid , ncname ( n , 1 ), VarID ) iret = nf90_put_var ( ncid , VarID , vars ( 1 : dim1 , n ),( / 1 , nrec / ),( / dim1 , 1 / )) end do iret = nf90_sync ( ncid ) end subroutine writestat_1D_nc subroutine writestat_2D_nc ( ncid , nvar , ncname , vars , nrec , dim1 , dim2 ) implicit none integer , intent ( in ) :: ncid , nvar , dim1 , dim2 integer , intent ( in ) :: nrec real , dimension (:,:,:), intent ( in ) :: vars character ( * ), dimension (:,:), intent ( in ) :: ncname integer :: iret , n , varid do n = 1 , nvar iret = nf90_inq_varid ( ncid , ncname ( n , 1 ), VarID ) iret = nf90_put_var ( ncid , VarID , vars ( 1 : dim1 , 1 : dim2 , n ),( / 1 , 1 , nrec / ),( / dim1 , dim2 , 1 / )) end do iret = nf90_sync ( ncid ) end subroutine writestat_2D_nc subroutine writestat_3D_nc ( ncid , nvar , ncname , vars , nrec , dim1 , dim2 , dim3 ) implicit none integer , intent ( in ) :: ncid , nvar , dim1 , dim2 , dim3 integer , intent ( in ) :: nrec real , dimension ( dim1 , dim2 , dim3 , nvar ), intent ( in ) :: vars character ( * ), dimension (:,:), intent ( in ) :: ncname integer :: iret , n , varid !write(*,*) 'write 3Dnc' do n = 1 , nvar iret = nf90_inq_varid ( ncid , ncname ( n , 1 ), VarID ) !write(*,*) 'MYID,.', myid !write(*,*) \"nth netcdf variable\",n !write(*,*) 'ncid',ncid !write(*,*) \"n\",n !write(*,*) 'ncname(n,1)',ncname(n,1) !write(*,*) 'VarID',VarID !write(*,*) 'nrec',nrec !write(*,*) 'imax',dim1 !write(*,*) 'jmax',dim2 !write(*,*) 'kmax',dim3 !write(*,*) 'shape(vars)',shape(vars) iret = nf90_put_var ( ncid , VarID , vars ( 1 : dim1 , 1 : dim2 , 1 : dim3 , n ),( / 1 , 1 , 1 , nrec / ),( / dim1 , dim2 , dim3 , 1 / )) end do iret = nf90_sync ( ncid ) end subroutine writestat_3D_nc subroutine writestat_3D_short_nc ( ncid , nvar , ncname , vars , nrec , dim1 , dim2 , dim3 ) implicit none integer , intent ( in ) :: ncid , nvar , dim1 , dim2 , dim3 integer , intent ( in ) :: nrec integer ( KIND = selected_int_kind ( 4 )), dimension ( dim1 , dim2 , dim3 , nvar ), intent ( in ) :: vars character ( * ), dimension (:,:), intent ( in ) :: ncname integer :: iret , n , varid !write(*,*) '3Dnc short' do n = 1 , nvar iret = nf90_inq_varid ( ncid , ncname ( n , 1 ), VarID ) iret = nf90_put_var ( ncid , VarID , vars ( 1 : dim1 , 1 : dim2 , 1 : dim3 , n ),( / 1 , 1 , 1 , nrec / ),( / dim1 , dim2 , dim3 , 1 / )) end do iret = nf90_sync ( ncid ) end subroutine writestat_3D_short_nc subroutine ncinfo ( out , in1 , in2 , in3 , in4 ) implicit none character ( * ), dimension ( 4 ), intent ( out ) :: out character ( * ), intent ( in ) :: in1 , in2 , in3 , in4 out ( 1 ) = in1 out ( 2 ) = in2 out ( 3 ) = in3 out ( 4 ) = in4 end subroutine ncinfo subroutine nchandle_error ( status ) use netcdf implicit none integer , intent ( in ) :: status if ( status /= nf90_noerr ) then write ( 0 , * ) trim ( nf90_strerror ( status )) write ( 0 , * ) 'ERROR: status' , status stop 1 end if end subroutine nchandle_error end module modstat_nc","tags":"","loc":"sourcefile/modstat_nc.f90.html"},{"title":"modsurfdata.f90 – uDALES","text":"Files dependent on this one sourcefile~~modsurfdata.f90~~AfferentGraph sourcefile~modsurfdata.f90 modsurfdata.f90 sourcefile~modinlet.f90 modinlet.f90 sourcefile~modinlet.f90->sourcefile~modsurfdata.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~modinlet.f90->sourcefile~modsave.f90 sourcefile~modibm.f90 modibm.f90 sourcefile~modibm.f90->sourcefile~modsurfdata.f90 sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~modsubgrid.f90->sourcefile~modsurfdata.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~modsubgrid.f90->sourcefile~modboundary.f90 sourcefile~modfielddump.f90 modfielddump.f90 sourcefile~modfielddump.f90->sourcefile~modsurfdata.f90 sourcefile~modthermodynamics.f90 modthermodynamics.f90 sourcefile~modthermodynamics.f90->sourcefile~modsurfdata.f90 sourcefile~modstatistics.f90 modstatistics.f90 sourcefile~modstatistics.f90->sourcefile~modsurfdata.f90 sourcefile~modboundary.f90->sourcefile~modsurfdata.f90 sourcefile~modboundary.f90->sourcefile~modinlet.f90 sourcefile~moddriver.f90 moddriver.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~modsave.f90->sourcefile~modsurfdata.f90 sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~modstatsdump.f90->sourcefile~modsurfdata.f90 sourcefile~modstatsdump.f90->sourcefile~modsubgrid.f90 sourcefile~modstatsdump.f90->sourcefile~modstatistics.f90 sourcefile~modforces.f90 modforces.f90 sourcefile~modforces.f90->sourcefile~modsurfdata.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~modstartup.f90->sourcefile~modsurfdata.f90 sourcefile~modstartup.f90->sourcefile~modinlet.f90 sourcefile~modstartup.f90->sourcefile~modsubgrid.f90 sourcefile~modstartup.f90->sourcefile~modthermodynamics.f90 sourcefile~modstartup.f90->sourcefile~modboundary.f90 sourcefile~modstartup.f90->sourcefile~modforces.f90 sourcefile~modpois.f90 modpois.f90 sourcefile~modstartup.f90->sourcefile~modpois.f90 sourcefile~modstartup.f90->sourcefile~moddriver.f90 sourcefile~modpois.f90->sourcefile~modboundary.f90 sourcefile~advec_2nd.f90 advec_2nd.f90 sourcefile~advec_2nd.f90->sourcefile~modibm.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modibm.f90 sourcefile~program.f90->sourcefile~modsubgrid.f90 sourcefile~program.f90->sourcefile~modfielddump.f90 sourcefile~program.f90->sourcefile~modthermodynamics.f90 sourcefile~program.f90->sourcefile~modboundary.f90 sourcefile~program.f90->sourcefile~modsave.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 sourcefile~program.f90->sourcefile~modforces.f90 sourcefile~program.f90->sourcefile~modstartup.f90 sourcefile~program.f90->sourcefile~modpois.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules modsurfdata Source Code modsurfdata.f90 Source Code !> \\file modsurfdata.f90 !! Variable definitions and auxilary routines for the surface model !> !! Variable definitions and auxilary routines for surface model !> !! This routine should have no dependency on any other routine, save perhaps modglobal or modfields. !!  \\author Thijs Heus, MPI-M !!  \\todo Documentation !!  \\par Revision list !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! !!whole module should be removed and variables moved module modsurfdata ! implicit none SAVE ! Surface properties real , allocatable :: tskin (:,:) !<  Skin temperature [K] real , allocatable :: qskin (:,:) !<  Skin specific humidity [kg/kg] real :: ps = - 1 !<  Surface pressure [Pa] ! Surface energy balance logical :: lmostlocal = . false . !<  Switch to apply MOST locally to get local Obukhov length real , allocatable :: obl (:,:) !<  Obukhov length [m] real :: oblav = 0.001 !<  Spatially averaged obukhov length [m] real , allocatable :: Cm (:,:) !<  Drag coefficient for momentum [-] real , allocatable :: Cs (:,:) !<  Drag coefficient for scalars [-] real , allocatable :: ustar (:,:) !<  Friction velocity [m/s] real , allocatable :: thlflux (:,:) !<  Kinematic temperature flux [K m/s] real , allocatable :: qtflux (:,:) !<  Kinematic specific humidity flux [kg/kg m/s] real , allocatable :: svflux (:,:,:) !<  Kinematic scalar flux [- m/s] ! Surface gradients of prognostic variables real , allocatable :: dudz (:,:) !<  U-wind gradient in surface layer [1/s] real , allocatable :: dvdz (:,:) !<  V-wind gradient in surface layer [1/s] real , allocatable :: dqtdz (:,:) !<  Specific humidity gradient in surface layer [kg/kg/m] real , allocatable :: dthldz (:,:) !<  Liquid water potential temperature gradient in surface layer [K/m] ! Surface properties in case of prescribed conditions (previous isurf 2, 3 and 4) real :: thls = - 1. !<  Surface liquid water potential temperature [K] real :: thl_top = - 1. !<  Surface liquid water potential temperature [K] at top wall real :: qts = - 1. !<  Surface specific humidity [kg/kg] real :: qt_top = - 1. !<  Top value of specific humidity [kg/kg] real :: thvs = - 1. !<  Surface virtual temperature [K] real , allocatable :: svs (:) !<  Surface scalar concentration [-] real , allocatable :: sv_top (:) ! top scalar concentration concentrations real :: z0 = - 1. !<  Surface roughness length [m] real :: z0h = - 1. !<  Surface roughness for heat [m] ! prescribed surface fluxes real :: Cmav !<  Average drag coefficient for momentum [-] real :: Csav !<  Average drag coefficient for scalars [-] real :: horvel !<  Average horizontal velocity at first level real :: wtsurf = - 1. !<  Prescribed kinematic temperature flux [K m/s] real :: wttop = 0. real :: wqtop = 0. real :: wqsurf = - 1. !<  Prescribed kinematic moisture flux [kg/kg m/s] real , allocatable :: wsvsurf (:) !<  Prescribed surface scalar(n) flux [- m/s] real , allocatable :: wsvtop (:) real :: wsvsurfdum ( 1 : 99 ) = 0. !<  Dummy variables as nsv allocated variable real :: wsvtopdum ( 1 : 99 ) = 0. end module modsurfdata","tags":"","loc":"sourcefile/modsurfdata.f90.html"},{"title":"program.f90 – uDALES","text":"This file depends on sourcefile~~program.f90~~EfferentGraph sourcefile~program.f90 program.f90 sourcefile~modpois.f90 modpois.f90 sourcefile~program.f90->sourcefile~modpois.f90 sourcefile~modibm.f90 modibm.f90 sourcefile~program.f90->sourcefile~modibm.f90 sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~program.f90->sourcefile~modsubgrid.f90 sourcefile~modfielddump.f90 modfielddump.f90 sourcefile~program.f90->sourcefile~modfielddump.f90 sourcefile~modstat_nc.f90 modstat_nc.f90 sourcefile~program.f90->sourcefile~modstat_nc.f90 sourcefile~modthermodynamics.f90 modthermodynamics.f90 sourcefile~program.f90->sourcefile~modthermodynamics.f90 sourcefile~modeb.f90 modEB.f90 sourcefile~program.f90->sourcefile~modeb.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~program.f90->sourcefile~initfac.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~program.f90->sourcefile~modboundary.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~program.f90->sourcefile~modsave.f90 sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~program.f90->sourcefile~modglobal.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~program.f90->sourcefile~modmpi.f90 sourcefile~modforces.f90 modforces.f90 sourcefile~program.f90->sourcefile~modforces.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~program.f90->sourcefile~modstartup.f90 sourcefile~modchecksim.f90 modchecksim.f90 sourcefile~program.f90->sourcefile~modchecksim.f90 sourcefile~modpois.f90->sourcefile~modboundary.f90 sourcefile~modpois.f90->sourcefile~modglobal.f90 sourcefile~modpois.f90->sourcefile~modmpi.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modpois.f90->sourcefile~modfields.f90 sourcefile~modibm.f90->sourcefile~initfac.f90 sourcefile~modibm.f90->sourcefile~modglobal.f90 sourcefile~modibm.f90->sourcefile~modmpi.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~modibm.f90->sourcefile~modsubgriddata.f90 sourcefile~modsurfdata.f90 modsurfdata.f90 sourcefile~modibm.f90->sourcefile~modsurfdata.f90 sourcefile~modibm.f90->sourcefile~modfields.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~modibm.f90->sourcefile~modibmdata.f90 sourcefile~modsubgrid.f90->sourcefile~modboundary.f90 sourcefile~modsubgrid.f90->sourcefile~modglobal.f90 sourcefile~modsubgrid.f90->sourcefile~modmpi.f90 sourcefile~modsubgrid.f90->sourcefile~modsubgriddata.f90 sourcefile~modsubgrid.f90->sourcefile~modsurfdata.f90 sourcefile~modinletdata.f90 modinletdata.f90 sourcefile~modsubgrid.f90->sourcefile~modinletdata.f90 sourcefile~modsubgrid.f90->sourcefile~modfields.f90 sourcefile~modfielddump.f90->sourcefile~modstat_nc.f90 sourcefile~modfielddump.f90->sourcefile~modglobal.f90 sourcefile~modfielddump.f90->sourcefile~modmpi.f90 sourcefile~modfielddump.f90->sourcefile~modsurfdata.f90 sourcefile~modfielddump.f90->sourcefile~modfields.f90 sourcefile~modstat_nc.f90->sourcefile~modglobal.f90 sourcefile~modstat_nc.f90->sourcefile~modmpi.f90 sourcefile~modthermodynamics.f90->sourcefile~modglobal.f90 sourcefile~modthermodynamics.f90->sourcefile~modmpi.f90 sourcefile~modthermodynamics.f90->sourcefile~modsurfdata.f90 sourcefile~modthermodynamics.f90->sourcefile~modfields.f90 sourcefile~modeb.f90->sourcefile~modstat_nc.f90 sourcefile~modeb.f90->sourcefile~initfac.f90 sourcefile~modeb.f90->sourcefile~modglobal.f90 sourcefile~modeb.f90->sourcefile~modmpi.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 sourcefile~modboundary.f90->sourcefile~modglobal.f90 sourcefile~modboundary.f90->sourcefile~modmpi.f90 sourcefile~modboundary.f90->sourcefile~modsubgriddata.f90 sourcefile~modinlet.f90 modinlet.f90 sourcefile~modboundary.f90->sourcefile~modinlet.f90 sourcefile~modboundary.f90->sourcefile~modsurfdata.f90 sourcefile~modboundary.f90->sourcefile~modinletdata.f90 sourcefile~modboundary.f90->sourcefile~modfields.f90 sourcefile~moddriver.f90 moddriver.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~modsave.f90->sourcefile~initfac.f90 sourcefile~modsave.f90->sourcefile~modglobal.f90 sourcefile~modsave.f90->sourcefile~modmpi.f90 sourcefile~modsave.f90->sourcefile~modsubgriddata.f90 sourcefile~modsave.f90->sourcefile~modsurfdata.f90 sourcefile~modsave.f90->sourcefile~modinletdata.f90 sourcefile~modsave.f90->sourcefile~modfields.f90 sourcefile~modsave.f90->sourcefile~modibmdata.f90 sourcefile~modstatsdump.f90->sourcefile~modsubgrid.f90 sourcefile~modstatsdump.f90->sourcefile~modstat_nc.f90 sourcefile~modstatsdump.f90->sourcefile~modglobal.f90 sourcefile~modstatsdump.f90->sourcefile~modmpi.f90 sourcefile~modstatsdump.f90->sourcefile~modsurfdata.f90 sourcefile~modstatistics.f90 modstatistics.f90 sourcefile~modstatsdump.f90->sourcefile~modstatistics.f90 sourcefile~modstatsdump.f90->sourcefile~modfields.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 sourcefile~modforces.f90->sourcefile~modglobal.f90 sourcefile~modforces.f90->sourcefile~modmpi.f90 sourcefile~modforces.f90->sourcefile~modsurfdata.f90 sourcefile~modforces.f90->sourcefile~modfields.f90 sourcefile~modforces.f90->sourcefile~modibmdata.f90 sourcefile~modstartup.f90->sourcefile~modpois.f90 sourcefile~modstartup.f90->sourcefile~modsubgrid.f90 sourcefile~modstartup.f90->sourcefile~modthermodynamics.f90 sourcefile~modstartup.f90->sourcefile~modboundary.f90 sourcefile~modstartup.f90->sourcefile~modglobal.f90 sourcefile~modstartup.f90->sourcefile~modmpi.f90 sourcefile~modstartup.f90->sourcefile~modforces.f90 sourcefile~modstartup.f90->sourcefile~modsubgriddata.f90 sourcefile~modstartup.f90->sourcefile~modinlet.f90 sourcefile~modstartup.f90->sourcefile~modsurfdata.f90 sourcefile~modstartup.f90->sourcefile~modinletdata.f90 sourcefile~modstartup.f90->sourcefile~modfields.f90 sourcefile~modstartup.f90->sourcefile~moddriver.f90 sourcefile~modstartup.f90->sourcefile~modibmdata.f90 sourcefile~modchecksim.f90->sourcefile~modglobal.f90 sourcefile~modchecksim.f90->sourcefile~modmpi.f90 sourcefile~modchecksim.f90->sourcefile~modsubgriddata.f90 sourcefile~modchecksim.f90->sourcefile~modfields.f90 sourcefile~modinlet.f90->sourcefile~modsave.f90 sourcefile~modinlet.f90->sourcefile~modglobal.f90 sourcefile~modinlet.f90->sourcefile~modmpi.f90 sourcefile~modinlet.f90->sourcefile~modsurfdata.f90 sourcefile~modinlet.f90->sourcefile~modinletdata.f90 sourcefile~modinlet.f90->sourcefile~modfields.f90 sourcefile~modstatistics.f90->sourcefile~modstat_nc.f90 sourcefile~modstatistics.f90->sourcefile~modglobal.f90 sourcefile~modstatistics.f90->sourcefile~modmpi.f90 sourcefile~modstatistics.f90->sourcefile~modsubgriddata.f90 sourcefile~modstatistics.f90->sourcefile~modsurfdata.f90 sourcefile~modstatistics.f90->sourcefile~modfields.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~moddriver.f90->sourcefile~modglobal.f90 sourcefile~moddriver.f90->sourcefile~modmpi.f90 sourcefile~moddriver.f90->sourcefile~modinletdata.f90 sourcefile~moddriver.f90->sourcefile~modfields.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs DALESURBAN Source Code program.f90 Source Code !> \\file program.f90 !! Main program !> !! \\mainpage !! Dutch Atmospheric Large Eddy Simulation -URBAN !! \\section DALES Dutch Atmospheric Large Eddy Simulation -URBAN !! !! @version 48 !! ! !! \\todo !! !! \\section License License !!  This file is part of DALESURBAN. !!  Copyright 1993-2014 Delft University of Technology !! program DALESURBAN !Version 48 !!---------------------------------------------------------------- !!     0.0    USE STATEMENTS FOR CORE MODULES !!---------------------------------------------------------------- use modmpi , only : myid , initmpi use modglobal , only : rk3step , timeleft , ib , jb , kb , ke use modstartup , only : startup , exitmodules use modsave , only : writerestartfiles use modboundary , only : boundary , grwdamp , tqaver use modthermodynamics , only : thermodynamics !  use modsurface,        only : surface use modsubgrid , only : subgrid use modforces , only : forces , coriolis , lstend , fixuinf1 , fixuinf2 , fixthetainf , nudge , masscorr use modpois , only : poisson use modibm , only : createwalls , ibmwallfun , ibmnorm , nearwall , bottom use initfac , only : readfacetfiles use modEB , only : initEB , EB !---------------------------------------------------------------- !     0.1     USE STATEMENTS FOR ADDONS STATISTICAL ROUTINES !---------------------------------------------------------------- use modchecksim , only : initchecksim , checksim use modstat_nc , only : initstat_nc use modfielddump , only : initfielddump , fielddump , exitfielddump use modstatsdump , only : initstatsdump , statsdump , exitstatsdump !tg3315 !use modbudget,       only : initbudget, budgetstat, exitbudget implicit none !---------------------------------------------------------------- !     1      READ NAMELISTS,INITIALISE GRID, CONSTANTS AND FIELDS !---------------------------------------------------------------- call initmpi write ( * , * ) \"done initmpi\" call startup write ( * , * ) \"done startup\" !--------------------------------------------------------- !      2     INITIALIZE STATISTICAL ROUTINES AND ADD-ONS !--------------------------------------------------------- call initchecksim call initstat_nc call initfielddump call initstatsdump !tg3315 call readfacetfiles call initEB write ( * , * ) \"done init stuff\" write ( 6 , * ) 'Determine immersed walls' call createwalls ! determine walls/blocks ! call nearwall       ! determine minimum distance and corresponding shear components, ils13 10.07.17, commented, not functional at the moment, not needed for vreman but for smag., fix in modibm write ( 6 , * ) 'Finished determining immersed walls' call boundary !ils13 22.06.2017 inserted boundary here to get values at ghost cells before iteration starts !  not necessary but abates the fact that temp field is randomised by randomisation of just velocity fields !  (because advection at start of time loop without being divergence free) !  call poisson !------------------------------------------------------ !   3.0   MAIN TIME LOOP !------------------------------------------------------ write ( * , * ) 'START myid ' , myid do while (( timeleft > 0 ) . or . ( rk3step < 3 )) call tstep_update !----------------------------------------------------- !   3.2   ADVECTION AND DIFFUSION !----------------------------------------------------- call advection ! now also includes predicted pressure gradient term call subgrid !----------------------------------------------------- !   3.3   THE SURFACE LAYER !----------------------------------------------------- call bottom !----------------------------------------------------- !   3.4   REMAINING TERMS !----------------------------------------------------- call coriolis !remaining terms of ns equation call forces !remaining terms of ns equation call lstend !large scale forcings call nudge ! nudge top cells of fields to enforce steady-state call ibmwallfun ! immersed boundary forcing: only shear forces. call masscorr ! correct pred. velocity pup to get correct mass flow call ibmnorm ! immersed boundary forcing: set normal velocities to zero call EB call scalsource ! adds continuous forces in specified region of domain !------------------------------------------------------ !   3.4   EXECUTE ADD ONS !------------------------------------------------------ call fixuinf2 call fixuinf1 !----------------------------------------------------------------------- !   3.5  PRESSURE FLUCTUATIONS, TIME INTEGRATION AND BOUNDARY CONDITIONS !----------------------------------------------------------------------- call grwdamp !damping at top of the model call poisson call tstep_integrate call boundary call fixthetainf !----------------------------------------------------- !   3.6   LIQUID WATER CONTENT AND DIAGNOSTIC FIELDS !----------------------------------------------------- call thermodynamics !----------------------------------------------------- !   3.7  WRITE RESTARTFILES AND DO STATISTICS !------------------------------------------------------ call checksim ! call writedatafiles   ! write data files for later analysis call writerestartfiles call fielddump call statsdump ! tg3315 end do !------------------------------------------------------- !             END OF TIME LOOP !------------------------------------------------------- !-------------------------------------------------------- !    4    FINALIZE ADD ONS AND THE MAIN PROGRAM !------------------------------------------------------- call exitfielddump call exitstatsdump !tg3315 call exitmodules end program DALESURBAN","tags":"","loc":"sourcefile/program.f90.html"},{"title":"initfac.f90 – uDALES","text":"This file depends on sourcefile~~initfac.f90~~EfferentGraph sourcefile~initfac.f90 initfac.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~initfac.f90~~AfferentGraph sourcefile~initfac.f90 initfac.f90 sourcefile~modibm.f90 modibm.f90 sourcefile~modibm.f90->sourcefile~initfac.f90 sourcefile~wf_gr.f90 wf_gr.f90 sourcefile~wf_gr.f90->sourcefile~initfac.f90 sourcefile~wf_uno.f90 wf_uno.f90 sourcefile~wf_uno.f90->sourcefile~initfac.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~initfac.f90 sourcefile~program.f90->sourcefile~modibm.f90 sourcefile~modeb.f90 modEB.f90 sourcefile~program.f90->sourcefile~modeb.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~program.f90->sourcefile~modsave.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~program.f90->sourcefile~modboundary.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~program.f90->sourcefile~modstartup.f90 sourcefile~modpois.f90 modpois.f90 sourcefile~program.f90->sourcefile~modpois.f90 sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~program.f90->sourcefile~modsubgrid.f90 sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 sourcefile~wfmneutral.f90 wfmneutral.f90 sourcefile~wfmneutral.f90->sourcefile~initfac.f90 sourcefile~advec_2nd.f90 advec_2nd.f90 sourcefile~advec_2nd.f90->sourcefile~initfac.f90 sourcefile~advec_2nd.f90->sourcefile~modibm.f90 sourcefile~modeb.f90->sourcefile~initfac.f90 sourcefile~modsave.f90->sourcefile~initfac.f90 sourcefile~scalsource.f90 scalsource.f90 sourcefile~scalsource.f90->sourcefile~initfac.f90 sourcefile~moddriver.f90 moddriver.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~modinlet.f90 modinlet.f90 sourcefile~modinlet.f90->sourcefile~modsave.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~modboundary.f90->sourcefile~modinlet.f90 sourcefile~modstartup.f90->sourcefile~moddriver.f90 sourcefile~modstartup.f90->sourcefile~modinlet.f90 sourcefile~modstartup.f90->sourcefile~modboundary.f90 sourcefile~modstartup.f90->sourcefile~modpois.f90 sourcefile~modstartup.f90->sourcefile~modsubgrid.f90 sourcefile~modpois.f90->sourcefile~modboundary.f90 sourcefile~modsubgrid.f90->sourcefile~modboundary.f90 sourcefile~modstatsdump.f90->sourcefile~modsubgrid.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules initfac Source Code initfac.f90 Source Code !!> \\file b2f.f90 !!  \\author Ivo Suter ! !   reads the necessary input files to deal with facets ! !   WARNING: if walls with more than 3 layers (4 points) are to be considered, this file needs to be changed !            e.g. walltypes needs to read 7+4*nlayers columns, offsets in reading facet properties also change accordingly module initfac use modglobal , only : ifinput , nblocks , nfcts , cexpnr , libm , bldT , rsmin , wsoil , wfc ,& nwalllayers , block , lEB use modmpi , only : myid , comm3d , mpierr , MPI_INTEGER , MPI_DOUBLE_PRECISION , MY_REAL , nprocs , cmyid , MPI_REAL8 , MPI_REAL4 , MPI_SUM , mpi_logical use netcdf implicit none public :: readfacetfiles , qsat , dqsatdT save !integer, allocatable :: block(:, :) !block coordinates and facet Nr corresponding to block faces !facet properties logical , allocatable :: faclGR (:) !logic array, is it a green (vegetated) facet? real , allocatable :: facz0 (:) !roughness for momentum on facets real , allocatable :: facz0h (:) !roughness for heat and moisture on facets real , allocatable :: facalb (:) !facet shortwave albedo real , allocatable :: facem (:) !facet longwave emissivity of all 5 faces of the blocks real , allocatable :: facdi (:, :) !inverse facet thickness real , allocatable :: facd (:,:) !facet thickness real , allocatable :: faccp (:, :) !facet specific heat capacity real , allocatable :: faclami (:, :) !inverse facet heat conductivity real , allocatable :: fackappa (:, :) !facet heat diffusivity (lambda/(rho cp)) real , allocatable :: faca (:) !facet area integer , allocatable :: facain (:) !facet area as sum of indeces integer , allocatable :: facets (:, :) !facet orientation, walltype, block and building Nr real , allocatable :: walltypes (:, :) !the defined wall and rooftypes with properties !radiation real , allocatable :: vf (:, :) !viewfactors between facets real , allocatable :: svf (:) !sky-viewfactor of facets real , allocatable :: netsw (:) !net shortwave radiation on facets real , allocatable :: facLWin (:) !incoming longwave on facets [W/m2] !temperature real , allocatable :: Tfacinit (:) !initial facet temperatures real , allocatable :: facT (:, :) !wall temperatures on surfaces and between layers (1=outdoors,end=indoors) real , allocatable :: facTdash (:, :) !temperature gradient dT/dz !fluxes real , allocatable :: facef (:) !evaporative flux on facets [W/m2] (single processor) real , allocatable :: facefi (:) !time integrated latent heat flux [J/m2] (used in modEB) real , allocatable :: facefsum (:) !evaporative flux on facets [W/m2] (sum over all processors) real , allocatable :: fachf (:) !heat flux on facets [Km/s] (single processor) real , allocatable :: fachfi (:) !time integrated heat flux [Km] real , allocatable :: fachfsum (:) !heat flux on facets [Km/s] (sum over all processors) !GR real , allocatable :: facf (:, :) !dependence of stomatal resistance/soil resistance real , allocatable :: fachurel (:) !relative humidity at ground surface real , allocatable :: facwsoil (:) !soil moisture of facets real , allocatable :: faccth (:) !sum of all transfer coefficients of the facet, used in Penman Moneith, unused real , allocatable :: facqsat (:) !saturation absoulute humidity at facet temperature !misc integer , allocatable :: typeloc (:) !array to match the walltype to sequential integers for indexing integer :: nwalltypes = 0 !number of different walltypes, will be determined automatically character ( 80 ) :: chmess !dummy character string integer :: nwallprops contains subroutine readfacetfiles use modglobal , only : block , cexpnr , iwalltemp implicit none !use modglobal, only:block !read initial&unchangeable facet values from files !read blocks and facet Nr corresponding to block faces (Order: Top, West, East, North, South) !define facets with properties and initial temperature !read facets.inp.xxx facetarea.inp.xxx vf.inp.xxx walltypes.inp.xxx !read netsw.inp.xxx (if sun is not constant, K needs to be calculated at every EB-timestep) !read tfacinit.inp.xxx !use modglobal, only : nblocks, nfcts, cexpnr, ifinput character ( len = 13 ) :: FILE_VF = 'vf.nc.inp.xxx' integer :: ncid , varid integer :: n = 0 , m = 0 , i = 0 , j = 0 , k = 0 , io = 0 integer :: iret if (. not .( nfcts > 0 )) return nwallprops = 6 + 4 * nwalllayers + 1 !allocate (block(nblocks, 11)) allocate ( faclGR ( 0 : nfcts )) allocate ( facz0 ( 0 : nfcts )) !0 is the default value (e.g. for internal walls) allocate ( facz0h ( 0 : nfcts )) allocate ( facalb ( 0 : nfcts )) allocate ( facem ( 0 : nfcts )) allocate ( facdi ( 0 : nfcts , nwalllayers )) allocate ( facd ( 0 : nfcts , nwalllayers )) allocate ( faccp ( 0 : nfcts , nwalllayers )) allocate ( faclami ( 0 : nfcts , nwalllayers )) allocate ( fackappa ( 0 : nfcts , nwalllayers + 1 )) allocate ( faca ( 0 : nfcts )) allocate ( facain ( 0 : nfcts )) allocate ( facets ( nfcts , 4 )) if ( lEB . eqv . . true .) then allocate ( vf ( 1 : nfcts , 1 : nfcts )) allocate ( svf ( 1 : nfcts )) allocate ( netsw ( 1 : nfcts )) allocate ( facLWin ( 1 : nfcts )) end if allocate ( Tfacinit ( 1 : nfcts )) allocate ( facT ( 0 : nfcts , nwalllayers + 1 )) allocate ( facTdash ( 1 : nfcts , nwalllayers + 1 )) allocate ( facef ( 1 : nfcts )) allocate ( facefi ( 1 : nfcts )) allocate ( facefsum ( 1 : nfcts )) allocate ( fachf ( 0 : nfcts )) allocate ( fachfi ( 0 : nfcts )) allocate ( fachfsum ( 1 : nfcts )) allocate ( facf ( 0 : nfcts , 5 )) allocate ( fachurel ( 0 : nfcts )) allocate ( facwsoil ( 0 : nfcts )) allocate ( faccth ( 0 : nfcts )) allocate ( facqsat ( 0 : nfcts )) !block = 0; faclGR = . false .; facz0 = 0. ; facz0h = 0. ; facalb = 0. ; facem = 0. ; facd = 0. ; facdi = 0. ; faccp = 0. faclami = 0. ; fackappa = 0. ; faca = 0. ; facain = 0 ; facets = 0 if ( lEB . eqv . . true .) then vf = 0. ; svf = 0. ; netsw = 0. ; facLWin = 0. end if Tfacinit = 0. ; facT = 0. ; facTdash = 0. facef = 0. ; facefi = 0. ; facefsum = 0. ; fachf = 0. ; fachfi = 0. ; fachfsum = 0. facf = 0. ; fachurel = 0. ; facwsoil = 0. ; faccth = 0. ; facqsat = 0. ; if ( myid == 0 . and . libm ) then ! read blocks corner coordinates and facet-Nr correspoinding to the block sides !   open (ifinput, file='blocks.inp.'//cexpnr) !   read (ifinput, '(a80)') chmess !   read (ifinput, '(a80)') chmess !   do n = 1, nblocks !     blockfile is :ilow iheigh jlow jheigh klow kheigh facTop facWest facEast facNorth facSouth !     read (ifinput, *) & !         block(n, 1), & !         block(n, 2), & !         block(n, 3), & !         block(n, 4), & !         block(n, 5), & !         block(n, 6), & !         block(n, 7), & !         block(n, 8), & !         block(n, 9), & !         block(n, 10), & !         block(n, 11) !   end do !   close (ifinput) if ( lEB ) then ! read facet areas open ( ifinput , file = 'facetarea.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess do n = 1 , nfcts read ( ifinput , * ) & faca ( n ) end do close ( ifinput ) write ( * , * ) \"faca\" , faca end if !lEB ! read wall & (green) roof types ! read once to determine number of types, allocate, read again nwalltypes = - 3 !3 lines as headers open ( ifinput , file = 'walltypes.inp.' // cexpnr ) do read ( ifinput , * , iostat = io ) if ( io /= 0 ) exit nwalltypes = nwalltypes + 1 end do close ( ifinput ) end if !(myid == 0 .and. libm) call MPI_BCAST ( nwalltypes , 1 , MPI_Integer , 0 , comm3d , mpierr ) allocate ( walltypes ( 1 : nwalltypes , nwallprops )) if ( myid == 0 ) then walltypes = 0. open ( ifinput , file = 'walltypes.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do n = 1 , nwalltypes read ( ifinput , * ) ( walltypes ( n , m ), m = 1 , nwallprops ) end do close ( ifinput ) end if !myid==0 call MPI_BCAST ( nwalltypes , 1 , MPI_Integer , 0 , comm3d , mpierr ) call MPI_BCAST ( walltypes , nwallprops * nwalltypes , MY_REAL , 0 , comm3d , mpierr ) !create an array mapping walltypes to sequential integers for indexing !e.g. lets assume walltype -3,-1,1,2,3 and 5 are defined. !index: [-3,-2,-1,0,1,2,3,4,5]  -> [-3,-2,-1,0,1,2,3,4,5] !value: [ 0, 0, 0,0,0,0,0,0,0]  -> [ 1, 0, 2,0,3,4,5,0,6] allocate ( typeloc ( int ( minval ( walltypes (:, 1 ))): int ( maxval ( walltypes (:, 1 ))))) if ( myid . eq . 0 ) then !all the read processes just need to be done on one processor typeloc = 0 do n = 1 , nwalltypes typeloc ( int ( walltypes ( n , 1 ))) = n end do ! read the facets open ( ifinput , file = 'facets.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess !orientation, walltype, block in block.inp, original block/building do n = 1 , nfcts read ( ifinput , * ) & facets ( n , 1 ), & facets ( n , 2 ), & facets ( n , 3 ), & facets ( n , 4 ) end do close ( ifinput ) ! calculate the number of indeces per facet in both dimensions (~area) do n = 1 , nfcts if ( facets ( n , 1 ) . eq . 1 ) then facain ( n ) = ( block ( facets ( n , 3 ), 2 ) - block ( facets ( n , 3 ), 1 ) + 1 ) * ( block ( facets ( n , 3 ), 4 ) - block ( facets ( n , 3 ), 3 ) + 1 ) else if ( facets ( n , 1 ) . eq . 2 ) then facain ( n ) = ( block ( facets ( n , 3 ), 6 ) - block ( facets ( n , 3 ), 5 ) + 1 ) * ( block ( facets ( n , 3 ), 4 ) - block ( facets ( n , 3 ), 3 ) + 1 ) else if ( facets ( n , 1 ) . eq . 3 ) then facain ( n ) = ( block ( facets ( n , 3 ), 6 ) - block ( facets ( n , 3 ), 5 ) + 1 ) * ( block ( facets ( n , 3 ), 4 ) - block ( facets ( n , 3 ), 3 ) + 1 ) else if ( facets ( n , 1 ) . eq . 4 ) then facain ( n ) = ( block ( facets ( n , 3 ), 2 ) - block ( facets ( n , 3 ), 1 ) + 1 ) * ( block ( facets ( n , 3 ), 6 ) - block ( facets ( n , 3 ), 5 ) + 1 ) else if ( facets ( n , 1 ) . eq . 5 ) then facain ( n ) = ( block ( facets ( n , 3 ), 2 ) - block ( facets ( n , 3 ), 1 ) + 1 ) * ( block ( facets ( n , 3 ), 6 ) - block ( facets ( n , 3 ), 5 ) + 1 ) end if end do ! assign the facet properties to their own arrays do n = 1 , nfcts i = typeloc ( facets ( n , 2 )) faclGR ( n ) = ( abs ( walltypes ( i , 2 ) - 1.00 ) < 1.0D-5 ) !logic for green surface, conversion from real to logical facz0 ( n ) = walltypes ( i , 3 ) !surface momentum roughness facz0h ( n ) = walltypes ( i , 4 ) !surface heat & moisture roughness facalb ( n ) = walltypes ( i , 5 ) !surface shortwave albedo facem ( n ) = walltypes ( i , 6 ) !surface longwave emissivity if ( facets ( n , 2 ) . lt . - 100 ) then !it's a bounding wall do j = 1 , nwalllayers !bounding walls don't need properties facdi ( n , j ) = 0. !bounding walls have no energy balance facd ( n , j ) = 0. !bounding walls have no thickness faclami ( n , j ) = 0. !bounding walls have no energy balance faccp ( n , j ) = 0. !bounding walls have no heat capacity end do else do j = 1 , nwalllayers !for all layers facdi ( n , j ) = 1 / walltypes ( i , j + 6 ) !inverse of facet thickness of layer j facd ( n , j ) = walltypes ( i , j + 6 ) !facet thickness of layer j faclami ( n , j ) = 1 / walltypes ( i , j + 12 ) !inverse of heat conductivity of layer j faccp ( n , j ) = walltypes ( i , j + 9 ) !specific heat capacity of layer j end do end if do j = 1 , nwalllayers + 1 fackappa ( n , j ) = walltypes ( i , j + 15 ) !heat duffusivity of layer 1 end do end do !give some dummy values for block internal facets (i.e. facets with walltype 0) facz0 ( 0 ) = 0.00999 ; facz0h ( 0 ) = 0.00999 ; facalb ( 0 ) = 0.999 ; facem ( 0 ) = 0.999 ; facd ( 0 , 1 ) = 0.999 ; facd ( 0 , 2 ) = 0.999 ; facdi ( 0 , 1 ) = 0.999 ; facdi ( 0 , 2 ) = 0.999 ; facdi ( 0 , 3 ) = 0.999 ; faccp ( 0 , 1 ) = 99 9. ; faccp ( 0 , 2 ) = 99 9. faccp ( 0 , 3 ) = 99 9. ; faclami ( 0 , 1 ) = 0.999 ; faclami ( 0 , 2 ) = 0.999 ; faclami ( 0 , 3 ) = 0.999 ; fackappa ( 0 , 1 ) = 0.00000999 ; fackappa ( 0 , 2 ) = 0.00000999 ; fackappa ( 0 , 3 ) = 0.00000999 ; faclGR ( 0 ) = . false . if ( lEB ) then ! read viewfactors between facets ! Open the file. NF90_NOWRITE tells netCDF we want read-only access to ! the file. FILE_VF = 'vf.nc.inp.' // cexpnr iret = nf90_open ( FILE_VF , NF90_NOWRITE , ncid ) ! Get the varid of the data variable, based on its name. iret = nf90_inq_varid ( ncid , \"view factor\" , varid ) ! Read the data. iret = nf90_get_var ( ncid , varid , vf ) write ( * , * ) \"vf(1,6),vf(1,7),vf(6,1),vf(7,1)\" , vf ( 1 , 6 ), vf ( 1 , 7 ), vf ( 6 , 1 ), vf ( 7 , 1 ) ! read skyviewfactors open ( ifinput , file = 'svf.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess do n = 1 , nfcts read ( ifinput , * ) & svf ( n ) end do close ( ifinput ) ! read net shortwave radiation open ( ifinput , file = 'netsw.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess do n = 1 , nfcts read ( ifinput , * ) & netsw ( n ) end do close ( ifinput ) end if !lEB if (( lEB ) . or . ( iwalltemp == 2 )) then ! read initial facet temepratures open ( ifinput , file = 'Tfacinit.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess do n = 1 , nfcts read ( ifinput , * ) & Tfacinit ( n ) end do close ( ifinput ) do n = 1 , nfcts facT ( n , 1 ) = Tfacinit ( n ) !building surfaces is given an initial temperature facT ( n , nwalllayers + 1 ) = bldT !inner most layer has the same temperature as the building interior do j = 2 , nwalllayers facT ( n , j ) = Tfacinit ( n ) - ( Tfacinit ( n ) - bldT ) / nwalllayers * ( j - 1 ) !scale linearly inside the wall end do end do do n = 1 , nwalllayers facT ( 0 , n ) = 28 8. end do facT ( 0 , nwalllayers + 1 ) = 29 9. end if !((lEB) .or. (iwalltemp == 2)) ! assign initial soil moisture (only outermost layer) do n = 1 , nfcts if ( faclGR ( n )) then facwsoil ( n ) = wsoil fachurel ( n ) = 0.5 * ( 1. - cos ( 3.14159 * wsoil / wfc )) end if end do end if !(myid .eq. 0) !write (*, *) \"starting broadcast of facet properties\" call MPI_BCAST ( block , 11 * nblocks , MPI_INTEGER , 0 , comm3d , mpierr ) !many of these are actually only needed on processor 0... call MPI_BCAST ( faclGR ( 0 : nfcts ), nfcts + 1 , mpi_logical , 0 , comm3d , mpierr ) call MPI_BCAST ( facz0 ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facz0h ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facalb ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facem ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facd ( 0 : nfcts , 1 : nwalllayers ),( nfcts + 1 ) * nwalllayers , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facdi ( 0 : nfcts , 1 : nwalllayers ), ( nfcts + 1 ) * nwalllayers , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( faccp ( 0 : nfcts , 1 : nwalllayers ), ( nfcts + 1 ) * nwalllayers , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( faclami ( 0 : nfcts , 1 : nwalllayers ), ( nfcts + 1 ) * nwalllayers , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( fackappa ( 0 : nfcts , 1 : nwalllayers + 1 ), ( nfcts + 1 ) * ( nwalllayers + 1 ), MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( faca ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facain ( 0 : nfcts ), nfcts + 1 , MPI_Integer , 0 , comm3d , mpierr ) call MPI_BCAST ( facets , 4 * nfcts , MPI_Integer , 0 , comm3d , mpierr ) !walltypes is broadcast further up if ( lEB . eqv . . true .) then call MPI_BCAST ( svf ( 1 : nfcts ), nfcts , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( netsw ( 1 : nfcts ), nfcts , MY_REAL , 0 , comm3d , mpierr ) end if !facLWin currently not being broadcast.. !vf currently not being broadcast call MPI_BCAST ( Tfacinit ( 1 : nfcts ), nfcts , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facT ( 0 : nfcts , 1 : nwalllayers + 1 ), ( nfcts + 1 ) * ( nwalllayers + 1 ), MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facTdash ( 1 : nfcts , 1 : nwalllayers + 1 ), ( nfcts ) * ( nwalllayers + 1 ), MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facef ( 1 : nfcts ), nfcts , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facefi ( 1 : nfcts ), nfcts , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facefsum ( 1 : nfcts ), nfcts , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( fachf ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( fachfi ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( fachfsum ( 1 : nfcts ), nfcts , MY_REAL , 0 , comm3d , mpierr ) ! standard plant & soil resistance for grass (Manickathan2018) in s/m facf (:, 4 ) = 20 0. facf (:, 5 ) = 5 0. call MPI_BCAST ( facf ( 0 : nfcts , 1 : 5 ), ( nfcts + 1 ) * 5 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( fachurel ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facwsoil ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( faccth ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) do n = 1 , nfcts facqsat ( n ) = qsat ( facT ( n , 1 )) end do call MPI_BCAST ( facqsat ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) end subroutine readfacetfiles real function qsat ( T ) implicit none real , intent ( in ) :: T real :: gres gres = 61 1.00 * exp ( 1 7.27 * ( T - 27 3.15 ) / ( T - 3 5.85 )) ![Pa] Bolton 1980 qsat = 0.62198 * 0.01 * gres / ( 1000 - 0.01 * gres ) ![kg/kg] Murphy & Koop 2005 !1000 can be replaced with actual air pressure if desired end function qsat real function dqsatdT ( T ) implicit none real , intent ( in ) :: T dqsatdT = 0.1384832710e-2 + 0.7708409674e-4 * ( T - 300 ) + 0.2022064593e-5 * ( T - 300 ) ** 2 + 0.000000036561 * ( T - 300 ) ** 3 !expansion of qsat(T) end function dqsatdt end module initfac","tags":"","loc":"sourcefile/initfac.f90.html"},{"title":"modinlet.f90 – uDALES","text":"This file depends on sourcefile~~modinlet.f90~~EfferentGraph sourcefile~modinlet.f90 modinlet.f90 sourcefile~modsurfdata.f90 modsurfdata.f90 sourcefile~modinlet.f90->sourcefile~modsurfdata.f90 sourcefile~modinletdata.f90 modinletdata.f90 sourcefile~modinlet.f90->sourcefile~modinletdata.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modinlet.f90->sourcefile~modfields.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~modinlet.f90->sourcefile~modsave.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modinlet.f90->sourcefile~modglobal.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modinlet.f90->sourcefile~modmpi.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modsave.f90->sourcefile~modsurfdata.f90 sourcefile~modsave.f90->sourcefile~modinletdata.f90 sourcefile~modsave.f90->sourcefile~modfields.f90 sourcefile~modsave.f90->sourcefile~modglobal.f90 sourcefile~modsave.f90->sourcefile~modmpi.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~modsave.f90->sourcefile~modsubgriddata.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~modsave.f90->sourcefile~modibmdata.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~modsave.f90->sourcefile~initfac.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~modinlet.f90~~AfferentGraph sourcefile~modinlet.f90 modinlet.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~modboundary.f90->sourcefile~modinlet.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~modstartup.f90->sourcefile~modinlet.f90 sourcefile~modstartup.f90->sourcefile~modboundary.f90 sourcefile~modpois.f90 modpois.f90 sourcefile~modstartup.f90->sourcefile~modpois.f90 sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~modstartup.f90->sourcefile~modsubgrid.f90 sourcefile~modpois.f90->sourcefile~modboundary.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modboundary.f90 sourcefile~program.f90->sourcefile~modstartup.f90 sourcefile~program.f90->sourcefile~modpois.f90 sourcefile~program.f90->sourcefile~modsubgrid.f90 sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 sourcefile~modsubgrid.f90->sourcefile~modboundary.f90 sourcefile~modstatsdump.f90->sourcefile~modsubgrid.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules modinlet Source Code modinlet.f90 Source Code !! modinlet.f90 contains the method of Lund (1998) to a generate a turbulent inlet profile. !! The velocity is extracted from a recycle plane, rescaled, and used as inlet condition !! Note that due to the staggered grid arrangement the u-components are recycled from !! cell(irecycl,:,:), while the v- and w- components are read from cell (irecycle-1,:,:). !! This is because the inlet condition is located at i=ib for u, and at i=ib-1 for v and w. !! !! Also the method of Kong (2000) is added to generate a turbulent temperature inlet profile !! !!  \\author Jasper Tomas,TU Delft, June 4th 2015 !!  \\par Revision list !!  \\todo Documentation !! module modinlet use modinletdata implicit none save public :: initinlet , exitinlet , momentumthickness , blthickness , dispthickness , writeinletfile , readinletfile , enthalpythickness , inletgen , inletgennotemp , zinterpolate1d , zinterpolatew1d , zinterpolatet1d , zinterpolate2d , blthicknesst , momentumthicknessexp , dispthicknessexp contains subroutine initinlet use modglobal , only : ih , ib , ie , jh , jb , je , kb , ke , kh , iinletgen , iplane , xf , lstoreplane , nstore , Uinf , ltempeq , pi , zf , zh use modfields , only : um use modmpi , only : myid , nprocs implicit none real :: pfi , epsi integer :: k if ( iinletgen == 1 ) then allocate ( Utav ( ib : ie , kb : ke )) allocate ( Uinl ( kb : ke )) allocate ( Winl ( kb : ke + 1 )) allocate ( Urec ( kb : ke )) allocate ( Wrec ( kb : ke + 1 )) allocate ( u0inletbc ( jb : je , kb : ke )) allocate ( v0inletbc ( jb : je , kb : ke )) allocate ( w0inletbc ( jb : je , kb : ke + 1 )) allocate ( u0inletbcold ( jb : je , kb : ke )) allocate ( v0inletbcold ( jb : je , kb : ke )) allocate ( w0inletbcold ( jb : je , kb : ke + 1 )) allocate ( uminletbc ( jb : je , kb : ke )) allocate ( vminletbc ( jb : je , kb : ke )) allocate ( wminletbc ( jb : je , kb : ke + 1 )) allocate ( uaver ( ib : ie , kb : ke )) allocate ( zirf ( kb : ke )) allocate ( ziif ( kb : ke )) allocate ( zirh ( kb : ke + 1 )) allocate ( ziih ( kb : ke + 1 )) allocate ( zorf ( kb : ke )) allocate ( zoif ( kb : ke )) allocate ( zorh ( kb : ke + 1 )) allocate ( zoih ( kb : ke + 1 )) allocate ( loclowif ( kb : ke )) allocate ( locupif ( kb : ke )) allocate ( loclowih ( kb : ke + 1 )) allocate ( locupih ( kb : ke + 1 )) allocate ( loclowof ( kb : ke )) allocate ( locupof ( kb : ke )) allocate ( loclowoh ( kb : ke + 1 )) allocate ( locupoh ( kb : ke + 1 )) allocate ( displ ( ib : ie )) allocate ( displold ( ib : ie )) allocate ( upupavinl ( kb : ke )) allocate ( vpvpavinl ( kb : ke )) allocate ( wpwpavinl ( kb : ke )) allocate ( upwpavinl ( kb : ke )) allocate ( thlpthlpavinl ( kb : ke )) allocate ( thlpupavinl ( kb : ke )) allocate ( thlpwpavinl ( kb : ke )) allocate ( heavif ( kb : ke )) allocate ( heavih ( kb : ke + 1 )) if ( lstoreplane ) then allocate ( storeu0inletbc ( jb : je , kb : ke , 1 : nstore )) allocate ( storev0inletbc ( jb : je , kb : ke , 1 : nstore )) allocate ( storew0inletbc ( jb : je , kb : ke + 1 , 1 : nstore )) end if epsi = 0.25 * di do k = kb , ke pfi = zf ( k ) - 1.2 * di - epsi if ( pfi < - epsi ) then heavif ( k ) = 1. elseif ( pfi <= epsi ) then heavif ( k ) = 0.5 * ( 1. - ( pfi / epsi ) - ( 1. / pi ) * sin ( pi * pfi / epsi )) elseif ( pfi > epsi ) then heavif ( k ) = 0. end if end do do k = kb , ke + 1 pfi = zh ( k ) - 1.2 * di - epsi if ( pfi < - epsi ) then heavih ( k ) = 1. elseif ( pfi <= epsi ) then heavih ( k ) = 0.5 * ( 1. - ( pfi / epsi ) - ( 1. / pi ) * sin ( pi * pfi / epsi )) elseif ( pfi > epsi ) then heavih ( k ) = 0. end if end do if ( ltempeq ) then allocate ( Ttav ( ib : ie , kb : ke )) allocate ( taver ( ib : ie , kb : ke )) allocate ( Tinl ( kb : ke )) allocate ( Trec ( kb : ke )) allocate ( t0inletbc ( jb : je , kb : ke )) allocate ( t0inletbcold ( jb : je , kb : ke )) allocate ( tminletbc ( jb : je , kb : ke )) allocate ( zotr ( kb : ke )) allocate ( zoti ( kb : ke )) allocate ( loclowot ( kb : ke )) allocate ( locupot ( kb : ke )) allocate ( heavit ( kb : ke )) if ( lstoreplane ) then allocate ( storet0inletbc ( jb : je , kb : ke , 1 : nstore )) end if ! Heaviside function for temperature epsi = 0.25 * dti do k = kb , ke pfi = zf ( k ) - 1.2 * dti - epsi if ( pfi < - epsi ) then heavit ( k ) = 1. elseif ( pfi <= epsi ) then heavit ( k ) = 0.5 * ( 1. - ( pfi / epsi ) - ( 1. / pi ) * sin ( pi * pfi / epsi )) elseif ( pfi > epsi ) then heavit ( k ) = 0. end if end do end if displ = 0. displold = 0. irecy = ib + iplane ! index of recycle plane equals iplane (read from namoptions) xfm = sum ( xf ( ib : ie )) / ( ie - ib + 1 ) ! mean(xf) xf2m = sum ( xf ( ib : ie ) ** 2. ) / ( ie - ib + 1 ) ! mean(xf&#94;2) !  btime = timee                              ! this is done to make sure btime is set when avint is computed correctly at startup (only for RA) else if ( iinletgen == 2 ) then allocate ( storeu0inletbc ( jb : je , kb : ke , 1 : nstore )) allocate ( storev0inletbc ( jb : je , kb : ke , 1 : nstore )) allocate ( storew0inletbc ( jb : je , kb : ke + 1 , 1 : nstore )) allocate ( u0rot ( 1 : nstore , jb - jh : je + jh , kb : ke )) allocate ( v0rot ( 1 : nstore , jb - jh : je + jh , kb : ke )) allocate ( u0inletbc ( jb : je , kb : ke )) allocate ( v0inletbc ( jb : je , kb : ke )) allocate ( w0inletbc ( jb : je , kb : ke + 1 )) allocate ( u0inletbcold ( jb : je , kb : ke )) allocate ( v0inletbcold ( jb : je , kb : ke )) allocate ( w0inletbcold ( jb : je , kb : ke + 1 )) allocate ( uminletbc ( jb : je , kb : ke )) allocate ( vminletbc ( jb : je , kb : ke )) allocate ( wminletbc ( jb : je , kb : ke + 1 )) if ( ltempeq ) then allocate ( storet0inletbc ( jb : je , kb : ke , 1 : nstore )) allocate ( t0inletbc ( jb : je , kb : ke )) allocate ( t0inletbcold ( jb : je , kb : ke )) allocate ( tminletbc ( jb : je , kb : ke )) end if !iangle = iangledeg * pi / 180.  ! convert degrees to radians irecy = ib + iplane ! read coordinates of inletprofile call readzincoord !    ddispdx      = 0.00038/Uinf        ! this value should becomputed from the w0 computed in the inletgenerator ddispdx = wtop / Uinf ! wtop is read from zgrid.inf ddispdxold = ddispdx ! this value should becomputed from the w0 computed in the inletgenerator !    inlfactor    = nprocs/nprocsinl     ! nprocs should be larger or equal to nprocsin! !    write(6,*) 'inlfactor= ',inlfactor else return end if end subroutine initinlet subroutine inletgen use modglobal , only : ib , ie , jb , je , jgb , jge , kb , ke , zf , zh , dzf , dzhi , timee , btime , totavtime , rk3step , dt , numol , iplane , lles , iinletgen , inletav , runavtime , Uinf , lwallfunc , linletRA , totinletav , lstoreplane , nstore , prandtlmoli , numol , grav , lbuoyancy , lfixinlet , luvolflowr , lfixutauin use modfields , only : u0 , v0 , w0 , thl0 , wm , uprof use modsurfdata , only : thls , thl_top use modsave , only : writerestartfiles use modmpi , only : slabsum , myid implicit none real , dimension ( ib : ib , jb : je , kb : ke ) :: uinletbc2 ! dummy variable real , dimension ( ib : ib , jb : je , kb : ke ) :: tinletbc2 ! dummy variable real , dimension ( jb : je , kb : ke ) :: uprec ! velocity fluctuation (up_rec = u0 - Urec) real , dimension ( jb : je , kb : ke ) :: vprec ! velocity fluctuation (vp_rec = v0 - 0) real , dimension ( jb : je , kb : ke + 1 ) :: wprec ! velocity fluctuation (wp_rec = w0 - Wrec) real , dimension ( jb : je , kb : ke ) :: tprec ! temperature fluctuation (tp_rec = t0 - Trec) real , dimension ( jb : je , kb : ke ) :: upinli , vpinli ! = gamma * (uprec,v interpolated to zii grid) real , dimension ( jb : je , kb : ke ) :: tpinli ! = lambda  * (tprec   interpolated to zii grid) real , dimension ( jb : je , kb : ke ) :: upinlo , vpinlo ! = gamma * (uprec,v interpolated to zoi grid) real , dimension ( jb : je , kb : ke ) :: tpinlo ! = lambda  * (tprec   interpolated to zoti grid) real , dimension ( jb : je , kb : ke + 1 ) :: wpinli ! = gamma * (wprec   interpolated to zii grid) real , dimension ( jb : je , kb : ke + 1 ) :: wpinlo ! = gamma * (wprec   interpolated to zoi grid) real , dimension ( kb : ke ) :: udiff ! difference between Uinl and Urec !    real,dimension(kb:ke)   :: Urecdiff                ! difference between Urec new and old real , dimension ( kb : ke ) :: urav ! j-averaged u-velocity (not time-averaged) real , dimension ( kb : ke ) :: trav ! j-averaged temperature (not time-averaged) real , dimension ( kb : ke ) :: uravdzf ! j-averaged u-velocity (not time-averaged) times dzf real , dimension ( kb : ke ) :: uinldzf ! j-averaged u-velocity (not time-averaged) times dzf real , dimension ( kb : ke ) :: Urecdzf ! Urec times dzf real , dimension ( kb : ke + 1 ) :: wrav ! j-averaged w-velocity (not time-averaged) real , dimension ( kb : ke ) :: Uinli ! = gamma * (Urec interpolated to ziif grid points) real , dimension ( kb : ke + 1 ) :: Winli ! = gamma * (Wrec interpolated to ziih grid points) real , dimension ( kb : ke ) :: Tinli ! = lambda  * (Trec interpolated to ziif grid points) real , dimension ( kb : ke ) :: Uinlo ! = gamma * (Urec interpolated to zioif grid points) real , dimension ( kb : ke + 1 ) :: Winlo ! = gamma * (Wrec interpolated to zoih grid points) real , dimension ( kb : ke ) :: Tinlo ! = lambda  * (Trec interpolated to zoti grid points) real , dimension ( kb : ke ) :: wfuncf ! weight function at full level real , dimension ( kb : ke + 1 ) :: wfunch ! weight function at half level real , dimension ( kb : ke ) :: wfunct ! weight function at full level real :: utaur2 , utaui2 ! (utau)&#94;2 at recycle station and inlet real :: gamm ! utaui / utaur real :: lamb ! ttaui / ttaur real :: avint , avinti ! avering interval real :: alpha , beta ! factors used in the Weight function !    real                    :: totalu                  ! total u-velocity at outlet real :: Urectot ! total u-velocity at recycle plane real :: rk3coef !    real                    :: di_test                 ! BL thickness as measured from Uinl real :: utop ! j-averaged top velocity real :: interval real :: dtinrk ! RK time step in inlet data real :: rk3coefin ! Cumulative RK time step in inlet data real :: dr_old real :: scalef ! scale factor to scale instantaneous velocity profile with to get constant mass flux real :: totaluinl ! bulk velocity at the inlet !    real                    :: q0                      ! heat flux integer i , j , k , kk , kdamp if ( iinletgen == 1 ) then u0inletbcold = u0inletbc v0inletbcold = v0inletbc w0inletbcold = w0inletbc t0inletbcold = t0inletbc ! temperature totaluold = totalu displold = displ ddispdxold = ddispdx ! compute time-average velocities rk3coef = dt / ( 4. - dble ( rk3step )) if ( rk3step == 1 ) then deltat = rk3coef elseif ( rk3step == 2 ) then deltat = rk3coef - ( dt / 3. ) elseif ( rk3step == 3 ) then deltat = rk3coef - ( dt / 2. ) end if if ( linletRA ) then ! this is a switch to use 'running average' avint = totinletav + timee - btime ! runav interval = averaging interval previuous sim  + current elapsed sim time else avint = inletav end if avinti = 1. / avint uaver = 0. taver = 0. do i = ib , ie call slabsum ( uaver ( i ,:), kb , ke , u0 ( i : i , jb : je , kb : ke ), i , i , jb , je , kb , ke , i , i , jb , je , kb , ke ) call slabsum ( taver ( i ,:), kb , ke , thl0 ( i : i , jb : je , kb : ke ), i , i , jb , je , kb , ke , i , i , jb , je , kb , ke ) end do wrav = 0. call slabsum ( wrav ( kb : ke + 1 ), kb , ke , w0 ( irecy - 1 : irecy - 1 , jb : je , kb : ke + 1 ), irecy - 1 , irecy - 1 , jb , je , kb , ke + 1 , irecy - 1 , irecy - 1 , jb , je , kb , ke + 1 ) trav = 0. call slabsum ( trav ( kb : ke ), kb , ke , thl0 ( irecy - 1 : irecy - 1 , jb : je , kb : ke ), irecy - 1 , irecy - 1 , jb , je , kb , ke , irecy - 1 , irecy - 1 , jb , je , kb , ke ) uaver = uaver / ( jge - jgb + 1 ) ! average over j-direction taver = taver / ( jge - jgb + 1 ) ! average over j-direction urav = uaver ( irecy ,:) wrav = wrav / ( jge - jgb + 1 ) ! average over j-direction trav = trav / ( jge - jgb + 1 ) ! average over j-direction do k = kb , ke Urec ( k ) = urav ( k ) * deltat * avinti + ( 1. - deltat * avinti ) * Urec ( k ) Trec ( k ) = trav ( k ) * deltat * avinti + ( 1. - deltat * avinti ) * Trec ( k ) end do do k = kb , ke + 1 Wrec ( k ) = wrav ( k ) * deltat * avinti + ( 1. - deltat * avinti ) * Wrec ( k ) end do do k = kb , ke do i = ib , ie Utav ( i , k ) = uaver ( i , k ) * deltat * avinti + ( 1. - deltat * avinti ) * Utav ( i , k ) Ttav ( i , k ) = taver ( i , k ) * deltat * avinti + ( 1. - deltat * avinti ) * Ttav ( i , k ) end do end do !    Urec = Urec +(Uinf-Urec(ke))     ! make sure at the recycle plane the top velocity equals Uinf !    Urecdiff = Urecdiff - Urec !    if (myid==0) then !      write(6,*) 'Urec_old - Urec_new (kb+40)=',Urecdiff(kb+40) !    end if !! check if Urec contains NaN !    if (myid==0) then !      write(6,*) 'Checking Urec for NaN' !      do k=kb,ke !        if (ISNAN(Urec(k))) then !          write(6,*) 'Urec(k)=NaN at k=kb+', k-kb !        end if !      end do !      write(6,*) 'Finished checking Urec for NaN' !    end if !    if (myid==0) then !      write(6,*) 'myid, Urec(ke)=',myid, Urec(ke) !      write(6,*) 'wrav(ke), Wrec(ke)=',wrav(ke), Wrec(ke) !      write(6,*) 'wrav(ke-1), Wrec(ke-1)=',wrav(ke-1), Wrec(ke-1) !      write(6,*) 'wrav(ke-10), Wrec(ke-10)=',wrav(ke-10), Wrec(ke-10) !      write(6,*) 'wrav(ke-30), Wrec(ke-30)=',wrav(ke-30), Wrec(ke-30) !      write(6,*) 'wrav(kb+10), Wrec(kb+10)=',wrav(kb+10), Wrec(kb+10) !      write(6,*) 'wrav(kb+11), Wrec(kb+11)=',wrav(kb+11), Wrec(kb+11) !    end if ! compute velocity fluctuation at recycle station do k = kb , ke do j = jb , je uprec ( j , k ) = u0 ( irecy , j , k ) - Urec ( k ) vprec ( j , k ) = v0 ( irecy - 1 , j , k ) ! mean v is zero tprec ( j , k ) = thl0 ( irecy - 1 , j , k ) - Trec ( k ) end do end do do k = kb , ke + 1 do j = jb , je wprec ( j , k ) = w0 ( irecy - 1 , j , k ) - Wrec ( k ) ! note that w-velocity is taken at i=irecy-1 !! end do end do if ( lwallfunc ) then call wallawinlet ( Urec ( kb ), dzf ( kb ), numol , utaur2 ) ! compute wall shear stress at recycle station else utaur2 = 2. * numol * Urec ( kb ) / dzf ( kb ) end if utaur = sqrt ( abs ( utaur2 )) ! compute utau at recycle station ! heat flux at recycle station (isothermal wall) q = alpha * dT/dz = (nu/prandtl) * dT/dz !    q0 = numol*prandtlmoli*(Trec(kb) - Trec(kb-1)) * dzhi(kb) q0 = numol * prandtlmoli * 2 * ( Trec ( kb ) - thls ) / dzf ( kb ) ttaur = q0 / utaur ! ttau = q/(rho*cp*utau) =  (alpha *dT/dz) / utau ! compute momentum thickness at inlet and recycle plane if ( lbuoyancy ) then lmor = ( thls * utaur ** 2 ) / ( 0.41 * grav * ttaur ) ! L = -T0*utau&#94;3 / kappa*g*<w'T'> = !     write(6,*) 'Initial dr,myid, utaur, ttaur, Lmor =', dr,myid,utaur,ttaur,lmor !     lmor = 0.3; lmoi = ( thls * utaui ** 2 ) / ( 0.41 * grav * ttaui ) ! L = -T0*utau&#94;3 / kappa*g*<w'T'> = !     lmoi = 0.3; !     write(6,*) 'Initial di_test,myid, utaui, ttaui, Lmoi =', di_test,myid,utaui,ttaui,lmoi dr_old = dr !     call blthicknessmo(dr,utaur,lmor)                    ! Also needed for momentumthickness call blthicknesst ( dr , Urec , 0.99 ) ! changed back to this one (instead of the above) !     call momentumthicknessmo(thetai,utaui,di,lmoi) !     call momentumthicknessmo(thetar,utaur,dr,lmor) call momentumthicknessexp ( thetai , Uinl ) call momentumthicknessexp ( thetar , Urec ) else !     call blthickness(dr,utaur)                           ! Also needed for momentumthickness call blthicknesst ( dr , Urec , 0.99 ) !     call momentumthickness(thetai,utaui,di) !     call momentumthickness(thetar,utaur,dr) call momentumthicknessexp ( thetai , Uinl ) call momentumthicknessexp ( thetar , Urec ) end if call enthalpythickness ( thetati , Tinl , Uinl ) call enthalpythickness ( thetatr , Trec , Urec ) !   call blthickness(dr,utaur) call blthicknesst ( dtr , Trec - thls , 0.99 ) ! compute utau at inlet from interior field !    if (thetai == 0.) then !      write(6,*) '!!! thetai = 0, myid=',myid !    else if (thetar == 0.) then !      write(6,*) '!!! thetar = 0, myid=',myid !      thetar=0.00001 !    else !      utaui = utaur* (thetar/thetai)**(1./8.)    ! See Lund (1998): 'Similar to Ludwig-Tillmann correlation' if (. not . lfixutauin ) then utaui = utaur * abs ( thetar / thetai ) ** ( 1. / 8. ) ! See Lund (1998): 'Similar to Ludwig-Tillmann correlation' end if if ( thetati == 0. ) then thetati = 0.0000001 end if ttaui = ttaur * abs ( thetatr / thetati ) ** ( 1. / 8. ) ! See Kong (2000): !    end if gamm = utaui / utaur ! Gamma in Lund (1998) if ( ttaur == 0. ) then ttaur = 0.0000001 end if lamb = ttaui / ttaur ! Lambda in Kong (2000) ! compute inner scaling coordinates zirf = utaur * zf / numol ! inner scaling zf-coordinate at recycle station zirh = utaur * zh / numol ! inner scaling zh-coordinate at recycle station ziif = utaui * zf / numol ! inner scaling zf-coordinate at inlet station ziih = utaui * zh / numol ! inner scaling zh-coordinate at inlet station ! compute outer scaling coordinates zorf = zf / dr ! outer scaling zf-coor as measured from Uinldinate at recycle station zorh = zh / dr ! outer scaling zh-coordinate at recycle station zoif = zf / di ! outer scaling zf-coordinate at inlet station  (could be done once, actually..) zoih = zh / di ! outer scaling zf-coordinate at inlet station  (could be done once, actually..) zotr = zf / dtr ! temperature outer scaling zf-coordinate at recycle station zoti = zf / dti ! temperature outer scaling zf-coordinate at inlet station !!!!! Interpolation starts here !!! First inner coordinates ! determine which elements are needed when recycle velocity profile is interpolated on inlet plane ! for u(,v)-components (zf) do k = kb , ke do kk = kb , ke if ( zirf ( kk ) >= ziif ( k )) then locupif ( k ) = kk loclowif ( k ) = kk - 1 exit elseif ( kk == ke ) then locupif ( k ) = ke + 1 ! this means extrapolation! loclowif ( k ) = ke - 1 ! waarom niet ke? of wordt dit niet gebruikt? end if end do end do ! for w-components (zh) do k = kb , ke + 1 do kk = kb , ke + 1 if ( zirh ( kk ) >= ziih ( k )) then locupih ( k ) = kk loclowih ( k ) = kk - 1 exit elseif ( kk == ke + 1 ) then locupih ( k ) = ke + 2 ! this means extrapolation! loclowih ( k ) = ke end if end do end do !!! Finished with inner coordinates !!! Do the same trick for outer coordinates ! determine which elements are needed when recycle velocity profile is interpolated on inlet plane ! for u(,v)-components (zf) do k = kb , ke do kk = kb , ke if ( zorf ( kk ) >= zoif ( k )) then locupof ( k ) = kk loclowof ( k ) = kk - 1 exit elseif ( kk == ke ) then locupof ( k ) = ke + 1 ! this means extrapolation! loclowof ( k ) = ke - 1 end if end do end do ! for w-components (zh) do k = kb , ke + 1 do kk = kb , ke + 1 if ( zorh ( kk ) >= zoih ( k )) then locupoh ( k ) = kk loclowoh ( k ) = kk - 1 exit elseif ( kk == ke + 1 ) then locupoh ( k ) = ke + 2 ! this means extrapolation! loclowoh ( k ) = ke end if end do end do !!! Finished with outer coordinates !!! Outer coordinates for temperature do k = kb , ke do kk = kb , ke if ( zotr ( kk ) >= zoti ( k )) then locupot ( k ) = kk loclowot ( k ) = kk - 1 exit elseif ( kk == ke ) then locupot ( k ) = ke + 1 ! this means extrapolation! loclowot ( k ) = ke - 1 end if end do end do !!! Finished with outer coordinates temperature !!! Now really interpolate !!! First inner coordinates ! compute Urec on zii grid do k = kb , ke if ( locupif ( k ) == ke + 1 ) then ! indicator for extrapolation! !        Uinli(k) = Urec(ke) + (Urec(ke) - Urec(ke-1)) / (zirf(ke)-zirf(ke-1)) * (ziif(k)-zirf(ke)) Uinli ( k ) = Urec ( ke ) Tinli ( k ) = Trec ( ke ) elseif ( loclowif ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) Uinli ( k ) = Urec ( kb ) / zirf ( kb ) * ziif ( k ) !        Tinli(k) = thls + Trec(kb)/zirf(kb)*ziif(k) !        Tinli(k) = (Trec(kb)-thls)/zirf(kb)*ziif(k) Tinli ( k ) = thls + ( Trec ( kb ) - thls ) / zirf ( kb ) * ziif ( k ) else ! normal interpolation Uinli ( k ) = Urec ( loclowif ( k )) + ( Urec ( locupif ( k )) - Urec ( loclowif ( k ))) / ( zirf ( locupif ( k )) - zirf ( loclowif ( k ))) * ( ziif ( k ) - zirf ( loclowif ( k ))) Tinli ( k ) = Trec ( loclowif ( k )) + ( Trec ( locupif ( k )) - Trec ( loclowif ( k ))) / ( zirf ( locupif ( k )) - zirf ( loclowif ( k ))) * ( ziif ( k ) - zirf ( loclowif ( k ))) if (( ziif ( k ) . gt . zirf ( locupif ( k ))) . or . ( ziif ( k ) . lt . zirf ( loclowif ( k )))) then write ( 6 , * ) '!!!Mistake in Interpolation !!!!' end if end if end do ! compute Wrec on zii grid Winli ( kb ) = 0.0 ! corresponds to ground level do k = kb + 1 , ke + 1 if ( locupih ( k ) == ke + 2 ) then ! indicator for extrapolation! !        Winli(k) = Wrec(ke+1) + (Wrec(ke+1) - Wrec(ke)) / (zirh(ke+1)-zirh(ke)) * (ziih(k)-zirh(ke+1)) Winli ( k ) = Wrec ( ke + 1 ) else ! normal interpolation Winli ( k ) = Wrec ( loclowih ( k )) + ( Wrec ( locupih ( k )) - Wrec ( loclowih ( k ))) / ( zirh ( locupih ( k )) - zirh ( loclowih ( k ))) * ( ziih ( k ) - zirh ( loclowih ( k ))) end if end do ! compute u- and v- and t-fluctuation on zii grid do k = kb , ke if ( locupif ( k ) == ke + 1 ) then ! indicator for extrapolation! !        upinli(:,k) = uprec(:,ke) + (uprec(:,ke) - uprec(:,ke-1)) / (zirf(ke)-zirf(ke-1)) * (ziif(k)-zirf(ke)) upinli (:, k ) = 0. vpinli (:, k ) = 0. tpinli (:, k ) = 0. elseif ( loclowif ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) upinli (:, k ) = uprec (:, kb ) / zirf ( kb ) * ziif ( k ) vpinli (:, k ) = vprec (:, kb ) / zirf ( kb ) * ziif ( k ) tpinli (:, k ) = tprec (:, kb ) / zirf ( kb ) * ziif ( k ) else ! normal interpolation upinli (:, k ) = uprec (:, loclowif ( k )) + ( uprec (:, locupif ( k )) - uprec (:, loclowif ( k ))) / ( zirf ( locupif ( k )) - zirf ( loclowif ( k ))) * ( ziif ( k ) - zirf ( loclowif ( k ))) vpinli (:, k ) = vprec (:, loclowif ( k )) + ( vprec (:, locupif ( k )) - vprec (:, loclowif ( k ))) / ( zirf ( locupif ( k )) - zirf ( loclowif ( k ))) * ( ziif ( k ) - zirf ( loclowif ( k ))) tpinli (:, k ) = tprec (:, loclowif ( k )) + ( tprec (:, locupif ( k )) - tprec (:, loclowif ( k ))) / ( zirf ( locupif ( k )) - zirf ( loclowif ( k ))) * ( ziif ( k ) - zirf ( loclowif ( k ))) end if end do ! compute w-fluctuation on zii grid do k = kb + 1 , ke + 1 !      if (locupih(k) == ke+1) then      ! indicator for extrapolation! if ( locupih ( k ) == ke + 2 ) then ! indicator for extrapolation! !        wpinli(:,k) = wprec(:,ke+1) + (wprec(:,ke+1) - wprec(:,ke)) / (zirh(ke+1)-zirh(ke)) * (ziih(k)-zirh(ke+1)) wpinli (:, k ) = 0. else ! normal interpolation wpinli (:, k ) = wprec (:, loclowih ( k )) + ( wprec (:, locupih ( k )) - wprec (:, loclowih ( k ))) / ( zirh ( locupih ( k )) - zirh ( loclowih ( k ))) * ( ziih ( k ) - zirh ( loclowih ( k ))) end if end do !! Finished with interpolating inner variables !! Continue with interpolating outer variables ! compute Urec on zoi grid do k = kb , ke if ( locupof ( k ) == ke + 1 ) then ! indicator for extrapolation! !        Uinlo(k) = Urec(ke) + (Urec(ke) - Urec(ke-1)) / (zorf(ke)-zorf(ke-1)) * (zoif(k)-zorf(ke)) !        Uinlo(k) = Urec(ke) Uinlo ( k ) = Uinf elseif ( loclowof ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) Uinlo ( k ) = Urec ( kb ) / zorf ( kb ) * zoif ( k ) else ! normal interpolation Uinlo ( k ) = Urec ( loclowof ( k )) + ( Urec ( locupof ( k )) - Urec ( loclowof ( k ))) / ( zorf ( locupof ( k )) - zorf ( loclowof ( k ))) * ( zoif ( k ) - zorf ( loclowof ( k ))) end if end do ! compute Wrec on zii grid Winlo ( kb ) = 0.0 ! corresponds to ground level do k = kb + 1 , ke + 1 if ( locupoh ( k ) == ke + 2 ) then ! indicator for extrapolation! !        Winlo(k) = Wrec(ke+1) + (Wrec(ke+1) - Wrec(ke)) / (zorh(ke+1)-zorh(ke)) * (zoih(k)-zorh(ke+1)) Winlo ( k ) = Wrec ( ke + 1 ) else ! normal interpolation Winlo ( k ) = Wrec ( loclowoh ( k )) + ( Wrec ( locupoh ( k )) - Wrec ( loclowoh ( k ))) / ( zorh ( locupoh ( k )) - zorh ( loclowoh ( k ))) * ( zoih ( k ) - zorh ( loclowoh ( k ))) end if end do ! compute u- and v-fluctuation on zoi grid do k = kb , ke if ( locupof ( k ) == ke + 1 ) then ! indicator for extrapolation! !        upinlo(:,k) = uprec(:,ke) + (uprec(:,ke) - uprec(:,ke-1)) / (zorf(ke)-zorf(ke-1)) * (zoif(k)-zorf(ke)) upinlo (:, k ) = 0. vpinlo (:, k ) = 0. elseif ( loclowof ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) upinlo (:, k ) = uprec (:, kb ) / zorf ( kb ) * zoif ( k ) vpinlo (:, k ) = vprec (:, kb ) / zorf ( kb ) * zoif ( k ) else ! normal interpolation upinlo (:, k ) = uprec (:, loclowof ( k )) + ( uprec (:, locupof ( k )) - uprec (:, loclowof ( k ))) / ( zorf ( locupof ( k )) - zorf ( loclowof ( k ))) * ( zoif ( k ) - zorf ( loclowof ( k ))) vpinlo (:, k ) = vprec (:, loclowof ( k )) + ( vprec (:, locupof ( k )) - vprec (:, loclowof ( k ))) / ( zorf ( locupof ( k )) - zorf ( loclowof ( k ))) * ( zoif ( k ) - zorf ( loclowof ( k ))) end if end do ! compute w-fluctuation on zoi grid do k = kb + 1 , ke + 1 if ( locupoh ( k ) == ke + 2 ) then ! indicator for extrapolation! !        wpinlo(:,k) = wprec(:,ke+1) + (wprec(:,ke+1) - wprec(:,ke)) / (zorh(ke+1)-zorh(ke)) * (zoih(k)-zorh(ke+1)) wpinlo (:, k ) = 0. else ! normal interpolation wpinlo (:, k ) = wprec (:, loclowoh ( k )) + ( wprec (:, locupoh ( k )) - wprec (:, loclowoh ( k ))) / ( zorh ( locupoh ( k )) - zorh ( loclowoh ( k ))) * ( zoih ( k ) - zorh ( loclowoh ( k ))) end if end do !! Finished interpolating outer velocity variables !! Interpolating outer temperature ! mean temperature do k = kb , ke if ( locupot ( k ) == ke + 1 ) then ! indicator for extrapolation! Tinlo ( k ) = thl_top elseif ( loclowot ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use Tinlo=thls at z+=0) !        Tinlo(k) = Trec(kb)/zotr(kb) * zoti(k) !        Tinlo(k) = (Trec(kb)-thls)/zotr(kb) * zoti(k) Tinlo ( k ) = thls + ( Trec ( kb ) - thls ) / zotr ( kb ) * zoti ( k ) else ! normal interpolation Tinlo ( k ) = Trec ( loclowot ( k )) + ( Trec ( locupot ( k )) - Trec ( loclowot ( k ))) / ( zotr ( locupot ( k )) - zotr ( loclowot ( k ))) * ( zoti ( k ) - zotr ( loclowot ( k ))) end if end do ! fluctuating temperature do k = kb , ke if ( locupot ( k ) == ke + 1 ) then ! indicator for extrapolation! !        upinlo(:,k) = uprec(:,ke) + (uprec(:,ke) - uprec(:,ke-1)) / (zorf(ke)-zorf(ke-1)) * (zoif(k)-zorf(ke)) tpinlo (:, k ) = 0. elseif ( loclowot ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use t=0 at z+=0) tpinlo (:, k ) = tprec (:, kb ) / zotr ( kb ) * zoti ( k ) else ! normal interpolation tpinlo (:, k ) = tprec (:, loclowot ( k )) + ( tprec (:, locupot ( k )) - tprec (:, loclowot ( k ))) / ( zotr ( locupot ( k )) - zotr ( loclowot ( k ))) * ( zoti ( k ) - zotr ( loclowot ( k ))) end if end do !! Finished interpolating out temperature !!!!! Finished Interpolation! !!!!! ! compute rescaled inner variables ! Winli = Winli (interpolation is enough) Uinli = gamm * Uinli Tinli = lamb * Tinli + ( 1. - lamb ) * thls ! this is different for isoflux wall! upinli = gamm * upinli vpinli = gamm * vpinli wpinli = gamm * wpinli tpinli = lamb * tpinli ! See Kong (2000) ! compute rescaled outer variables ! Winlo = Winlo (interpolation is enough) Uinlo = gamm * Uinlo + ( 1. - gamm ) * Uinf Tinlo = lamb * Tinlo + ( 1. - lamb ) * thl_top !    Uinlo = gamm* Uinlo  + (1.- gamm)*Urec(ke) upinlo = gamm * upinlo vpinlo = gamm * vpinlo wpinlo = gamm * wpinlo tpinlo = lamb * tpinlo ! See Kong (2000) !    utop = Uinlo(ke) !    Uinlo = Uinlo +(Uinf-utop)     ! make sure at the inlet the mean top velocity equals Uinf !! add defect velocity to make sure the j-averaged velocity at the top equals Uinf !    utop = Uinlo(ke) !    do k=kb,ke !        Uinlo(k) = Uinlo(k)*Uinf/utop !    end do ! Compute weight function (alpha=4, b=0.2) alpha = 4. beta = 0.2 wfuncf = 0.5 * ( 1. + tanh ( alpha * ( zoif - beta ) / (( 1. - 2. * beta ) * zoif + beta ) ) / tanh ( alpha ) ) ! for full level height wfunch = 0.5 * ( 1. + tanh ( alpha * ( zoih - beta ) / (( 1. - 2. * beta ) * zoih + beta ) ) / tanh ( alpha ) ) ! for half level height wfunct = 0.5 * ( 1. + tanh ( alpha * ( zoti - beta ) / (( 1. - 2. * beta ) * zoti + beta ) ) / tanh ( alpha ) ) ! for temperature (full level height) do k = kb , ke if ( wfuncf ( k ) . gt . 1. ) then wfuncf ( k ) = 1. end if if ( wfunct ( k ) . gt . 1. ) then wfunct ( k ) = 1. end if end do do k = kb , ke + 1 if ( wfunch ( k ) . gt . 1. ) then wfunch ( k ) = 1. end if end do !    write(6,*) 'maxval(wfuncf)=', maxval(wfuncf) !    write(6,*) 'maxval(wfunch)=', maxval(wfunch) ! Compute the velocity components for the inlet BC do k = kb , ke do j = jb , je !      u0inletbc(j,k) = (Uinli(k)+ upinli(j,k))*(1.-wfuncf(k)) +  (Uinlo(k) + upinlo(j,k))* wfuncf(k) !      v0inletbc(j,k) =            vpinli(j,k) *(1.-wfuncf(k)) +              vpinlo(j,k) * wfuncf(k) !      t0inletbc(j,k) = (Tinli(k)+ tpinli(j,k))*(1.-wfunct(k)) +  (Tinlo(k) + tpinlo(j,k))* wfunct(k) u0inletbc ( j , k ) = ( Uinli ( k ) + upinli ( j , k ) * heavif ( k )) * ( 1. - wfuncf ( k )) + ( Uinlo ( k ) + upinlo ( j , k ) * heavif ( k )) * wfuncf ( k ) v0inletbc ( j , k ) = vpinli ( j , k ) * heavif ( k ) * ( 1. - wfuncf ( k )) + vpinlo ( j , k ) * heavif ( k ) * wfuncf ( k ) t0inletbc ( j , k ) = ( Tinli ( k ) + tpinli ( j , k ) * heavit ( k )) * ( 1. - wfunct ( k )) + ( Tinlo ( k ) + tpinlo ( j , k ) * heavit ( k )) * wfunct ( k ) end do end do do k = kb , ke + 1 do j = jb , je w0inletbc ( j , k ) = ( Winli ( k ) + wpinli ( j , k ) * heavih ( k )) * ( 1 - wfunch ( k )) + ( Winlo ( k ) + wpinlo ( j , k ) * heavih ( k )) * wfunch ( k ) end do end do w0inletbc (:, kb ) = 0. w0inletbc (:, ke + 1 ) = 0. !!    kdamp = kb + floor(0.75*(ke-kb+1)) !    kdamp = kb + 144  ! => zf = 2.24 !    do k=kdamp,ke !    do j=jb,je !      if (u0inletbc(j,k) > Uinf) then !        u0inletbc(j,k) = Uinf !      end if !    end do !    end do ! Compute j-averaged inlet U  (used for compute thetai) uinletbc2 ( ib , jb : je , kb : ke ) = u0inletbc ( jb : je , kb : ke ) ! this is just a dummy variable to give uninletbc the right dimension in slabsum tinletbc2 ( ib , jb : je , kb : ke ) = t0inletbc ( jb : je , kb : ke ) ! this is just a dummy variable to give tninletbc the right dimension in slabsum urav = 0. trav = 0. call slabsum ( urav , kb , ke , uinletbc2 , ib , ib , jb , je , kb , ke , ib , ib , jb , je , kb , ke ) call slabsum ( trav , kb , ke , tinletbc2 , ib , ib , jb , je , kb , ke , ib , ib , jb , je , kb , ke ) !    call slabsum(urav  ,kb,ke,u0 ,ib-1,ie+1,jb-1,je+1,kb-1,ke+1,ib,ib,jb,je,kb,ke) urav = urav / ( jge - jgb + 1 ) ! average over j-direction trav = trav / ( jge - jgb + 1 ) ! average over j-direction ! determine bulk velocity of new profile do k = kb , ke uravdzf ( k ) = urav ( k ) * dzf ( k ) end do totalu = sum ( uravdzf ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! Area-averaged outflow velocity ! rescale the instantaneous profile to keep mass flux constant (tot avoid pressure fluctuations) if ( luvolflowr ) then do k = kb , ke uinldzf ( k ) = Uinl ( k ) * dzf ( k ) end do totaluinl = sum ( uinldzf ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! Area-averaged inflow velocity scalef = totaluinl / totalu ! compute factor to scale the velocity profile with u0inletbc (:,:) = u0inletbc (:,:) * scalef ! rescale the velocity profile to have constant mass-flux urav (:) = urav (:) * scalef ! also rescale the part that is added to the mean end if !! add defect velocity to make sure the mass flow is the same as the initial mass flow !   u0inletbc = u0inletbc + (ubulk-totalu) !   urav      = urav      + (ubulk-totalu) !! add defect velocity to make sure the j-averaged velocity at the top equals Uinf !    utop = urav(ke) !    do k=kb,ke !      do j=jb,je !        u0inletbc(j,k) = u0inletbc(j,k)*Uinf/utop !      end do !      urav(k) = urav(k)*Uinf/utop !    end do !    u0inletbc = u0inletbc + (Uinf-utop) !    urav      = urav      + (Uinf-utop) !    if (myid==0) then !    write(6,*) 'u0inletbc(jb+2,ke)', u0inletbc !    end if ! Compute j- and time-averaged  inlet U  (used for compute thetai) if (. not . lfixinlet ) then ! only update the average inlet profiles when lfixinlet .eqv..false. do k = kb , ke Uinl ( k ) = urav ( k ) * deltat * avinti + ( 1. - deltat * avinti ) * Uinl ( k ) end do end if do k = kb , ke Tinl ( k ) = trav ( k ) * deltat * avinti + ( 1. - deltat * avinti ) * Tinl ( k ) end do !    utop = Uinl(ke) !    Uinl = Uinl +(Uinf-utop)     ! make sure at the inlet the mean top velocity equals Uinf !    uminletbc = uminletbc + (Uinf-utop) ! write inletplane to array (and to file after 1000 time steps) if ( lstoreplane ) then storeu0inletbc (:,:, nstepread ) = u0inletbc (:,:) storev0inletbc (:,:, nstepread ) = v0inletbc (:,:) storew0inletbc (:,:, nstepread ) = w0inletbc (:,:) storet0inletbc (:,:, nstepread ) = t0inletbc (:,:) nstepread = nstepread + 1 if ( nstepread == nstore + 1 ) then nfile = nfile + 1 ! next file number call writeinletfile ! write 1000 time steps to file call writerestartfiles nstepread = 1 ! reset counter end if ! nstepread == 1001 end if ! lstoreplane if ( rk3step == 1 ) then uminletbc = u0inletbc vminletbc = v0inletbc wminletbc = w0inletbc tminletbc = t0inletbc end if if ( lbuoyancy ) then !     call blthicknessmo(di_test,utaui,lmoi) call blthicknesst ( di_test , Uinl , 0.99 ) !     call dispthicknessmo(displ)  ! needed in top BC call dispthicknessexp ( displ ) else !     call blthickness(di_test,utaui) call blthicknesst ( di_test , Uinl , 0.99 ) !     call dispthickness(displ)  ! needed in top BC call dispthicknessexp ( displ ) end if call blthicknesst ( dti_test , Tinl - thls , 0.99 ) if (( myid == 0 ) . and . ( rk3step == 3 )) then write ( 6 , * ) 'Inlet Gen: gamma,lambda=' , gamm , lamb write ( 6 , * ) 'Inlet Gen: Uinl(ke),Tinl(ke)=' , Uinl ( ke ), Tinl ( ke ) write ( 6 , * ) 'Inlet Gen: utaui,utaur =' , utaui , utaur write ( 6 , * ) 'Inlet Gen: ttaui,ttaur =' , ttaui , ttaur write ( 6 , * ) 'Inlet Gen: Lmoi,Lmor =' , lmoi , lmor write ( 6 , * ) 'Inlet Gen: deltar, deltai_test' , dr , di_test write ( 6 , * ) 'Inlet Gen: deltatr, deltati_test' , dtr , dti_test write ( 6 , * ) 'Inlet Gen: d*i, d*r=' , displ ( ib ), displ ( irecy ) write ( 6 , * ) 'Inlet Gen: thetai,thetar' , thetai , thetar write ( 6 , * ) 'Inlet Gen: thetati,thetatr' , thetati , thetatr if ( luvolflowr ) then write ( 6 , * ) 'Inlet Gen: mass flux correction factor = ' , scalef !       write(6,*) 'Inlet Gen: mass flux                   = ',totalreadu write ( 6 , * ) 'Inlet Gen: mass flux                   = ' , totaluinl end if end if elseif ( iinletgen == 2 ) then if ( myid == 0 ) then write ( 6 , * ) 'nstepread=' , nstepread end if u0inletbcold = u0inletbc v0inletbcold = v0inletbc w0inletbcold = w0inletbc t0inletbcold = t0inletbc ! determine time step interval in simulation rk3coef = dt / ( 4. - dble ( rk3step )) if ( rk3step == 1 ) then deltat = rk3coef elseif ( rk3step == 2 ) then deltat = rk3coef - ( dt / 3. ) elseif ( rk3step == 3 ) then deltat = rk3coef - ( dt / 2. ) end if ! determine time step interval in inlet data rk3coefin = dtin / ( 4. - dble ( rk3stepin )) if ( rk3stepin == 1 ) then dtinrk = rk3coefin elseif ( rk3stepin == 2 ) then dtinrk = rk3coefin - ( dtin / 3. ) elseif ( rk3stepin == 3 ) then dtinrk = rk3coefin - ( dtin / 2. ) end if interval = dtinrk - elapstep elapstep = elapstep + deltat if ( elapstep > dtinrk ) then ! use new value at next time step nstepread = nstepread + 1 elapstep = mod ( elapstep , dtinrk ) rk3stepin = mod ( rk3stepin , 3 ) + 1 rk3coefin = dtin / ( 4. - dble ( rk3stepin )) if ( rk3stepin == 1 ) then dtinrk = rk3coefin elseif ( rk3stepin == 2 ) then dtinrk = rk3coefin - ( dtin / 3. ) elseif ( rk3stepin == 3 ) then dtinrk = rk3coefin - ( dtin / 2. ) end if u0inletbc (:,:) = storeu0inletbc (:,:, nstepread ) v0inletbc (:,:) = storev0inletbc (:,:, nstepread ) w0inletbc (:,:) = storew0inletbc (:,:, nstepread ) t0inletbc (:,:) = storet0inletbc (:,:, nstepread ) if ( nstepread == nstore ) then nfile = nfile + 1 call readinletfile call writerestartfiles nstepread = 0 end if interval = dtinrk deltat = elapstep !        write(6,*) 'dtinrk,deltat=', dtinrk,deltat end if u0inletbc (:,:) = ( 1. - deltat / interval ) * u0inletbc (:,:) + ( deltat / interval ) * storeu0inletbc (:,:, nstepread + 1 ) v0inletbc (:,:) = ( 1. - deltat / interval ) * v0inletbc (:,:) + ( deltat / interval ) * storev0inletbc (:,:, nstepread + 1 ) w0inletbc (:,:) = ( 1. - deltat / interval ) * w0inletbc (:,:) + ( deltat / interval ) * storew0inletbc (:,:, nstepread + 1 ) t0inletbc (:,:) = ( 1. - deltat / interval ) * t0inletbc (:,:) + ( deltat / interval ) * storet0inletbc (:,:, nstepread + 1 ) !! massflow correction uinletbc2 ( ib , jb : je , kb : ke ) = u0inletbc ( jb : je , kb : ke ) ! this is just a dummy variable to give uninletbc the right dimension in slabsum urav = 0. call slabsum ( urav , kb , ke , uinletbc2 , ib , ib , jb , je , kb , ke , ib , ib , jb , je , kb , ke ) urav = urav / ( jge - jgb + 1 ) ! average over j-direction ! determine bulk velocity of new (interpolated) profile do k = kb , ke uravdzf ( k ) = urav ( k ) * dzf ( k ) end do totalu = sum ( uravdzf ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! Area-averaged outflow velocity ! rescale the instantaneous profile to keep mass flux constant (tot avoid pressure fluctuations) scalef = totalreadu / totalu ! compute factor to scale the velocity profile with u0inletbc (:,:) = u0inletbc (:,:) * scalef ! rescale the velocity profile to have constant mass-flux !! end of massflow correction of interpolated streamwise velocity if ( rk3step == 1 ) then uminletbc = u0inletbc vminletbc = v0inletbc wminletbc = w0inletbc tminletbc = t0inletbc end if end if ! iinletgen end subroutine inletgen subroutine inletgennotemp use modglobal , only : ib , ie , jb , je , jgb , jge , kb , ke , zf , zh , dzf , dzhi , timee , btime , totavtime , rk3step , dt , numol , iplane , lles , iinletgen , inletav , runavtime , Uinf , lwallfunc , linletRA , totinletav , lstoreplane , nstore , lfixinlet , lfixutauin , luvolflowr use modfields , only : u0 , v0 , w0 , wm , uprof use modsave , only : writerestartfiles use modmpi , only : slabsum , myid implicit none real , dimension ( ib : ib , jb : je , kb : ke ) :: uinletbc2 ! dummy variable real , dimension ( jb : je , kb : ke ) :: uprec ! velocity fluctuation (up_rec = u0 - Urec) real , dimension ( jb : je , kb : ke ) :: vprec ! velocity fluctuation (vp_rec = v0 - 0) real , dimension ( jb : je , kb : ke + 1 ) :: wprec ! velocity fluctuation (wp_rec = w0 - Wrec) real , dimension ( jb : je , kb : ke ) :: upinli , vpinli ! = gamma * (uprec,v interpolated to zii grid) real , dimension ( jb : je , kb : ke ) :: upinlo , vpinlo ! = gamma * (uprec,v interpolated to zoi grid) real , dimension ( jb : je , kb : ke + 1 ) :: wpinli ! = gamma * (wprec   interpolated to zii grid) real , dimension ( jb : je , kb : ke + 1 ) :: wpinlo ! = gamma * (wprec   interpolated to zoi grid) real , dimension ( kb : ke ) :: udiff ! difference between Uinl and Urec !    real,dimension(kb:ke)   :: Urecdiff                ! difference between Urec new and old real , dimension ( kb : ke ) :: urav ! j-averaged u-velocity (not time-averaged) real , dimension ( kb : ke ) :: uravdzf ! j-averaged u-velocity (not time-averaged) times dzf real , dimension ( kb : ke ) :: uinldzf ! j-averaged u-velocity (not time-averaged) times dzf real , dimension ( kb : ke ) :: Urecdzf ! Urec times dzf real , dimension ( kb : ke + 1 ) :: wrav ! j-averaged w-velocity (not time-averaged) real , dimension ( kb : ke ) :: Uinli ! = gamma * (Urec interpolated to ziif grid points) real , dimension ( kb : ke + 1 ) :: Winli ! = gamma * (Wrec interpolated to ziih grid points) real , dimension ( kb : ke ) :: Uinlo ! = gamma * (Urec interpolated to zioif grid points) real , dimension ( kb : ke + 1 ) :: Winlo ! = gamma * (Wrec interpolated to zoih grid points) real , dimension ( kb : ke ) :: wfuncf ! weight function at full level real , dimension ( kb : ke + 1 ) :: wfunch ! weight function at half level real :: utaur2 , utaui2 ! (utau)&#94;2 at recycle station and inlet real :: gamm ! utaui / utaur real :: avint , avinti ! avering interval real :: alpha , beta ! factors used in the Weight function !    real                    :: totalu                  ! total u-velocity at outlet real :: Urectot ! total u-velocity at recycle plane real :: rk3coef !    real                    :: di_test                 ! BL thickness as measured from Uinl real :: utop ! j-averaged top velocity real :: interval real :: dtinrk ! RK time step in inlet data real :: rk3coefin ! Cumulative RK time step in inlet data real :: dr_old real :: scalef ! scale factor to scale instantaneous velocity profile with to get constant mass flux real :: totaluinl ! bulk velocity at the inlet integer i , j , k , kk if ( iinletgen == 1 ) then u0inletbcold = u0inletbc v0inletbcold = v0inletbc w0inletbcold = w0inletbc totaluold = totalu displold = displ ddispdxold = ddispdx ! compute time-average velocities rk3coef = dt / ( 4. - dble ( rk3step )) if ( rk3step == 1 ) then deltat = rk3coef elseif ( rk3step == 2 ) then deltat = rk3coef - ( dt / 3. ) elseif ( rk3step == 3 ) then deltat = rk3coef - ( dt / 2. ) end if if ( linletRA ) then ! this is a switch to use 'running average' avint = totinletav + timee - btime ! runav interval = averaging interval previuous sim  + current elapsed sim time else avint = inletav end if avinti = 1. / avint uaver = 0. do i = ib , ie call slabsum ( uaver ( i ,:), kb , ke , u0 ( i : i , jb : je , kb : ke ), i , i , jb , je , kb , ke , i , i , jb , je , kb , ke ) end do wrav = 0. call slabsum ( wrav ( kb : ke + 1 ), kb , ke , w0 ( irecy - 1 : irecy - 1 , jb : je , kb : ke + 1 ), irecy - 1 , irecy - 1 , jb , je , kb , ke + 1 , irecy - 1 , irecy - 1 , jb , je , kb , ke + 1 ) uaver = uaver / ( jge - jgb + 1 ) ! average over j-direction urav = uaver ( irecy ,:) wrav = wrav / ( jge - jgb + 1 ) ! average over j-direction do k = kb , ke Urec ( k ) = urav ( k ) * deltat * avinti + ( 1. - deltat * avinti ) * Urec ( k ) end do do k = kb , ke + 1 Wrec ( k ) = wrav ( k ) * deltat * avinti + ( 1. - deltat * avinti ) * Wrec ( k ) end do do k = kb , ke do i = ib , ie Utav ( i , k ) = uaver ( i , k ) * deltat * avinti + ( 1. - deltat * avinti ) * Utav ( i , k ) end do end do ! compute velocity fluctuation at recycle station do k = kb , ke do j = jb , je uprec ( j , k ) = u0 ( irecy , j , k ) - Urec ( k ) vprec ( j , k ) = v0 ( irecy - 1 , j , k ) ! mean v is zero end do end do do k = kb , ke + 1 do j = jb , je wprec ( j , k ) = w0 ( irecy - 1 , j , k ) - Wrec ( k ) ! note that w-velocity is taken at i=irecy-1 !! end do end do if ( lwallfunc ) then call wallawinlet ( Urec ( kb ), dzf ( kb ), numol , utaur2 ) ! compute wall shear stress at recycle station else utaur2 = 2. * numol * Urec ( kb ) / dzf ( kb ) end if utaur = sqrt ( abs ( utaur2 )) ! compute utau at recycle station ! compute momentum thickness at inlet and recycle plane dr_old = dr !   call blthickness(dr,utaur)                     ! also needed for thetar call blthicknesst ( dr , Urec , 0.99 ) !   call momentumthickness(thetai,utaui,di)        ! di is kept fixed call momentumthicknessexp ( thetai , Uinl ) !   call momentumthickness(thetar,utaur,dr) call momentumthicknessexp ( thetar , Urec ) !   call blthickness(dr,utaur) if (. not . lfixutauin ) then utaui = utaur * abs ( thetar / thetai ) ** ( 1. / 8. ) ! See Lund (1998): 'Similar to Ludwig-Tillmann correlation' end if gamm = utaui / utaur ! Gamma in Lund (1998) ! compute inner scaling coordinates zirf = utaur * zf / numol ! inner scaling zf-coordinate at recycle station zirh = utaur * zh / numol ! inner scaling zh-coordinate at recycle station ziif = utaui * zf / numol ! inner scaling zf-coordinate at inlet station ziih = utaui * zh / numol ! inner scaling zh-coordinate at inlet station ! compute outer scaling coordinates zorf = zf / dr ! outer scaling zf-coor as measured from Uinldinate at recycle station zorh = zh / dr ! outer scaling zh-coordinate at recycle station zoif = zf / di ! outer scaling zf-coordinate at inlet station  (could be done once, actually..) zoih = zh / di ! outer scaling zf-coordinate at inlet station  (could be done once, actually..) !!!!! Interpolation starts here !!! First inner coordinates ! determine which elements are needed when recycle velocity profile is interpolated on inlet plane ! for u(,v)-components (zf) do k = kb , ke do kk = kb , ke if ( zirf ( kk ) >= ziif ( k )) then locupif ( k ) = kk loclowif ( k ) = kk - 1 exit elseif ( kk == ke ) then locupif ( k ) = ke + 1 ! this means extrapolation! loclowif ( k ) = ke - 1 ! waarom niet ke? of wordt dit niet gebruikt? end if end do end do ! for w-components (zh) do k = kb , ke + 1 do kk = kb , ke + 1 if ( zirh ( kk ) >= ziih ( k )) then locupih ( k ) = kk loclowih ( k ) = kk - 1 exit elseif ( kk == ke + 1 ) then locupih ( k ) = ke + 2 ! this means extrapolation! loclowih ( k ) = ke end if end do end do !!! Finished with inner coordinates !!! Do the same trick for outer coordinates ! determine which elements are needed when recycle velocity profile is interpolated on inlet plane ! for u(,v)-components (zf) do k = kb , ke do kk = kb , ke if ( zorf ( kk ) >= zoif ( k )) then locupof ( k ) = kk loclowof ( k ) = kk - 1 exit elseif ( kk == ke ) then locupof ( k ) = ke + 1 ! this means extrapolation! loclowof ( k ) = ke - 1 end if end do end do ! for w-components (zh) do k = kb , ke + 1 do kk = kb , ke + 1 if ( zorh ( kk ) >= zoih ( k )) then locupoh ( k ) = kk loclowoh ( k ) = kk - 1 exit elseif ( kk == ke + 1 ) then locupoh ( k ) = ke + 2 ! this means extrapolation! loclowoh ( k ) = ke end if end do end do !!! Finished with outer coordinates !!! Now really interpolate !!! First inner coordinates ! compute Urec on zii grid do k = kb , ke if ( locupif ( k ) == ke + 1 ) then ! indicator for extrapolation! !        Uinli(k) = Urec(ke) + (Urec(ke) - Urec(ke-1)) / (zirf(ke)-zirf(ke-1)) * (ziif(k)-zirf(ke)) Uinli ( k ) = Urec ( ke ) elseif ( loclowif ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) Uinli ( k ) = Urec ( kb ) / zirf ( kb ) * ziif ( k ) else ! normal interpolation Uinli ( k ) = Urec ( loclowif ( k )) + ( Urec ( locupif ( k )) - Urec ( loclowif ( k ))) / ( zirf ( locupif ( k )) - zirf ( loclowif ( k ))) * ( ziif ( k ) - zirf ( loclowif ( k ))) if (( ziif ( k ) . gt . zirf ( locupif ( k ))) . or . ( ziif ( k ) . lt . zirf ( loclowif ( k )))) then write ( 6 , * ) '!!!Mistake in Interpolation !!!!' end if end if end do ! compute Wrec on zii grid Winli ( kb ) = 0.0 ! corresponds to ground level do k = kb + 1 , ke + 1 if ( locupih ( k ) == ke + 2 ) then ! indicator for extrapolation! !        Winli(k) = Wrec(ke+1) + (Wrec(ke+1) - Wrec(ke)) / (zirh(ke+1)-zirh(ke)) * (ziih(k)-zirh(ke+1)) Winli ( k ) = Wrec ( ke + 1 ) else ! normal interpolation Winli ( k ) = Wrec ( loclowih ( k )) + ( Wrec ( locupih ( k )) - Wrec ( loclowih ( k ))) / ( zirh ( locupih ( k )) - zirh ( loclowih ( k ))) * ( ziih ( k ) - zirh ( loclowih ( k ))) end if end do ! compute u- and v- and t-fluctuation on zii grid do k = kb , ke if ( locupif ( k ) == ke + 1 ) then ! indicator for extrapolation! !        upinli(:,k) = uprec(:,ke) + (uprec(:,ke) - uprec(:,ke-1)) / (zirf(ke)-zirf(ke-1)) * (ziif(k)-zirf(ke)) upinli (:, k ) = 0. vpinli (:, k ) = 0. elseif ( loclowif ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) upinli (:, k ) = uprec (:, kb ) / zirf ( kb ) * ziif ( k ) vpinli (:, k ) = vprec (:, kb ) / zirf ( kb ) * ziif ( k ) else ! normal interpolation upinli (:, k ) = uprec (:, loclowif ( k )) + ( uprec (:, locupif ( k )) - uprec (:, loclowif ( k ))) / ( zirf ( locupif ( k )) - zirf ( loclowif ( k ))) * ( ziif ( k ) - zirf ( loclowif ( k ))) vpinli (:, k ) = vprec (:, loclowif ( k )) + ( vprec (:, locupif ( k )) - vprec (:, loclowif ( k ))) / ( zirf ( locupif ( k )) - zirf ( loclowif ( k ))) * ( ziif ( k ) - zirf ( loclowif ( k ))) end if end do ! compute w-fluctuation on zii grid do k = kb + 1 , ke + 1 !      if (locupih(k) == ke+1) then      ! indicator for extrapolation! if ( locupih ( k ) == ke + 2 ) then ! indicator for extrapolation! !        wpinli(:,k) = wprec(:,ke+1) + (wprec(:,ke+1) - wprec(:,ke)) / (zirh(ke+1)-zirh(ke)) * (ziih(k)-zirh(ke+1)) wpinli (:, k ) = 0. else ! normal interpolation wpinli (:, k ) = wprec (:, loclowih ( k )) + ( wprec (:, locupih ( k )) - wprec (:, loclowih ( k ))) / ( zirh ( locupih ( k )) - zirh ( loclowih ( k ))) * ( ziih ( k ) - zirh ( loclowih ( k ))) end if end do !! Finished with interpolating inner variables !! Continue with interpolating outer variables ! compute Urec on zoi grid do k = kb , ke if ( locupof ( k ) == ke + 1 ) then ! indicator for extrapolation! !        Uinlo(k) = Urec(ke) + (Urec(ke) - Urec(ke-1)) / (zorf(ke)-zorf(ke-1)) * (zoif(k)-zorf(ke)) !        Uinlo(k) = Urec(ke) Uinlo ( k ) = Uinf elseif ( loclowof ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) Uinlo ( k ) = Urec ( kb ) / zorf ( kb ) * zoif ( k ) else ! normal interpolation Uinlo ( k ) = Urec ( loclowof ( k )) + ( Urec ( locupof ( k )) - Urec ( loclowof ( k ))) / ( zorf ( locupof ( k )) - zorf ( loclowof ( k ))) * ( zoif ( k ) - zorf ( loclowof ( k ))) end if end do ! compute Wrec on zii grid Winlo ( kb ) = 0.0 ! corresponds to ground level do k = kb + 1 , ke + 1 if ( locupoh ( k ) == ke + 2 ) then ! indicator for extrapolation! !        Winlo(k) = Wrec(ke+1) + (Wrec(ke+1) - Wrec(ke)) / (zorh(ke+1)-zorh(ke)) * (zoih(k)-zorh(ke+1)) Winlo ( k ) = Wrec ( ke + 1 ) else ! normal interpolation Winlo ( k ) = Wrec ( loclowoh ( k )) + ( Wrec ( locupoh ( k )) - Wrec ( loclowoh ( k ))) / ( zorh ( locupoh ( k )) - zorh ( loclowoh ( k ))) * ( zoih ( k ) - zorh ( loclowoh ( k ))) end if end do ! compute u- and v-fluctuation on zoi grid do k = kb , ke if ( locupof ( k ) == ke + 1 ) then ! indicator for extrapolation! !        upinlo(:,k) = uprec(:,ke) + (uprec(:,ke) - uprec(:,ke-1)) / (zorf(ke)-zorf(ke-1)) * (zoif(k)-zorf(ke)) upinlo (:, k ) = 0. vpinlo (:, k ) = 0. elseif ( loclowof ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) upinlo (:, k ) = uprec (:, kb ) / zorf ( kb ) * zoif ( k ) vpinlo (:, k ) = vprec (:, kb ) / zorf ( kb ) * zoif ( k ) else ! normal interpolation upinlo (:, k ) = uprec (:, loclowof ( k )) + ( uprec (:, locupof ( k )) - uprec (:, loclowof ( k ))) / ( zorf ( locupof ( k )) - zorf ( loclowof ( k ))) * ( zoif ( k ) - zorf ( loclowof ( k ))) vpinlo (:, k ) = vprec (:, loclowof ( k )) + ( vprec (:, locupof ( k )) - vprec (:, loclowof ( k ))) / ( zorf ( locupof ( k )) - zorf ( loclowof ( k ))) * ( zoif ( k ) - zorf ( loclowof ( k ))) end if end do ! compute w-fluctuation on zoi grid do k = kb + 1 , ke + 1 if ( locupoh ( k ) == ke + 2 ) then ! indicator for extrapolation! !        wpinlo(:,k) = wprec(:,ke+1) + (wprec(:,ke+1) - wprec(:,ke)) / (zorh(ke+1)-zorh(ke)) * (zoih(k)-zorh(ke+1)) wpinlo (:, k ) = 0. else ! normal interpolation wpinlo (:, k ) = wprec (:, loclowoh ( k )) + ( wprec (:, locupoh ( k )) - wprec (:, loclowoh ( k ))) / ( zorh ( locupoh ( k )) - zorh ( loclowoh ( k ))) * ( zoih ( k ) - zorh ( loclowoh ( k ))) end if end do !! Finished interpolating outer velocity variables !!!!! Finished Interpolation! !!!!! ! compute rescaled inner variables ! Winli = Winli (interpolation is enough) Uinli = gamm * Uinli upinli = gamm * upinli vpinli = gamm * vpinli wpinli = gamm * wpinli ! compute rescaled outer variables ! Winlo = Winlo (interpolation is enough) Uinlo = gamm * Uinlo + ( 1. - gamm ) * Uinf !    Uinlo = gamm* Uinlo  + (1.- gamm)*Urec(ke) upinlo = gamm * upinlo vpinlo = gamm * vpinlo wpinlo = gamm * wpinlo ! Compute weight function (alpha=4, b=0.2) alpha = 4. beta = 0.2 wfuncf = 0.5 * ( 1. + tanh ( alpha * ( zoif - beta ) / (( 1. - 2. * beta ) * zoif + beta ) ) / tanh ( alpha ) ) ! for full level height wfunch = 0.5 * ( 1. + tanh ( alpha * ( zoih - beta ) / (( 1. - 2. * beta ) * zoih + beta ) ) / tanh ( alpha ) ) ! for half level height do k = kb , ke if ( wfuncf ( k ) . gt . 1. ) then wfuncf ( k ) = 1. end if end do do k = kb , ke + 1 if ( wfunch ( k ) . gt . 1. ) then wfunch ( k ) = 1. end if end do ! Compute the velocity components for the inlet BC do k = kb , ke do j = jb , je u0inletbc ( j , k ) = ( Uinli ( k ) + upinli ( j , k )) * ( 1. - wfuncf ( k )) + ( Uinlo ( k ) + upinlo ( j , k )) * wfuncf ( k ) v0inletbc ( j , k ) = vpinli ( j , k ) * ( 1. - wfuncf ( k )) + vpinlo ( j , k ) * wfuncf ( k ) end do end do do k = kb , ke + 1 do j = jb , je w0inletbc ( j , k ) = ( Winli ( k ) + wpinli ( j , k )) * ( 1 - wfunch ( k )) + ( Winlo ( k ) + wpinlo ( j , k )) * wfunch ( k ) end do end do w0inletbc (:, kb ) = 0. w0inletbc (:, ke + 1 ) = 0. ! Compute j-averaged inlet U  (used for compute thetai) uinletbc2 ( ib , jb : je , kb : ke ) = u0inletbc ( jb : je , kb : ke ) ! this is just a dummy variable to give uninletbc the right dimension in slabsum urav = 0. call slabsum ( urav , kb , ke , uinletbc2 , ib , ib , jb , je , kb , ke , ib , ib , jb , je , kb , ke ) urav = urav / ( jge - jgb + 1 ) ! average over j-direction ! determine bulk velocity of new profile do k = kb , ke uravdzf ( k ) = urav ( k ) * dzf ( k ) end do totalu = sum ( uravdzf ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! Area-averaged outflow velocity ! correct instantaneous inflow velocity for constant mass-flux if ( luvolflowr ) then do k = kb , ke uinldzf ( k ) = Uinl ( k ) * dzf ( k ) end do totaluinl = sum ( uinldzf ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! Area-averaged inflow velocity that should be kept scalef = totaluinl / totalu ! compute factor to scale the velocity profile with u0inletbc (:,:) = u0inletbc (:,:) * scalef ! rescale the velocity profile to have constant mass-flux urav (:) = urav (:) * scalef ! also rescale the part that is added to the mean end if ! Compute j- and time-averaged  inlet U  (used for compute thetai) if (. not . lfixinlet ) then ! only update the average inlet profiles when lfixinlet .eqv..false. do k = kb , ke Uinl ( k ) = urav ( k ) * deltat * avinti + ( 1. - deltat * avinti ) * Uinl ( k ) end do end if ! write inletplane to array (and to file after 1000 time steps) if ( lstoreplane ) then storeu0inletbc (:,:, nstepread ) = u0inletbc (:,:) storev0inletbc (:,:, nstepread ) = v0inletbc (:,:) storew0inletbc (:,:, nstepread ) = w0inletbc (:,:) nstepread = nstepread + 1 if ( nstepread == nstore + 1 ) then nfile = nfile + 1 ! next file number call writeinletfile ! write 1000 time steps to file call writerestartfiles nstepread = 1 ! reset counter end if ! nstepread == 1001 end if ! lstoreplane if ( rk3step == 1 ) then uminletbc = u0inletbc vminletbc = v0inletbc wminletbc = w0inletbc end if !   call blthickness(di_test,utaui) call blthicknesst ( di_test , Uinl , 0.99 ) !   call dispthickness(displ)  ! needed in top BC call dispthicknessexp ( displ ) ! needed in top BC if (( myid == 0 ) . and . ( rk3step == 3 )) then write ( 6 , * ) 'Inlet Gen: gamma=' , gamm write ( 6 , * ) 'Inlet Gen: Uinl(ke)=' , Uinl ( ke ) write ( 6 , * ) 'Inlet Gen: utaui,utaur =' , utaui , utaur write ( 6 , * ) 'Inlet Gen: deltar, deltai_test' , dr , di_test write ( 6 , * ) 'Inlet Gen: d*i, d*r=' , displ ( ib ), displ ( irecy ) write ( 6 , * ) 'Inlet Gen: thetai,thetar' , thetai , thetar if ( luvolflowr ) then write ( 6 , * ) 'Inlet Gen: mass flux correction factor = ' , scalef !       write(6,*) 'Inlet Gen: mass flux                   = ',totalreadu write ( 6 , * ) 'Inlet Gen: mass flux                   = ' , totaluinl end if end if elseif ( iinletgen == 2 ) then if ( myid == 0 ) then write ( 6 , * ) 'nstepread=' , nstepread end if u0inletbcold = u0inletbc v0inletbcold = v0inletbc w0inletbcold = w0inletbc ! determine time step interval in simulation rk3coef = dt / ( 4. - dble ( rk3step )) if ( rk3step == 1 ) then deltat = rk3coef elseif ( rk3step == 2 ) then deltat = rk3coef - ( dt / 3. ) elseif ( rk3step == 3 ) then deltat = rk3coef - ( dt / 2. ) end if ! determine time step interval in inlet data rk3coefin = dtin / ( 4. - dble ( rk3stepin )) if ( rk3stepin == 1 ) then dtinrk = rk3coefin elseif ( rk3stepin == 2 ) then dtinrk = rk3coefin - ( dtin / 3. ) elseif ( rk3stepin == 3 ) then dtinrk = rk3coefin - ( dtin / 2. ) end if interval = dtinrk - elapstep elapstep = elapstep + deltat if ( elapstep > dtinrk ) then ! use new value at next time step nstepread = nstepread + 1 elapstep = mod ( elapstep , dtinrk ) rk3stepin = mod ( rk3stepin , 3 ) + 1 rk3coefin = dtin / ( 4. - dble ( rk3stepin )) if ( rk3stepin == 1 ) then dtinrk = rk3coefin elseif ( rk3stepin == 2 ) then dtinrk = rk3coefin - ( dtin / 3. ) elseif ( rk3stepin == 3 ) then dtinrk = rk3coefin - ( dtin / 2. ) end if u0inletbc (:,:) = storeu0inletbc (:,:, nstepread ) v0inletbc (:,:) = storev0inletbc (:,:, nstepread ) w0inletbc (:,:) = storew0inletbc (:,:, nstepread ) if ( nstepread == nstore ) then nfile = nfile + 1 call readinletfile call writerestartfiles nstepread = 0 end if interval = dtinrk deltat = elapstep !        write(6,*) 'dtinrk,deltat=', dtinrk,deltat end if u0inletbc (:,:) = ( 1. - deltat / interval ) * u0inletbc (:,:) + ( deltat / interval ) * storeu0inletbc (:,:, nstepread + 1 ) v0inletbc (:,:) = ( 1. - deltat / interval ) * v0inletbc (:,:) + ( deltat / interval ) * storev0inletbc (:,:, nstepread + 1 ) w0inletbc (:,:) = ( 1. - deltat / interval ) * w0inletbc (:,:) + ( deltat / interval ) * storew0inletbc (:,:, nstepread + 1 ) !! massflow correction uinletbc2 ( ib , jb : je , kb : ke ) = u0inletbc ( jb : je , kb : ke ) ! this is just a dummy variable to give uninletbc the right dimension in slabsum urav = 0. call slabsum ( urav , kb , ke , uinletbc2 , ib , ib , jb , je , kb , ke , ib , ib , jb , je , kb , ke ) urav = urav / ( jge - jgb + 1 ) ! average over j-direction ! determine bulk velocity of new (interpolated) profile do k = kb , ke uravdzf ( k ) = urav ( k ) * dzf ( k ) end do totalu = sum ( uravdzf ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! Area-averaged outflow velocity ! rescale the instantaneous profile to keep mass flux constant (tot avoid pressure fluctuations) scalef = totalreadu / totalu ! compute factor to scale the velocity profile with u0inletbc (:,:) = u0inletbc (:,:) * scalef ! rescale the velocity profile to have constant mass-flux !! end of massflow correction of interpolated streamwise velocity if ( rk3step == 1 ) then uminletbc = u0inletbc vminletbc = v0inletbc wminletbc = w0inletbc end if end if ! iinletgen end subroutine inletgennotemp subroutine momentumthicknessexp ( output , uinput ) use modglobal , only : jb , kb , ke , dzf !,Uinf use modinletdata , only : ubulk use modmpi , only : myid implicit none real , dimension ( kb : ke ), intent ( in ) :: uinput !< input velocity real , intent ( out ) :: output !< momentum thickness real , dimension ( kb : ke ) :: mthick !       real    :: umax integer :: k !      write(6,*) 'uinletbc(jb,ke),Uinl(ke)=', uinletbc(jb,ke),uinput(ke) !       umax = maxval(uinput) do k = kb , ke mthick ( k ) = (( uinput ( k ) / uinput ( ke )) - ( uinput ( k ) ** 2. / uinput ( ke ) ** 2. ) ) * dzf ( k ) !         mthick(k) = ((uinput(k)/umax) - (uinput(k)**2. / umax**2.) )*dzf(k) end do output = sum ( mthick ) ! momentum thickness end subroutine momentumthicknessexp subroutine momentumthickness ( output , ustar , blth ) use modglobal , only : pi , Uinf !    use modinletdata, only : ubulk !   use modmpi, only    : myid implicit none real , intent ( in ) :: ustar ! friction velocity real , intent ( in ) :: blth ! boundary layer thickness real , intent ( out ) :: output ! momentum thickness real :: B = 5.0 ! Wake parameter real :: C = 0.5 ! Coles parameter real :: kappa = 0.41 ! Von k�r�n constant real :: lam ! = Uinf/ustar lam = Uinf / ustar output = (( 1. + C ) / ( kappa * lam ) - ( 1. / (( kappa ** 2 ) * ( lam ** 2 ))) * ( 2. + 2. * C * ( 1.852 / pi + 1. ) + ( 3. / 2. ) * ( C ** 2 ))) * blth end subroutine momentumthickness subroutine momentumthicknessmo ( output , ustar , blth , lmo ) use modglobal , only : pi , Uinf !    use modinletdata, only : ubulk !   use modmpi, only    : myid implicit none real , intent ( in ) :: ustar ! friction velocity real , intent ( in ) :: lmo ! Obukhov length real , intent ( in ) :: blth ! boundary layer thickness real , intent ( out ) :: output ! momentum thickness real :: B = 5.0 ! Wake parameter real :: C = 0.5 ! Coles parameter real :: kappa = 0.41 ! Von k�r�n constant real :: cmo = 0.702 ! constant in MO theory (0.135*5.2) real :: lam ! = Uinf/ustar lam = Uinf / ustar output = ( 1. + C + 0.5 * cmo * blth / lmo ) / ( kappa * lam ) - ( 1. / (( kappa ** 2 ) * ( lam ** 2 ))) * ( 2. + 2. * C * ( 1.852 / pi + 1. ) + ( 3. / 2. ) * ( C ** 2 ) + ( blth - 0.25 ) * 2. * cmo / lmo + ( 1. + 4. / pi ) * blth * C * cmo / lmo + ( 1. / 6. ) * (( cmo / lmo ) ** 2 ) * ( blth ** 2 ) ) * blth end subroutine momentumthicknessmo subroutine enthalpythickness ( output , tinput , uinput ) use modglobal , only : jb , kb , ke , dzf !,Uinf use modinletdata , only : ubulk use modsurfdata , only : thls use modmpi , only : myid implicit none real , dimension ( kb : ke ), intent ( in ) :: tinput !< input temperature real , dimension ( kb : ke ), intent ( in ) :: uinput !< input velocity real , intent ( out ) :: output !< momentum thickness real , dimension ( kb : ke ) :: ethick real thlsdummy integer :: k thlsdummy = thls if ( tinput ( ke ) == thls ) then thlsdummy = thls - 0.000001 end if do k = kb , ke !         ethick(k) = (uinput(k)/uinput(ke)) * ((tinput(k) - tinput(ke)) /(thls - tinput(ke)) )*dzf(k) ethick ( k ) = ( uinput ( k ) / uinput ( ke )) * (( tinput ( k ) - tinput ( ke )) / ( thlsdummy - tinput ( ke )) ) * dzf ( k ) end do output = sum ( ethick ) ! enthalpy thickness if ( output == 0. ) then output = 0.000001 end if end subroutine enthalpythickness subroutine dispthicknessexp ( output ) ! output is an array of length (ib:ie)) containing displacement thickness values use modglobal , only : ib , ie , kb , ke , dzf , xf !,Uinf implicit none real , dimension ( ib : ie ), intent ( out ) :: output !< dispacement thickness real , dimension ( kb : ke ) :: dthick !       real    :: umax real :: dispm real :: disp2m real :: xfdispm integer :: i , k ! write(6,*) 'Uinl(ke)=', uinput(ke) do i = ib , ie !       umax = maxval(Utav(i,:)) do k = kb , ke dthick ( k ) = ( 1. - Utav ( i , k ) / Utav ( i , ke )) * dzf ( k ) ! time-averaged, j-averaged velocity !         dthick(k) = (1.- Utav(i,k)/ umax) *dzf(k)       ! time-averaged, j-averaged velocity end do output ( i ) = sum ( dthick ) ! displacement thickness end do dispm = sum ( output ( ib : ie )) / ( ie - ib + 1 ) ! mean(displacement) disp2m = sum ( output ( ib : ie ) ** 2. ) / ( ie - ib + 1 ) ! mean(displacement&#94;2) xfdispm = sum ( xf ( ib : ie ) * output ( ib : ie )) / ( ie - ib + 1 ) ! mean(xf*displ) ddispdx = ( xfdispm - ( xfm * dispm )) / ( xf2m - xfm ** 2. ) ! this is d/dx(delta*) !       ddispdx = 0.    ! for the test !       dinl    = dispm - ddispdx*xfm                         ! this is the starting value (delta* = dinl + d/dx(delta)*x) end subroutine dispthicknessexp subroutine dispthickness ( output ) ! output is an array of length (ib:ie)) containing displacement thickness values use modglobal , only : ib , ie , kb , ke , dzf , xf , Uinf , numol implicit none real , dimension ( ib : ie ), intent ( out ) :: output !< dispacement thickness !       real, dimension(kb:ke)                    :: dthick real :: dispm real :: disp2m real :: xfdispm real :: ustar , blth real :: B = 5.0 ! Wake parameter real :: C = 0.5 ! Coles parameter real :: kappa = 0.41 ! Von k�r�n constant real :: lam ! = Uinf/ustar integer :: i do i = ib , ie ustar = sqrt ( abs ( 2 * numol * Utav ( i , kb ) / dzf ( kb ))) ! average streamwise friction lam = Uinf / ustar blth = ( lam * numol / Uinf ) * exp ( kappa * ( lam - B ) - 2. * C ) ! See App. Lund et al. output ( i ) = (( 1. + C ) / ( kappa * lam ) ) * blth end do dispm = sum ( output ( ib : ie )) / ( ie - ib + 1 ) ! mean(displacement) disp2m = sum ( output ( ib : ie ) ** 2. ) / ( ie - ib + 1 ) ! mean(displacement&#94;2) xfdispm = sum ( xf ( ib : ie ) * output ( ib : ie )) / ( ie - ib + 1 ) ! mean(xf*displ) ddispdx = ( xfdispm - ( xfm * dispm )) / ( xf2m - xfm ** 2. ) ! this is d/dx(delta*) end subroutine dispthickness subroutine dispthicknessmo ( output ) ! output is an array of length (ib:ie)) containing displacement thickness values use modglobal , only : ib , ie , kb , ke , dzf , xf , Uinf , numol , grav , prandtlmoli use modsurfdata , only : thls implicit none real , dimension ( ib : ie ), intent ( out ) :: output !< dispacement thickness !       real, dimension(kb:ke)                    :: dthick real :: dispm real :: disp2m real :: xfdispm real :: ustar , tstar , blth real :: B = 5.0 ! Wake parameter real :: C = 0.5 ! Coles parameter real :: kappa = 0.41 ! Von k�rm�n constant real :: cmo = 0.702 ! constant in MO theory (0.135*5.2) real :: lam ! = Uinf/ustar real :: func , dfunc , utaunu , lmo integer :: i , n blth = di ! initial value do i = ib , ie ustar = sqrt ( abs ( 2. * numol * Utav ( i , kb ) / dzf ( kb ))) ! average streamwise friction at x-location tstar = numol * prandtlmoli * 2. * ( Ttav ( i , kb ) - thls ) / ( dzf ( kb ) * ustar ) ! average shear temp. at x-location lmo = ( thls * ustar ** 2 ) / ( kappa * grav * tstar ) ! obukhov length at this x-location if (( lmo >= 1000 0. ) . or . ( lmo <= 0.01 )) then lmo = 100 0. end if !         lmo = 0.3  !! TEMPORARY utaunu = ustar / numol lam = Uinf / ustar do n = 1 , 10 ! Newton Raphson method to find BL height !           write(6,*) 'blth,ustar,tstar,Lmo =',blth,ustar,tstar,lmo func = log ( blth ) + ( cmo * blth / lmo ) + log ( utaunu ) - kappa * ( lam - B ) + 2. * C !           func   = log(blth) + log(utaunu) - kappa*(lam-B) +2.*C dfunc = 1. / blth + cmo / lmo blth = blth - ( func / dfunc ) if ( blth <= 0. ) then blth = di end if end do output ( i ) = (( 1. + C + 0.5 * cmo * blth / lmo ) / ( kappa * lam ) ) * blth end do dispm = sum ( output ( ib : ie )) / ( ie - ib + 1 ) ! mean(displacement) disp2m = sum ( output ( ib : ie ) ** 2. ) / ( ie - ib + 1 ) ! mean(displacement&#94;2) xfdispm = sum ( xf ( ib : ie ) * output ( ib : ie )) / ( ie - ib + 1 ) ! mean(xf*displ) ddispdx = ( xfdispm - ( xfm * dispm )) / ( xf2m - xfm ** 2. ) ! this is d/dx(delta*) end subroutine dispthicknessmo ! thermal boundary layer thickness subroutine blthicknesst ( output , uinput , criterion ) use modglobal , only : kb , ke , zh , zf implicit none real , dimension ( kb : ke ), intent ( in ) :: uinput !< input velocity real , intent ( in ) :: criterion !< criterion for BL thickness computation (e.g. 0.95 or 0.99) real , intent ( out ) :: output !< BL thickness based on input criterion !       real, dimension(kb:ke)             :: mthick real :: ucrit !       real                               :: umax integer :: k !     umax = maxval(uinput) ucrit = uinput ( ke ) * criterion ! Velocity at which BL-thickness is reached !     ucrit = umax*criterion  ! Velocity at which BL-thickness is reached do k = kb , ke if ( uinput ( k ) . GT . criterion * uinput ( ke )) then if ( k == kb ) then output = zh ( kb ) + ( zf ( k ) - zh ( k )) / uinput ( k ) * ucrit ! interpolate z to BL-height exit else output = zf ( k - 1 ) + ( zf ( k ) - zf ( k - 1 )) / ( uinput ( k ) - uinput ( k - 1 )) * ( ucrit - uinput ( k - 1 )) !  interpolate z to BL-height exit end if else if ( k == ke ) then output = zf ( ke ) ! maximum BL thickness end if end do end subroutine blthicknesst !  subroutine blthickness(output,uinput,criterion) ! !    use modglobal, only : kb,ke,zh,zf !    implicit none ! !       real, dimension(kb:ke), intent(in) :: uinput     !< input velocity !       real, intent(in)                   :: criterion  !< criterion for BL thickness computation (e.g. 0.95 or 0.99) !       real, intent(out)                  :: output     !< BL thickness based on input criterion !!       real, dimension(kb:ke)             :: mthick !       real                               :: ucrit !!       real                               :: umax !       integer :: k ! !!     umax = maxval(uinput) !     ucrit = uinput(ke)*criterion  ! Velocity at which BL-thickness is reached !!     ucrit = umax*criterion  ! Velocity at which BL-thickness is reached !     do k=kb,ke !       if (uinput(k) .GT. criterion*uinput(ke)) then !         if (k==kb) then !           output = zh(kb)+ (zf(k)-zh(k))/uinput(k)*ucrit ! interpolate z to BL-height !           exit !         else !           output = zf(k-1) + (zf(k)-zf(k-1))/(uinput(k)-uinput(k-1))*(ucrit-uinput(k-1)) ! interpolate z to BL-height !           exit !         end if !       else if (k==ke) then !         output = zf(ke)      ! maximum BL thickness !       end if !     end do !   end subroutine blthickness subroutine blthickness ( output , ustar ) use modglobal , only : numol , Uinf implicit none real , intent ( in ) :: ustar ! friction velocity real , intent ( out ) :: output !< BL thickness based on law of the wake !       real, dimension(kb:ke)             :: mthick !       real                               :: ucrit !       real                               :: umax !       integer :: k real :: B = 5.0 ! Wake parameter real :: C = 0.5 ! Coles parameter real :: kappa = 0.41 ! Von k�r�n constant real :: lam ! = Uinf/ustar lam = Uinf / ustar output = ( lam * numol / Uinf ) * exp ( kappa * ( lam - B ) - 2. * C ) ! See App. Lund et al. end subroutine blthickness subroutine blthicknessmo ( output , ustar , lmo ) ! This routine compute the BL thicknes for a buoyancy affected boundary layer: ! Newton-Raphson method is used use modglobal , only : numol , Uinf implicit none real , intent ( in ) :: ustar ! friction velocity real , intent ( in ) :: lmo ! Obukhov length real , intent ( inout ) :: output !< BL thickness based on law of the wake !       real, dimension(kb:ke)             :: mthick !       real                               :: ucrit !       real                               :: umax !       integer :: k real :: B = 5.0 ! Wake parameter real :: C = 0.5 ! Coles parameter real :: kappa = 0.41 ! Von k�r�n constant real :: cmo = 0.702 ! Constant in MO theory (0.135*5.2) real :: lam ! = Uinf/ustar real :: func , dfunc , utaunu integer :: n utaunu = ustar / numol lam = Uinf / ustar !       write(6,*) 'Initial delta, Lmo =', output,lmo do n = 1 , 10 func = log ( output ) + ( cmo * output / lmo ) + log ( utaunu ) - kappa * ( lam - B ) + 2. * C !         func   = log(output) + log(utaunu) - kappa*(lam-B) +2.*C dfunc = 1. / output + cmo / lmo output = output - ( func / dfunc ) if ( output <= 0. ) then output = di end if end do !       write(6,*) 'Computed delta, Lmo =', output,lmo end subroutine blthicknessmo subroutine wallawinlet ( utan , dx , visc , tau ) ! this should be the same as wallaw in modboundary!!! This routine is just ! copied to avoid circular dependencies implicit none real , intent ( in ) :: utan , dx , visc real , intent ( out ) :: tau real const1 , const2 , const3 , const4 real tausub , taupow real sub , dutan , utankr , utanabs real aaa , bbb real dxi parameter ( aaa = 8.3 ) parameter ( bbb = 0.1428571429 ) dxi = 1. / dx const1 = 0.5 * ( 1. - bbb ) * aaa ** (( 1. + bbb ) / ( 1. - bbb )) const2 = ( 1. + bbb ) / aaa const3 = aaa ** ( 2. / ( 1. - bbb )) const4 = 2. / ( 1. + bbb ) utanabs = abs ( utan ) utankr = 0.5 * visc * dxi * const3 dutan = utankr - utanabs sub = max ( sign ( 1. , dutan ), 0. ) tausub = 2. * visc * utanabs * dxi !      taupow3   =   const1 * (visc * dxi)**(1.+bbb) + (const2 * (visc * !      dxi)**bbb) * utanabs taupow = ( const1 * ( visc * dxi ) ** ( 1. + bbb ) + ( const2 * ( visc * dxi ) ** bbb ) * utanabs ) ** const4 !      if (taupow3<=0) then !        write(6,*) 'taupow3 <=0!!!' !      end if tau = sub * tausub + ( 1. - sub ) * taupow tau = sign ( tau , utan ) ! give tau the same sign as utan return end subroutine wallawinlet subroutine writeinletfile use modglobal , only : jb , je , kb , ke , cexpnr , ifoutput , nstore , ltempeq use modmpi , only : cmyid , myid !    use modinletdata, only : storeu0inletbc,storev0inletbc,storew0inletbc,nfile implicit none integer fileid integer j , k , n character ( 24 ) name name = 'inlet/inlet_    k   .' write ( name ( 13 : 16 ) , '(i4.4)' ) nfile name ( 18 : 20 ) = cmyid name ( 22 : 24 ) = cexpnr write ( 6 , * ) 'Writing Inlet velocity: ' , name open ( ifoutput , file = name , form = 'unformatted' , position = 'append' ) write ( ifoutput ) ((( storeu0inletbc ( j , k , n ), j = jb , je ), k = kb , ke ), n = 1 , nstore ) write ( ifoutput ) ((( storev0inletbc ( j , k , n ), j = jb , je ), k = kb , ke ), n = 1 , nstore ) write ( ifoutput ) ((( storew0inletbc ( j , k , n ), j = jb , je ), k = kb , ke + 1 ), n = 1 , nstore ) close ( ifoutput ) if ( ltempeq ) then name = 'inlet/itemp_    k   .' write ( name ( 13 : 16 ) , '(i4.4)' ) nfile name ( 18 : 20 ) = cmyid name ( 22 : 24 ) = cexpnr write ( 6 , * ) 'Writing Inlet temperature: ' , name open ( ifoutput , file = name , form = 'unformatted' , position = 'append' ) write ( ifoutput ) ((( storet0inletbc ( j , k , n ), j = jb , je ), k = kb , ke ), n = 1 , nstore ) close ( ifoutput ) end if end subroutine writeinletfile subroutine readinletfile use modglobal , only : ib , jb , je , jmax , kb , ke , cexpnr , ifinput , nstore , ltempeq , ntrun , zh , jgb , jge , jh use modmpi , only : cmyid , myid , nprocs , slabsum , excjs !    use modinletdata, only : storeu0inletbc,storev0inletbc,storew0inletbc,nfile implicit none real , dimension ( ib : ib , jb : jb + inlfactor * jmax - 1 , kbin : kein ) :: udummy real , dimension ( kbin : kein ) :: uread real , dimension ( kbin : kein ) :: ureaddzfin real , dimension ( jb : jb + jtotin - 1 , kbin : kein , 1 : nstore ) :: storeu0inold real , dimension ( jb : jb + jtotin - 1 , kbin : kein , 1 : nstore ) :: storev0inold real , dimension ( jb : jb + jtotin - 1 , kbin : kein + 1 , 1 : nstore ) :: storew0inold real , dimension ( jb : jb + jtotin - 1 , kbin : kein , 1 : nstore ) :: storet0inold real , dimension ( jb : jb + jtotdum - 1 , kbin : kein , 1 : nstore ) :: storeu0indum real , dimension ( jb : jb + jtotdum - 1 , kbin : kein , 1 : nstore ) :: storev0indum real , dimension ( jb : jb + jtotdum - 1 , kbin : kein + 1 , 1 : nstore ) :: storew0indum real , dimension ( jb : jb + jtotdum - 1 , kbin : kein , 1 : nstore ) :: storet0indum real , dimension ( jb : je , kbin : kein , 1 : nstore ) :: storeu0innew real , dimension ( jb : je , kbin : kein , 1 : nstore ) :: storev0innew real , dimension ( jb : je , kbin : kein + 1 , 1 : nstore ) :: storew0innew real , dimension ( jb : je , kbin : kein , 1 : nstore ) :: storet0innew integer filen , filee integer fileid integer j , k , n , js , jf , jfdum , jsdum character ( 24 ) name jfdum = jbdum - 1 ! initial value do fileid = filenumstart , filenumstart + ( filestoread - 1 ) if ( filen == - 1 ) then filen = nprocsinl - 1 ! -1 means the last proc (periodic) else filen = fileid - floor ( real ( fileid ) / real ( nprocsinl )) * nprocsinl ! loop over proc's end if !        write(6,*) '!!!!! filen = ', filen name = 'inlet/inlet_    k   .' write ( name ( 13 : 16 ) , '(i4.4)' ) nfile write ( name ( 18 : 20 ) , '(i3.3)' ) filen name ( 22 : 24 ) = cexpnr write ( 6 , * ) 'Reading Inlet velocity: ' , name open ( unit = ifinput , file = name , form = 'unformatted' ) read ( ifinput ) ((( storeu0inold ( j , k , n ), j = jbin , jein ), k = kbin , kein ), n = 1 , nstore ) read ( ifinput ) ((( storev0inold ( j , k , n ), j = jbin , jein ), k = kbin , kein ), n = 1 , nstore ) read ( ifinput ) ((( storew0inold ( j , k , n ), j = jbin , jein ), k = kbin , kein + 1 ), n = 1 , nstore ) close ( ifinput ) if ( ltempeq ) then name = 'inlet/itemp_    k   .' write ( name ( 13 : 16 ) , '(i4.4)' ) nfile write ( name ( 18 : 20 ) , '(i3.3)' ) filen name ( 22 : 24 ) = cexpnr write ( 6 , * ) 'Reading Inlet temperature: ' , name open ( unit = ifinput , file = name , form = 'unformatted' ) read ( ifinput ) ((( storet0inold ( j , k , n ), j = jbin , jein ), k = kbin , kein ), n = 1 , nstore ) close ( ifinput ) end if ! determine start and end indices if ( filen == procinlo ) then js = jbeg else js = jbin end if if ( filen == procinup ) then jf = jend else jf = jein end if jsdum = jfdum + 1 jfdum = jsdum + ( jf - js ) !        if (jsdum >= 3) write(6,*) 'myid, jsdum = ',myid, jsdum !        if (jfdum >= 3) write(6,*) 'myid, jfdum = ',myid, jfdum !!! put values from original in dummy variable storeu0indum ( jsdum : jfdum ,:,:) = storeu0inold ( js : jf ,:,:) ! s: start  f: final storev0indum ( jsdum : jfdum ,:,:) = storev0inold ( js : jf ,:,:) ! s: start  f: final storew0indum ( jsdum : jfdum ,:,:) = storew0inold ( js : jf ,:,:) ! s: start  f: final if ( ltempeq ) then storet0indum ( jsdum : jfdum ,:,:) = storet0inold ( js : jf ,:,:) ! s: start  f: final end if end do ! loop over original inlet files ! now interpolate in y call yinterpolate ( storeu0indum , storeu0innew , kbin , kein ) call yinterpolate ( storev0indum , storev0innew , kbin , kein ) call yinterpolate ( storew0indum , storew0innew , kbin , kein + 1 ) call yinterpolate ( storet0indum , storet0innew , kbin , kein ) if (. not . lzinzsim ) then ! interpolate when zin =/ zsim call zinterpolate ( storeu0innew (:,:,:), storeu0inletbc ) ! interpolate inlet profile to zgrid call zinterpolate ( storev0innew (:,:,:), storev0inletbc ) ! interpolate inlet profile to zgrid call zinterpolatew ( storew0innew (:,:,:), storew0inletbc ) ! interpolate inlet profile to zgrid if ( ltempeq ) then call zinterpolatet ( storet0innew (:,:,:), storet0inletbc ) ! interpolate inlet profile to zgrid end if else storeu0inletbc (:,:,:) = storeu0inold (:,:,:) storev0inletbc (:,:,:) = storev0inold (:,:,:) storew0inletbc (:,:,:) = storew0inold (:,:,:) if ( ltempeq ) then storet0inletbc (:,:,:) = storet0inold (:,:,:) end if end if if ( iangle /= 0.0 ) then ! modify for inflow angle do n = 1 , nstore do k = kb , ke do j = jb , je u0rot ( n , j , k ) = storeu0inletbc ( j , k , n ) ! swap indices in order v0rot ( n , j , k ) = storev0inletbc ( j , k , n ) ! to use excjs end do end do end do call excjs ( u0rot , 1 , nstore , jb , je , kb , ke , 0 , jh ) call excjs ( v0rot , 1 , nstore , jb , je , kb , ke , 0 , jh ) !         write(6,*) 'v0rot(1,je+1,30) = ',v0rot(1,je+1,30) do n = 1 , nstore do k = kb , ke do j = jb , je ! apply horizontal rotation (neglecting the delta_x difference) storeu0inletbc ( j , k , n ) = u0rot ( n , j , k ) * cos ( iangle ) - 0.5 * sin ( iangle ) * ( v0rot ( n , j , k ) + v0rot ( n , j + 1 , k )) storev0inletbc ( j , k , n ) = v0rot ( n , j , k ) * cos ( iangle ) + 0.5 * sin ( iangle ) * ( u0rot ( n , j , k ) + u0rot ( n , j - 1 , k )) end do end do end do end if ! iangle =/0.0 end subroutine readinletfile subroutine zinterpolate ( input , output ) use modglobal , only : jb , je , kb , ke , zf , nstore implicit none real , dimension ( jb : je , kbin : kein , 1 : nstore ), intent ( in ) :: input real , dimension ( jb : je , kb : ke , 1 : nstore ), intent ( inout ) :: output integer k do k = kb , ke if ( linuf ( k ) == kein + 1 ) then ! indicator for extrapolation! output (:, k ,:) = input (:, kein ,:) elseif ( linlf ( k ) == kbin - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) output (:, k ,:) = input (:, kbin ,:) / zfin ( kbin ) * zf ( k ) !        output(:,k,:) = input(:,kbin,:)   ! temeperature is not zero at the wall, so line above is wrong else ! normal interpolation output (:, k ,:) = input (:, linlf ( k ),:) + ( input (:, linuf ( k ),:) - input (:, linlf ( k ),:)) / ( zfin ( linuf ( k )) - zfin ( linlf ( k ))) * ( zf ( k ) - zfin ( linlf ( k ))) if (( zf ( k ) . gt . zfin ( linuf ( k ))) . or . ( zf ( k ) . lt . zfin ( linlf ( k )))) then write ( 6 , * ) '!!!Mistake in zinterpolate !!!!' end if end if end do end subroutine zinterpolate subroutine zinterpolate1d ( input , output ) use modglobal , only : kb , ke , zf implicit none real , dimension ( kbin : kein ), intent ( in ) :: input real , dimension ( kb : ke ), intent ( inout ) :: output integer k do k = kb , ke if ( linuf ( k ) == kein + 1 ) then ! indicator for extrapolation! output ( k ) = input ( kein ) elseif ( linlf ( k ) == kbin - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) output ( k ) = input ( kbin ) / zfin ( kbin ) * zf ( k ) !        output(:,k,:) = input(:,kbin,:)   ! temeperature is not zero at the wall, so line above is wrong else ! normal interpolation output ( k ) = input ( linlf ( k )) + ( input ( linuf ( k )) - input ( linlf ( k ))) / ( zfin ( linuf ( k )) - zfin ( linlf ( k ))) * ( zf ( k ) - zf ( linlf ( k ))) if (( zf ( k ) . gt . zfin ( linuf ( k ))) . or . ( zf ( k ) . lt . zfin ( linlf ( k )))) then write ( 6 , * ) '!!!Mistake in zinterpolate1d !!!!' end if end if end do end subroutine zinterpolate1d subroutine zinterpolate2d ( input , output ) use modglobal , only : ib , ie , kb , ke , zf , nstore implicit none real , dimension ( ib : ie , kbin : kein ), intent ( in ) :: input real , dimension ( ib : ie , kb : ke ), intent ( inout ) :: output integer k do k = kb , ke if ( linuf ( k ) == kein + 1 ) then ! indicator for extrapolation! output (:, k ) = input (:, kein ) elseif ( linlf ( k ) == kbin - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) output (:, k ) = input (:, kbin ) / zfin ( kbin ) * zf ( k ) !        output(:,k,:) = input(:,kbin,:)   ! temeperature is not zero at the wall, so line above is wrong else ! normal interpolation output (:, k ) = input (:, linlf ( k )) + ( input (:, linuf ( k )) - input (:, linlf ( k ))) / ( zfin ( linuf ( k )) - zfin ( linlf ( k ))) * ( zf ( k ) - zf ( linlf ( k ))) if (( zf ( k ) . gt . zfin ( linuf ( k ))) . or . ( zf ( k ) . lt . zfin ( linlf ( k )))) then write ( 6 , * ) '!!!Mistake in zinterpolate2d !!!!' end if end if end do end subroutine zinterpolate2d subroutine zinterpolatew ( input , output ) use modglobal , only : jb , je , kb , ke , zh , nstore implicit none real , dimension ( jb : je , kbin : kein + 1 , 1 : nstore ), intent ( in ) :: input real , dimension ( jb : je , kb : ke + 1 , 1 : nstore ), intent ( inout ) :: output integer k do k = kb , ke + 1 if ( linuh ( k ) == kein + 2 ) then ! indicator for extrapolation! output (:, k ,:) = input (:, kein + 1 ,:) elseif ( linlh ( k ) == kbin - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) output (:, k ,:) = input (:, kbin ,:) ! =0 !        output(:,k,:) = input(:,kbin,:)/zhin(kbin) * zh(k) !        output(:,k,:) = input(:,kbin,:)   ! temeperature is not zero at the wall, so line above is wrong else ! normal interpolation output (:, k ,:) = input (:, linlh ( k ),:) + ( input (:, linuh ( k ),:) - input (:, linlh ( k ),:)) / ( zhin ( linuh ( k )) - zhin ( linlh ( k ))) * ( zh ( k ) - zhin ( linlh ( k ))) if (( zh ( k ) . gt . zhin ( linuh ( k ))) . or . ( zh ( k ) . lt . zhin ( linlh ( k )))) then write ( 6 , * ) '!!!Mistake in zinterpolatew !!!!' end if end if end do end subroutine zinterpolatew subroutine zinterpolatew1d ( input , output ) use modglobal , only : kb , ke , zh implicit none real , dimension ( kbin : kein + 1 ), intent ( in ) :: input real , dimension ( kb : ke + 1 ), intent ( inout ) :: output integer k do k = kb , ke + 1 if ( linuh ( k ) == kein + 2 ) then ! indicator for extrapolation! output ( k ) = input ( kein + 1 ) elseif ( linlh ( k ) == kbin - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) output ( k ) = input ( kbin ) !=0 !        output(k) = input(kbin)/zhin(kbin) * zh(k) !        output(:,k,:) = input(:,kbin,:)   ! temeperature is not zero at the wall, so line above is wrong else ! normal interpolation output ( k ) = input ( linlh ( k )) + ( input ( linuh ( k )) - input ( linlh ( k ))) / ( zhin ( linuh ( k )) - zhin ( linlh ( k ))) * ( zh ( k ) - zh ( linlh ( k ))) if (( zh ( k ) . gt . zhin ( linuh ( k ))) . or . ( zh ( k ) . lt . zhin ( linlh ( k )))) then write ( 6 , * ) '!!!Mistake in zinterpolatew1d !!!!' end if end if end do end subroutine zinterpolatew1d subroutine zinterpolatet ( input , output ) use modglobal , only : jb , je , kb , ke , zf , nstore use modsurfdata , only : thls implicit none real , dimension ( jb : je , kbin : kein , 1 : nstore ), intent ( in ) :: input real , dimension ( jb : je , kb : ke , 1 : nstore ), intent ( inout ) :: output integer k do k = kb , ke if ( linuf ( k ) == kein + 1 ) then ! indicator for extrapolation! output (:, k ,:) = input (:, kein ,:) elseif ( linlf ( k ) == kbin - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) output (:, k ,:) = thls + ( input (:, kb ,:) - thls ) / zfin ( kbin ) * zf ( k ) !         output(:,k,:) = (input(:,kb,:)-thls)/zfin(kbin)*zf(k) !        output(:,k,:) = input(:,kbin,:)/zfin(kbin) * zf(k) !        output(:,k,:) = input(:,kbin,:)   ! temeperature is not zero at the wall, so line above is wrong else ! normal interpolation output (:, k ,:) = input (:, linlf ( k ),:) + ( input (:, linuf ( k ),:) - input (:, linlf ( k ),:)) / ( zfin ( linuf ( k )) - zfin ( linlf ( k ))) * ( zf ( k ) - zfin ( linlf ( k ))) if (( zf ( k ) . gt . zfin ( linuf ( k ))) . or . ( zf ( k ) . lt . zfin ( linlf ( k )))) then write ( 6 , * ) '!!!Mistake in zinterpolatet !!!!' end if end if end do end subroutine zinterpolatet subroutine zinterpolatet1d ( input , output ) use modglobal , only : jb , je , kb , ke , zf , nstore use modsurfdata , only : thls implicit none real , dimension ( kbin : kein ), intent ( in ) :: input real , dimension ( kb : ke ), intent ( inout ) :: output integer k do k = kb , ke if ( linuf ( k ) == kein + 1 ) then ! indicator for extrapolation! output ( k ) = input ( kein ) elseif ( linlf ( k ) == kbin - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) output ( k ) = ( input ( kb ) - thls ) / zfin ( kbin ) * zf ( k ) !        output(:,k,:) = input(:,kbin,:)/zfin(kbin) * zf(k) !        output(:,k,:) = input(:,kbin,:)   ! temeperature is not zero at the wall, so line above is wrong else ! normal interpolation output ( k ) = input ( linlf ( k )) + ( input ( linuf ( k )) - input ( linlf ( k ))) / ( zfin ( linuf ( k )) - zfin ( linlf ( k ))) * ( zf ( k ) - zf ( linlf ( k ))) if (( zf ( k ) . gt . zfin ( linuf ( k ))) . or . ( zf ( k ) . lt . zfin ( linlf ( k )))) then write ( 6 , * ) '!!!Mistake in zinterpolatet1d !!!!' end if end if end do end subroutine zinterpolatet1d subroutine yinterpolate ( input , output , ks , kf ) use modglobal , only : jb , je , nstore integer , intent ( in ) :: ks integer , intent ( in ) :: kf real , dimension ( jbdum : jedum , ks : kf , 1 : nstore ), intent ( in ) :: input real , dimension ( jb : je , ks : kf , 1 : nstore ), intent ( inout ) :: output integer j do j = jb , je !      if (np==0 .and. yloclowf(j)==) output ( j ,:,:) = input ( yloclowf ( j ),:,:) + ( input ( ylocupf ( j ),:,:) - input ( yloclowf ( j ),:,:)) / ( yfdum ( ylocupf ( j )) - yfdum ( yloclowf ( j ))) * ( yf ( j ) - yfdum ( yloclowf ( j ))) end do end subroutine yinterpolate subroutine yinterpolateh ( input , output , ks , kf ) use modglobal , only : jb , je , nstore integer , intent ( in ) :: ks integer , intent ( in ) :: kf real , dimension ( jbdum : jedum , ks : kf , 1 : nstore ), intent ( in ) :: input real , dimension ( jb : je , ks : kf , 1 : nstore ), intent ( inout ) :: output integer j , jj do j = jb , je !      if (np==0 .and. yloclowf(j)==) output ( j ,:,:) = input ( yloclowh ( j ),:,:) + ( input ( ylocuph ( j ),:,:) - input ( yloclowh ( j ),:,:)) / ( yhdum ( ylocuph ( j )) - yhdum ( yloclowh ( j ))) * ( yh ( j ) - yhdum ( yloclowh ( j ))) end do end subroutine yinterpolateh subroutine readzincoord use modglobal , only : kb , ke , kh , ifinput , zf , zh , ysize , jb , je , dy use modmpi , only : myid , mpi_integer , comm3d , mpierr , my_real , nprocs implicit none character ( 72 ) chmess character ( 20 ) namezinlet character ( 20 ) namezinfo integer ierr , k , kk , kmaxin , j , jj real ysizeproc namelist / INFO / nprocsinl , jgtotinl , kmaxin , dtin , wtop , totalreadu namezinlet = 'zgrid.inl' namezinfo = 'zgrid.inf' if ( myid == 0 ) then open ( ifinput , file = namezinfo , status = 'old' , iostat = ierr ) if ( ierr /= 0 ) then write ( 0 , * ) 'ERROR: zgrid.inf does not exist' stop 1 end if read ( ifinput , INFO , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'Problem in zgrid.inf INFO' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif write ( 6 , INFO ) close ( ifinput ) end if kbin = 0 kein = kmaxin - 1 call MPI_BCAST ( nprocsinl , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( jgtotinl , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( kbin , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( kein , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( dtin , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wtop , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( totalreadu , 1 , MY_REAL , 0 , comm3d , mpierr ) allocate ( zhin ( kbin : kein + 1 )) allocate ( zfin ( kbin : kein + 1 )) allocate ( dzfin ( kbin - 1 : kein + 1 )) allocate ( dzhin ( kbin : kein + 1 )) if ( myid == 0 ) then write ( 6 , * ) 'loading ' , namezinlet open ( ifinput , file = namezinlet ) read ( ifinput , '(a72)' ) chmess read ( ifinput , '(a72)' ) chmess do k = kbin , kein read ( ifinput , * ) zfin ( k ) end do close ( ifinput ) zhin ( kbin ) = 0.0 do k = kbin , kein zhin ( k + 1 ) = zhin ( k ) + 2.0 * ( zfin ( k ) - zhin ( k )) end do zfin ( kein + kh ) = zfin ( kein ) + 2.0 * ( zhin ( kein + kh ) - zfin ( kein )) do k = kbin , kein dzfin ( k ) = zhin ( k + 1 ) - zhin ( k ) end do dzfin ( kein + 1 ) = dzfin ( kein ) dzfin ( kbin - 1 ) = dzfin ( kbin ) dzhin ( kbin ) = 2 * zfin ( kbin ) do k = kbin + 1 , kein + kh dzhin ( k ) = zfin ( k ) - zfin ( k - 1 ) end do ! check if the inlet mesh and the simulation mesh differ do k = kb , min ( ke , kein ) if ( abs ( zfin ( k ) - zf ( k )) > 1e-7 ) then lzinzsim = . false . end if enddo end if ! myid==0 ! MPI broadcast kmax elements from zf call MPI_BCAST ( zfin , kein - kbin + 2 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( zhin , kein - kbin + 2 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dzfin , kein - kbin + 3 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dzhin , kein - kbin + 2 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lzinzsim , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) if (. not . lzinzsim ) then if ( myid == 0 ) then write ( 6 , * ) 'zgrid.inl does not equal zgrid.inp: Inlet will be interpolated in z' end if !      allocate(linlf(kbin:kein)) !      allocate(linuf(kbin:kein)) !      allocate(linlh(kbin:kein+1)) !      allocate(linuh(kbin:kein+1)) allocate ( linlf ( kb : ke )) allocate ( linuf ( kb : ke )) allocate ( linlh ( kb : ke + 1 )) allocate ( linuh ( kb : ke + 1 )) ! zf do k = kb , ke do kk = kbin , kein if ( zfin ( kk ) >= zf ( k )) then linuf ( k ) = kk linlf ( k ) = kk - 1 exit elseif ( kk == kein ) then linuf ( k ) = kein + 1 ! this means extrapolation! linlf ( k ) = kein - 1 ! waarom niet ke? of wordt dit niet gebruikt? end if end do end do ! for w-components (zh) do k = kb , ke + 1 do kk = kbin , kein + 1 if ( zhin ( kk ) >= zh ( k )) then linuh ( k ) = kk linlh ( k ) = kk - 1 exit elseif ( kk == kein + 1 ) then linuh ( k ) = kein + 2 ! this means extrapolation! linlh ( k ) = kein end if end do end do else ! lzinzsim  -> grids are equal if ( myid == 0 ) then write ( 6 , * ) 'zgrid.inl equals zgrid.inp: Inlet will not be interpolated in z' end if end if ! Now prepare everything for interpolation in y-direction jgbin = 1 jgein = jgbin + jgtotinl - 1 jtotin = jgtotinl / nprocsinl jbin = 1 jein = 1 + jtotin - 1 ysizeproc = ysize / nprocs dyin = ysize / jgtotinl jbdum = 1 jtotdum = ceiling ( ysizeproc / real ( dyin )) + 1 ! dummy indices jedum = jbdum + jtotdum - 1 !     allocate(yf   (jb    :je)) allocate ( yf ( jb : je + 1 )) allocate ( yh ( jb : je + 1 )) allocate ( yfin ( jgbin : jgein + 1 )) allocate ( yhin ( jgbin - 1 : jgein + 1 )) !     allocate(yfdum(jbdum :jedum)) allocate ( yfdum ( jbdum : jedum + 1 )) allocate ( yhdum ( jbdum : jedum + 1 )) allocate ( yloclowf ( jb : je + 1 )) allocate ( ylocupf ( jb : je + 1 )) allocate ( yloclowh ( jb : je + 1 )) allocate ( ylocuph ( jb : je + 1 )) ! make global y-grid (equidistant) for inlet data do j = jgbin - 1 , jgein + 1 yhin ( j ) = ( j - jgbin ) * dyin end do do j = jgbin , jgein + 1 yfin ( j ) = yhin ( j ) + 0.5 * dyin end do ! make new y-grid (equidistant) do j = jb , je + 1 yh ( j ) = myid * ( ysize / nprocs ) + ( j - jb ) * dy yf ( j ) = yh ( j ) + 0.5 * dy end do ! check which original cells are needed for interpolation do j = jgein + 1 , jgbin , - 1 if ( yhin ( j ) <= yh ( jb )) then if ( yfin ( j ) <= yf ( jb )) then procinlo = floor ( real ( j - jgbin ) / real ( jtotin )) ! this is the first cell to consider filenumstart = procinlo jgbeg = j jbeg = j - ( procinlo * jtotin ) !            jend = jbeg+jtotdum-1 jj = j + jtotdum - 1 !            procinup = floor((j-jgbin)/real(jtotin)) !            procinup = floor((j-jgbin+1)/real(jtotin)) procinup = floor ( real ( jj - jgbin ) / real ( jtotin )) filenumend = procinup jend = jj - ( procinup * jtotin ) procinup = procinup - floor ( real ( procinup ) / real ( nprocsinl )) * nprocsinl ! continue on first procinl again else if ( j == jgbin ) then jgbeg = j - 1 jbeg = jein procinlo = nprocsinl - 1 filenumstart = - 1 jj = j + jtotdum - 2 procinup = floor ( real ( jj - jgbin ) / real ( jtotin )) filenumend = procinup jend = jj - ( procinup * jtotin ) procinup = procinup - floor ( real ( procinup ) / real ( nprocsinl )) * nprocsinl !continue on first procinl again else procinlo = floor ( real ( j - jgbin - 1 ) / real ( jtotin )) ! One cell lower is needed filenumstart = procinlo jgbeg = j - 1 jbeg = j - ( procinlo * jtotin ) - 1 jj = j + jtotdum - 2 procinup = floor ( real ( jj - jgbin ) / real ( jtotin )) filenumend = procinup jend = jj - ( procinup * jtotin ) procinup = procinup - floor ( real ( procinup ) / real ( nprocsinl )) * nprocsinl ! continue on first procinl again end if ! j=jgbin end if exit end if end do write ( 6 , * ) '!! myid,procinlo,jbeg,procinup,jend,jgbeg = ' , myid , procinlo , jbeg , procinup , jend , jgbeg ! make dummy y-grid (equidistant) do j = jbdum , jedum + 1 yhdum ( j ) = yhin ( jgbeg ) + ( j - jbdum + 1 ) * dyin yfdum ( j ) = yhdum ( j ) + 0.5 * dyin end do !      if (procoldup /= procoldlo) then !        write(6,*) '!!! Start-cell and end-cell are not in the same file!!!' !      end if filestoread = filenumend - filenumstart + 1 ! no. of files to be read !      write(6,*) '!! procinlo,procinup = ',procinlo,procinup !      write(6,*) '!! jbin,jein,jbeg,jend= ',jbin,jein,jbeg,jend ! for components defined on yf do j = jb , je do jj = jbdum + 1 , jedum + 1 if ( yfdum ( jj ) >= yf ( j )) then ylocupf ( j ) = jj yloclowf ( j ) = jj - 1 exit end if end do end do ! for components defined on yh do j = jb , je + 1 do jj = jbdum + 1 , jedum + 1 if ( yhdum ( jj ) >= yh ( j )) then ylocuph ( j ) = jj yloclowh ( j ) = jj - 1 exit end if end do end do end subroutine readzincoord subroutine exitinlet use modglobal , only : iinletgen , lstoreplane , ltempeq if ( iinletgen == 1 ) then deallocate ( Uinl , Winl , Urec , Wrec , u0inletbc , v0inletbc , w0inletbc , zirf , ziif , ziih , zirh , zorf , zoif , zorh , zoih , loclowif , locupif , loclowih , locupih , loclowof , locupof , loclowoh , locupoh , uminletbc , vminletbc , wminletbc , u0inletbcold , v0inletbcold , w0inletbcold , Utav , upupavinl , vpvpavinl , wpwpavinl , upwpavinl , thlpthlpavinl , thlpupavinl , thlpwpavinl ) if ( ltempeq ) then deallocate ( t0inletbc , tminletbc , t0inletbcold , loclowot , locupot , zotr , zoti , Tinl , Trec ) end if if ( lstoreplane ) then deallocate ( storeu0inletbc , storev0inletbc , storew0inletbc ) if ( ltempeq ) then deallocate ( storet0inletbc ) end if end if else if ( iinletgen == 2 ) then deallocate ( storeu0inletbc , storev0inletbc , storew0inletbc , u0inletbc , v0inletbc , w0inletbc , uminletbc , vminletbc , wminletbc , u0inletbcold , v0inletbcold , w0inletbcold ) if ( ltempeq ) then deallocate ( t0inletbc , tminletbc , t0inletbcold , storet0inletbc ) end if end if end subroutine exitinlet end module","tags":"","loc":"sourcefile/modinlet.f90.html"},{"title":"scalsource.f90 – uDALES","text":"This file depends on sourcefile~~scalsource.f90~~EfferentGraph sourcefile~scalsource.f90 scalsource.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~scalsource.f90->sourcefile~modglobal.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~scalsource.f90->sourcefile~modfields.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~scalsource.f90->sourcefile~initfac.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~scalsource.f90->sourcefile~modmpi.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines createscals scalsource Source Code scalsource.f90 Source Code !> \\file scalsource.f90 !!tg3315, 8 Apr 2016 !> Input point, line or planar scalars subroutine createscals use modglobal , only : nsv , ib , ie , jb , je , kb , ke , ih , jh , kh , lscasrcr , cexpnr , ifinput , imax , jmax , jtot ,& libm , nblocks , xSa , ySa , zSa , lscasrc , xS , yS , zS use modfields , only : scar , scarl use modmpi , only : myid , MY_REAL , comm3d , mpierr use initfac , only : block implicit none integer :: i , j , k , n , m , p , il , iu , jl , ju , ku ! if (lscasrc) then ! allocate(xSa(1:nsv)) ! allocate(ySa(1:nsv)) ! allocate(zSa(1:nsv)) ! hard code point source locations ! xSa(1:nsv) = (/ 453., 463., 523., 539., 407. /) ! ySa(1:nsv) = (/ 375., 371., 327., 341., 325. /) ! zSa(1:nsv) = (/ 4.   , 4.   , 4. , 4.  , 4.  /) ! all point sources from position defined in namoptions ! xSa = xS; ySa = yS; zSa = zS ! end if if ( lscasrcr . AND . nsv . gt . 0 ) then ! read 2-D field of point sources for vehicular emissions network open ( ifinput , file = 'scals.inp.' // cexpnr ) do j = jb , jtot read ( ifinput , * ) scar (:, j ) end do scarl ( ib : ie , jb : je ) = scar ( ib : ie , jb + myid * jmax : je + myid * jmax ) ! Set scarl to 0 if set inside an obstacle if ( libm ) then do n = 1 , nblocks il = block ( n , 1 ) iu = block ( n , 2 ) jl = block ( n , 3 ) - myid * jmax ju = block ( n , 4 ) - myid * jmax ku = block ( n , 6 ) if ( ju < jb . or . jl > je ) then cycle else if ( ju > je ) ju = je if ( jl < jb ) jl = jb ! addition due to all blocks at lowest layer if ( ku > 0 ) then scarl ( il : iu , jl : ju ) = 0. end if end if end do end if end if !lscasrcr end subroutine subroutine scalsource use modglobal , only : nsv , ib , ie , jb , je , kb , ke , ih , jh , kh , ihc , jhc , khc , xf , zf , xh , zh , dy , jmax , lchem ,& xS , yS , zS , SS , sigS , lscasrc , lscasrcl , lscasrcr , libm , dxfi , dzfi , nblocks , xSa , ySa , zSa use modfields , only : svp , svpp , scar , scarl use modmpi , only : myid , mpierr , MY_REAL , comm3d , MPI_SUM use initfac , only : block implicit none integer :: i , j , k , n , il , iu , jl , ju , kl , ku , ncan real :: xL , zL real :: dyi real :: ra2 = 0. real :: scalsum = 0. real :: scalsumt = 0. real :: Pi = 3.1415927 dyi = 1. / dy ! 2-D network of point sources at lowest level if ( lscasrcr . AND . nsv . gt . 0 ) then if ( lchem ) then svp ( ib : ie , jb : je , kb + 1 , 1 ) = svp ( ib : ie , jb : je , kb + 1 , 1 ) + 0.522 * scarl svp ( ib : ie , jb : je , kb + 1 , 2 ) = svp ( ib : ie , jb : je , kb + 1 , 2 ) + 0.2 * scarl svp ( ib : ie , jb : je , kb + 1 , 4 ) = svp ( ib : ie , jb : je , kb + 1 , 4 ) + scarl else svp ( ib : ie , jb : je , kb + 1 , 1 ) = svp ( ib : ie , jb : je , kb + 1 , 1 ) + scarl end if end if !lscasrcr scalsum = 0. !  Input passive scalar point sources if ( lscasrc . AND . nsv . gt . 0 ) then do n = 1 , nsv do k = kb , ke do j = jb , je do i = ib , ie ra2 = ( xf ( i ) - xS ) ** 2 + (( j + myid * jmax - 0.5 ) * dy - yS ) ** 2 + ( zf ( k ) - zS ) ** 2 if ( ra2 . LE . 9 * sigS ** 2 ) then scalsum = scalsum + dxfi ( i ) * dyi * dzfi ( k ) * SS * exp ( - ra2 / ( 2 * sigS ** 2 )) svp ( i , j , k , n ) = svp ( i , j , k , n ) + dxfi ( i ) * dyi * dzfi ( k ) * SS * exp ( - ra2 / ( 2 * sigS ** 2 )) end if end do end do end do end do ! Set svpp to 0 when set inside an obstacle if ( libm ) then do n = 1 , nblocks il = block ( n , 1 ) iu = block ( n , 2 ) kl = block ( n , 5 ) ku = block ( n , 6 ) jl = block ( n , 3 ) - myid * jmax ju = block ( n , 4 ) - myid * jmax if ( ju < jb . or . jl > je ) then cycle else if ( ju > je ) ju = je if ( jl < jb ) jl = jb svp ( il : iu , jl : ju , kl : ku ,:) = 0. end if end do end if ! Normalise scalar field to 1/s !call MPI_ALLREDUCE(scalsum,scalsumt,1,MY_REAL,MPI_SUM,comm3d,mpierr) !svpp(:,:,:,1) = svpp(:,:,:,1) / scalsumt !svp(:,:,:,1) = svp(:,:,:,1) + svpp(:,:,:,1) scalsum = 0. end if !lscasrc ! Input passive scalar line sources if ( lscasrcl . AND . nsv . gt . 0 ) then ncan = count ( block (:, 6 ) > 0 ) !tg3315 update due to block at lowest level zL = zf ( kb + 1 ) if ( nblocks > 0 ) then do n = 1 , ncan - 1 ! not ncan and ncan+1 because we do not want release in first and last canyon for BCxs==2 if ( n == ncan + 1 ) then ! Added to run for pollutant in first canyon !xL = xh(block(1,1) - (block(2,1) - block(1,2)+1)/2) xL = xh ( block ( 1 , 1 )) - 0.5 * ( xh ( block ( 2 , 1 )) - xh ( block ( 1 , 2 ) + 1 )) !          ra2 = (i - (block(1,1) - (block(2,1) - block(1,2))/2.0))**2 + (k)**2 !tg3315 commented for chem validation else !cycle through all other canyons !xL = xh(block(n,2) + (block(2,1) - block(1,2)+1)/2) xL = xh ( block ( n , 2 ) + 1 ) + 0.5 * ( xh ( block ( 2 , 1 )) - xh ( block ( 1 , 2 ) + 1 )) !          ra2 =(xf(i) - xL)**2 + zf(k)**2 end if do i = ib , ie do k = kb , ke !           if (ra2 .LE. 12*sigS**2) then !scalsum = scalsum + dxf(i) * jmax * dy * dzf(k) * (SS/2*Pi*sigS**2) * exp(-ra2/(2*sigS**2)) !tg3315 use this if we want to normalise th scalar conc. !sums values in building too... !              scalsum = scalsum + dy * (je - jb +1) * ( (SS/4.) * & !                        (erf((xh(i+1)-xL)/(sqrt(2.)*sigS)) - erf((xh(i)-xL)/(sqrt(2.)*sigS))) * & !                        (erf((zh(k+1)-zh(kb+1))/(sqrt(2.)*sigS)) - erf((zh(k)-zh(kb+1))/(sqrt(2.)*sigS))) + & !                        (SS/4.) * & !                        (erf((xh(i+1)-xL)/(sqrt(2.)*sigS)) - erf((xh(i)-xL)/(sqrt(2.)*sigS))) * & !                        (erf((zh(k+1)+zh(kb+1))/(sqrt(2.)*sigS)) - erf((zh(k)+zh(kb+1))/(sqrt(2.)*sigS))) ) !                        * dxfi(i) * dzfi(k) svp ( i , jb : je , k , 1 ) = svp ( i , jb : je , k , 1 ) + ( ( SS / 4. ) * & ! SS in g/ms... no normalisation ( erf (( xh ( i + 1 ) - xL ) / ( sqrt ( 2. ) * sigS )) - erf (( xh ( i ) - xL ) / ( sqrt ( 2. ) * sigS ))) * & ( erf (( zh ( k + 1 ) - zL ) / ( sqrt ( 2. ) * sigS )) - erf (( zh ( k ) - zL ) / ( sqrt ( 2. ) * sigS ))) + & ( SS / 4. ) * & ! reflection from ground... ( erf (( xh ( i + 1 ) - xL ) / ( sqrt ( 2. ) * sigS )) - erf (( xh ( i ) - xL ) / ( sqrt ( 2. ) * sigS ))) * & ( erf (( zh ( k ) - 2 * ( zh ( k ) - zh ( kb + 1 )) - zL ) / ( sqrt ( 2. ) * sigS )) - erf (( zh ( k + 1 ) - 2 * ( zh ( k + 1 ) - zh ( kb + 1 )) - zL ) / ( sqrt ( 2. ) * sigS ))) ) & * dxfi ( i ) * dzfi ( k ) !svp(i,jb:je,k,3) = svp(i,jb:je,k,3) + ( (SS/4.) * & ! SS in g/ms... no normalisation !          (erf((xh(i+1)-xL)/(sqrt(2.)*sigS)) - erf((xh(i)-xL)/(sqrt(2.)*sigS))) * & !          (erf((zh(k+1)-zL)/(sqrt(2.)*sigS)) - erf((zh(k)-zL)/(sqrt(2.)*sigS))) + & !          (SS/4.) * & ! reflection from ground... !          (erf((xh(i+1)-xL)/(sqrt(2.)*sigS)) - erf((xh(i)-xL)/(sqrt(2.)*sigS))) * & !          (erf((zh(k)-2*(zh(k)-zh(kb+1))-zL)/(sqrt(2.)*sigS)) - erf((zh(k+1)-2*(zh(k+1)-zh(kb+1))-zL)/(sqrt(2.)*sigS))) ) & !          * dxfi(i) * dzfi(k) !            end if end do end do end do end if !nblocks ! Set svpp to 0 when set inside an obstacle if ( libm ) then do n = 1 , nblocks il = block ( n , 1 ) iu = block ( n , 2 ) kl = kb ku = block ( n , 6 ) jl = block ( n , 3 ) - myid * jmax ju = block ( n , 4 ) - myid * jmax if ( ju < jb . or . jl > je ) then cycle else if ( ju > je ) ju = je if ( jl < jb ) jl = jb svp ( il : iu , jl : ju , kl : ku ,:) = 0. end if end do end if !libm ! Normalise scalar field to 1/s !    call MPI_ALLREDUCE(scalsum,scalsumt,1,MY_REAL,MPI_SUM,comm3d,mpierr) !    write(*,*), 'scalsum', scalsum !    if (lchem) then !svpp(:,:,:,1) = svpp(:,:,:,1) !      svp(:,:,:,1) = svp(:,:,:,1) + svpp(:,:,:,1) !svp(:,:,:,2) = svp(:,:,:,2) + 0.1518 * svpp(:,:,:,1) !    else !      svpp(:,:,:,1) = svpp(:,:,:,1)/ scalsumt !tg3315 not normalised 07/11/2017 !      svp(:,:,:,1) = svp(:,:,:,1) + svpp(:,:,:,1) !svp(:,:,:,2) = svp(:,:,:,2) + 0.1518 * svpp(:,:,:,1) !    end if svpp = 0. scalsum = 0. end if !lscasrcl end subroutine scalsource","tags":"","loc":"sourcefile/scalsource.f90.html"},{"title":"modboundary.f90 – uDALES","text":"This file depends on sourcefile~~modboundary.f90~~EfferentGraph sourcefile~modboundary.f90 modboundary.f90 sourcefile~modinlet.f90 modinlet.f90 sourcefile~modboundary.f90->sourcefile~modinlet.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~modboundary.f90->sourcefile~modsubgriddata.f90 sourcefile~modsurfdata.f90 modsurfdata.f90 sourcefile~modboundary.f90->sourcefile~modsurfdata.f90 sourcefile~modinletdata.f90 modinletdata.f90 sourcefile~modboundary.f90->sourcefile~modinletdata.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modboundary.f90->sourcefile~modfields.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modboundary.f90->sourcefile~modglobal.f90 sourcefile~moddriver.f90 moddriver.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modboundary.f90->sourcefile~modmpi.f90 sourcefile~modinlet.f90->sourcefile~modsurfdata.f90 sourcefile~modinlet.f90->sourcefile~modinletdata.f90 sourcefile~modinlet.f90->sourcefile~modfields.f90 sourcefile~modinlet.f90->sourcefile~modglobal.f90 sourcefile~modinlet.f90->sourcefile~modmpi.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~modinlet.f90->sourcefile~modsave.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 sourcefile~moddriver.f90->sourcefile~modinletdata.f90 sourcefile~moddriver.f90->sourcefile~modfields.f90 sourcefile~moddriver.f90->sourcefile~modglobal.f90 sourcefile~moddriver.f90->sourcefile~modmpi.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~modsave.f90->sourcefile~modsubgriddata.f90 sourcefile~modsave.f90->sourcefile~modsurfdata.f90 sourcefile~modsave.f90->sourcefile~modinletdata.f90 sourcefile~modsave.f90->sourcefile~modfields.f90 sourcefile~modsave.f90->sourcefile~modglobal.f90 sourcefile~modsave.f90->sourcefile~modmpi.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~modsave.f90->sourcefile~modibmdata.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~modsave.f90->sourcefile~initfac.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~modboundary.f90~~AfferentGraph sourcefile~modboundary.f90 modboundary.f90 sourcefile~modpois.f90 modpois.f90 sourcefile~modpois.f90->sourcefile~modboundary.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~modstartup.f90->sourcefile~modboundary.f90 sourcefile~modstartup.f90->sourcefile~modpois.f90 sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~modstartup.f90->sourcefile~modsubgrid.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modboundary.f90 sourcefile~program.f90->sourcefile~modpois.f90 sourcefile~program.f90->sourcefile~modstartup.f90 sourcefile~program.f90->sourcefile~modsubgrid.f90 sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 sourcefile~modsubgrid.f90->sourcefile~modboundary.f90 sourcefile~modstatsdump.f90->sourcefile~modsubgrid.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules modboundary Source Code modboundary.f90 Source Code !> \\file modboundary.f90 !> !> !! \\par Revision list !! All boundary conditions are in this file, except for immersed boundaries. !! \\par Authors !! module modboundary implicit none save private public :: initboundary , boundary , grwdamp , ksp , tqaver , & bcp , bcpup , closurebc integer :: ksp = - 1 !<    lowest level of sponge layer real , allocatable :: tsc (:) !<   damping coefficients to be used in grwdamp. real :: rnu0 = 2.75e-3 contains !> !! Initializing Boundary; specifically the sponge layer !> subroutine initboundary use modglobal , only : ib , kb , ke , kh , kmax , pi , zf , iplane use modinletdata , only : irecy , irecydriver implicit none real :: zspb , zspt integer :: k allocate ( tsc ( kb : ke + kh )) ! Sponge layer if ( ksp == - 1 ) then !      ksp  = min(3*kmax/4,kmax - 15) ksp = ( kb - 1 ) + max ( min ( 3 * kmax / 4 , kmax - 15 ), 1 ) end if zspb = zf ( ksp ) zspt = zf ( ke ) tsc ( kb : ksp - 1 ) = 0.0 do k = ksp , ke tsc ( k ) = rnu0 * sin ( 0.5 * pi * ( zf ( k ) - zspb ) / ( zspt - zspb )) ** 2 end do tsc ( ke + 1 ) = tsc ( ke ) irecy = ib + iplane irecydriver = iplane ! + ib end subroutine initboundary !> !! Execute boundary conditions subroutine boundary use modglobal , only : ib , ie , ih , jb , je , jgb , jge , jh , kb , ke , kh , linoutflow , dzf , zh , dy , & timee , ltempeq , lmoist , BCxm , BCym , BCxT , BCyT , BCxq , BCyq , BCxs , BCys , BCtopm , BCtopT ,& BCtopq , BCtops , e12min , idriver , luvolflowr , luoutflowr use modfields , only : u0 , v0 , w0 , um , vm , wm , thl0 , thlm , qt0 , qtm , uout , uouttot , e120 , e12m ,& u0av use modsubgriddata , only : ekh , ekm use modsurfdata , only : thl_top , qt_top , sv_top , wttop , wqtop , wsvtop use modmpi , only : myid , slabsum use modinlet , only : inletgen , inletgennotemp use moddriver , only : drivergen use modinletdata , only : irecy , ubulk , iangle !    use modsurface, only : getobl implicit none real , dimension ( kb : ke ) :: uaverage integer i , k ! if not using massflowrate need to set outflow velocity if ( luoutflowr ) then ! do nothing - calculated in modforces elseif (. not . luvolflowr ) then !ubulk = sum(u0av)/(ke-kb+1) do k = kb , ke uaverage ( k ) = u0av ( k ) * dzf ( k ) end do ! need a method to know if we have all blocks at lowest cell kb ! assuming this for now (hence kb+1) uouttot = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb + 1 )) else uouttot = ubulk end if !BCxm!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !periodic or inflow/outflow conditions for momentum if ( BCxm . eq . 1 ) then !periodic call cyclicmi if ( idriver == 1 ) then ! write driver files call drivergen end if else if ( BCxm . eq . 2 ) then !previously iinletgen 1 uouttot = cos ( iangle ) * ubulk if ( ltempeq ) then call inletgen else call inletgennotemp end if ! iolet - called due to BCtopm = 3 else if ( BCxm . eq . 3 ) then ! previously iinletgen 2 uouttot = cos ( iangle ) * ubulk if ( ltempeq ) then call inletgen else call inletgennotemp end if ! iolet - called due to BCtopm = 3 else if ( BCxm . eq . 4 ) then !previously (inoutflow without iinlet) uouttot = cos ( iangle ) * ubulk if ( ltempeq ) then call inletgen else call inletgennotemp end if ! iolet - called due to BCtopm = 3 else if ( BCxm . eq . 5 ) then ! driver from drivergen (idriver == 2) uouttot = ubulk ! does this hold for all forcings of precursor simulations? tg3315 call drivergen ! iolet - called due to BCtopm = 3 else write ( 0 , * ) \"ERROR: lateral boundary type for veloctiy in x-direciton undefined\" stop 1 end if !BCym!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !currently BC in y is always periodic for momentum if ( BCym . eq . 1 ) then call cyclicmj else write ( 0 , * ) \"ERROR: lateral boundary type for velocity in y-direction undefined\" stop 1 end if !BCxT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! if ( BCxT . eq . 1 ) then call cyclichi else if ( BCxT . eq . 2 ) then !inoutflow - will be overwritten unless BCxm == 1 call iohi ! make sure uouttot is known and realistic else if ( BCxT . eq . 3 ) then !do nothing, temperature is considered in iolet else write ( 0 , * ) \"ERROR: lateral boundary type for temperature in x-direction undefined\" stop 1 end if !BCyT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! if ( BCyT . eq . 1 ) then call cyclichj else write ( 0 , * ) \"ERROR: lateral boundary type for temperature in y-direction undefined\" stop 1 end if !BCxq!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! if ( BCxq . eq . 1 ) then call cyclicqi else if ( BCxq . eq . 2 ) then !inoutflow  - will be overwritten unless BCxm == 1 call ioqi ! tg3315 - make sure uouttot is known and realistic elseif ( BCxq . eq . 3 ) then !do nothing, temperature is considered in iolet else write ( 0 , * ) \"ERROR: lateral boundary type for humidity in x-direction undefined\" stop 1 end if !BCyq!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! if ( BCyq . eq . 1 ) then call cyclicqj else write ( 0 , * ) \"ERROR: lateral boundary type for humidity in y-direction undefined\" stop 1 end if !BCys!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! if ( BCys . eq . 1 ) then call cyclicsj elseif ( BCys . eq . 5 ) then ! done in scalSIRANE else write ( 0 , * ) \"ERROR: lateral boundary type for scalars in y-direction undefined\" stop 1 end if !BCxs!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! if ( BCxs . eq . 1 ) then call cyclicsi else if ( BCxs . eq . 2 ) then !inoutflow  - will be overwritten unless BCxm == 1 call iosi ! make sure uouttot is known and correct for the running set-up else if ( BCxs . eq . 3 ) then ! do nothing - considered in iolet else if ( BCxs . eq . 4 ) then !scalrec - will be overwritten unless BCxm == 1 call scalrec else if ( BCxs . eq . 5 ) then !previously SIRANE - will be overwritten unless BCxm == 1 call scalSIRANE !  make sure uouttot/ vouttot is known and realistic else write ( 0 , * ) \"ERROR: lateral boundary type for scalars in x-direction undefined\" stop 1 end if !BCtopm!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! if ( BCtopm . eq . 1 ) then !free-slip = zero-flux call fluxtop ( um , ekm , 0.0 ) call fluxtop ( u0 , ekm , 0.0 ) call fluxtop ( vm , ekm , 0.0 ) call fluxtop ( v0 , ekm , 0.0 ) e120 (:, :, ke + 1 ) = e12min ! free slip top wall e12m (:, :, ke + 1 ) = e12min w0 (:, :, ke + 1 ) = 0.0 wm (:, :, ke + 1 ) = 0.0 else if ( BCtopm . eq . 2 ) then !no-slip = zero velocity at wall call valuetop ( um , 0.0 ) call valuetop ( u0 , 0.0 ) call valuetop ( vm , 0.0 ) call valuetop ( v0 , 0.0 ) w0 (:, :, ke + 1 ) = 0.0 wm (:, :, ke + 1 ) = 0.0 else if ( BCtopm . eq . 3 ) then call fluxtop ( um , ekm , 0.0 ) call fluxtop ( u0 , ekm , 0.0 ) call fluxtop ( vm , ekm , 0.0 ) call fluxtop ( v0 , ekm , 0.0 ) e120 (:, :, ke + 1 ) = e12min ! free slip top wall e12m (:, :, ke + 1 ) = e12min if ( idriver == 2 ) then ! does not use ddispdx, Uinf etc. w0 (:, :, ke + 1 ) = 0.0 wm (:, :, ke + 1 ) = 0.0 else call inlettop ! for iinletgen... end if call iolet !ils13, 13.8.18: iolet also deals with lateral boundaries!! else write ( 0 , * ) \"ERROR: top boundary type for velocity undefined\" stop 1 end if !BCtopT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! if ( BCtopT . eq . 1 ) then call fluxtop ( thlm , ekh , wttop ) call fluxtop ( thl0 , ekh , wttop ) else if ( BCtopT . eq . 2 ) then call valuetop ( thlm , thl_top ) call valuetop ( thl0 , thl_top ) else write ( 0 , * ) \"ERROR: top boundary type for temperature undefined\" stop 1 end if !BCtopq!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! if ( BCtopq . eq . 1 ) then call fluxtop ( qtm , ekh , wqtop ) call fluxtop ( qt0 , ekh , wqtop ) else if ( BCtopq . eq . 2 ) then call valuetop ( qtm , qt_top ) call valuetop ( qt0 , qt_top ) else write ( 0 , * ) \"ERROR: top boundary type for humidity undefined\" stop 1 end if !BCtops!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! if ( BCtops . eq . 1 ) then call fluxtopscal ( wsvtop ) call fluxtopscal ( wsvtop ) else if ( BCtops . eq . 2 ) then call valuetopscal ( sv_top ) call valuetopscal ( sv_top ) else write ( 0 , * ) \"ERROR: top boundary type for scalars undefined\" stop 1 end if end subroutine boundary subroutine closurebc use modsubgriddata , only : ekm , ekh use modglobal , only : ib , ie , jb , je , kb , ke , ih , jh , kh , numol , prandtlmoli , linoutflow , BCtopm use modmpi , only : excjs integer i , j ! Top and bottom ! ils13, 13.8.18: what should it be for slip or mixed BCs ? if (( BCtopm . eq . 1 ) . or . ( BCtopm . eq . 3 )) then !free-slip do j = jb - 1 , je + 1 do i = ib - 1 , ie + 1 ekm ( i , j , ke + 1 ) = ekm ( i , j , ke ) ! zero-gradient top wall ekh ( i , j , ke + 1 ) = ekh ( i , j , ke ) ! zero-gradient top wall ekm ( i , j , kb - 1 ) = 2. * numol - ekm ( i , j , kb ) ! no-slip lower wall ekh ( i , j , kb - 1 ) = ( 2. * numol * prandtlmoli ) - ekh ( i , j , kb ) ! no-slip lower wall end do end do else if ( BCtopm . eq . 2 ) then !no-slip do j = jb - 1 , je + 1 do i = ib - 1 , ie + 1 ekm ( i , j , ke + 1 ) = 2. * numol - ekm ( i , j , ke ) ! no-slip top wall ekh ( i , j , ke + 1 ) = ( 2. * numol * prandtlmoli ) - ekh ( i , j , ke ) ! no-slip top wall ekm ( i , j , kb - 1 ) = 2. * numol - ekm ( i , j , kb ) ! no-slip lower wall ekh ( i , j , kb - 1 ) = ( 2. * numol * prandtlmoli ) - ekh ( i , j , kb ) ! no-slip lower wall end do end do end if ! horizontal BC's if ( linoutflow ) then ! inflow/outflow ekm ( ib - 1 , :, :) = ekm ( ib , :, :) ekm ( ie + 1 , :, :) = ekm ( ie , :, :) ekh ( ib - 1 , :, :) = ekh ( ib , :, :) ekh ( ie + 1 , :, :) = ekh ( ie , :, :) else ekm ( ib - 1 , :, :) = ekm ( ie , :, :) ! periodic ekm ( ie + 1 , :, :) = ekm ( ib , :, :) ekh ( ib - 1 , :, :) = ekh ( ie , :, :) ekh ( ie + 1 , :, :) = ekh ( ib , :, :) end if call excjs ( ekm , ib , ie , jb , je , kb - kh , ke + kh , ih , jh ) call excjs ( ekh , ib , ie , jb , je , kb - kh , ke + kh , ih , jh ) end subroutine closurebc !> Sets lateral periodic boundary conditions for the scalars subroutine iosi use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , nsv , dt , rk3step , dxhi , ltempeq , & ihc , jhc , khc , dy use modfields , only : sv0 , svm , svprof , uouttot use modinletdata , only : ubulk real rk3coef integer k , n , m rk3coef = dt / ( 4. - dble ( rk3step )) do n = 1 , nsv do k = kb , ke + 1 sv0 ( ib - 1 , :, k , n ) = 2 * svprof ( k , n ) - sv0 ( ib , :, k , n ) svm ( ib - 1 , :, k , n ) = 2 * svprof ( k , n ) - svm ( ib , :, k , n ) end do sv0 ( ie + 1 , :, :, n ) = sv0 ( ie , :, :, n ) - ( sv0 ( ie + 1 , :, :, n ) - sv0 ( ie , :, :, n )) * dxhi ( ie + 1 ) * rk3coef * uouttot ! tg3315 should be uouttot and will have to change depending on forcing svm ( ie + 1 , :, :, n ) = svm ( ie , :, :, n ) - ( svm ( ie + 1 , :, :, n ) - svm ( ie , :, :, n )) * dxhi ( ie + 1 ) * rk3coef * uouttot enddo return end subroutine iosi subroutine scalrec use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , nsv , dt , rk3step , dxhi , ltempeq , & ihc , jhc , khc , dy use modfields , only : sv0 , svm , svprof , uouttot , um , u0 , vm , v0 use modinletdata , only : ubulk real rk3coef integer k , n , m ! recycling method for scalar fields following Matheou and Bowman (2015) if ( nsv > 0 ) then rk3coef = dt / ( 4. - dble ( rk3step )) do m = 1 , ihc ! loop over virtual cells do n = 1 , nsv - 1 sv0 ( ib - m , :, :, n + 1 ) = sv0 ( ie + 1 - m , :, :, n ) sv0 ( ie + m , :, :, n ) = sv0 ( ib - 1 + m , :, :, n + 1 ) svm ( ib - m , :, :, n + 1 ) = svm ( ie + 1 - m , :, :, n ) svm ( ie + m , :, :, n ) = svm ( ib - 1 + m , :, :, n + 1 ) end do ! zero conc. on scalar 1 !tg3315 should be changed to as above in sv0 ( ib - m , :, :, 1 ) = 0. svm ( ib - m , :, :, 1 ) = 0. ! DIY outflow BC (advection step as linout) tg3315 sv0 ( ie + m ,:,:, nsv ) = sv0 ( ie + 1 - m ,:,:, nsv ) - ( sv0 ( ie + m ,:,:, nsv ) - sv0 ( ie + 1 - m ,:,:, nsv )) * dxhi ( ie + m ) * rk3coef * uouttot svm ( ie + m ,:,:, nsv ) = svm ( ie + 1 - m ,:,:, nsv ) - ( svm ( ie + m ,:,:, nsv ) - svm ( ie + 1 - m ,:,:, nsv )) * dxhi ( ie + m ) * rk3coef * uouttot end do end if return end subroutine scalrec subroutine scalSIRANE use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , nsv , dt , lscalrec , lmoistinout , ltempinout , rk3step , dxhi , ltempeq ,& ihc , jhc , khc , lSIRANEinout , dy use modfields , only : sv0 , svm , svprof use modinletdata , only : ubulk use modmpi , only : myid , nprocs real rk3coef integer k , n , m if ( nsv > 0 ) then !rk3coef = dt / (4. - dble(rk3step)) do n = 1 , nsv do m = 1 , ihc do k = kb , ke + 1 sv0 ( ib - m , :, k , n ) = 2 * svprof ( k , n ) - sv0 ( ib - m + 1 , :, k , n ) !scalars have two ghost cells...??? svm ( ib - m , :, k , n ) = 2 * svprof ( k , n ) - svm ( ib - m + 1 , :, k , n ) end do !              sv0(ie+m,:,:,n)= sv0(ie+m-1,:,:,n) - (sv0(ie+m,:,:,n)-sv0(ie+m-1,:,:,n))*dxhi(ie+m)*rk3coef*ubulk !              svm(ie+m,:,:,n)= svm(ie+m-1,:,:,n) - (svm(ie+m,:,:,n)-svm(ie+m-1,:,:,n))*dxhi(ie+m)*rk3coef*ubulk !changed from uouttot to ubulk here !tg3315 08/11/2017 !              sv0(ie+m,:,:,n)= sv0(ie+m-1,:,:,n) - (sv0(ie+m,:,:,n)-sv0(ie+m-1,:,:,n))*dxhi(ie+m)*rk3coef*u0(ie+m,:,:) !              svm(ie+m,:,:,n)= svm(ie+m-1,:,:,n) - (svm(ie+m,:,:,n)-svm(ie+m-1,:,:,n))*dxhi(ie+m)*rk3coef*um(ie+m,:,:) !changed from uouttot to ubulk here !tg3315 08/11/2017 svm ( ie + m , :, :, n ) = svm ( ie + m - 1 , :, :, n ) sv0 ( ie + m , :, :, n ) = sv0 ( ie + m - 1 , :, :, n ) end do !m, ihc end do !n, nsv do m = 1 , jhc do n = 1 , nsv if ( myid == 0 ) then do k = kb , ke + 1 sv0 (:, jb - m , k , n ) = 2 * svprof ( k , n ) - sv0 (:, jb - m + 1 , k , n ) svm (:, jb - m , k , n ) = 2 * svprof ( k , n ) - svm (:, jb - m + 1 , k , n ) end do end if if ( myid == nprocs - 1 ) then !sv0(:,je+m,:,n)= sv0(:,je+m-1,:,n) - (sv0(:,je+m,:,n)-sv0(:,je+m-1,:,n))*dy*rk3coef*ubulk !svm(:,je+m,:,n)= svm(:,je+m-1,:,n) - (svm(:,je+m,:,n)-svm(:,je+m-1,:,n))*dy*rk3coef*ubulk !changed from uouttot to ubulk here !tg3315 08/11/2017 !      sv0(:,je+m,:,n)= sv0(:,je+m-1,:,n) - (sv0(:,je+m,:,n)-sv0(:,je+m-1,:,n))*dy*rk3coef*v0(:,je+m,:) !      svm(:,je+m,:,n)= svm(:,je+m-1,:,n) - (svm(:,je+m,:,n)-svm(:,je+m-1,:,n))*dy*rk3coef*vm(:,je+m,:) !changed from uouttot to ubulk here !tg3315 08/11/2017 svm (:, je + m , :, n ) = svm (:, je + m - 1 , :, n ) sv0 (:, je + m , :, n ) = sv0 (:, je + m - 1 , :, n ) end if end do !n, nsv end do !m, jhc end if !nsv>0 return end subroutine scalSIRANE !!!!!!!!!!! x/i periodic BC for scalars!!!!!!!!!!! !> Sets x/i periodic boundary conditions for the temperature subroutine cyclichi use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , nsv , dt , rk3step , dxhi , ihc , jhc , khc , dy use modfields , only : thl0 , thlm integer m do m = 1 , ih thl0 ( ib - m , :, :) = thl0 ( ie + 1 - m , :, :) thl0 ( ie + m , :, :) = thl0 ( ib - 1 + m , :, :) thlm ( ib - m , :, :) = thlm ( ie + 1 - m , :, :) thlm ( ie + m , :, :) = thlm ( ib - 1 + m , :, :) end do return end subroutine cyclichi !> Sets x/i periodic boundary conditions for the humidity subroutine cyclicqi use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , nsv , dt , rk3step , dxhi , ihc , jhc , khc , dy use modfields , only : qt0 , qtm integer m do m = 1 , ih qt0 ( ib - m , :, :) = qt0 ( ie + 1 - m , :, :) qt0 ( ie + m , :, :) = qt0 ( ib - 1 + m , :, :) qtm ( ib - m , :, :) = qtm ( ie + 1 - m , :, :) qtm ( ie + m , :, :) = qtm ( ib - 1 + m , :, :) end do return end subroutine cyclicqi !> Sets x/iperiodic boundary conditions for the scalars subroutine cyclicsi use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , nsv , dt , rk3step , dxhi , ihc , jhc , khc , dy use modfields , only : sv0 , svm integer m do m = 1 , ihc sv0 ( ib - m , :, :, :) = sv0 ( ie + 1 - m , :, :, :) sv0 ( ie + m , :, :, :) = sv0 ( ib - 1 + m , :, :, :) svm ( ib - m , :, :, :) = svm ( ie + 1 - m , :, :, :) svm ( ie + m , :, :, :) = svm ( ib - 1 + m , :, :, :) end do return end subroutine cyclicsi !!!!!!!!!!!end x/i periodic BC for scalars!!!!!!!! !> Sets x/inlet-outlet boundary conditions for moisture subroutine ioqi use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , dxhi , rk3step , dt use modfields , only : qt0 , qtm , qtprof , uouttot use modinletdata , only : ubulk integer k , j real rk3coef rk3coef = dt / ( 4. - dble ( rk3step )) do k = kb , ke do j = jb , je qt0 ( ib - 1 , j , k ) = 2 * qtprof ( k ) - qt0 ( ib , j , k ) !watch! qtm ( ib - 1 , j , k ) = 2 * qtprof ( k ) - qtm ( ib , j , k ) end do end do !uouttot is zero unless lmassflowr qt0 ( ie + 1 , :, :) = qt0 ( ie , :, :) - ( qt0 ( ie + 1 , :, :) - qt0 ( ie , :, :)) * dxhi ( ie + 1 ) * rk3coef * uouttot ! tg3315 should be uouttot and will have to change depending on forcing qtm ( ie + 1 , :, :) = qtm ( ie , :, :) - ( qtm ( ie + 1 , :, :) - qtm ( ie , :, :)) * dxhi ( ie + 1 ) * rk3coef * uouttot end subroutine ioqi !> Sets x/in;et-outlet boundary conditions for temperature subroutine iohi use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , dxhi , rk3step , dt use modfields , only : thl0 , thlm , thlprof , uouttot use modinletdata , only : ubulk integer k , j real rk3coef rk3coef = dt / ( 4. - dble ( rk3step )) do k = kb , ke do j = jb , je thl0 ( ib - 1 , j , k ) = 2 * thlprof ( k ) - thl0 ( ib , j , k ) !watch! thlm ( ib - 1 , j , k ) = 2 * thlprof ( k ) - thlm ( ib , j , k ) end do end do thl0 ( ie + 1 , :, :) = thl0 ( ie , :, :) - ( thl0 ( ie + 1 , :, :) - thl0 ( ie , :, :)) * dxhi ( ie + 1 ) * rk3coef * uouttot ! tg3315 should be uouttot and will have to change depending on forcing thlm ( ie + 1 , :, :) = thlm ( ie , :, :) - ( thlm ( ie + 1 , :, :) - thlm ( ie , :, :)) * dxhi ( ie + 1 ) * rk3coef * uouttot end subroutine iohi !!!!!!!!!!! y/j periodic BC for scalars!!!!!!!!!!! !> Sets y/j periodic boundary conditions for the temperature subroutine cyclichj use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , nsv , dt , rk3step , dxhi , ihc , jhc , khc , dy use modfields , only : thl0 , thlm use modmpi , only : excjs , myid , nprocs call excjs ( thl0 , ib , ie , jb , je , kb , ke + kh , ih , jh ) call excjs ( thlm , ib , ie , jb , je , kb , ke + kh , ih , jh ) return end subroutine cyclichj !> Sets y/j periodic boundary conditions for the humidity subroutine cyclicqj use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , nsv , dt , rk3step , dxhi , ihc , jhc , khc , dy use modfields , only : qt0 , qtm use modmpi , only : excjs , myid , nprocs call excjs ( qt0 , ib , ie , jb , je , kb , ke + kh , ih , jh ) call excjs ( qtm , ib , ie , jb , je , kb , ke + kh , ih , jh ) return end subroutine cyclicqj !> Sets y/j periodic boundary conditions for the scalars subroutine cyclicsj use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , nsv , dt , rk3step , dxhi , ihc , jhc , khc , dy use modfields , only : sv0 , svm use modmpi , only : excjs , myid , nprocs integer n do n = 1 , nsv call excjs ( sv0 (:, :, :, n ), ib , ie , jb , je , kb - khc , ke + khc , ihc , jhc ) call excjs ( svm (:, :, :, n ), ib , ie , jb , je , kb - khc , ke + khc , ihc , jhc ) enddo return end subroutine cyclicsj !!!!!!!!!!!end y/j periodic BC for scalars!!!!!!!! !>set lateral periodic boundary conditions for momentum in x/i direction subroutine cyclicmi use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , jmax use modfields , only : u0 , um , v0 , vm , w0 , wm , e120 , e12m use modsubgriddata , only : loneeqn , lsmagorinsky integer n , m do m = 1 , ih u0 ( ib - m , :, :) = u0 ( ie + 1 - m , :, :) u0 ( ie + m , :, :) = u0 ( ib - 1 + m , :, :) v0 ( ib - m , :, :) = v0 ( ie + 1 - m , :, :) v0 ( ie + m , :, :) = v0 ( ib - 1 + m , :, :) w0 ( ib - m , :, :) = w0 ( ie + 1 - m , :, :) w0 ( ie + m , :, :) = w0 ( ib - 1 + m , :, :) um ( ib - m , :, :) = um ( ie + 1 - m , :, :) um ( ie + m , :, :) = um ( ib - 1 + m , :, :) vm ( ib - m , :, :) = vm ( ie + 1 - m , :, :) vm ( ie + m , :, :) = vm ( ib - 1 + m , :, :) wm ( ib - m , :, :) = wm ( ie + 1 - m , :, :) wm ( ie + m , :, :) = wm ( ib - 1 + m , :, :) e120 ( ib - m , :, :) = e120 ( ie + 1 - m , :, :) e120 ( ie + m , :, :) = e120 ( ib - 1 + m , :, :) e12m ( ib - m , :, :) = e12m ( ie + 1 - m , :, :) e12m ( ie + m , :, :) = e12m ( ib - 1 + m , :, :) end do if ( loneeqn ) then e120 ( ib - m , :, :) = e120 ( ie + 1 - m , :, :) e120 ( ie + m , :, :) = e120 ( ib - 1 + m , :, :) e12m ( ib - m , :, :) = e12m ( ie + 1 - m , :, :) e12m ( ie + m , :, :) = e12m ( ib - 1 + m , :, :) end if return end subroutine cyclicmi !>set lateral periodic boundary conditions for momentum in y/j direction subroutine cyclicmj use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , jmax use modfields , only : u0 , um , v0 , vm , w0 , wm , e120 , e12m , shear use modsubgriddata , only : loneeqn , lsmagorinsky use modmpi , only : excjs integer n , m call excjs ( u0 , ib , ie , jb , je , kb , ke + kh , ih , jh ) call excjs ( v0 , ib , ie , jb , je , kb , ke + kh , ih , jh ) call excjs ( w0 , ib , ie , jb , je , kb , ke + kh , ih , jh ) call excjs ( um , ib , ie , jb , je , kb , ke + kh , ih , jh ) call excjs ( vm , ib , ie , jb , je , kb , ke + kh , ih , jh ) call excjs ( wm , ib , ie , jb , je , kb , ke + kh , ih , jh ) if ( loneeqn ) then call excjs ( e120 , ib , ie , jb , je , kb , ke + kh , ih , jh ) call excjs ( e12m , ib , ie , jb , je , kb , ke + kh , ih , jh ) ! exchange shear components between processors do n = 1 , 12 ! for all 12 components call excjs ( shear (:, :, :, n ), ib , ie , jb , je , kb , ke , 0 , 1 ) end do end if if ( lsmagorinsky ) then ! exchange shear components between processors do n = 1 , 12 ! for all 12 components call excjs ( shear (:, :, :, n ), ib , ie , jb , je , kb , ke , 0 , 1 ) end do end if return end subroutine cyclicmj !>set inlet and outlet boundary conditions in i-direction subroutine iolet use modglobal , only : dxhi , dxhci , xh , zh , ib , ie , jb , je , ih , jh , kb , ke , kh , nsv , rk3step , dt , iinletgen , ltempeq , lmoist , ihc , idriver , dy , dzf , jtot , zh use modfields , only : u0 , um , v0 , vm , w0 , wm , e120 , e12m , thl0 , thlm , qt0 , qtm , sv0 , svm , uprof , vprof , e12prof , thlprof , & qtprof , svprof , uouttot , wouttot use modmpi , only : excjs , myid , slabsum use modinletdata , only : u0inletbcold , v0inletbcold , w0inletbcold , uminletbc , vminletbc , wminletbc , totaluold , & t0inletbcold , tminletbc , u0driver , v0driver , w0driver , e120driver , thl0driver , qt0driver , umdriver , vmdriver , wmdriver ,& e12mdriver , thlmdriver , qtmdriver , sv0driver , svmdriver real rk3coef real , dimension ( kb : ke ) :: uin integer n , i , j , k , m rk3coef = dt / ( 4. - dble ( rk3step )) ! Inlet boundary is located at ib (not ib-1)! ! Inlet if (( iinletgen == 1 ) . or . ( iinletgen == 2 )) then do j = jb , je do k = kb , ke u0 ( ib , j , k ) = u0inletbcold ( j , k ) um ( ib , j , k ) = uminletbc ( j , k ) u0 ( ib - 1 , j , k ) = 2 * u0 ( ib , j , k ) - u0 ( ib + 1 , j , k ) um ( ib - 1 , j , k ) = 2 * um ( ib , j , k ) - um ( ib + 1 , j , k ) v0 ( ib - 1 , j , k ) = v0inletbcold ( j , k ) vm ( ib - 1 , j , k ) = vminletbc ( j , k ) ! to be changed in the future: e12 should be taken from recycle plane! e120 ( ib - 1 , j , k ) = e120 ( ib , j , k ) ! extrapolate e12 from interior e12m ( ib - 1 , j , k ) = e12m ( ib , j , k ) ! extrapolate e12 from interior do n = 1 , nsv do m = 1 , ihc sv0 ( ib - m , j , k , n ) = 2 * svprof ( k , n ) - sv0 ( ib + ( m - 1 ), j , k , n ) svm ( ib - m , j , k , n ) = 2 * svprof ( k , n ) - svm ( ib + ( m - 1 ), j , k , n ) enddo enddo end do do k = kb , ke + 1 w0 ( ib - 1 , j , k ) = w0inletbcold ( j , k ) wm ( ib - 1 , j , k ) = wminletbc ( j , k ) end do end do ! Heat if ( ltempeq ) then do k = kb , ke do j = jb , je thl0 ( ib - 1 , j , k ) = t0inletbcold ( j , k ) thlm ( ib - 1 , j , k ) = tminletbc ( j , k ) end do end do end if if ( lmoist ) then do k = kb , ke do j = jb , je qt0 ( ib - 1 , j , k ) = 2 * qtprof ( k ) - qt0 ( ib , j , k ) !watch! qtm ( ib - 1 , j , k ) = 2 * qtprof ( k ) - qtm ( ib , j , k ) end do end do end if ! Driver inlet elseif ( idriver == 2 ) then do j = jb - 1 , je + 1 do k = kb , ke !tg3315 removed +1 following above... u0 ( ib , j , k ) = u0driver ( j , k ) !max(0.,u0driver(j,k)) um ( ib , j , k ) = umdriver ( j , k ) !max(0.,umdriver(j,k)) u0 ( ib - 1 , j , k ) = u0driver ( j , k ) !max(0.,2.*u0(ib,j,k)-u0(ib+1,j,k)) um ( ib - 1 , j , k ) = umdriver ( j , k ) !max(0.,2.*um(ib,j,k)-um(ib+1,j,k)) v0 ( ib , j , k ) = v0driver ( j , k ) !max(0.,v0driver(j,k)) vm ( ib , j , k ) = vmdriver ( j , k ) !max(0.,vmdriver(j,k)) v0 ( ib - 1 , j , k ) = v0driver ( j , k ) !max(0.,v0driver(j,k)) vm ( ib - 1 , j , k ) = vmdriver ( j , k ) !max(0.,vmdriver(j,k)) ! to be changed in the future: e12 should be taken from recycle plane! !e120(ib-1,j,k) = e120driver(j,k)      ! extrapolate e12 from interior !e12m(ib-1,j,k) = e12mdriver(j,k)      ! extrapolate e12 from interior do n = 1 , nsv do m = 1 , ihc sv0 ( ib - m , j , k , n ) = sv0driver ( j , k , n ) svm ( ib - m , j , k , n ) = svmdriver ( j , k , n ) !sv0(ib-m,j,k,n) = 2*svprof(k,n) - sv0(ib+(m-1),j,k,n) !svm(ib-m,j,k,n) = 2*svprof(k,n) - svm(ib+(m-1),j,k,n) enddo sv0 ( ib , j , k , n ) = sv0driver ( j , k , n ) svm ( ib , j , k , n ) = svmdriver ( j , k , n ) enddo end do do k = kb , ke + 1 w0 ( ib - 1 , j , k ) = w0driver ( j , k ) !max(0.,w0driver(j,k)) wm ( ib - 1 , j , k ) = wmdriver ( j , k ) !max(0.,wmdriver(j,k)) w0 ( ib , j , k ) = w0driver ( j , k ) !max(0.,w0driver(j,k)) wm ( ib , j , k ) = wmdriver ( j , k ) !max(0.,wmdriver(j,k)) end do end do ! Heat if ( ltempeq ) then do j = jb - 1 , je + 1 do k = kb , ke + 1 thl0 ( ib , j , k ) = thl0driver ( j , k ) thlm ( ib , j , k ) = thlmdriver ( j , k ) thl0 ( ib - 1 , j , k ) = thl0driver ( j , k ) thlm ( ib - 1 , j , k ) = thlmdriver ( j , k ) !thlm(ib-1,j,k) = 2*thlm(ib,j,k) - thlm(ib+1,j,k) !thl0(ib-1,j,k) = 2*thl0(ib,j,k) - thl0(ib+1,j,k) end do end do end if if ( lmoist ) then do j = jb - 1 , je + 1 do k = kb , ke + 1 qt0 ( ib , j , k ) = qt0driver ( j , k ) ! qt0(ib-1,j,k) = 2*qtprof(k) - qt0(ib,j,k) qtm ( ib , j , k ) = qtmdriver ( j , k ) ! qtm(ib-1,j,k) = 2*qtprof(k) - qtm(ib,j,k) qt0 ( ib - 1 , j , k ) = qt0driver ( j , k ) ! qt0(ib-1,j,k) = 2*qtprof(k) - qt0(ib,j,k)  !watch! qtm ( ib - 1 , j , k ) = qtmdriver ( j , k ) ! qtm(ib-1,j,k) = 2*qtprof(k) - qtm(ib,j,k) ! qt0(ib-1,j,k) = 2*qt0(ib,j,k) - qt0(ib+1,j,k) ! qtm(ib-1,j,k) = 2*qtm(ib,j,k) - qtm(ib+1,j,k) end do end do end if else ! (if iinetgen==0) do j = jb - 1 , je + 1 do k = kb , ke + 1 ! Momentum u0 ( ib , j , k ) = uprof ( k ) um ( ib , j , k ) = uprof ( k ) v0 ( ib - 1 , j , k ) = 2 * vprof ( k ) - v0 ( ib , j , k ) ! (v(ib)+v(ib-1))/2 = vprof vm ( ib - 1 , j , k ) = 2 * vprof ( k ) - vm ( ib , j , k ) ! (v(ib)+v(ib-1))/2 = vprof e120 ( ib - 1 , j , k ) = 2 * e12prof ( k ) - e120 ( ib , j , k ) ! (e12(ib)+e12(ib-1))/2=e12prof e12m ( ib - 1 , j , k ) = 2 * e12prof ( k ) - e12m ( ib , j , k ) ! (e12(ib)+e12(ib-1))/2=e12prof do n = 1 , nsv do m = 1 , ihc sv0 ( ib - m , j , k , n ) = 2 * svprof ( k , n ) - sv0 ( ib + ( m - 1 ), j , k , n ) svm ( ib - m , j , k , n ) = 2 * svprof ( k , n ) - svm ( ib + ( m - 1 ), j , k , n ) end do end do !end if enddo enddo ! Heat if ( ltempeq ) then do j = jb - 1 , je + 1 do k = kb , ke + 1 thl0 ( ib - 1 , j , k ) = 2 * thlprof ( k ) - thl0 ( ib , j , k ) thlm ( ib - 1 , j , k ) = 2 * thlprof ( k ) - thlm ( ib , j , k ) end do end do end if if ( lmoist ) then do j = jb - 1 , je + 1 do k = kb , ke + 1 qt0 ( ib - 1 , j , k ) = 2 * qtprof ( k ) - qt0 ( ib , j , k ) qtm ( ib - 1 , j , k ) = 2 * qtprof ( k ) - qtm ( ib , j , k ) end do end do end if u0 ( ib - 1 , :, :) = 2 * u0 ( ib , :, :) - u0 ( ib + 1 , :, :) ! (u(ib+1)+u(ib-1))/2 = u(ib) um ( ib - 1 , :, :) = 2 * um ( ib , :, :) - um ( ib + 1 , :, :) ! (u(ib+1)+u(ib-1))/2 = u(ib) w0 ( ib - 1 , :, :) = - w0 ( ib , :, :) ! (w(ib)+w(ib-1))/2 = 0 wm ( ib - 1 , :, :) = - wm ( ib , :, :) end if ! iinletgen==1 .or. iinletgen==2 ! tg3315 added to ensure that uouttot matches driven inflow regardless of forcing ! set up assuming we have a block at lowest cell kb if ( idriver == 2 ) then uin = 0. uouttot = 0. call slabsum ( uin , kb , ke , um , ib - ih , ie + ih , jb - jh , je + jh , kb - kh , ke + kh , ie , ie , jb , je , kb , ke ) ! determine horizontal (j) average outflow velocity old do k = kb , ke uin ( k ) = uin ( k ) * dzf ( k ) * dy ! flow rate through each slab at ib end do uouttot = sum ( uin ( kb + 1 : ke )) / (( zh ( ke + 1 ) - zh ( kb + 1 )) * jtot * dy ) ! convective outflow velocity end if ! Outlet ! Momentum v0 ( ie + 1 , :, :) = v0 ( ie , :, :) - ( v0 ( ie + 1 , :, :) - v0 ( ie , :, :)) * dxhi ( ie + 1 ) * rk3coef * uouttot w0 ( ie + 1 , :, :) = w0 ( ie , :, :) - ( w0 ( ie + 1 , :, :) - w0 ( ie , :, :)) * dxhi ( ie + 1 ) * rk3coef * uouttot vm ( ie + 1 , :, :) = vm ( ie , :, :) - ( vm ( ie + 1 , :, :) - vm ( ie , :, :)) * dxhi ( ie + 1 ) * rk3coef * uouttot wm ( ie + 1 , :, :) = wm ( ie , :, :) - ( wm ( ie + 1 , :, :) - wm ( ie , :, :)) * dxhi ( ie + 1 ) * rk3coef * uouttot e120 ( ie + 1 , :, :) = e120 ( ie , :, :) - ( e120 ( ie + 1 , :, :) - e120 ( ie , :, :)) * dxhi ( ie + 1 ) * rk3coef * uouttot e12m ( ie + 1 , :, :) = e12m ( ie , :, :) - ( e12m ( ie + 1 , :, :) - e12m ( ie , :, :)) * dxhi ( ie + 1 ) * rk3coef * uouttot ! Heat if ( ltempeq ) then thl0 ( ie + 1 , :, :) = thl0 ( ie , :, :) - ( thl0 ( ie + 1 , :, :) - thl0 ( ie , :, :)) * dxhi ( ie + 1 ) * rk3coef * uouttot thlm ( ie + 1 , :, :) = thlm ( ie , :, :) - ( thlm ( ie + 1 , :, :) - thlm ( ie , :, :)) * dxhi ( ie + 1 ) * rk3coef * uouttot end if if ( lmoist ) then qt0 ( ie + 1 , :, :) = qt0 ( ie , :, :) - ( qt0 ( ie + 1 , :, :) - qt0 ( ie , :, :)) * dxhi ( ie + 1 ) * rk3coef * uouttot qtm ( ie + 1 , :, :) = qtm ( ie , :, :) - ( qtm ( ie + 1 , :, :) - qtm ( ie , :, :)) * dxhi ( ie + 1 ) * rk3coef * uouttot end if ! tg3315 !changed dxhi to dxhci!? do n = 1 , nsv sv0 ( ie + 1 , :, :, n ) = sv0 ( ie , :, :, n ) - ( sv0 ( ie + 1 , :, :, n ) - sv0 ( ie , :, :, n )) * dxhci ( ie + 1 ) * rk3coef * uouttot svm ( ie + 1 , :, :, n ) = svm ( ie , :, :, n ) - ( svm ( ie + 1 , :, :, n ) - svm ( ie , :, :, n )) * dxhci ( ie + 1 ) * rk3coef * uouttot end do return end subroutine iolet !>set boundary conditions pup,pvp,pwp in subroutine fillps in modpois.f90 subroutine bcpup ( pup , pvp , pwp , rk3coef ) use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , linoutflow , dxfi , iinletgen , & Uinf , libm , jmax , idriver use modfields , only : pres0 , up , vp , wp , um , w0 , u0 , uouttot use modmpi , only : excjs , myid use modinletdata , only : irecy , u0inletbc , ddispdx , u0driver real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ), intent ( inout ) :: pup real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ), intent ( inout ) :: pvp real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ), intent ( inout ) :: pwp real , intent ( in ) :: rk3coef real rk3coefi integer i , j , k rk3coefi = 1. / rk3coef if ( linoutflow ) then if (( iinletgen == 1 ) . or . ( iinletgen == 2 )) then do j = jb , je do i = ib , ie pwp ( i , j , kb ) = 0. pwp ( i , j , ke + kh ) = ( Uinf * ddispdx ) * rk3coefi end do end do do k = kb , ke do j = jb , je pup ( ie + 1 , j , k ) = - ( u0 ( ie + 1 , j , k ) - u0 ( ie , j , k )) * dxfi ( ie ) * uouttot + um ( ie + 1 , j , k ) * rk3coefi ! du/dt +u*du/dx=0 -> pup(i)=um(i)/rk3coef -um(i)*(um(i)-um(i-1))/dxf(i-1) pup ( ib , j , k ) = u0inletbc ( j , k ) * rk3coefi end do end do elseif ( idriver == 2 ) then do j = jb , je do i = ib , ie pwp ( i , j , kb ) = 0. pwp ( i , j , ke + kh ) = 0. !(Uinf*ddispdx ) *rk3coefi ! tg3315 - idriver does not use Uinf ddisp etc. end do end do do k = kb , ke do j = jb , je pup ( ie + 1 , j , k ) = - ( u0 ( ie + 1 , j , k ) - u0 ( ie , j , k )) * dxfi ( ie ) * uouttot + um ( ie + 1 , j , k ) * rk3coefi ! du/dt +u*du/dx=0 -> pup(i)=um(i)/rk3coef -um(i)*(um(i)-um(i-1))/dxf(i-1) pup ( ib , j , k ) = u0driver ( j , k ) * rk3coefi end do end do else ! if not iinletgen do j = jb , je do i = ib , ie pwp ( i , j , kb ) = 0. pwp ( i , j , ke + kh ) = 0. end do end do do k = kb , ke do j = jb , je pup ( ie + 1 , j , k ) = - ( u0 ( ie + 1 , j , k ) - u0 ( ie , j , k )) * dxfi ( ie ) * uouttot + um ( ie + 1 , j , k ) * rk3coefi ! du/dt +u*du/dx=0 -> pup(i)=um(i)/rk3coef -um(i)*(um(i)-um(i-1))/dxf(i-1) pup ( ib , j , k ) = pup ( ib , j , k ) - up ( ib , j , k ) ! pup(ib)= up(ib) + um(ib)/rk3coef, where up should be zero! end do end do end if ! inletgen else ! if not linoutflow do j = jb , je do i = ib , ie pwp ( i , j , kb ) = 0. pwp ( i , j , ke + kh ) = 0. end do end do do k = kb , ke do j = jb , je pup ( ie + 1 , j , k ) = pup ( ib , j , k ) ! cyclic !pup(ib - 1, j, k) = pup(ie, j, k) ! tg3315 is this condition not needed? Was not here before but I think exists in Dales4.0 in modpois...!? end do end do endif call excjs ( pup , ib , ie , jb , je , kb , ke + kh , ih , jh ) ! cyclic call excjs ( pvp , ib , ie , jb , je , kb , ke + kh , ih , jh ) ! cyclic call excjs ( pwp , ib , ie , jb , je , kb , ke + kh , ih , jh ) ! cyclic end subroutine bcpup !>set pressure boundary conditions subroutine bcp ( p ) use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , linoutflow , dxfi use modfields , only : pres0 , up , u0 , um , uouttot use modmpi , only : excj real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ), intent ( inout ) :: p !< pressure integer i , j , k if ( linoutflow ) then do k = kb , ke do j = jb , je p ( ib - 1 , j , k ) = p ( ib , j , k ) ! inflow:  dp/dn=0 pres0 ( ib - 1 , j , k ) = pres0 ( ib , j , k ) ! inflow:  dp/dn=0 p ( ie + 1 , j , k ) = - p ( ie , j , k ) ! outflow: p=0 pres0 ( ie + 1 , j , k ) = - pres0 ( ie , j , k ) ! outflow: p=0 up ( ie + 1 , j , k ) = - ( u0 ( ie + 1 , j , k ) - u0 ( ie , j , k )) * dxfi ( ie ) * uouttot enddo enddo else do k = kb , ke do j = jb , je p ( ib - 1 , j , k ) = p ( ie , j , k ) p ( ie + 1 , j , k ) = p ( ib , j , k ) enddo enddo endif call excj ( p , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 ) ! cyclic call excj ( pres0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 ) ! cyclic end subroutine bcp !> !! grwdamp damps gravity waves in the upper part of the domain. !> !! The lower limit of the damping region is set by ksp !! Horizontal fluctuations at the top of the domain (for instance gravity waves) !! are damped out by a sponge layer through an additional forcing/source term. !! \\latexonly !! \\begin{eqnarray} !! \\force{i}{sp}(z) &=& -\\frac{1}{t&#94;{\\mr{sp}}}\\left(\\xav{\\fav{u_i}}-\\fav{u_i}\\right), \\\\\\\\ !!  \\source{\\varphi}{sp}(z) &=& -\\frac{1}{t&#94;{\\mr{sp}}}\\left(\\xav{\\varphi}-\\varphi\\right), !! \\end{eqnarray} !! with $t&#94;{\\mr{sp}}$ a relaxation time scale that goes from !! $t&#94;{\\mr{sp}}_0=1/(2.75\\times10&#94;{-3})\\mr{s}\\approx 6$min at the top of the domain !! to infinity at the bottom of the sponge layer. !! \\endlatexonly subroutine grwdamp use modglobal , only : ke , kmax , lcoriol , igrw_damp , geodamptime use modfields , only : up , vp , wp , thlp , qtp , u0 , v0 , w0 , thl0 , qt0 , ug , vg , thl0av , qt0av , u0av , v0av use modmpi , only : myid implicit none integer k select case ( igrw_damp ) case ( 0 ) !do nothing case ( 1 ) do k = ksp , ke up (:, :, k ) = up (:, :, k ) - ( u0 (:, :, k ) - u0av ( k )) * tsc ( k ) vp (:, :, k ) = vp (:, :, k ) - ( v0 (:, :, k ) - v0av ( k )) * tsc ( k ) wp (:, :, k ) = wp (:, :, k ) - w0 (:, :, k ) * tsc ( k ) thlp (:, :, k ) = thlp (:, :, k ) - ( thl0 (:, :, k ) - thl0av ( k )) * tsc ( k ) qtp (:, :, k ) = qtp (:, :, k ) - ( qt0 (:, :, k ) - qt0av ( k )) * tsc ( k ) end do if ( lcoriol ) then do k = ksp , ke up (:, :, k ) = up (:, :, k ) - ( u0 (:, :, k ) - ug ( k )) * (( 1. / ( geodamptime * rnu0 )) * tsc ( k )) vp (:, :, k ) = vp (:, :, k ) - ( v0 (:, :, k ) - vg ( k )) * (( 1. / ( geodamptime * rnu0 )) * tsc ( k )) end do end if case ( 2 ) do k = ksp , ke up (:, :, k ) = up (:, :, k ) - ( u0 (:, :, k ) - ug ( k )) * tsc ( k ) vp (:, :, k ) = vp (:, :, k ) - ( v0 (:, :, k ) - vg ( k )) * tsc ( k ) wp (:, :, k ) = wp (:, :, k ) - w0 (:, :, k ) * tsc ( k ) thlp (:, :, k ) = thlp (:, :, k ) - ( thl0 (:, :, k ) - thl0av ( k )) * tsc ( k ) qtp (:, :, k ) = qtp (:, :, k ) - ( qt0 (:, :, k ) - qt0av ( k )) * tsc ( k ) end do case ( 3 ) do k = ksp , ke up (:, :, k ) = up (:, :, k ) - ( u0 (:, :, k ) - u0av ( k )) * tsc ( k ) vp (:, :, k ) = vp (:, :, k ) - ( v0 (:, :, k ) - v0av ( k )) * tsc ( k ) wp (:, :, k ) = wp (:, :, k ) - w0 (:, :, k ) * tsc ( k ) thlp (:, :, k ) = thlp (:, :, k ) - ( thl0 (:, :, k ) - thl0av ( k )) * tsc ( k ) qtp (:, :, k ) = qtp (:, :, k ) - ( qt0 (:, :, k ) - qt0av ( k )) * tsc ( k ) end do case default write ( 0 , * ) \"ERROR: no gravity wave damping option selected\" stop 1 end select return end subroutine grwdamp subroutine fluxtop ( field , ek , flux ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , dzf , dzh , dzhi , eps1 real , intent ( inout ) :: field ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) real , intent ( in ) :: ek ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) real , intent ( in ) :: flux ! if ( abs ( flux ) . le . eps1 ) then !it's zero-flux, we don't need to do the calculation field (:, :, ke + 1 ) = field (:, :, ke ) else field (:, :, ke + 1 ) = field (:, :, ke ) + dzh ( ke + 1 ) * flux / ( dzhi ( ke + 1 ) * ( 0.5 * ( dzf ( ke ) * ek (:, :, ke + 1 ) + dzf ( ke + 1 ) * ek (:, :, ke )))) end if ! end subroutine fluxtop subroutine valuetop ( field , val ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , eps1 real , intent ( inout ) :: field ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) real , intent ( in ) :: val ! field (:, :, ke + 1 ) = 2 * val - field (:, :, ke ) ! end subroutine valuetop subroutine fluxtopscal ( flux ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , dzf , dzh , dzhi , nsv , khc use modfields , only : sv0 , svm use modsubgriddata , only : ekh real , intent ( in ) :: flux ( 1 : nsv ) integer :: m , n ! !all the ghost cells have the same value? do m = 1 , khc do n = 1 , nsv sv0 ( ib - ih : ie + ih , jb - jh : je + jh , ke + m , n ) = sv0 ( ib - ih : ie + ih , jb - jh : je + jh , ke , n ) + dzh ( ke + 1 ) * flux ( n ) / ( dzhi ( ke + 1 ) * ( 0.5 * ( dzf ( ke ) * ekh ( ib - ih : ie + ih , jb - jh : je + jh , ke + 1 ) + dzf ( ke + 1 ) * ekh ( ib - ih : ie + ih , jb - jh : je + jh , ke )))) svm ( ib - ih : ie + ih , jb - jh : je + jh , ke + m , n ) = svm ( ib - ih : ie + ih , jb - jh : je + jh , ke , n ) + dzh ( ke + 1 ) * flux ( n ) / ( dzhi ( ke + 1 ) * ( 0.5 * ( dzf ( ke ) * ekh ( ib - ih : ie + ih , jb - jh : je + jh , ke + 1 ) + dzf ( ke + 1 ) * ekh ( ib - ih : ie + ih , jb - jh : je + jh , ke )))) end do end do ! end subroutine fluxtopscal subroutine valuetopscal ( val ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , eps1 , nsv , khc use modfields , only : sv0 , svm real , intent ( in ) :: val ( 1 : nsv ) integer :: m , n ! ! all the ghost cells have the same vlaue? do m = 1 , khc do n = 1 , nsv sv0 (: , : , ke + m , n ) = 2 * val ( n ) - sv0 (: , : , ke , n ) svm (: , : , ke + m , n ) = 2 * val ( n ) - svm (: , : , ke , n ) end do end do ! end subroutine valuetopscal !> Sets top boundary conditions for momentum subroutine inlettop use modglobal , only : ib , ie , jb , je , kb , ke , ih , jh , kh , dzh , dzf , & e12min , dxfi , dxf , dxhi , xh , jgb , jge , Uinf , dzfi use modfields , only : w0 , wm , wout , wouttot use modinletdata , only : Uinl , ddispdxold use modmpi , only : slabsumi , myid implicit none integer :: i real :: nji do i = ib , ie w0 ( i , :, ke + 1 ) = Uinf * ddispdxold wm ( i , :, ke + 1 ) = Uinf * ddispdxold end do call slabsumi ( wout , ib , ie , w0 , ib - ih , ie + ih , jb - jh , je + jh , kb - kh , ke + kh , ib , ie , jb , je , ke + 1 , ke + 1 ) ! determine vertical (j) average outflow velocity nji = 1. / ( jge - jgb + 1 ) do i = ib , ie wout ( i ) = wout ( i ) * dxf ( i ) * nji end do wouttot = sum ( wout ( ib : ie )) / ( xh ( ie + 1 ) - xh ( ib )) ! Area-averaged outflow velocity return end subroutine inlettop !>Set thl, qt and sv(n) equal to slab average at level kmax subroutine tqaver use modmpi , only : comm3d , mpierr , my_real , mpi_sum use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , nsv , rslabs use modfields , only : thl0 , qt0 , sv0 implicit none real thl0a , qt0a real thl0al , qt0al integer n real , allocatable , dimension (:) :: sv0al , sv0a allocate ( sv0al ( nsv ), sv0a ( nsv )) thl0al = sum ( thl0 ( ib : ie , jb : je , ke )) qt0al = sum ( qt0 ( ib : ie , jb : je , ke )) do n = 1 , nsv sv0al ( n ) = sum ( sv0 ( ib : ie , jb : je , ke , n )) enddo call MPI_ALLREDUCE ( thl0al , thl0a , 1 , MY_REAL , & MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( qt0al , qt0a , 1 , MY_REAL , & MPI_SUM , comm3d , mpierr ) if ( nsv > 0 ) then call MPI_ALLREDUCE ( sv0al , sv0a , nsv , MY_REAL , & MPI_SUM , comm3d , mpierr ) end if thl0a = thl0a / rslabs qt0a = qt0a / rslabs sv0a = sv0a / rslabs thl0 ( ib : ie , jb : je , ke ) = thl0a qt0 ( ib : ie , jb : je , ke ) = qt0a do n = 1 , nsv sv0 ( ib : ie , jb : je , ke , n ) = sv0a ( n ) enddo deallocate ( sv0al , sv0a ) return end subroutine tqaver end module modboundary","tags":"","loc":"sourcefile/modboundary.f90.html"},{"title":"modsave.f90 – uDALES","text":"This file depends on sourcefile~~modsave.f90~~EfferentGraph sourcefile~modsave.f90 modsave.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~modsave.f90->sourcefile~modsubgriddata.f90 sourcefile~modsurfdata.f90 modsurfdata.f90 sourcefile~modsave.f90->sourcefile~modsurfdata.f90 sourcefile~modinletdata.f90 modinletdata.f90 sourcefile~modsave.f90->sourcefile~modinletdata.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modsave.f90->sourcefile~modmpi.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modsave.f90->sourcefile~modfields.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~modsave.f90->sourcefile~initfac.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modsave.f90->sourcefile~modglobal.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~modsave.f90->sourcefile~modibmdata.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~modsave.f90~~AfferentGraph sourcefile~modsave.f90 modsave.f90 sourcefile~moddriver.f90 moddriver.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~modinlet.f90 modinlet.f90 sourcefile~modinlet.f90->sourcefile~modsave.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modsave.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~program.f90->sourcefile~modboundary.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~program.f90->sourcefile~modstartup.f90 sourcefile~modpois.f90 modpois.f90 sourcefile~program.f90->sourcefile~modpois.f90 sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~program.f90->sourcefile~modsubgrid.f90 sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~modboundary.f90->sourcefile~modinlet.f90 sourcefile~modstartup.f90->sourcefile~moddriver.f90 sourcefile~modstartup.f90->sourcefile~modinlet.f90 sourcefile~modstartup.f90->sourcefile~modboundary.f90 sourcefile~modstartup.f90->sourcefile~modpois.f90 sourcefile~modstartup.f90->sourcefile~modsubgrid.f90 sourcefile~modpois.f90->sourcefile~modboundary.f90 sourcefile~modsubgrid.f90->sourcefile~modboundary.f90 sourcefile~modstatsdump.f90->sourcefile~modsubgrid.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules modsave Source Code modsave.f90 Source Code !> \\file modsave.f90 !! Writes restart and data files. !> !! modsave.f90 writes the restart and data files !!  \\author Jasper Tomas, June 4th 2015 !!  \\todo documentation !!  \\par Revision list ! module modsave implicit none ! private ! public :: writerestartfiles, writedatafiles save contains !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine writerestartfiles use modsurfdata , only : ustar , thlflux , qtflux , svflux , dudz , dvdz , dthldz , dqtdz , ps , thls , qts , thvs , oblav use modfields , only : u0 , v0 , w0 , thl0 , qt0 , ql0 , ql0h , e120 , dthvdz , presf , presh , sv0 , mindist , wall ,& uav , vav , wav , uuav , vvav , wwav , uvav , uwav , vwav , thlav , thl2av , qtav , qlav , ql2av , qt2av , svav , sv2av , momthick ,& friction , displthick , pres0 , viscratioav , thluav , thlvav , thlwav , qtuav , qtvav , qtwav , qluav , qlvav , qlwav , svuav , svvav , svwav ,& upupav , vpvpav , wpwpav , thlpthlpav , qlpqlpav , qtpqtpav , svpsvpav , upvpav , upwpav , vpwpav , thlpupav , thlpvpav ,& thlpwpav , qlpupav , qlpvpav , qlpwpav , qtpupav , qtpvpav , qtpwpav , svpupav , svpvpav , svpwpav , presav ,& uusgsav , vvsgsav , wwsgsav , uwsgsav , thlusgsav , thlwsgsav , qlusgsav , qlwsgsav , qtusgsav , qtwsgsav , svusgsav , svwsgsav , tkesgsav ,& strain2av , disssgsav , t_vav , tvmx , tvmy , tvmz , tsgsmx1 , tsgsmx2 , tsgsmy1 , tsgsmy2 , tsgsmz1 ,& tsgsmz2 , t_sgsav , nusgsav , tpm , t_pav , ttmx , ttmy , ttmz , t_tav , p_bav , d_sgsav , p_tav , tkeadv use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , trestart , tnextrestart , dt_lim , timee , btime , xh ,& cexpnr , ntimee , rk3step , ifoutput , nsv , timeleft , dt , ntrun , totavtime ,& iinletgen , timee , runavtime , inletav , totinletav , linletRA , ltempeq , lmoist , jgb , jge ,& dzf , dzfi , dzhi , dxf , dxfi , dyi , dxhi , nstore , numol , dy2i , grav , libm , jmax , nblocks use modmpi , only : cmyid , myid , slabsum , excjs use modsubgriddata , only : ekm use modibmdata , only : ibmxforcevol use initfac , only : block use modinletdata , only : Urec , Wrec , Uinl , Utav , QLinl , QTinl , QLrec , QTrec , QTtav , QLtav , Ttav , upupavinl , vpvpavinl , wpwpavinl , upwpavinl ,& thlpthlpavinl , thlpupavinl , thlpwpavinl , qlpqlpavinl , qlpupavinl , qlpwpavinl , qtpqtpavinl , qtpupavinl , qtpwpavinl , Tinl , Trec , nstepread implicit none logical :: lexitnow = . false . integer imin , ihour integer i , j , k , n , im , ip , jm , jp , jpp , km , kp , kpp , il , iu , jl , ju , kl , ku character ( 21 ) name , name2 , name3 , name4 , linkname if ( timee == 0 ) return !    if (rk3step /=3) return if (( iinletgen == 2 ) . and . ( nstepread == nstore )) then ! This overrules the need for rk3step to be 3 in case of reading inletfiles write ( 6 , * ) 'Writing restartfiles after reading in new inletfiles' else if ( rk3step /= 3 ) return ! Normal check end if name = 'exit_now.' // cexpnr inquire ( file = trim ( name ), EXIST = lexitnow ) if ((( timee >= tnextrestart )) . or . (( lexitnow ) . or . ( nstepread == nstore + 1 ))) then tnextrestart = tnextrestart + trestart name = 'initd        _   .' write ( name ( 6 : 13 ) , '(i8.8)' ) ntrun name ( 15 : 17 ) = cmyid name ( 19 : 21 ) = cexpnr open ( ifoutput , file = name , form = 'unformatted' , status = 'replace' ) write ( ifoutput ) ((( mindist ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke ) write ( ifoutput ) (((( wall ( i , j , k , n ), i = ib , ie ), j = jb , je ), k = kb , ke ), n = 1 , 5 ) write ( ifoutput ) ((( u0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( v0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( w0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( pres0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( thl0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( e120 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( ekm ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( qt0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( ql0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( ql0h ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) timee , dt if ( myid == 0 ) then write ( * , * ) '-------------------------' write ( * , * ) 'Saving initd restart file' write ( * , * ) 'ntrun ::: ' , ntrun write ( * , * ) 'timee ::: ' , timee write ( * , * ) '-------------------------' endif close ( ifoutput ) if ( nsv > 0 ) then name = 'inits        _   .' write ( name ( 6 : 13 ) , '(i8.8)' ) ntrun name ( 15 : 17 ) = cmyid name ( 19 : 21 ) = cexpnr open ( ifoutput , file = name , form = 'unformatted' ) write ( ifoutput ) (((( sv0 ( i , j , k , n ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ), n = 1 , nsv ) write ( ifoutput ) timee close ( ifoutput ) end if if ( myid == 0 ) then write ( * , '(A,F15.7,A,I4)' ) 'dump at time = ' , timee , ' unit = ' , ifoutput end if end if end subroutine writerestartfiles end module modsave","tags":"","loc":"sourcefile/modsave.f90.html"},{"title":"modsubgriddata.f90 – uDALES","text":"Files dependent on this one sourcefile~~modsubgriddata.f90~~AfferentGraph sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~modibm.f90 modibm.f90 sourcefile~modibm.f90->sourcefile~modsubgriddata.f90 sourcefile~wf_gr.f90 wf_gr.f90 sourcefile~wf_gr.f90->sourcefile~modsubgriddata.f90 sourcefile~wf_uno.f90 wf_uno.f90 sourcefile~wf_uno.f90->sourcefile~modsubgriddata.f90 sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~modsubgrid.f90->sourcefile~modsubgriddata.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~modsubgrid.f90->sourcefile~modboundary.f90 sourcefile~tstep.f90 tstep.f90 sourcefile~tstep.f90->sourcefile~modsubgriddata.f90 sourcefile~advection.f90 advection.f90 sourcefile~advection.f90->sourcefile~modsubgriddata.f90 sourcefile~wfmneutral.f90 wfmneutral.f90 sourcefile~wfmneutral.f90->sourcefile~modsubgriddata.f90 sourcefile~modstatistics.f90 modstatistics.f90 sourcefile~modstatistics.f90->sourcefile~modsubgriddata.f90 sourcefile~modboundary.f90->sourcefile~modsubgriddata.f90 sourcefile~modinlet.f90 modinlet.f90 sourcefile~modboundary.f90->sourcefile~modinlet.f90 sourcefile~moddriver.f90 moddriver.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~modsave.f90->sourcefile~modsubgriddata.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~modstartup.f90->sourcefile~modsubgriddata.f90 sourcefile~modstartup.f90->sourcefile~modsubgrid.f90 sourcefile~modstartup.f90->sourcefile~modboundary.f90 sourcefile~modpois.f90 modpois.f90 sourcefile~modstartup.f90->sourcefile~modpois.f90 sourcefile~modstartup.f90->sourcefile~modinlet.f90 sourcefile~modstartup.f90->sourcefile~moddriver.f90 sourcefile~modchecksim.f90 modchecksim.f90 sourcefile~modchecksim.f90->sourcefile~modsubgriddata.f90 sourcefile~modpois.f90->sourcefile~modboundary.f90 sourcefile~modinlet.f90->sourcefile~modsave.f90 sourcefile~advec_2nd.f90 advec_2nd.f90 sourcefile~advec_2nd.f90->sourcefile~modibm.f90 sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~modstatsdump.f90->sourcefile~modsubgrid.f90 sourcefile~modstatsdump.f90->sourcefile~modstatistics.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modibm.f90 sourcefile~program.f90->sourcefile~modsubgrid.f90 sourcefile~program.f90->sourcefile~modboundary.f90 sourcefile~program.f90->sourcefile~modsave.f90 sourcefile~program.f90->sourcefile~modstartup.f90 sourcefile~program.f90->sourcefile~modchecksim.f90 sourcefile~program.f90->sourcefile~modpois.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules modsubgriddata Source Code modsubgriddata.f90 Source Code !!> \\file modsubdata.f90 !!!  Provides variable definitions for Calculates and applies the Sub Filter Scale diffusion ! !> !!  Calculates and applies the Sub Filter Scale diffusion !> !!  \\author Jasper Tomas, TU Delft !!  \\author Pier Siebesma, K.N.M.I. !!  \\author Stephan de Roode,TU Delft !!  \\author Chiel van Heerwaarden, Wageningen U.R. !!  \\author Thijs Heus,MPI-M !!  \\par Revision list !!  \\todo Documentation module modsubgriddata implicit none save ! private logical :: ldelta = . false . !<  switch for subgrid length formulation (on/off) logical :: lmason = . false . !<  switch for decreased length scale near the surface logical :: lsmagorinsky = . false . !<  switch for smagorinsky subgrid scheme logical :: lvreman = . false . !<  switch for Vreman (2004) subgrid scheme logical :: lbuoycorr = . false . !<  switch for buoyancy correction in Vreman (2004) subgrid scheme logical :: loneeqn = . false . !<  switch for one-eqn subgrid scheme real :: cf = 2.5 !< filter constant real :: Rigc = 0.25 !< critical Richardson number real :: Prandtl = 0.333 !  real :: Prandtl = 3.0 !  real :: prandtli= 1./3. real :: prandtli real :: cm = 0.12 real :: cn = 0.76 real :: ch1 = 1. real :: ch2 = 2. real :: ce1 = 0.19 real :: ce2 = 0.51 real :: cs = - 1. real :: nmason = 2. !< exponent in Mason correction function real :: alpha_kolm = 1.5 !< factor in Kolmogorov expression for spectral energy real :: beta_kolm = 1. !< factor in Kolmogorov relation for temperature spectrum !  real :: damp   = 1.      !< used in van driest damping function real :: dampmin = 1e-10 !< maximum damping used in van driest/Piomelli damping function real :: c_vreman = 0.07 !< model constant for subgrid-scale model by Vreman (2004) !  real :: c_vreman  = 0.025      !< model constant for subgrid-scale model by Vreman (2004) corresponds with smag_const=0.1 real , allocatable :: ekm (:,:,:) !< k-coefficient for momentum real , allocatable :: ekh (:,:,:) !< k-coefficient for heat and q_tot real , allocatable :: sbdiss (:,:,:) !< dissiation real , allocatable :: sbshr (:,:,:) !< shear production real , allocatable :: sbbuo (:,:,:) !< buoyancy production / destruction real , allocatable :: zlt (:,:,:) !< filter width real , allocatable :: csz (:,:) !< Smagorinsky constant real , allocatable :: damp (:,:,:) !< used in van Driest/Piomelli damping function end module modsubgriddata","tags":"","loc":"sourcefile/modsubgriddata.f90.html"},{"title":"modpois.f90 – uDALES","text":"This file depends on sourcefile~~modpois.f90~~EfferentGraph sourcefile~modpois.f90 modpois.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modpois.f90->sourcefile~modglobal.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modpois.f90->sourcefile~modfields.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~modpois.f90->sourcefile~modboundary.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modpois.f90->sourcefile~modmpi.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modboundary.f90->sourcefile~modglobal.f90 sourcefile~modboundary.f90->sourcefile~modfields.f90 sourcefile~modboundary.f90->sourcefile~modmpi.f90 sourcefile~modinlet.f90 modinlet.f90 sourcefile~modboundary.f90->sourcefile~modinlet.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~modboundary.f90->sourcefile~modsubgriddata.f90 sourcefile~modsurfdata.f90 modsurfdata.f90 sourcefile~modboundary.f90->sourcefile~modsurfdata.f90 sourcefile~modinletdata.f90 modinletdata.f90 sourcefile~modboundary.f90->sourcefile~modinletdata.f90 sourcefile~moddriver.f90 moddriver.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~modinlet.f90->sourcefile~modglobal.f90 sourcefile~modinlet.f90->sourcefile~modfields.f90 sourcefile~modinlet.f90->sourcefile~modmpi.f90 sourcefile~modinlet.f90->sourcefile~modsurfdata.f90 sourcefile~modinlet.f90->sourcefile~modinletdata.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~modinlet.f90->sourcefile~modsave.f90 sourcefile~moddriver.f90->sourcefile~modglobal.f90 sourcefile~moddriver.f90->sourcefile~modfields.f90 sourcefile~moddriver.f90->sourcefile~modmpi.f90 sourcefile~moddriver.f90->sourcefile~modinletdata.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~modsave.f90->sourcefile~modglobal.f90 sourcefile~modsave.f90->sourcefile~modfields.f90 sourcefile~modsave.f90->sourcefile~modmpi.f90 sourcefile~modsave.f90->sourcefile~modsubgriddata.f90 sourcefile~modsave.f90->sourcefile~modsurfdata.f90 sourcefile~modsave.f90->sourcefile~modinletdata.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~modsave.f90->sourcefile~modibmdata.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~modsave.f90->sourcefile~initfac.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~modpois.f90~~AfferentGraph sourcefile~modpois.f90 modpois.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~modstartup.f90->sourcefile~modpois.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modpois.f90 sourcefile~program.f90->sourcefile~modstartup.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules modpois Source Code modpois.f90 Source Code !> \\file modpois.f90 !!  Solves the Poisson equation for the pressure fluctuations !> !!  \\author Jasper Tomas, TU Delft, 31 March 2014 !!  \\author Harm Jonker, TU Delft !!  \\author Hans Cuijpers, IMAU !!  \\todo documentation !!  \\par Revision list !! Jasper Tomas: Now a different Poisson solver is implemented that can be used for inflow/outflow boundary conditions in the i-direction. !! Periodic BC's can also still be used. ! !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! module modpois implicit none private public :: initpois , poisson , exitpois , p save real , allocatable :: p (:,:,:) ! difference between p at previous and new step (p = P_new - P_old) contains subroutine initpois use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh implicit none allocate ( p ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) end subroutine initpois subroutine poisson use modglobal , only : ib , ie , ih , kb , ke , kh , kmax , dxh , dxf , dy , dzf , dzh , linoutflow , iinletgen , ipoiss , POISS_FFT , POISS_CYC use modmpi , only : myid , nprocs , barrou implicit none integer ibc1 , ibc2 , kbc1 , kbc2 , ksen call fillps !  ibc?=1: neumann !  ibc?=2: periodic !  ibc?=3: dirichlet select case ( ipoiss ) case ( POISS_FFT ) call solmpj ( p ) case ( POISS_CYC ) if ( linoutflow ) then ibc1 = 1 ! inlet ibc2 = 3 ! outlet else ibc1 = 2 ibc2 = 2 endif kbc1 = 1 kbc2 = 1 ksen = kmax / nprocs call poisr ( p , dxf , dxh , dy , dzf , dzh , & ibc1 , ibc2 , kbc1 , kbc2 , ksen ) case default write ( 0 , * ) \"Invalid choice for Poisson solver\" stop 1 end select call tderive end subroutine poisson subroutine exitpois implicit none deallocate ( p ) end subroutine exitpois ! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine fillps ! Chiel van Heerwaarden,  19 June 2007 ! Adapted fillps for RK3 time loop use modfields , only : up , vp , wp , um , vm , wm , u0 , v0 , w0 use modglobal , only : rk3step , ib , ie , jb , je , kb , ke , ih , jh , kh , dxfi , dyi , dzfi , dt ,& linoutflow , libm use modmpi , only : excjs use modboundary , only : bcpup !    use modibm,    only : ibmnorm implicit none real , allocatable :: pup (:,:,:), pvp (:,:,:), pwp (:,:,:) integer i , j , k real rk3coef , rk3coefi allocate ( pup ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( pvp ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( pwp ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) rk3coef = dt / ( 4. - dble ( rk3step )) rk3coefi = 1. / rk3coef do k = kb , ke do j = jb , je do i = ib , ie pup ( i , j , k ) = up ( i , j , k ) + um ( i , j , k ) * rk3coefi ! see equation 5.81 pvp ( i , j , k ) = vp ( i , j , k ) + vm ( i , j , k ) * rk3coefi pwp ( i , j , k ) = wp ( i , j , k ) + wm ( i , j , k ) * rk3coefi end do end do end do !**************************************************************** !     Fill the right hand for the poisson solver. !     The values for up(i2,j,k) and vp(i,j2,k) are still !     unknown and have to be set cyclic. !     Also we take wp(i,j,1) and wp(i,j,k1) equal to zero. !     NOTE: !     The poisson-solver only accepts values for i from 2 to i1, !     for j from 1 to jmax and for k from 1 to kmax. !     The right-hand p is therefore filled in this partical way. !************************************************************** call bcpup ( pup , pvp , pwp , rk3coef ) ! boundary conditions for pup,pvp,pwp do k = kb , ke do j = jb , je do i = ib , ie p ( i , j , k ) = ( pup ( i + 1 , j , k ) - pup ( i , j , k ) ) * dxfi ( i ) & ! see equation 5.72 + ( pvp ( i , j + 1 , k ) - pvp ( i , j , k ) ) * dyi & + ( pwp ( i , j , k + 1 ) - pwp ( i , j , k ) ) * dzfi ( k ) end do end do end do deallocate ( pup , pvp , pwp ) end subroutine fillps subroutine tderive !-----------------------------------------------------------------| !                                                                 | !*** *tderive*  read input fields for initialisation              | !                                                                 | !      Hans Cuijpers   I.M.A.U.     06/01/1995                    | !                                                                 | !     purpose.                                                    | !     --------                                                    | !                                                                 | !     Refill array p with pressure values. The poisson-solver     | !     produced a pressure array p in which the i-index varied     | !     between 2 and i1, the j- and k-index between 1 and resp.    | !     jmax and kmax. For our further calculations we'll change    | !     the range for the j-index to vary between 2 and j1.         | !                                                                 | !     Further we set cyclic boundary conditions for the pressure- | !     fluctuations in the x-y plane.                              | !                                                                 | !**   interface.                                                  | !     ----------                                                  | !                                                                 | !             *tderive* is called from *program*.                 | !                                                                 | !-----------------------------------------------------------------| use modfields , only : up , vp , wp , pres0 , IIc , IIcs use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , dxhi , dyi , dzhi , linoutflow , rslabs use modmpi , only : myid , excj , slabsum , avexy_ibm use modboundary , only : bcp implicit none integer i , j , k real , dimension ( kb - kh : ke + kh ) :: pij !    logical, dimension(ib:ie, jb:je, kb:ke) :: pnan real :: pijk !    integer :: ipnan ! Mathieu ATTTT: CHANGED!!! Loop removed!!! ! **  Boundary conditions ************** call bcp ( p ) ! boundary conditions for p. !***************************************************************** ! **  Calculate time-derivative for the velocities with known **** ! **  pressure gradients.  *************************************** !***************************************************************** !   if (myid == 0) then !     write(*,*) \"net ts\", p(ib, jb, :) !   end if !pnan = isnan(p(ib:ie, jb:je, kb:ke)) !ipnan = 0 !do k=kb,ke !do j=jb,je !do i=ib,ie !  if (pnan(i,j,k)) then !    ipnan = ipnan + 1 !  end if !end do !end do !end do !   write(*,*) \"NaN\", myid, ipnan !    write(*,*) \"NaN\", myid, dble(isnan(p)) !sum(real(isnan(p))) do k = kb , ke do j = jb , je do i = ib , ie vp ( i , j , k ) = vp ( i , j , k ) - ( p ( i , j , k ) - p ( i , j - 1 , k )) * dyi end do end do end do if ( linoutflow ) then do k = kb , ke do j = jb , je do i = ib , ie + 1 up ( i , j , k ) = up ( i , j , k ) - ( p ( i , j , k ) - p ( i - 1 , j , k )) * dxhi ( i ) ! see equation 5.82 (u is computed from the mass conservation) end do end do end do else do k = kb , ke do j = jb , je do i = ib , ie up ( i , j , k ) = up ( i , j , k ) - ( p ( i , j , k ) - p ( i - 1 , j , k )) * dxhi ( i ) ! see equation 5.82 (u is computed from the mass conservation) end do end do end do endif do k = kb + 1 , ke do j = jb , je do i = ib , ie wp ( i , j , k ) = wp ( i , j , k ) - ( p ( i , j , k ) - p ( i , j , k - 1 )) * dzhi ( k ) end do end do end do ! tg3315 02/02/2019 ! account for pressure offset that results from ill-defined problem in pressure ! correction method when periodic horizontal BCs are applied. Arises within cyclic ! reduction scheme (called by BLKTRI) and due to the numerics in PRODP in ! cycred.f which define the BC in the periodic case. A linear offset existed in ! the pressure correction term (p) and this can be controlled by subtracting ! the volume averaged modified pressure from this value at all time steps. ! Periodic: p - <p>_ijk ! Makes no change on physical effect of modified pressure in code. ! tg3315 - update 24/06/19 -- there is a missing term in the application of the periodic BCs for pup, could this be part of the problem? Test with this to see if can avoid use of pijk below. ! refer to mvr for necessity of this ! useful refs: ! https://opensky.ucar.edu/islandora/object/technotes%3A98/datastream/PDF/download/citation.pdf ! https://epubs.siam.org/doi/pdf/10.1137/0711042 pij = 0. ; pijk = 0. ; if (. not . linoutflow ) then call slabsum ( pij ( kb : ke ), kb , ke , p ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , ib , ie , jb , je , kb , ke ) pij = pij / rslabs pijk = sum ( pij ( kb : ke )) / ( ke - kb ) end if do k = kb - 1 , ke + 1 do j = jb - 1 , je + 1 do i = ib - 1 , ie + 1 pres0 ( i , j , k ) = pres0 ( i , j , k ) + p ( i , j , k ) - pijk ! update of the pressure: P_new = P_old + p enddo enddo enddo return end subroutine tderive !ils13, 13.08.18: currently unused, not callled subroutine ALL_ALL_j ( p , ptrans , iaction ) ! purpose: do all-to-all communication ! data are only distributed over the j-direction for p ! data are only distributed over the k-direction for ptrans ! NOTE: p     (0:imax+1  etc !       ptrans(1:imax    etc use modglobal , only : imax , isen , jmax , jsen , jtot , kmax use modmpi , only : comm3d , mpierr , my_real , nprocs , barrou implicit none integer iaction real p ( 0 : imax + 1 , 0 : jmax + 1 , 0 : kmax + 1 ) real ptrans ( 1 : isen , 1 : jtot , 1 : kmax ) ! help arrays for sending and receiving real , allocatable , dimension (:) :: bufin , bufout ! help variables integer ii , jbegin , jend , proc integer ibegin , iend integer i , j , k allocate ( bufin ( imax * jmax * kmax ), bufout ( imax * jmax * kmax )) if ( iaction == 0 ) then ii = 0 do proc = 0 , nprocs - 1 ibegin = ( proc ) * isen + 1 iend = ( proc + 1 ) * isen do i = ibegin , iend do j = 1 , jmax do k = 1 , kmax ii = ii + 1 bufin ( ii ) = p ( i , j , k ) enddo enddo enddo enddo ii = 0 !     call barrou() call MPI_ALLTOALL ( bufin , ( isen * jsen * kmax ), MY_REAL , & bufout ,( isen * jsen * kmax ), MY_REAL , & comm3d , mpierr ) !     call barrou() ii = 0 do proc = 0 , nprocs - 1 jbegin = proc * jsen + 1 jend = ( proc + 1 ) * jsen do i = 1 , isen do j = jbegin , jend do k = 1 , kmax ii = ii + 1 ptrans ( i , j , k ) = bufout ( ii ) enddo enddo enddo enddo !     call barrou() elseif ( iaction == 1 ) then ii = 0 do proc = 0 , nprocs - 1 jbegin = proc * jsen + 1 jend = ( proc + 1 ) * jsen do i = 1 , isen do j = jbegin , jend do k = 1 , kmax ii = ii + 1 bufin ( ii ) = ptrans ( i , j , k ) enddo enddo enddo enddo !     call barrou() call MPI_ALLTOALL ( bufin , ( isen * jsen * kmax ), MY_REAL , & bufout ,( isen * jsen * kmax ), MY_REAL , & comm3d , mpierr ) !     call barrou() ii = 0 do proc = 0 , nprocs - 1 ibegin = ( proc ) * isen + 1 iend = ( proc + 1 ) * isen do i = ibegin , iend do j = 1 , jmax do k = 1 , kmax ii = ii + 1 p ( i , j , k ) = bufout ( ii ) enddo enddo enddo enddo !     call barrou() endif deallocate ( bufin , bufout ) return end subroutine ALL_ALL_j ! ! Mathieu added ALL_ALL_j2 which transposes between j and k instead of i and k ! This was to be able to use solver poisr, maybe we should tidy this up later ! on! ALL_ALL_j2 uses ksen which is NOT in the modules... it is provided in the ! header for this reason ! subroutine ALL_ALL_j2 ( p , ptrans , iaction , ksen ) ! use modglobal , only : imax , isen , jmax , jsen , jtot , kmax use modmpi , only : comm3d , mpierr , my_real , nprocs , barrou implicit none ! !     include 'param.txt' ! !     include 'mpif.h' !     include 'mpi_cons.txt' ! integer iaction , ksen real p ( 0 : imax + 1 , 0 : jmax + 1 , 0 : kmax + 1 ) real ptrans ( 1 : imax , 1 : jtot , 1 : ksen ) integer i , j , k ! ! ! purpose: do all-to-all communication ! ! data are only distributed over the j-direction for p ! data are only distributed over the k-direction for ptrans ! ! help arrays for sending and receiving ! real bufin (( imax ) * jmax * ( kmax )) real bufout (( imax ) * jmax * ( kmax )) ! ! help variables ! integer ii , jstart , jend , proc integer kstart , kend , jvalue , kvalue ! ! if ( iaction . eq . 0 ) then ! ii = 0 do proc = 0 , nprocs - 1 kstart = ( proc ) * ksen + 1 kend = ( proc + 1 ) * ksen do k = kstart , kend do j = 1 , jmax do i = 1 , imax ii = ii + 1 bufin ( ii ) = p ( i , j , k ) enddo enddo enddo enddo ! ! ii = 0 ! ! call barrou () ! call MPI_ALLTOALL ( bufin , ( imax * jsen * ksen ), MY_REAL , & bufout ,( imax * jsen * ksen ), MY_REAL , & comm3d , mpierr ) !      bufout = bufin ! call barrou () ! ii = 0 ! do proc = 0 , nprocs - 1 jstart = proc * jsen + 1 jend = ( proc + 1 ) * jsen do k = 1 , ksen do j = jstart , jend do i = 1 , imax ii = ii + 1 ptrans ( i , j , k ) = bufout ( ii ) enddo enddo enddo ! enddo ! ! call barrou () ! ! elseif ( iaction . eq . 1 ) then ! ii = 0 ! do proc = 0 , nprocs - 1 jstart = proc * jsen + 1 jend = ( proc + 1 ) * jsen do k = 1 , ksen do j = jstart , jend do i = 1 , imax ii = ii + 1 bufin ( ii ) = ptrans ( i , j , k ) enddo enddo enddo ! enddo ! call barrou () ! call MPI_ALLTOALL ( bufin , ( imax * jsen * ksen ), MY_REAL , & bufout ,( imax * jsen * ksen ), MY_REAL , & comm3d , mpierr ) !      bufout = bufin ! call barrou () ! ! ii = 0 ! do proc = 0 , nprocs - 1 kstart = ( proc ) * ksen + 1 kend = ( proc + 1 ) * ksen do k = kstart , kend do j = 1 , jmax do i = 1 , imax ii = ii + 1 p ( i , j , k ) = bufout ( ii ) enddo enddo enddo enddo ! ! call barrou () endif ! return end subroutine ALL_ALL_j2 ! subroutine poisr SUBROUTINE poisr ( rhs , dx , dxh , dy , dz , dzh , & ibc1 , ibc2 , kbc1 , kbc2 , ksen ) ! ! CHANGES: ! includes jtot and ksen (calculated in poisson.f) in header !          help array rhst with dimensions (imax,jtot,ksen) !          ALL_ALL copy rhs to rhst and back for FFT's ! !  ibc?=1: neumann !  ibc?=2: periodic !  ibc?=3: dirichlet ! ! only FFT in j-direction, cyclic reduction in the others !      include'param.txt' !     include 'mpif.h' !     include 'mpi_cons.txt' use modglobal , only : imax , isen , jmax , jsen , jtot , kmax , poisrcheck use modfields , only : worksave use modmpi , only : myid , comm3d , mpierr , my_real , nprocs , barrou , MPI_SUM implicit none ! authors: m.j.b.m. pourquie, b.j. boersma integer i , j , k , ksen real rhs ( 0 : imax + 1 , 0 : jmax + 1 , 0 : kmax + 1 ), dx ( 0 : IMAX + 1 ), dxh ( 1 : IMAX + 1 ), dy real , allocatable , dimension (:,:,:) :: rhs2 real , allocatable , dimension (:) :: work integer ier , iperio , kperio integer ibc1 , ibc2 , kbc1 , kbc2 real dz ( 0 : kmax + 1 ), dzh ( 1 : kmax + 1 ), pi !   dz: kb-1:ke+1,  dzh: kb:ke+1 real a ( imax ), b ( imax ), c ( imax ), bin ( imax ) real az ( kmax ), bz ( kmax ), cz ( kmax ) real yrt ( jtot ) real , allocatable , dimension (:,:) :: vfftj real , allocatable , dimension (:,:) :: y real wj ( jtot + 15 ) real angle , tst integer ipos , jv real suml , sum ! ! test write !     write(6,*)'POISR, kmax, ksen, nprocs,jmax,jtot ',kmax, ksen, nprocs ,jmax,jtot allocate ( rhs2 ( imax , jtot , ksen )) allocate ( work ( 2 * imax * jmax * kmax )) allocate ( vfftj ( imax * ksen , jtot )) allocate ( y ( imax , kmax )) pi = 4. * atan ( 1. ) do i = 1 , imax a ( i ) = 1. / ( dx ( i ) * dxh ( i )) c ( i ) = 1. / ( dx ( i ) * dxh ( i + 1 )) b ( i ) = - ( a ( i ) + c ( i )) enddo if (( ibc1 ). eq . 1 ) then ! Neumann b ( 1 ) = b ( 1 ) + a ( 1 ) elseif ( ibc1 . eq . 2 ) then ! periodic b ( 1 ) = b ( 1 ) elseif ( ibc1 . eq . 3 ) then ! Dir b ( 1 ) = b ( 1 ) - a ( 1 ) endif if (( ibc2 ). eq . 1 ) then ! Neumann b ( imax ) = b ( imax ) + c ( imax ) elseif (( ibc2 ). eq . 2 ) then b ( imax ) = b ( imax ) elseif (( ibc2 ). eq . 3 ) then !         b(imax) = b(imax) - c(kmax)   ! Jasper T. : bug? Should be b(imax) - c(imax)? b ( imax ) = b ( imax ) - c ( imax ) endif if ( ibc1 . ne . 2 ) then c ( imax ) = 0. a ( 1 ) = 0. endif !     do i=1,imax !        write(6,*)'i, abc(i)',i, a(i),b(i),c(i) !     enddo ! ! fill coefficients in k-direction !      do k=1,kmax                          ! Mathieu's version !         az(k) =  1./(dz(k)*dzh(k-1)) !         cz(k) =  1./(dz(k)*dzh(k)) !         bz(k) =  - (az(k) + cz(k)) !      enddo do k = 1 , kmax az ( k ) = 1. / ( dz ( k ) * dzh ( k )) cz ( k ) = 1. / ( dz ( k ) * dzh ( k + 1 )) bz ( k ) = - ( az ( k ) + cz ( k )) enddo ! ! BC: ! !periodic     bz(1)    = bz(1) - az(1) !periodic      az(1)    = 0. !periodic     bz(kmax) = bz(kmax) - az(kmax) !periodic      az(kmax) = 0. if (( kbc1 ). eq . 1 ) then ! Neumann bz ( 1 ) = bz ( 1 ) + az ( 1 ) elseif ( kbc1 . eq . 2 ) then ! periodic bz ( 1 ) = bz ( 1 ) endif if (( kbc2 ). eq . 1 ) then ! Neumann bz ( kmax ) = bz ( kmax ) + cz ( kmax ) elseif (( kbc2 ). eq . 2 ) then bz ( kmax ) = bz ( kmax ) elseif (( kbc2 ). eq . 3 ) then ! ! p = 0. bz ( kmax ) = bz ( kmax ) - cz ( kmax ) endif if ( kbc1 . ne . 2 ) then cz ( kmax ) = 0. az ( 1 ) = 0. endif !     do k=1,kmax !        write(6,*)'k, abc(k)',k, az(k),bz(k),cz(k) !     enddo ! ! initialise for FFT ! PAR !     call vrffti(jmax,wj) call vrffti ( jtot , wj ) ! yrt ( 1 ) = 0. ! PAR !     yrt(jmax)=-4./(dy*dy) yrt ( jtot ) =- 4. / ( dy * dy ) do j = 3 , jtot , 2 ! ! 2.*(cos2(alpha) -1) = 2.*(-2.*sin(alpha)**2 yrt ( j - 1 ) = ( - 4. / ( dy * dy )) * ( sin ( float (( j - 1 )) * pi / ( 2. * jtot ))) ** 2 yrt ( j ) = yrt ( j - 1 ) enddo !     help = rhs ! ! sum check (comment out if not deeded) ! !!      suml = 0. !!      do k=1,kmax !!         do j=1,jmax !!         do i=1,imax !!         suml = suml + rhs(i,j,k)*dx(i)*dy*dz(k) !!         enddo !!         enddo !!      enddo !!      call MPI_ALLREDUCE(suml, sum, 1, MY_REAL, MPI_SUM, comm3d,mpierr) !!      if(myid.eq.0) write(6,*)'solver sum = ', sum ! ! end sum check ! call barrou () call ALL_ALL_j2 ( rhs , rhs2 , 0 , ksen ) call barrou () do k = 1 , ksen do i = 1 , imax ipos = ( k - 1 ) * imax + i do j = 1 , jtot vfftj ( ipos , j ) = rhs2 ( i , j , k ) !     suml = suml + rhs2(i,j,k)*dy*dz(k)*dx(i) enddo enddo enddo !     call MPI_ALLREDUCE(suml, sum, 1, MY_REAL, MPI_SUM, comm3d,mpierr) !     if(myid.eq.0) write(6,*)'solver sum = ', sum ! call vrfftf ( imax * ksen , jtot , vfftj , rhs2 , imax * ksen , wj ) ! !      goto 1234 do k = 1 , ksen do i = 1 , imax ipos = ( k - 1 ) * imax + i do j = 1 , jtot rhs2 ( i , j , k ) = vfftj ( ipos , j ) enddo enddo enddo call barrou () call ALL_ALL_j2 ( rhs , rhs2 , 1 , ksen ) call barrou () !     call sumchk3(rhs,imax,jmax,kmax,8,1) ! PAR CHECK!!! do j = 1 , jmax ! begin loop over angles !     do j=1,jtot       ! begin loop over angles ! ! add proper part to diagonal jv = j + myid * jmax do i = 1 , imax ! PAR CHECK!! bin ( i ) = b ( i ) + yrt ( jv ) !!!!!!!!!/(Rp(i)**2) enddo !ATTT      do k=1,ksen do k = 1 , kmax do i = 1 , imax ipos = ( k - 1 ) * imax + i !PAR CHECK y ( i , k ) = rhs ( i , j , k ) !vfftj(ipos,j) enddo enddo iperio = 1 kperio = 1 if ( ibc1 . eq . 2 ) iperio = 0 ! i periodic if ( kbc1 . eq . 2 ) kperio = 0 ! k periodic if ( poisrcheck . eq . 0 ) then poisrcheck = 1 CALL BLKTRI ( 0 , kperio , kmax , az , bz , cz , iperio , imax , a , bin , c , imax , y & ! !                   &#94; 0 for periodic BC , ier , work ) !     write(6,*)'ier = ', ier, iperio, kperio !     if(ier.ne.0)stop 'IER' worksave = work write ( 6 , * ) 'First time step in POISR, poisrcheck=' , poisrcheck end if CALL BLKTRI ( 1 , kperio , kmax , az , bz , cz , iperio , imax , a , bin , c , imax , y & , ier , worksave ) ! !     write(6,*)'myid, ier = ', myid, ier, j !      if(ier.ne.0)stop 'IER' do k = 1 , kmax do i = 1 , imax ipos = ( k - 1 ) * imax + i !PAR CHECK !        vfftj(ipos,j) = y(i,k) rhs ( i , j , k ) = y ( i , k ) enddo enddo enddo ! end loop over angles 1234 continue !     call sumchk3(rhs,imax,jmax,kmax,9,1) ! call barrou () call ALL_ALL_j2 ( rhs , rhs2 , 0 , ksen ) call barrou () ! do k = 1 , ksen do i = 1 , imax ipos = ( k - 1 ) * imax + i do j = 1 , jtot vfftj ( ipos , j ) = rhs2 ( i , j , k ) enddo enddo enddo call vrfftb ( imax * ksen , jtot , vfftj , rhs2 , imax * ksen , wj ) !!ATTTT      dok=1,kmax do k = 1 , ksen do i = 1 , imax ipos = ( k - 1 ) * imax + i do j = 1 , jtot rhs2 ( i , j , k ) = vfftj ( ipos , j ) !     if(abs(rhs(i,j,k)-help(i,j,k)).gt.1.e-13)then !       write(6,*)'ERRR', i, j, k, rhs(i,j,k), help(i,j,k) !     endif enddo enddo enddo call barrou () call ALL_ALL_j2 ( rhs , rhs2 , 1 , ksen ) call barrou () !     call sumchk3(rhs,imax,jmax,kmax,2,1) deallocate ( rhs2 ) deallocate ( work ) deallocate ( vfftj ) deallocate ( y ) return end subroutine poisr subroutine solmpj ( p1 ) ! version: working version, barrou's removed, !          correct timing fft's !          AAPC with MPI-provided routines !          uses only 2 AAPC, using MPI-rovided routines, !          to pre-distribute the arrays s.t. complete !          2-D planes are present on each processor !          uses ALLTOALL instead of ALLTOALLV !          ONLY distribution in j-direction allowed ! NOTE: input array p1 is supposed to have the ip1ray distribution, !       i.e. the entire range of the first index must be present on !       each processor !****************************************************************** !********************  FAST POISSON SOLVER ************************ !*****                                                        ***** !***               P_xx + P_yy + P_zz  =f(x,y,z)                *** !****                                                         ***** !****************************************************************** !   FOURIER TRANSFORMS IN X AND Y DIRECTION   GIVE: !   a&#94;2 P + b&#94;2 P + P_zz =  F(x,y,z) = FFT_i [ FTT_j (f(x,y,z))] !   where a and b are the KNOWN eigenvalues, and P_zz is !   P_zz =[ P_{i,j,k+1} - 2 P_{i,j,k} +P_{i,j,k-1} ] / (dz * dz) !   a&#94;2 P + b&#94;2 +P_zz = !   [P_{i,j,k+1}-(2+a&#94;2+ b&#94;2) P_{i,j,k}+P_{i,j,k-1}]/(dz*dz)=F( x,y,z) !   The equation above results in a tridiagonal system in k which !   can be solved with Gaussian elemination --> P !   The P we have found with the Gaussian elemination is still in !   the Fourier Space and 2 backward FFTS are necessary to compute !   the physical P !****************************************************************** !****************************************************************** !****************************************************************** !****   Programmer: Bendiks Jan Boersma                      ****** !****               email : b.j.boersma@wbmt.tudelft.nl      ****** !****                                                        ****** !****   USES      :  VFFTPACK   (netlib)                     ****** !****             :  FFTPACK    (netlib)                     ****** !****                (B.J. Boersma & L.J.P. Timmermans)      ****** !****                                                        ****** !****************************************************************** !****************************************************************** ! mpi-version, no master region for timing !              copy times all included use modmpi , only : myid , comm3d , mpierr , nprocs , barrou use modglobal , only : imax , jmax , kmax , isen , jtot , pi , dyi , dzf , dzh , dxfi , kb , ke , kh !, rhoa !    use modfields, only : rhobf, rhobh implicit none real :: dxi integer :: i1 , j1 , k1 !   real, intent(inout), dimension(:,:,:) :: p1 real p1 ( 0 : imax + 1 , 0 : jmax + 1 , 0 : kmax + 1 ) real , allocatable , dimension (:,:,:) :: d , p2 real , allocatable , dimension (:,:,:) :: xyzrt real , allocatable , dimension (:) :: xrt , yrt , a , b , c , FFTI , FFTJ , winew , wjnew , rhobf , rhobh real z , ak , bk , bbk , fac integer jv integer i , j , k !real dzl(ke+kh-(kb-kh)),dzhl(ke+kh-(kb-kh)) real dzl ( 0 : kmax + 1 ), dzhl ( 1 : kmax + 1 ) dxi = dxfi ( 1 ) dzl ( 0 : kmax + 1 ) = dzf ( kb - kh : ke + kh ) dzhl ( 1 : kmax + 1 ) = dzh ( kb : ke + kh ) i1 = imax + 1 j1 = jmax + 1 k1 = kmax + 1 !   allocate(p1(0:i1,0:j1,0:k1)) ! p and d distributed equally: allocate ( d ( imax , jmax , kmax )) ! re-distributed p: allocate ( p2 ( isen , jtot , kmax )) ! re-distributed p1: allocate ( rhobf ( 1 : kmax ), rhobh ( 1 : kmax + 1 )) allocate ( xyzrt ( 0 : i1 , 0 : j1 , 0 : k1 ), xrt ( 0 : i1 ), yrt ( 0 : jtot + 1 )) allocate ( a ( 0 : kmax + 1 ), b ( 0 : kmax + 1 ), c ( 0 : kmax + 1 )) allocate ( FFTI ( imax ), FFTJ ( jtot ), winew ( 2 * imax + 15 ), wjnew ( 2 * jtot + 15 )) rhobf = 1 ; rhobh = 1 ; call MPI_COMM_RANK ( comm3d , myid , mpierr ) call MPI_COMM_SIZE ( comm3d , nprocs , mpierr ) call rffti ( imax , winew ) call rffti ( jtot , wjnew ) !     call barrou() !FFT  ---> I direction fac = 1. / sqrt ( imax * 1. ) do k = 1 , kmax do j = 1 , jmax do i = 1 , imax FFTI ( i ) = p1 ( i , j , k ) end do call rfftf ( imax , FFTI , winew ) do i = 1 , imax ! ATT: First back to p1, then re-distribution!!! p1 ( i , j , k ) = FFTI ( i ) * fac end do end do end do call ALL_ALL_j ( p1 , p2 , 0 ) !FFT  ---> J direction fac = 1. / sqrt ( jtot * 1. ) do i = 1 , isen do k = 1 , kmax do j = 1 , jtot FFTJ ( j ) = p2 ( i , j , k ) end do call rfftf ( jtot , FFTJ , wjnew ) do j = 1 , jtot ! ATTT back to pl p2 ( i , j , k ) = FFTJ ( j ) * fac end do end do end do !     call barrou() call ALL_ALL_j ( p1 , p2 , 1 ) !     call barrou() ! Generate Eigenvalues  (xrt and yrt ) !  I --> direction fac = 1. / ( 2. * imax ) do i = 3 , imax , 2 xrt ( i - 1 ) =- 4. * dxi * dxi * ( sin ( float (( i - 1 )) * pi * fac )) ** 2 xrt ( i ) = xrt ( i - 1 ) end do xrt ( 1 ) = 0. xrt ( imax ) = - 4. * dxi * dxi !  J --> direction fac = 1. / ( 2. * jtot ) do j = 3 , jtot , 2 yrt ( j - 1 ) =- 4. * dyi * dyi * ( sin ( float (( j - 1 )) * pi * fac )) ** 2 yrt ( j ) = yrt ( j - 1 ) end do yrt ( 1 ) = 0. yrt ( jtot ) = - 4. * dyi * dyi ! Generate tridiagonal matrix ! NOTE -- dzfm dzh are defined from 0 -- hence ..-1 do k = 1 , kmax ! SB fixed the coefficients a ( k ) = rhobh ( k ) / ( dzl ( k ) * dzhl ( k )) c ( k ) = rhobh ( k + 1 ) / ( dzl ( k ) * dzhl ( k + 1 )) b ( k ) =- ( a ( k ) + c ( k )) end do b ( 1 ) = b ( 1 ) + a ( 1 ) a ( 1 ) = 0. b ( kmax ) = b ( kmax ) + c ( kmax ) c ( kmax ) = 0. do k = 1 , kmax do j = 1 , jmax jv = j + myid * jmax do i = 1 , imax xyzrt ( i , j , k ) = rhobf ( k ) * ( xrt ( i ) + yrt ( jv )) !!! LH end do end do end do ! SOLVE TRIDIAGONAL SYSTEMS WITH GAUSSIAN ELEMINATION do j = 1 , jmax jv = j + myid * jmax do i = 1 , imax z = 1. / ( b ( 1 ) + xyzrt ( i , j , 1 )) d ( i , j , 1 ) = c ( 1 ) * z p1 ( i , j , 1 ) = p1 ( i , j , 1 ) * z end do end do do k = 2 , kmax - 1 do j = 1 , jmax jv = j + myid * jmax do i = 1 , imax bbk = b ( k ) + xyzrt ( i , j , k ) z = 1. / ( bbk - a ( k ) * d ( i , j , k - 1 )) d ( i , j , k ) = c ( k ) * z p1 ( i , j , k ) = ( p1 ( i , j , k ) - a ( k ) * p1 ( i , j , k - 1 )) * z end do end do end do ak = a ( kmax ) bk = b ( kmax ) do j = 1 , jmax jv = j + myid * jmax do i = 1 , imax bbk = bk + xyzrt ( i , j , kmax ) z = bbk - ak * d ( i , j , kmax - 1 ) if ( z /= 0. ) then p1 ( i , j , kmax ) = ( p1 ( i , j , kmax ) - ak * p1 ( i , j , kmax - 1 )) / z else p1 ( i , j , kmax ) = 0. end if end do end do do k = kmax - 1 , 1 , - 1 do j = 1 , jmax do i = 1 , imax p1 ( i , j , k ) = p1 ( i , j , k ) - d ( i , j , k ) * p1 ( i , j , k + 1 ) end do end do end do !     call barrou() ! MPI_ALL CALL!!! call ALL_ALL_j ( p1 , p2 , 0 ) !     call barrou() ! BACKWARD FFT ---> I direction ! BACKWARD FFT ---> J direction fac = 1. / sqrt ( jtot * 1. ) do i = 1 , isen do k = 1 , kmax do j = 1 , jtot ! ATT, ADAPTED!!! FFTJ ( j ) = p2 ( i , j , k ) end do call rfftb ( jtot , FFTJ , wjnew ) do j = 1 , jtot ! ATT back to p2!!! p2 ( i , j , k ) = FFTJ ( j ) * fac end do end do end do !     call barrou() call ALL_ALL_j ( p1 , p2 , 1 ) fac = 1. / sqrt ( imax * 1. ) do k = 1 , kmax do j = 1 , jmax do i = 1 , imax FFTI ( i ) = p1 ( i , j , k ) end do call rfftb ( imax , FFTI , winew ) do i = 1 , imax ! ATT back to p1 !!! p1 ( i , j , k ) = FFTI ( i ) * fac end do end do end do deallocate ( d , p2 , xyzrt , xrt , yrt , a , b , c , FFTI , FFTJ , winew , wjnew ) !     call barrou() return end subroutine solmpj end module modpois","tags":"","loc":"sourcefile/modpois.f90.html"},{"title":"modthermodynamics.f90 – uDALES","text":"This file depends on sourcefile~~modthermodynamics.f90~~EfferentGraph sourcefile~modthermodynamics.f90 modthermodynamics.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modthermodynamics.f90->sourcefile~modglobal.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modthermodynamics.f90->sourcefile~modfields.f90 sourcefile~modsurfdata.f90 modsurfdata.f90 sourcefile~modthermodynamics.f90->sourcefile~modsurfdata.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modthermodynamics.f90->sourcefile~modmpi.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~modthermodynamics.f90~~AfferentGraph sourcefile~modthermodynamics.f90 modthermodynamics.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~modstartup.f90->sourcefile~modthermodynamics.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modthermodynamics.f90 sourcefile~program.f90->sourcefile~modstartup.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules modthermodynamics Source Code modthermodynamics.f90 Source Code !>\\file modthermodynamics.f90 !! Do the thermodynamics !> !! Do the thermodynamics !> !! Timeseries of the most relevant parameters. Written to tmser1.expnr and tmsurf.expnr !! If netcdf is true, this module leads the tmser.expnr.nc output !!  \\author Pier Siebesma, K.N.M.I. !!  \\author Stephan de Roode,TU Delft !!  \\author Thijs Heus,MPI-M !!  \\par Revision list !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! module modthermodynamics implicit none !   private public :: thermodynamics , calc_halflev public :: lqlnr logical :: lqlnr = . false . !< switch for ql calc. with Newton-Raphson (on/off) real , allocatable :: th0av (:) real :: chi_half = 0.5 !< set wet, dry or intermediate (default) mixing over the cloud edge real , allocatable :: thv0 (:,:,:) contains !> Allocate and initialize arrays subroutine initthermodynamics use modglobal , only : kb , ke , kh , ib , ie , jb , je implicit none allocate ( th0av ( kb : ke + kh )) allocate ( thv0 ( ib : ie , jb : je , kb : ke + kh )) th0av = 0. end subroutine initthermodynamics !> Do moist thermodynamics. !! Calculate the liquid water content, do the microphysics, calculate the mean hydrostatic pressure, calculate the fields at the half levels, and finally calculate the virtual potential temperature. subroutine thermodynamics use modglobal , only : lmoist , timee , kb , ke , kh , ib , ih , ie , jb , jh , je , rlv , cp , rslabs , rd , rv , libm , eps1 use modfields , only : thl0 , thl0h , qt0 , qt0h , ql0 , ql0h , presf , presh , exnf , exnh , thvh , thv0h , qt0av , ql0av , thvf , rhof , IIc , IIw , IIcs , IIws use modmpi , only : slabsum , avexy_ibm , myid !ILS13 added variables behind \"exnh\" implicit none integer :: k if ( timee == 0 ) call diagfld if ( lmoist ) then call thermo ( thl0 , qt0 , ql0 , presf , exnf ) end if call diagfld call calc_halflev !calculate halflevel values of qt0 and thl0 if ( lmoist ) then call thermo ( thl0h , qt0h , ql0h , presh , exnh ) end if call calthv !ILS13 introduced from DALES4.0   13.05.2015 thvh = 0. !    call slabsum(thvh,kb,ke+kh,thv0h(:,:,kb:ke+kh),ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) !redefine halflevel thv using calculated thv !    thvh = thvh/rslabs call avexy_ibm ( thvh ( kb : ke + kh ), thv0h ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. false .) !    if (libm) then !      call avexy_ibm(thvh(kb:ke),thv0h(ib:ie,jb:je,kb:ke),ib,ie,jb,je,kb,ke,IIw(ib:ie,jb:je,kb:ke),IIws(kb:ke)) !    else !      call slabsum(thvh,kb,ke+kh,thv0h(:,:,kb:ke+kh),ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) !     !redefine halflevel thv using calculated thv !     thvh = thvh/rslabs !    end if thvh ( kb ) = th0av ( kb ) * ( 1 + ( rv / rd - 1 ) * qt0av ( kb ) - rv / rd * ql0av ( kb )) ! override first level if ( abs ( thvh ( kb + 1 )) < eps1 ) then thvh ( kb + 1 ) = th0av ( kb + 1 ) * ( 1 + ( rv / rd - 1 ) * qt0av ( kb + 1 ) - rv / rd * ql0av ( kb + 1 )) ! override second level if all blocks at kb end if !    where (thvh==0) !override slabs completely covered by blocks !      thvh = th0av(kb)*(1+(rv/rd-1)*qt0av(kb)-rv/rd*ql0av(kb)) !    endwhere do k = kb , ke + kh !    thv0(ib+ih:ie,jb+jh:je,k) = (thl0(ib+ih:ie,jb+ih:je,k)+rlv*ql0(ib+ih:ie,jb+ih:je,k)/(cp*exnf(k)))*(1+(rv/rd-1)*qt0(ib+ih:ie,jb+ih:je,k)-rv/rd*ql0(ib+ih:ie,jb+ih:je,k)) thv0 ( ib : ie , jb : je , k ) = ( thl0 ( ib : ie , jb : je , k ) + rlv * ql0 ( ib : ie , jb : je , k ) / ( cp * exnf ( k ))) * ( 1 + ( rv / rd - 1 ) * qt0 ( ib : ie , jb : je , k ) - rv / rd * ql0 ( ib : ie , jb : je , k )) enddo thvf = 0.0 !write(*,*) \"thv0\",thv0 !    call slabsum(thvf,kb,ke+kh,thv0,ib,ie+ih,jb,je+jh,kb,ke+kh,ib+ih,ie,jb+ih,je,kb,ke+kh) !    call slabsum(thvf,kb,ke+kh,thv0,ib,ie,jb,je,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( thvf ( kb : ke + kh ), thv0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) !    write(*,*) 'IIc(2,2,:), myid' , IIc(12,2,:), myid !    where (thvf==0) !override slabs completely covered by blocks !      thvf = th0av(kb)*(1+(rv/rd-1)*qt0av(kb)-rv/rd*ql0av(kb)) !    endwhere !    thvf = thvf/rslabs !write(*,*) \"thvf\",thvf !write(*,*) \"exnf\",exnf !    do k=1,k1 !      rhof(k) = presf(k)/(rd*thvf(k)*exnf(k)) !    end do end subroutine thermodynamics !> Cleans up after the run subroutine exitthermodynamics implicit none deallocate ( th0av ) end subroutine exitthermodynamics !> Calculate thetav and dthvdz subroutine calthv use modglobal , only : lmoist , ib , ie , jb , je , kb , ke , kh , zf , zh , dzh , rlv , rd , rv , cp , eps1 use modfields , only : thl0 , thl0h , ql0 , ql0h , qt0 , qt0h , sv0 , exnf , exnh , thv0h , dthvdz use modsurfdata , only : dthldz , dqtdz implicit none integer i , j , k real qs real c1 , c2 , dq , dth , dthv , temp real a_dry , b_dry , a_moist , b_moist , c_liquid , epsilon , eps_I , chi_sat , chi real del_thv_sat , del_thv_dry dthvdz = 0.0 if ( lmoist ) then do k = kb , ke + kh do j = jb , je do i = ib , ie thv0h ( i , j , k ) = ( thl0h ( i , j , k ) + rlv * ql0h ( i , j , k ) / ( cp * exnh ( k ))) & * ( 1 + ( rv / rd - 1 ) * qt0h ( i , j , k ) - rv / rd * ql0h ( i , j , k )) end do end do end do do k = kb + 1 , ke do j = jb , je do i = ib , ie ! !         default thv jump computed unsaturated ! epsilon = rd / rv eps_I = 1 / epsilon - 1. !cstep approx 0.608 a_dry = 1. + eps_I * qt0 ( i , j , k ) b_dry = eps_I * thl0 ( i , j , k ) dth = thl0 ( i , j , k + 1 ) - thl0 ( i , j , k - 1 ) dq = qt0 ( i , j , k + 1 ) - qt0 ( i , j , k - 1 ) del_thv_dry = a_dry * dth + b_dry * dq dthv = del_thv_dry if ( ql0 ( i , j , k ) > 0 ) then !include moist thermodynamics temp = thl0 ( i , j , k ) * exnf ( k ) + ( rlv / cp ) * ql0 ( i , j , k ) qs = qt0 ( i , j , k ) - ql0 ( i , j , k ) a_moist = ( 1. - qt0 ( i , j , k ) + qs / epsilon * ( 1. + rlv / ( rv * temp ))) & / ( 1. + rlv ** 2 * qs / ( cp * rv * temp ** 2 )) b_moist = a_moist * rlv / cp - temp c_liquid = a_dry * rlv / cp - thl0 ( i , j , k ) / epsilon del_thv_sat = a_moist * dth + b_moist * dq chi = 2 * chi_half * ( zf ( k ) - zf ( k - 1 )) / ( dzh ( k ) + dzh ( k + 1 )) chi_sat = c_liquid * ql0 ( i , j , k ) / ( del_thv_dry - del_thv_sat ) if ( chi < chi_sat ) then !mixed parcel is saturated dthv = del_thv_sat end if end if dthvdz ( i , j , k ) = dthv / ( dzh ( k + 1 ) + dzh ( k )) end do end do end do do j = jb , je do i = ib , ie dthvdz ( i , j , kb ) = 0. end do end do else !      thv0h = thl0h thv0h = thl0h (:,:, kb : ke + kh ) do k = kb + 1 , ke do j = jb , je do i = ib , ie dthvdz ( i , j , k ) = ( thl0 ( i , j , k + 1 ) - thl0 ( i , j , k - 1 )) / ( dzh ( k + 1 ) + dzh ( k )) end do end do end do do j = jb , je do i = ib , ie dthvdz ( i , j , kb ) = 0. end do end do end if !CvH remove WHERE !where (abs(dthvdz)<eps1) !  dthvdz = sign(eps1,dthvdz) !end where do k = kb , ke do j = jb , je do i = ib , ie if ( abs ( dthvdz ( i , j , k )) < eps1 ) then dthvdz ( i , j , k ) = sign ( eps1 , dthvdz ( i , j , k )) end if end do end do end do end subroutine calthv !> Calculate diagnostic slab averaged fields. !!     Calculates slab averaged fields assuming !!     hydrostatic equilibrium for: u,v,theta_l,theta_v, !!     qt,ql,exner,pressure and the density !! \\author      Pier Siebesma   K.N.M.I.     06/01/1995 subroutine diagfld use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , khc , nsv , zh , zf , rslabs , grav , rlv , cp , rd , rv , pref0 use modfields , only : u0 , v0 , thl0 , qt0 , ql0 , sv0 , u0av , v0av , thl0av , qt0av , ql0av , sv0av , & presf , presh , exnf , exnh , rhof , thvf , IIc , IIcs , IIu , IIus , IIv , IIvs use modsurfdata , only : thls , ps use modmpi , only : slabsum , myid , avexy_ibm implicit none real tv integer k , n !!********************************************************* !!  1.0   calculate average profiles of u,v,thl,qt and ql * !!        assuming hydrostatic equilibrium                * !!********************************************************* ! initialise local MPI arrays u0av = 0.0 v0av = 0.0 thl0av = 0.0 th0av = 0.0 qt0av = 0.0 ql0av = 0.0 sv0av = 0. !CvH changed momentum array dimensions to same value as scalars! !  call slabsum(u0av  ,kb,ke+kh,u0  ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) !    call slabsum(u0av  ,kb,ke+kh,u0(:,:,kb:ke+kh)  ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( u0av ( kb : ke + kh ), u0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIu ( ib : ie , jb : je , kb : ke + kh ), IIus ( kb : ke + kh ),. false .) !  call slabsum(v0av  ,kb,ke+kh,v0  ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) !    call slabsum(v0av  ,kb,ke+kh,v0(:,:,kb:ke+kh)  ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( v0av ( kb : ke + kh ), v0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIv ( ib : ie , jb : je , kb : ke + kh ), IIvs ( kb : ke + kh ),. false .) !  call slabsum(thl0av,kb,ke+kh,thl0,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) !    call slabsum(thl0av,kb,ke+kh,thl0(:,:,kb:ke+kh),ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( thl0av ( kb : ke + kh ), thl0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) !write(*,*) 'thl0av(kb), thl0av(kb+1)', thl0av(kb), thl0av(kb+1) !if (IIbl == 0) then ! as lEB applies blocks to kb and masking matrices average this to zero !  thl0av(kb) = thl0av(kb+1) !end if !  call slabsum(qt0av ,kb,ke+kh,qt0 ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) !    call slabsum(qt0av ,kb,ke+kh,qt0(:,:,kb:ke+kh) ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( qt0av ( kb : ke + kh ), qt0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) !    call slabsum(ql0av ,kb,ke+kh,ql0 ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( ql0av ( kb : ke + kh ), ql0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) exnf = 1 - grav * zf / ( cp * thls ) exnh = 1 - grav * zh / ( cp * thls ) th0av = thl0av + ( rlv / cp ) * ql0av / exnf !write(*,*) 'thl0av',thl0av !write(*,*) 'th0av',th0av do n = 1 , nsv !       call slabsum(sv0av(kb,n),kb,ke+kh,sv0(ib-ih,jb-jh,kb,n),ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( sv0av ( kb : ke + khc , n ), sv0 ( ib : ie , jb : je , kb : ke + khc , n ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + khc ), IIcs ( kb : ke + khc ),. false .) end do !    sv0av = sv0av/rslabs !*********************************************************** !  2.0   calculate average profile of pressure at full and * !        half levels, assuming hydrostatic equilibrium.    * !*********************************************************** !    2.1 Use first guess of theta, then recalculate theta call fromztop exnf = ( presf / pref0 ) ** ( rd / cp ) th0av = thl0av + ( rlv / cp ) * ql0av / exnf !    2.2 Use new updated value of theta for determination of pressure call fromztop !*********************************************************** !  3.0   Construct density profiles and exner function     * !       for further use in the program                     * !*********************************************************** !    3.1 determine exner exnh ( kb ) = ( ps / pref0 ) ** ( rd / cp ) exnf ( kb ) = ( presf ( kb ) / pref0 ) ** ( rd / cp ) do k = kb + 1 , ke + kh exnf ( k ) = ( presf ( k ) / pref0 ) ** ( rd / cp ) exnh ( k ) = ( presh ( k ) / pref0 ) ** ( rd / cp ) end do thvf ( kb ) = th0av ( kb ) * exnf ( kb ) * ( 1 + ( rv / rd - 1 ) * qt0av ( kb ) - rv / rd * ql0av ( kb )) rhof ( kb ) = presf ( kb ) / ( rd * thvf ( kb )) !    3.2 determine rho do k = kb + 1 , ke !+kh    ? !   write(*,*) \"exnf(k)\",exnf(k) !   write(*,*) \"th0av(k)\",th0av(k) !   write(*,*) \"qt0av(k)\",qt0av(k) !   write(*,*) \"ql0av(k)\",ql0av(k) thvf ( k ) = th0av ( k ) * exnf ( k ) * ( 1. + ( rv / rd - 1 ) * qt0av ( k ) - rv / rd * ql0av ( k )) rhof ( k ) = presf ( k ) / ( rd * thvf ( k )) end do return end subroutine diagfld !> Calculates slab averaged pressure !!      Input :  zf,zh,theta and qt profile !!      Output:  pressure profile at full and !!               half levels !! !!      Method: Using hydrostatic equilibrium !! !!                              -g*pref0**(rd/cp) !! =====>       dp**(rd/cp)/dz = -------------- !!                                 cp*thetav !! \\author Pier Siebesma   K.N.M.I.     06/01/1995 subroutine fromztop use modglobal , only : kmax , kb , ke , kh , dzf , dzh , rv , rd , cp , tmelt , zf , grav , pref0 , lEB use modfields , only : qt0av , ql0av , presf , presh , thvh , thvf , IIcs use modsurfdata , only : ps , thvs implicit none integer k real rdocp real , allocatable , dimension (:) :: thetah , qth , qlh allocate ( thetah ( kb : ke + kh ), qth ( kb : ke + kh ), qlh ( kb : ke + kh )) rdocp = rd / cp !************************************************** !    1.0 Determine theta and qt at half levels    * !************************************************** do k = kb + 1 , ke + kh thetah ( k ) = ( th0av ( k ) * dzf ( k - 1 ) + th0av ( k - 1 ) * dzf ( k )) / ( 2 * dzh ( k )) qth ( k ) = ( qt0av ( k ) * dzf ( k - 1 ) + qt0av ( k - 1 ) * dzf ( k )) / ( 2 * dzh ( k )) qlh ( k ) = ( ql0av ( k ) * dzf ( k - 1 ) + ql0av ( k - 1 ) * dzf ( k )) / ( 2 * dzh ( k )) end do !************************************************** !     2.1  calculate pressures at full levels     * !          assuming hydrostatic equilibrium       * !************************************************** !     1: lowest level: use thvs thvh ( kb ) = thvs presf ( kb ) = ps ** rdocp - & grav * ( pref0 ** rdocp ) * zf ( kb ) / ( cp * thvh ( kb )) presf ( kb ) = presf ( kb ) ** ( 1. / rdocp ) !     2: higher levels do k = kb + 1 , ke + kh thvh ( k ) = thetah ( k ) * ( 1 + ( rv / rd - 1 ) * qth ( k ) - rv / rd * qlh ( k )) presf ( k ) = presf ( k - 1 ) ** rdocp - grav * ( pref0 ** rdocp ) * dzh ( k ) / ( cp * thvh ( k )) presf ( k ) = presf ( k ) ** ( 1. / rdocp ) end do !************************************************** !     2.2   calculate pressures at half levels    * !           assuming hydrostatic equilibrium      * !************************************************** presh ( kb ) = ps thvf ( kb ) = th0av ( kb ) * ( 1 + ( rv / rd - 1 ) * qt0av ( kb ) - rv / rd * ql0av ( kb )) do k = kb + 1 , ke + kh thvf ( k ) = th0av ( k ) * ( 1 + ( rv / rd - 1 ) * qt0av ( k ) - rv / rd * ql0av ( k )) presh ( k ) = presh ( k - 1 ) ** rdocp - grav * ( pref0 ** rdocp ) * dzf ( k - 1 ) / ( cp * thvf ( k - 1 )) presh ( k ) = presh ( k ) ** ( 1. / rdocp ) end do deallocate ( thetah , qth , qlh ) return end subroutine fromztop !> Calculates liquid water content. !!     Given theta_l and q_tot the liquid water content !!     is calculated, making an \"all-or-nothing\" assumption. !!     if lfull=true   ==> ql at full levels on output !!     if lfull=false  ==> ql at half levels on output !! !! \\author Hans Cuijpers   I.M.A.U. !! \\author Pier Siebesma   K.N.M.I.     06/01/1995 subroutine thermo ( thl , qt , ql , pressure , exner ) !  use modglobal, only : ih,jh,i1,j1,k1,es0,at,bt,rd,rv,rlv,cp,tmelt use modglobal , only : ih , jh , ib , ie , jb , je , kb , ke , kh , es0 , at , bt , rd , rv , rlv , cp , tmelt use modsurfdata , only : thls implicit none integer i , j , k real tl , es , qs , qsl , b1 !  real, intent(in)  :: qt(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh),thl(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh),exner(kb:ke+kh),pressure(kb:ke+kh) real , intent ( in ) :: qt ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ), thl ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ), exner ( kb : ke + kh ), pressure ( kb : ke + kh ) real , intent ( out ) :: ql ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) real :: Tnr , qsatur , Tnr_old integer :: niter , nitert if ( lqlnr ) then !mc      calculation of T with Newton-Raphson method !mc      first guess is Tnr=tl !mc nitert = 0 do k = kb , ke + kh do j = jb , je do i = ib , ie tl = thl ( i , j , k ) * exner ( k ) Tnr = tl Tnr_old = 0. do while ( abs ( Tnr - Tnr_old ) / Tnr > 1e-5 ) niter = niter + 1 Tnr_old = Tnr es = es0 * exp ( at * ( Tnr - tmelt ) / ( Tnr - bt )) qsatur = rd / rv * es / ( pressure ( k ) - ( 1 - rd / rv ) * es ) Tnr = Tnr - ( Tnr + ( rlv / cp ) * qsatur - tl - & ( rlv / cp ) * qt ( i , j , k )) / ( 1 + ( rlv ** 2 * qsatur ) / & ( rv * cp * Tnr ** 2 )) end do nitert = max ( nitert , niter ) niter = 0 ql ( i , j , k ) = dim ( qt ( i , j , k ) - qsatur , 0. ) end do end do end do else do k = kb , ke + kh do j = jb , je do i = ib , ie tl = thl ( i , j , k ) * exner ( k ) es = es0 * exp ( at * ( tl - tmelt ) / ( tl - bt )) qsl = rd / rv * es / ( pressure ( k ) - ( 1 - rd / rv ) * es ) b1 = rlv ** 2 / ( tl ** 2 * cp * rv ) qs = qsl * ( 1. + b1 * qt ( i , j , k )) / ( 1. + b1 * qsl ) ql ( i , j , k ) = dim ( qt ( i , j , k ) - qs , 0. ) end do end do end do end if return end subroutine thermo !> Calculates the scalars at half levels. !! If the kappa advection scheme is active, interpolation needs to be done consistently. subroutine calc_halflev use modglobal , only : ib , ie , jb , je , kb , ke , kh , dzf , dzh , iadv_thl , iadv_qt , iadv_kappa use modfields , only : thl0 , thl0h , qt0 , qt0h use modsurfdata , only : qts , thls implicit none integer :: i , j , k !      do  k=kb+1,ke+kh do k = kb , ke + kh do j = jb , je do i = ib , ie thl0h ( i , j , k ) = ( thl0 ( i , j , k ) * dzf ( k - 1 ) + thl0 ( i , j , k - 1 ) * dzf ( k )) / ( 2 * dzh ( k )) end do end do end do thl0h ( ib : ie , jb : je , kb ) = thls !      do  k=kb+1,ke+kh do k = kb , ke + kh do j = jb , je do i = ib , ie qt0h ( i , j , k ) = ( qt0 ( i , j , k ) * dzf ( k - 1 ) + qt0 ( i , j , k - 1 ) * dzf ( k )) / ( 2 * dzh ( k )) end do end do end do qt0h ( ib : ie , jb : je , kb ) = qts end subroutine calc_halflev end module modthermodynamics","tags":"","loc":"sourcefile/modthermodynamics.f90.html"},{"title":"advection.f90 – uDALES","text":"This file depends on sourcefile~~advection.f90~~EfferentGraph sourcefile~advection.f90 advection.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~advection.f90->sourcefile~modglobal.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~advection.f90->sourcefile~modfields.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~advection.f90->sourcefile~modsubgriddata.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines advection Source Code advection.f90 Source Code !> \\file advection.f90 !!  Advection management !! \\par Revision list !! variable x-grid now possible !! \\par Authors !> Advection redirection function subroutine advection use modglobal , only : lmoist , nsv , iadv_mom , iadv_tke , iadv_thl , iadv_qt , iadv_sv , & iadv_cd2 , iadv_kappa , iadv_upw , & ltempeq , ih , jh , kh , ihc , jhc , khc use modfields , only : u0 , up , v0 , vp , w0 , wp , e120 , e12p , thl0 , thlp , qt0 , qtp , sv0 , svp use modsubgriddata , only : loneeqn implicit none integer :: n select case ( iadv_mom ) case ( iadv_cd2 ) call advecu_2nd ( u0 , up ) call advecv_2nd ( v0 , vp ) call advecw_2nd ( w0 , wp ) case default write ( 0 , * ) \"ERROR: Unknown advection scheme\" stop 1 end select if ( loneeqn ) then select case ( iadv_tke ) case ( iadv_cd2 ) call advecc_2nd ( ih , jh , kh , e120 , e12p ) case default write ( 0 , * ) \"ERROR: Unknown advection scheme\" stop 1 end select end if select case ( iadv_thl ) case ( iadv_cd2 ) if ( ltempeq ) call advecc_2nd ( ih , jh , kh , thl0 , thlp ) case ( iadv_kappa ) call advecc_kappa ( ihc , jhc , khc , thl0 , thlp ) case default write ( 0 , * ) \"ERROR: Unknown advection scheme\" stop 1 end select if ( lmoist ) then select case ( iadv_qt ) case ( iadv_cd2 ) call advecc_2nd ( ih , jh , kh , qt0 , qtp ) case default write ( 0 , * ) \"ERROR: Unknown advection scheme\" stop 1 end select end if do n = 1 , nsv select case ( iadv_sv ( n )) case ( iadv_cd2 ) call advecc_2nd ( ihc , jhc , khc , sv0 (:, :, :, n ), svp (:, :, :, n )) case ( iadv_kappa ) call advecc_kappa ( ihc , jhc , khc , sv0 (:, :, :, n ), svp (:, :, :, n )) case ( iadv_upw ) call advecc_upw ( ihc , jhc , khc , sv0 (:, :, :, n ), svp (:, :, :, n )) case default write ( 0 , * ) \"ERROR: Unknown advection scheme\" stop 1 end select end do end subroutine advection","tags":"","loc":"sourcefile/advection.f90.html"},{"title":"modfielddump.f90 – uDALES","text":"This file depends on sourcefile~~modfielddump.f90~~EfferentGraph sourcefile~modfielddump.f90 modfielddump.f90 sourcefile~modstat_nc.f90 modstat_nc.f90 sourcefile~modfielddump.f90->sourcefile~modstat_nc.f90 sourcefile~modsurfdata.f90 modsurfdata.f90 sourcefile~modfielddump.f90->sourcefile~modsurfdata.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modfielddump.f90->sourcefile~modfields.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modfielddump.f90->sourcefile~modglobal.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modfielddump.f90->sourcefile~modmpi.f90 sourcefile~modstat_nc.f90->sourcefile~modglobal.f90 sourcefile~modstat_nc.f90->sourcefile~modmpi.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~modfielddump.f90~~AfferentGraph sourcefile~modfielddump.f90 modfielddump.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modfielddump.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules modfielddump Source Code modfielddump.f90 Source Code !> \\file modfielddump.f90 !!  Dumps 3D fields of several variables !> !!  Dumps 3D fields of several variables Written to wb*.myid.expnr !! If netcdf is true, this module leads the fielddump.myid.expnr.nc output !!  \\author Jasper Tomas, TU Delft Match 31 2014 !!  \\author Thijs Heus,MPI-M !!  \\par Revision list !! Possibility to write tecplot (formatted!!) file ! !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! module modfielddump use modglobal , only : longint use modfields , only : ncname implicit none private PUBLIC :: initfielddump , fielddump , exitfielddump save !NetCDF variables integer :: ncid , nrec = 0 !  real, pointer :: point type domainptr real , pointer :: point (:,:,:) end type domainptr type ( domainptr ), dimension ( 30 ) :: pfields character ( 80 ) :: fname = 'fielddump.xxx.xxx.nc' !dimension(nvar,4) :: ncname character ( 80 ), dimension ( 1 , 4 ) :: tncname integer :: klow , khigh , n , nvar logical :: ldiracc = . false . !< switch for doing direct access writing (on/off) logical :: lbinary = . false . ! contains !> Initializing fielddump. Read out the namelist, initializing the variables subroutine initfielddump use modmpi , only : myid , my_real , mpierr , comm3d , mpi_logical , mpi_integer , cmyid , mpi_character use modglobal , only : imax , jmax , kmax , cexpnr , ifnamopt , fname_options , dtmax , kb , ke , ladaptive , dt_lim , btime , nsv , fieldvars , ib , ie , jb , je , kb , ke , lfielddump use modstat_nc , only : open_nc , define_nc , ncinfo , writestat_dims_nc use modfields , only : u0 , v0 , w0 , thl0 , sv0 , ql0 , qt0 , pres0 implicit none integer :: ierr !  type(domainptr), dimension(nvar) :: pfields nvar = ( LEN ( trim ( fieldvars )) + 1 ) / 3 if ( nvar == 0 ) then lfielddump = . false . print * , 'empty fieldvars therefore lfielddump = .false. and no instantaneous fields outputted' return else allocate ( ncname ( nvar , 4 )) end if klow = kb khigh = ke !ils13 13.08.18: why is this broadcast, doesn't every processor do it anyway? call MPI_BCAST ( klow , 1 , MPI_INTEGER , 0 , comm3d , ierr ) call MPI_BCAST ( khigh , 1 , MPI_INTEGER , 0 , comm3d , ierr ) call MPI_BCAST ( lfielddump , 1 , MPI_LOGICAL , 0 , comm3d , ierr ) call MPI_BCAST ( ldiracc , 1 , MPI_LOGICAL , 0 , comm3d , ierr ) call MPI_BCAST ( lbinary , 1 , MPI_LOGICAL , 0 , comm3d , ierr ) call MPI_BCAST ( ncname , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( nvar , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) !    dt_lim = min(dt_lim,tnext) if (. not .( lfielddump )) return fname ( 11 : 13 ) = cmyid fname ( 15 : 17 ) = cexpnr call ncinfo ( tncname ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) ! tg3315 reads in fields specified by fieldvars do n = 1 , nvar select case ( fieldvars ( 3 * n - 2 : 3 * n - 1 )) case ( 'u0' ) call ncinfo ( ncname ( n ,:), 'u' , 'West-East velocity' , 'm/s' , 'mttt' ) pfields ( n )% point => u0 ( ib : ie , jb : je , kb : ke ) case ( 'v0' ) call ncinfo ( ncname ( n ,:), 'v' , 'South-North velocity' , 'm/s' , 'tmtt' ) pfields ( n )% point => v0 ( ib : ie , jb : je , kb : ke ) case ( 'w0' ) call ncinfo ( ncname ( n ,:), 'w' , 'Vertical velocity' , 'm/s' , 'ttmt' ) pfields ( n )% point => w0 ( ib : ie , jb : je , kb : ke ) case ( 'th' ) call ncinfo ( ncname ( n ,:), 'thl' , 'Liquid water potential temperature' , 'K' , 'tttt' ) pfields ( n )% point => thl0 ( ib : ie , jb : je , kb : ke ) case ( 'ql' ) call ncinfo ( ncname ( n ,:), 'ql' , 'Liquid water mixing ratio' , '1e-5kg/kg' , 'tttt' ) pfields ( n )% point => ql0 ( ib : ie , jb : je , kb : ke ) case ( 'qt' ) call ncinfo ( ncname ( n ,:), 'qt' , 'Total water mixing ratio' , '1e-5kg/kg' , 'tttt' ) pfields ( n )% point => qt0 ( ib : ie , jb : je , kb : ke ) case ( 's1' ) call ncinfo ( ncname ( n ,:), 'sca1' , 'scalar 1' , 'M' , 'tttt' ) pfields ( n )% point => sv0 ( ib : ie , jb : je , kb : ke , 1 ) case ( 's2' ) call ncinfo ( ncname ( n ,:), 'sca2' , 'scalar 2' , 'M' , 'tttt' ) pfields ( n )% point => sv0 ( ib : ie , jb : je , kb : ke , 2 ) case ( 's3' ) call ncinfo ( ncname ( n ,:), 'sca3' , 'scalar 3' , 'M' , 'tttt' ) pfields ( n )% point => sv0 ( ib : ie , jb : je , kb : ke , 3 ) case ( 's4' ) call ncinfo ( ncname ( n ,:), 'sca4' , 'scalar 4' , 'M' , 'tttt' ) pfields ( n )% point => sv0 ( ib : ie , jb : je , kb : ke , 4 ) case ( 's5' ) call ncinfo ( ncname ( n ,:), 'sca5' , 'scalar 5' , 'M' , 'tttt' ) pfields ( n )% point => sv0 ( ib : ie , jb : je , kb : ke , 5 ) case ( 'p0' ) call ncinfo ( ncname ( n ,:), 'pres' , 'pressure field' , 'M' , 'tttt' ) pfields ( n )% point => pres0 ( ib : ie , jb : je , kb : ke ) case default call ncinfo ( ncname ( n ,:), 'u' , 'West-East velocity' , 'm/s' , 'mttt' ) pfields ( n )% point => u0 ( ib : ie , jb : je , kb : ke ) end select end do call open_nc ( fname , ncid , nrec , n1 = imax , n2 = jmax , n3 = khigh - klow + 1 ) if ( nrec == 0 ) then call define_nc ( ncid , 1 , tncname ) call writestat_dims_nc ( ncid ) end if call define_nc ( ncid , nvar , ncname ) call open_nc ( fname , ncid , nrec , n1 = imax , n2 = jmax , n3 = khigh - klow + 1 ) !        call open_nc( fname, ncid, nrec, n1=imax+2, n2=jmax+2, n3=khigh-klow+1)  !if want to print ghostcells if ( nrec == 0 ) then write ( * , * ) \"calling define_nc\" call define_nc ( ncid , 1 , tncname ) write ( * , * ) \"calling writestat_dims_nc\" call writestat_dims_nc ( ncid ) end if call define_nc ( ncid , nvar , ncname ) end subroutine initfielddump !> Do fielddump. Collect data to truncated (2 byte) integers, and write them to file subroutine fielddump use modfields , only : u0 , v0 , w0 , thl0 , qt0 , ql0 , sv0 !ILS13 21.04.2015 changed to u0 from um  etc use modsurfdata , only : thls , qts , thvs use modglobal , only : ib , ie , ih , jb , je , jh , ke , kb , kh , rk3step , timee , dt_lim , cexpnr , ifoutput , imax , jmax ,& tfielddump , tnextfielddump , nsv , lfielddump !use modmpi,    only : myid,cmyid !use modsubgriddata, only : ekm,sbshr use modstat_nc , only : writestat_nc use modmpi , only : myid , cmyid implicit none real , allocatable :: vars (:,:,:,:) integer i , j , k integer :: writecounter = 1 if (. not . ( timee >= tnextfielddump )) return if (. not . lfielddump ) return if ( rk3step /= 3 ) return tnextfielddump = tnextfielddump + tfielddump allocate ( vars ( ib : ie , jb : je , kb : ke , nvar )) do n = 1 , nvar vars ( ib : ie , jb : je , kb : ke , n ) = pfields ( n )% point end do call writestat_nc ( ncid , 1 , tncname ,( / timee / ), nrec ,. true .) call writestat_nc ( ncid , nvar , ncname , vars , nrec , imax , jmax , khigh - klow + 1 ) deallocate ( vars ) end subroutine fielddump !> Clean up when leaving the run subroutine exitfielddump use modglobal , only : lfielddump use modstat_nc , only : exitstat_nc implicit none if ( lfielddump ) call exitstat_nc ( ncid ) end subroutine exitfielddump end module modfielddump","tags":"","loc":"sourcefile/modfielddump.f90.html"},{"title":"modchem.f90 – uDALES","text":"This file depends on sourcefile~~modchem.f90~~EfferentGraph sourcefile~modchem.f90 modchem.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modchem.f90->sourcefile~modglobal.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modchem.f90->sourcefile~modfields.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~modchem.f90~~AfferentGraph sourcefile~modchem.f90 modchem.f90 sourcefile~tstep.f90 tstep.f90 sourcefile~tstep.f90->sourcefile~modchem.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules modchem Source Code modchem.f90 Source Code !> \\file modchem.f90 !!tg3315, 2 Nov 2017 !> Input chemistry of the null cycle into DALES following Zhong, Cai 2015. !> Assumes scalar fields are in order 1: NO, 2: NO2 and 3: O3. module modchem implicit none save contains subroutine chem use modglobal , only : lchem , k1 , JNO2 , dt , rk3step , ib , ie , ihc , ih , jb , je , jhc , jh , kb , ke , khc , kh use modfields , only : svp , svm , sv0 , IIc implicit none real , dimension ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc ) :: dummyNO , dummyNO2 , dummyO3 if ( lchem . eqv . . false .) return ! forward Euler ! [NO] !    svp(:,:,:,1) = svp(:,:,:,1) + 30.006 * ( JNO2 * (svm(:,:,:,2)/46.005) - k1 * (svm(:,:,:,1) / 30.006) * (svm(:,:,:,3)/47.997) ) ! [NO2] !    svp(:,:,:,2) = svp(:,:,:,2) + 46.005 * (-JNO2 * (svm(:,:,:,2)/46.005) + k1 * (svm(:,:,:,1) / 30.006) * (svm(:,:,:,3)/47.997) ) ! [O3] !    svp(:,:,:,3) = svp(:,:,:,3) + 47.997 * ( JNO2 * (svm(:,:,:,2)/46.005) - k1 * (svm(:,:,:,1) / 30.006) * (svm(:,:,:,3)/47.997) ) if (. not . rk3step == 3 ) return ! convert into mol/m&#94;3 dummyNO = IIc * sv0 (:,:, kb : ke + khc , 1 ) / 3 0.006 dummyNO2 = IIc * sv0 (:,:, kb : ke + khc , 2 ) / 4 6.005 dummyO3 = IIc * sv0 (:,:, kb : ke + khc , 3 ) / 4 7.997 !backward Euler, semi-implicit !    sv0(:,:,kb:ke+khc,1) = 30.006 * ( ( (sv0(:,:,kb:ke+khc,1)/30.006) + JNO2 * dummyNO2 * dt) / (1. + k1 * dummyO3 * dt) ) !    sv0(:,:,kb:ke+khc,2) = 46.005 * ( ( (sv0(:,:,kb:ke+khc,2)/46.005) + k1 * dummyNO * dummyO3 * dt )  / (1. + JNO2 * dt) ) !    sv0(:,:,kb:ke+khc,3) = 47.997 * ( ( (sv0(:,:,kb:ke+khc,3)/47.997) + JNO2 * dummyNO2 * dt) / (1. + k1 * dummyNO * dt) ) !backward Euler, fully implicit. Derivation at (/projects/Chemistry/FullyImplicit.mw) sv0 (:,:, kb : ke + khc , 1 ) = 3 0.006 * ( ( sv0 (:,:, kb : ke + khc , 1 ) / 3 0.006 ) + ( dt * ( - k1 * dummyNO * dummyO3 + JNO2 * dummyNO2 ) ) / & ( 1. + ( ( dummyNO + dummyO3 ) * k1 + JNO2 ) * dt ) ) sv0 (:,:, kb : ke + khc , 2 ) = 4 6.005 * ( ( sv0 (:,:, kb : ke + khc , 2 ) / 4 6.005 ) - ( dt * ( - k1 * dummyNO * dummyO3 + JNO2 * dummyNO2 ) ) / & ( 1. + ( ( dummyNO + dummyO3 ) * k1 + JNO2 ) * dt ) ) sv0 (:,:, kb : ke + khc , 3 ) = 4 7.997 * ( ( sv0 (:,:, kb : ke + khc , 3 ) / 4 7.997 ) + ( dt * ( - k1 * dummyNO * dummyO3 + JNO2 * dummyNO2 ) ) / & ( 1. + ( ( dummyNO + dummyO3 ) * k1 + JNO2 ) * dt ) ) ! alternative method in Zhong 2017 eqn. 7, analytical solution! end subroutine chem end module modchem","tags":"","loc":"sourcefile/modchem.f90.html"},{"title":"modsubgrid.f90 – uDALES","text":"This file depends on sourcefile~~modsubgrid.f90~~EfferentGraph sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~modsubgrid.f90->sourcefile~modsubgriddata.f90 sourcefile~modsurfdata.f90 modsurfdata.f90 sourcefile~modsubgrid.f90->sourcefile~modsurfdata.f90 sourcefile~modinletdata.f90 modinletdata.f90 sourcefile~modsubgrid.f90->sourcefile~modinletdata.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modsubgrid.f90->sourcefile~modfields.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~modsubgrid.f90->sourcefile~modboundary.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modsubgrid.f90->sourcefile~modglobal.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modsubgrid.f90->sourcefile~modmpi.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modboundary.f90->sourcefile~modsubgriddata.f90 sourcefile~modboundary.f90->sourcefile~modsurfdata.f90 sourcefile~modboundary.f90->sourcefile~modinletdata.f90 sourcefile~modboundary.f90->sourcefile~modfields.f90 sourcefile~modboundary.f90->sourcefile~modglobal.f90 sourcefile~modboundary.f90->sourcefile~modmpi.f90 sourcefile~moddriver.f90 moddriver.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~modinlet.f90 modinlet.f90 sourcefile~modboundary.f90->sourcefile~modinlet.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 sourcefile~moddriver.f90->sourcefile~modinletdata.f90 sourcefile~moddriver.f90->sourcefile~modfields.f90 sourcefile~moddriver.f90->sourcefile~modglobal.f90 sourcefile~moddriver.f90->sourcefile~modmpi.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~modinlet.f90->sourcefile~modsurfdata.f90 sourcefile~modinlet.f90->sourcefile~modinletdata.f90 sourcefile~modinlet.f90->sourcefile~modfields.f90 sourcefile~modinlet.f90->sourcefile~modglobal.f90 sourcefile~modinlet.f90->sourcefile~modmpi.f90 sourcefile~modinlet.f90->sourcefile~modsave.f90 sourcefile~modsave.f90->sourcefile~modsubgriddata.f90 sourcefile~modsave.f90->sourcefile~modsurfdata.f90 sourcefile~modsave.f90->sourcefile~modinletdata.f90 sourcefile~modsave.f90->sourcefile~modfields.f90 sourcefile~modsave.f90->sourcefile~modglobal.f90 sourcefile~modsave.f90->sourcefile~modmpi.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~modsave.f90->sourcefile~modibmdata.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~modsave.f90->sourcefile~initfac.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~modsubgrid.f90~~AfferentGraph sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~modstartup.f90->sourcefile~modsubgrid.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modsubgrid.f90 sourcefile~program.f90->sourcefile~modstartup.f90 sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 sourcefile~modstatsdump.f90->sourcefile~modsubgrid.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules modsubgrid Source Code modsubgrid.f90 Source Code !!> \\file modsubgrid.f90 !!!  Calculates and applies the Sub Filter Scale diffusion ! !> !!  \\author Jasper Tomas, TU Delft !!  \\author Pier Siebesma, K.N.M.I. !!  \\author Stephan de Roode,TU Delft !!  \\author Chiel van Heerwaarden, Wageningen U.R. !!  \\author Thijs Heus,MPI-M !!  \\par Revision list !! Jasper Tomas: !!   -Implemented Vreman model (2004) !!   -wall-damping applied for 1-equation and Smagorinsky models !!   -factor 2 smaller constant in 1-equation and Smagorinsky models !!  \\todo Documentation !! module modsubgrid use modsubgriddata implicit none save public :: subgrid , initsubgrid , exitsubgrid , subgridnamelist contains subroutine initsubgrid use modglobal , only : ih , ib , ie , jh , jb , je , kb , ke , kh , delta , zf , fkar , & pi , ifnamopt , fname_options use modmpi , only : myid implicit none integer :: i , k real :: ceps , ch real :: mlen call subgridnamelist allocate ( ekm ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( ekh ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( zlt ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( sbdiss ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( sbshr ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( sbbuo ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( csz ( ib - ih : ie + ih , kb : ke + kh )) allocate ( damp ( ib : ie , jb : je , kb : ke )) damp = 1. cm = cf / ( 2. * pi ) * ( 1.5 * alpha_kolm ) ** ( - 1.5 ) !     ch   = 2. * alpha_kolm / beta_kolm ch = prandtl ch2 = ch - ch1 ceps = 2. * pi / cf * ( 1.5 * alpha_kolm ) ** ( - 1.5 ) ce1 = ( cn ** 2 ) * ( cm / Rigc - ch1 * cm ) ce2 = ceps - ce1 if ( cs == - 1. ) then csz (:,:) = ( cm ** 3 / ceps ) ** 0.25 !< Smagorinsky constant else csz (:,:) = cs end if !    if(lmason) then !      do k = kb,ke+kh !        do i=ib-ih,ie+ih !          mlen   = (1. / (csz(i,k) * delta(i,k))**nmason + 1. / (fkar * zf(k))**nmason)**(-1./nmason) !          csz(i,k) = mlen / delta(i,k) !        end do !      end do !    end if if ( myid == 0 ) then write ( 6 , * ) 'cf    = ' , cf write ( 6 , * ) 'cm    = ' , cm write ( 6 , * ) 'ch    = ' , ch write ( 6 , * ) 'ch1   = ' , ch1 write ( 6 , * ) 'ch2   = ' , ch2 write ( 6 , * ) 'ceps  = ' , ceps write ( 6 , * ) 'ceps1 = ' , ce1 write ( 6 , * ) 'ceps2 = ' , ce2 write ( 6 , * ) 'cs    = ' , cs write ( 6 , * ) 'Rigc  = ' , Rigc endif end subroutine initsubgrid subroutine subgridnamelist use modglobal , only : pi , ifnamopt , fname_options , lles use modmpi , only : myid , nprocs , comm3d , mpierr , my_real , mpi_logical , mpi_integer implicit none integer :: ierr namelist / NAMSUBGRID / & ldelta , lmason , cf , cn , Rigc , Prandtl , lsmagorinsky , lvreman , loneeqn , c_vreman , cs , nmason , lbuoycorr if ( myid == 0 ) then open ( ifnamopt , file = fname_options , status = 'old' , iostat = ierr ) read ( ifnamopt , NAMSUBGRID , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions NAMSUBGRID' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif write ( 6 , NAMSUBGRID ) close ( ifnamopt ) end if call MPI_BCAST ( ldelta , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lmason , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( nmason , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lsmagorinsky , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lvreman , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( loneeqn , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( c_vreman , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( cs , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( cf , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( cn , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( Rigc , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( Prandtl , 1 , MY_REAL , 0 , comm3d , mpierr ) prandtli = 1. / Prandtl write ( * , * ) '1/prandtl' , prandtli if (( lsmagorinsky ) . or . ( lvreman ) . or . ( loneeqn )) then lles = . true . endif end subroutine subgridnamelist subroutine subgrid ! Diffusion subroutines ! Thijs Heus, Chiel van Heerwaarden, 15 June 2007 use modglobal , only : ih , jh , kh , nsv , lmoist , lles , ib , ie , jb , je , kb , ke , imax , jmax , kmax ,& ihc , jhc , khc , ltempeq use modfields , only : up , vp , wp , e12p , thl0 , thlp , qt0 , qtp , sv0 , svp , shear use modsurfdata , only : ustar , thlflux , qtflux , svflux use modmpi , only : myid , comm3d , mpierr , my_real , nprocs implicit none integer n , proces call closure call diffu ( up ) call diffv ( vp ) call diffw ( wp ) if ( loneeqn ) call diffe ( e12p ) ! only in case of LES with 1-eq subgrid model if ( ltempeq ) call diffc ( ih , jh , kh , thl0 , thlp ) if ( lmoist ) call diffc ( ih , jh , kh , qt0 , qtp ) do n = 1 , nsv call diffc ( ihc , jhc , khc , sv0 (:,:,:, n ), svp (:,:,:, n )) end do if ( loneeqn ) call sources ! only in case of LES with 1-eq subgrid model end subroutine subroutine exitsubgrid implicit none deallocate ( ekm , ekh , zlt , sbdiss , sbbuo , sbshr , csz ) end subroutine exitsubgrid subroutine closure !-----------------------------------------------------------------| !                                                                 | !*** *closure*  calculates K-coefficients                         | !                                                                 | !      Hans Cuijpers   I.M.A.U.   06/01/1995                      | !                                                                 | !     purpose.                                                    | !     --------                                                    | !                                                                 | !     All the K-closure factors are calculated.                   | !                                                                 | !     ekm(i,j,k) = k sub m : for velocity-closure                 | !     ekh(i,j,k) = k sub h : for temperture-closure               | !     ekh(i,j,k) = k sub h = k sub c : for concentration-closure  | !                                                                 | !     We will use the next model for these factors:               | !                                                                 | !     k sub m = 0.12 * l * sqrt(E)                                | !                                                                 | !     k sub h = k sub c = ( 1 + (2*l)/D ) * k sub m               | !                                                                 | !           where : l = mixing length  ( in model = z2 )          | !                   E = subgrid energy                            | !                   D = grid-size distance                        | !                                                                 | !**   interface.                                                  | !     ----------                                                  | !                                                                 | !             *closure* is called from *program*.                 | !                                                                 | !-----------------------------------------------------------------| use modglobal , only : ib , ie , jb , je , kb , ke , kh , ih , jh , jmax , delta , ekmin , grav , zf , fkar , jgb , jge ,& dxf , dxf2 , dxhi , dxfi , dy2 , dyi , dyiq , dzf , dzf2 , dzfi , dzhi , rk3step , rslabs , & numol , numoli , prandtlmoli , lles , rk3step , dxfiq , dzfiq , lbuoyancy , dzh use modfields , only : dthvdz , e120 , u0 , v0 , w0 , thl0 , mindist , wall , shear use modsurfdata , only : dudz , dvdz , thvs , ustar use modmpi , only : excjs , myid , nprocs , comm3d , mpierr , my_real , mpi_sum , slabsumi use modboundary , only : closurebc use modinletdata , only : utaui implicit none real , dimension ( ib : ie ) :: shearbot real :: strain2 , mlen , uhor , distplus , utaubot , a11 , a12 , a13 , & a21 , a22 , a23 , a31 , a32 , a33 , aa , b11 , b12 , b13 , b21 , b22 , & b23 , b33 , bb , const , const2 integer :: i , j , k , kp , km , jp , jm , im , ip , iw , jw , kw , c1 , c2 !  if (lles  .and. rk3step == 1) then        ! compute ekm and ekh only once in complete RK-cycle if ( lsmagorinsky ) then do k = kb , ke kp = k + 1 km = k - 1 do i = ib , ie ip = i + 1 im = i - 1 mlen = csz ( i , k ) * delta ( i , k ) do j = jb , je jp = j + 1 jm = j - 1 iw = wall ( i , j , k , 1 ) ! indices of closest wall jw = wall ( i , j , k , 2 ) - myid * jmax ! indices of closest wall in local j-index kw = wall ( i , j , k , 3 ) c1 = wall ( i , j , k , 4 ) ! shear stress component c2 = wall ( i , j , k , 5 ) ! shear stress component if (( jw >= jb - 1 ) . and . ( jw <= je + 1 )) then ! check if jw is within the halo of this proc !write(*,'(A,E9.2,A,E9.2,A,E9.2,A,E9.2)') 'component1:', c1, 'component2:', c2, 'shear c1:', shear(iw,jw,kw,c1), 'shear c2:', shear(iw,jw,kw,c2) distplus = mindist ( i , j , k ) * sqrt ( abs ( shear ( iw , jw , kw , c1 )) + abs ( shear ( iw , jw , kw , c2 ))) * numoli damp ( i , j , k ) = sqrt ( 1. - exp (( - distplus * 0.04 ) ** 3. )) ! Wall-damping according to Piomelli !    write(*,'(A,2(1pE9.2))') 'damp, distplus', damp(i,j,k), distplus else damp ( i , j , k ) = 1. end if strain2 = ( & (( u0 ( ip , j , k ) - u0 ( i , j , k )) * dxfi ( i ) ) ** 2 + & (( v0 ( i , jp , k ) - v0 ( i , j , k )) * dyi ) ** 2 + & (( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) ) ** 2 ) strain2 = strain2 + 0.125 * ( & (( w0 ( i , j , kp ) - w0 ( im , j , kp )) * dxhi ( i ) + & ( u0 ( i , j , kp ) - u0 ( i , j , k )) * dzhi ( kp ) ) ** 2 + & (( w0 ( i , j , k ) - w0 ( im , j , k )) * dxhi ( i ) + & ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) ) ** 2 + & (( w0 ( ip , j , k ) - w0 ( i , j , k )) * dxhi ( ip ) + & ( u0 ( ip , j , k ) - u0 ( ip , j , km )) * dzhi ( k ) ) ** 2 + & (( w0 ( ip , j , kp ) - w0 ( i , j , kp )) * dxhi ( ip ) + & ( u0 ( ip , j , kp ) - u0 ( ip , j , k )) * dzhi ( kp ) ) ** 2 ) strain2 = strain2 + 0.125 * ( & (( u0 ( i , jp , k ) - u0 ( i , j , k )) * dyi + & ( v0 ( i , jp , k ) - v0 ( im , jp , k )) * dxhi ( i ) ) ** 2 + & (( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi + & ( v0 ( i , j , k ) - v0 ( im , j , k )) * dxhi ( i ) ) ** 2 + & (( u0 ( ip , j , k ) - u0 ( ip , jm , k )) * dyi + & ( v0 ( ip , j , k ) - v0 ( i , j , k )) * dxhi ( ip ) ) ** 2 + & (( u0 ( ip , jp , k ) - u0 ( ip , j , k )) * dyi + & ( v0 ( ip , jp , k ) - v0 ( i , jp , k )) * dxhi ( ip ) ) ** 2 ) strain2 = strain2 + 0.125 * ( & (( v0 ( i , j , kp ) - v0 ( i , j , k )) * dzhi ( kp ) + & ( w0 ( i , j , kp ) - w0 ( i , jm , kp )) * dyi ) ** 2 + & (( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) + & ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi ) ** 2 + & (( v0 ( i , jp , k ) - v0 ( i , jp , km )) * dzhi ( k ) + & ( w0 ( i , jp , k ) - w0 ( i , j , k )) * dyi ) ** 2 + & (( v0 ( i , jp , kp ) - v0 ( i , jp , k )) * dzhi ( kp ) + & ( w0 ( i , jp , kp ) - w0 ( i , j , kp )) * dyi ) ** 2 ) ekm ( i , j , k ) = ( mlen * damp ( i , j , k )) ** 2. * sqrt ( 2. * strain2 ) ekh ( i , j , k ) = ekm ( i , j , k ) * prandtli end do end do end do damp (:,:,:) = max ( damp (:,:,:), dampmin ) ekm (:,:,:) = ekm (:,:,:) + numol ! add molecular viscosity ekh (:,:,:) = ekh (:,:,:) + numol * prandtlmoli ! add molecular diffusivity !write(*,'(A,3(1pE9.2))') 'strain2, ekm, ekh', strain2, ekm(10,10,10), ekh(10,10,10) !    ekm(:,:,:) = max(ekm(:,:,:),ekmin) !    ekh(:,:,:) = max(ekh(:,:,:),ekmin) elseif ( lvreman ) then if (( lbuoyancy ) . and . ( lbuoycorr )) then const = prandtli * grav / ( thvs * sqrt ( 2. * 3. )) do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie ! aij = du_i / dx_i ip = i + 1 im = i - 1 a11 = ( u0 ( ip , j , k ) - u0 ( i , j , k )) * dxfi ( i ) a12 = ((( v0 ( ip , jp , k ) + v0 ( ip , j , k )) * dxf ( i ) + & ( v0 ( i , jp , k ) + v0 ( i , j , k )) * dxf ( ip )) * dxhi ( ip ) & - & (( v0 ( i , jp , k ) + v0 ( i , j , k )) * dxf ( im ) + & ( v0 ( im , jp , k ) + v0 ( im , j , k )) * dxf ( i )) * dxhi ( i )) * dxfiq ( i ) a13 = ((( w0 ( ip , j , kp ) + w0 ( ip , j , k )) * dxf ( i ) + & ( w0 ( i , j , kp ) + w0 ( i , j , k )) * dxf ( ip )) * dxhi ( ip ) & - & (( w0 ( i , j , kp ) + w0 ( i , j , k )) * dxf ( im ) + & ( w0 ( im , j , kp ) + w0 ( im , j , k )) * dxf ( i )) * dxhi ( i )) * dxfiq ( i ) a21 = ( u0 ( ip , jp , k ) + u0 ( i , jp , k ) - u0 ( ip , jm , k ) - u0 ( i , jm , k ) ) * dyiq ! simplified after writing out interpolation. a22 = ( v0 ( i , jp , k ) - v0 ( i , j , k )) * dyi a23 = ( w0 ( i , jp , kp ) + w0 ( i , jp , k ) - w0 ( i , jm , kp ) - w0 ( i , jm , k ) ) * dyiq ! simplified after writing out interpolation. a31 = ((( u0 ( ip , j , kp ) + u0 ( i , j , kp )) * dzf ( k ) + & ( u0 ( ip , j , k ) + u0 ( i , j , k )) * dzf ( kp )) * dzhi ( kp ) & - & (( u0 ( ip , j , k ) + u0 ( i , j , k )) * dzf ( km ) + & ( u0 ( ip , j , km ) + u0 ( i , j , km )) * dzf ( k )) * dzhi ( k ) ) * dzfiq ( k ) a32 = ((( v0 ( i , jp , kp ) + v0 ( i , j , kp )) * dzf ( k ) + & ( v0 ( i , jp , k ) + v0 ( i , j , k )) * dzf ( kp )) * dzhi ( kp ) & - & (( v0 ( i , jp , k ) + v0 ( i , j , k )) * dzf ( km ) + & ( v0 ( i , jp , km ) + v0 ( i , j , km )) * dzf ( k )) * dzhi ( k ) ) * dzfiq ( k ) a33 = ( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) aa = a11 * a11 + a21 * a21 + a31 * a31 + & a12 * a12 + a22 * a22 + a32 * a32 + & a13 * a13 + a23 * a23 + a33 * a33 b11 = dxf2 ( i ) * a11 * a11 + dy2 * a21 * a21 + dzf2 ( k ) * a31 * a31 b22 = dxf2 ( i ) * a12 * a12 + dy2 * a22 * a22 + dzf2 ( k ) * a32 * a32 b12 = dxf2 ( i ) * a11 * a12 + dy2 * a21 * a22 + dzf2 ( k ) * a31 * a32 b33 = dxf2 ( i ) * a13 * a13 + dy2 * a23 * a23 + dzf2 ( k ) * a33 * a33 b13 = dxf2 ( i ) * a11 * a13 + dy2 * a21 * a23 + dzf2 ( k ) * a31 * a33 b23 = dxf2 ( i ) * a12 * a13 + dy2 * a22 * a23 + dzf2 ( k ) * a32 * a33 bb = b11 * b22 - b12 * b12 + b11 * b33 - b13 * b13 + b22 * b33 - b23 * b23 dthvdz ( i , j , k ) = ( thl0 ( i , j , k + 1 ) - thl0 ( i , j , k - 1 )) / ( dzh ( k + 1 ) + dzh ( k )) if ( dthvdz ( i , j , k ) <= 0 ) then const2 = ( bb / aa ) else ! write(*,*) \"const\",const ! write(*,*) \"delta\",delta const2 = ( bb / aa ) - ( delta ( i , k ) ** 4 ) * dthvdz ( i , j , k ) * const if ( const2 < 0.0 ) const2 = 0.0 end if ekm ( i , j , k ) = c_vreman * sqrt ( const2 ) ekh ( i , j , k ) = ekm ( i , j , k ) * prandtli end do end do end do ekm (:,:,:) = ekm (:,:,:) + numol ! add molecular viscosity ekh (:,:,:) = ekh (:,:,:) + numol * prandtlmoli ! add molecular diffusivity else ! neutral case do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie ! aij = du_i / dx_i ip = i + 1 im = i - 1 a11 = ( u0 ( ip , j , k ) - u0 ( i , j , k )) * dxfi ( i ) a12 = ((( v0 ( ip , jp , k ) + v0 ( ip , j , k )) * dxf ( i ) + & ( v0 ( i , jp , k ) + v0 ( i , j , k )) * dxf ( ip )) * dxhi ( ip ) & - & (( v0 ( i , jp , k ) + v0 ( i , j , k )) * dxf ( im ) + & ( v0 ( im , jp , k ) + v0 ( im , j , k )) * dxf ( i )) * dxhi ( i )) * dxfiq ( i ) a13 = ((( w0 ( ip , j , kp ) + w0 ( ip , j , k )) * dxf ( i ) + & ( w0 ( i , j , kp ) + w0 ( i , j , k )) * dxf ( ip )) * dxhi ( ip ) & - & (( w0 ( i , j , kp ) + w0 ( i , j , k )) * dxf ( im ) + & ( w0 ( im , j , kp ) + w0 ( im , j , k )) * dxf ( i )) * dxhi ( i )) * dxfiq ( i ) a21 = ( u0 ( ip , jp , k ) + u0 ( i , jp , k ) - u0 ( ip , jm , k ) - u0 ( i , jm , k ) ) * dyiq !simplified after writing out interpolation. a22 = ( v0 ( i , jp , k ) - v0 ( i , j , k )) * dyi a23 = ( w0 ( i , jp , kp ) + w0 ( i , jp , k ) - w0 ( i , jm , kp ) - w0 ( i , jm , k ) ) * dyiq !simplified after writing out interpolation. a31 = ((( u0 ( ip , j , kp ) + u0 ( i , j , kp )) * dzf ( k ) + & ( u0 ( ip , j , k ) + u0 ( i , j , k )) * dzf ( kp )) * dzhi ( kp ) & - & (( u0 ( ip , j , k ) + u0 ( i , j , k )) * dzf ( km ) + & ( u0 ( ip , j , km ) + u0 ( i , j , km )) * dzf ( k )) * dzhi ( k ) ) * dzfiq ( k ) a32 = ((( v0 ( i , jp , kp ) + v0 ( i , j , kp )) * dzf ( k ) + & ( v0 ( i , jp , k ) + v0 ( i , j , k )) * dzf ( kp )) * dzhi ( kp ) & - & (( v0 ( i , jp , k ) + v0 ( i , j , k )) * dzf ( km ) + & ( v0 ( i , jp , km ) + v0 ( i , j , km )) * dzf ( k )) * dzhi ( k ) ) * dzfiq ( k ) a33 = ( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) aa = a11 * a11 + a21 * a21 + a31 * a31 + & a12 * a12 + a22 * a22 + a32 * a32 + & a13 * a13 + a23 * a23 + a33 * a33 b11 = dxf2 ( i ) * a11 * a11 + dy2 * a21 * a21 + dzf2 ( k ) * a31 * a31 b22 = dxf2 ( i ) * a12 * a12 + dy2 * a22 * a22 + dzf2 ( k ) * a32 * a32 b12 = dxf2 ( i ) * a11 * a12 + dy2 * a21 * a22 + dzf2 ( k ) * a31 * a32 b33 = dxf2 ( i ) * a13 * a13 + dy2 * a23 * a23 + dzf2 ( k ) * a33 * a33 b13 = dxf2 ( i ) * a11 * a13 + dy2 * a21 * a23 + dzf2 ( k ) * a31 * a33 b23 = dxf2 ( i ) * a12 * a13 + dy2 * a22 * a23 + dzf2 ( k ) * a32 * a33 bb = b11 * b22 - b12 * b12 + b11 * b33 - b13 * b13 + b22 * b33 - b23 * b23 if ( bb < 0.00000001 ) then ekm ( i , j , k ) = 0. ekh ( i , j , k ) = 0. else ekm ( i , j , k ) = c_vreman * sqrt ( bb / aa ) ekh ( i , j , k ) = ekm ( i , j , k ) * prandtli end if end do end do end do !    ekm(:,:,:) = max(ekm(:,:,:),ekmin) !    ekh(:,:,:) = max(ekh(:,:,:),ekmin) end if ! lbuoyancy ekm (:,:,:) = ekm (:,:,:) + numol ! add molecular viscosity ekh (:,:,:) = ekh (:,:,:) + numol * prandtlmoli ! add molecular diffusivity !do TKE scheme elseif ( loneeqn ) then do k = kb , ke do j = jb , je do i = ib , ie iw = wall ( i , j , k , 1 ) ! indices of closest wall jw = wall ( i , j , k , 2 ) - myid * jmax ! indices of closest wall in local j-index kw = wall ( i , j , k , 3 ) c1 = wall ( i , j , k , 4 ) ! shear stress component c2 = wall ( i , j , k , 5 ) ! shear stress component !ILS13 removed near-wall damping 25.06.2014 !if (jw >= jb-1 .and. jw <= je+1) then      ! check if jw is within the halo of this proc !  distplus = mindist(i,j,k)*sqrt(abs(shear(iw,jw,kw,c1))+abs(shear(iw,jw,kw,c2)))*numoli !  damp(i,j,k) = sqrt(1. - exp((-distplus*0.04)**3.))            ! Wall-damping according to Piomelli !else damp ( i , j , k ) = 1. !end if if (( ldelta ) . or . ( dthvdz ( i , j , k ) <= 0 )) then zlt ( i , j , k ) = delta ( i , k ) ekm ( i , j , k ) = cm * zlt ( i , j , k ) * damp ( i , j , k ) * e120 ( i , j , k ) !* 0.5! LES with near-wall damping !!! added factor 0.5 for shear-driven flow ekh ( i , j , k ) = ( ch1 + ch2 ) * ekm ( i , j , k ) ! maybe ekh should be calculated from (molecular) Prandtl number ekm ( i , j , k ) = ekm ( i , j , k ) + numol ! add molecular viscosity ekh ( i , j , k ) = ekh ( i , j , k ) + numol * prandtlmoli ! add molecular diffusivity else !            zlt(i,j,k) = min(delta(i,k),cn*e120(i,j,k)/sqrt(grav/thvs*abs(dthvdz(i,j,k)))) zlt ( i , j , k ) = min ( delta ( i , k ), cn * e120 ( i , j , k ) / sqrt ( grav / thvs * abs ( dthvdz ( i , j , k )))) !thls is used ekm ( i , j , k ) = cm * zlt ( i , j , k ) * damp ( i , j , k ) * e120 ( i , j , k ) !* 0.5     ! LES with near-wall damping !!! added factor 0.5 for shear-driven flow ekh ( i , j , k ) = ( ch1 + ch2 * zlt ( i , j , k ) / delta ( i , k )) * ekm ( i , j , k ) !  needed in LES! ekm ( i , j , k ) = ekm ( i , j , k ) + numol ! add molecular viscosity ekh ( i , j , k ) = ekh ( i , j , k ) + numol * prandtlmoli ! add molecular diffusivity endif end do end do end do !   write(*,'(1A,F8.4)') 'ekh', ekh(2,3,3) damp (:,:,:) = max ( damp (:,:,:), dampmin ) !    ekm(:,:,:) = max(ekm(:,:,:),ekmin) !    ekh(:,:,:) = max(ekh(:,:,:),ekmin) else ! no subgrid model (DNS!) ekm = numol ekh = numol * prandtlmoli end if !  write(*,'(A,3(1pE9.2))') 'strain2, ekm, ekh', strain2, ekm(10,10,10), ekh(10,10,10) !do i=ib,ie !write(*,'(A,1(1pE9.2))') 'damp, ekm', damp(i,32,kb), ekm(i,32,kb) !end do !************************************************************* !     Set boundary condition for K-closure factors.          ! Also other BC's!! !************************************************************* call closurebc return end subroutine closure subroutine sources ! only in case of LES computation !-----------------------------------------------------------------| !                                                                 | !*** *sources*                                                    | !      calculates various terms from the subgrid TKE equation     | !                                                                 | !     Hans Cuijpers   I.M.A.U.     06/01/1995                     | !                                                                 | !     purpose.                                                    | !     --------                                                    | !                                                                 | !      Subroutine sources calculates all other terms in the       | !      subgrid energy equation, except for the diffusion terms.   | !      These terms are calculated in subroutine diff.             | !                                                                 | !**   interface.                                                  | !     ----------                                                  | !                                                                 | !     *sources* is called from *program*.                         | !                                                                 | !-----------------------------------------------------------------| use modglobal , only : ib , ie , jb , je , kb , ke , delta , dxhi , dxfi , dy , dyi , dzfi , dzhi , grav , numol , prandtlmol ,& dzh , delta use modfields , only : u0 , v0 , w0 , e120 , e12p , dthvdz , thl0 , thvf use modsurfdata , only : dudz , dvdz , thvs !    use modmpi,       only : myid implicit none real tdef2 , prandtlmoli integer i , j , k , im , ip , jm , jp , km , kp prandtlmoli = 1. / prandtlmol ! Added by J. Tomas (thermodynamics routine is bypassed) ! thv does not exist (equals thl), therefore dthvdz is computed here ! IS+HJ: thermodynamics is back in now (which calculates dthvdz) !    do k=kb,ke !      do j=jb,je !        do i=ib,ie !          dthvdz(i,j,k) = (thl0(i,j,k+1)-thl0(i,j,k-1))/(dzh(k+1)+dzh(k)) ! !         if (dthvdz(i,j,k) == 0.0) then ! !           write(6,*) 'dthvdz(i,j,k)=0,i,j,k',i,j,k ! !         end if !        end do !      end do !    end do ! End of addition by J. Tomas (thermodynamics routine is bypassed) do k = kb + 1 , ke do j = jb , je do i = ib , ie kp = k + 1 km = k - 1 jp = j + 1 jm = j - 1 ip = i + 1 im = i - 1 tdef2 = 2. * ( & (( u0 ( ip , j , k ) - u0 ( i , j , k )) * dxfi ( i ) ) ** 2 + & (( v0 ( i , jp , k ) - v0 ( i , j , k )) * dyi ) ** 2 + & (( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) ) ** 2 ) tdef2 = tdef2 + 0.25 * ( & (( w0 ( i , j , kp ) - w0 ( im , j , kp )) * dxhi ( i ) + & ( u0 ( i , j , kp ) - u0 ( i , j , k )) * dzhi ( kp ) ) ** 2 + & ! (( w0 ( i , j , k ) - w0 ( im , j , k )) * dxhi ( i ) + & ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) ) ** 2 + & ! (( w0 ( ip , j , k ) - w0 ( i , j , k )) * dxhi ( ip ) + & ( u0 ( ip , j , k ) - u0 ( ip , j , km )) * dzhi ( k ) ) ** 2 + & ! (( w0 ( ip , j , kp ) - w0 ( i , j , kp )) * dxhi ( ip ) + & ( u0 ( ip , j , kp ) - u0 ( ip , j , k )) * dzhi ( kp ) ) ** 2 ) tdef2 = tdef2 + 0.25 * ( & (( u0 ( i , jp , k ) - u0 ( i , j , k )) * dyi + & ( v0 ( i , jp , k ) - v0 ( im , jp , k )) * dxhi ( i ) ) ** 2 + & ! (( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi + & ( v0 ( i , j , k ) - v0 ( im , j , k )) * dxhi ( i ) ) ** 2 + & ! (( u0 ( ip , j , k ) - u0 ( ip , jm , k )) * dyi + & ( v0 ( ip , j , k ) - v0 ( i , j , k )) * dxhi ( ip )) ** 2 + & ! (( u0 ( ip , jp , k ) - u0 ( ip , j , k )) * dyi + & ( v0 ( ip , jp , k ) - v0 ( i , jp , k )) * dxhi ( ip )) ** 2 ) tdef2 = tdef2 + 0.25 * ( & (( v0 ( i , j , kp ) - v0 ( i , j , k )) * dzhi ( kp ) + & ( w0 ( i , j , kp ) - w0 ( i , jm , kp )) * dyi ) ** 2 + & ! (( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) + & ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi ) ** 2 + & ! (( v0 ( i , jp , k ) - v0 ( i , jp , km )) * dzhi ( k ) + & ( w0 ( i , jp , k ) - w0 ( i , j , k )) * dyi ) ** 2 + & ! (( v0 ( i , jp , kp ) - v0 ( i , jp , k )) * dzhi ( kp ) + & ( w0 ( i , jp , kp ) - w0 ( i , j , kp )) * dyi ) ** 2 ) !    sbshr(i,j,k)  = ekm(i,j,k)*tdef2/ ( 2*e120(i,j,k)) !    sbbuo(i,j,k)  = -ekh(i,j,k)*grav/thvs*dthvdz(i,j,k)/ ( 2*e120(i,j,k)) !    sbdiss(i,j,k) = - (ce1 + ce2*zlt(i,j,k)/delta(i,k)) * e120(i,j,k)**2 /(2.*zlt(i,j,k)) sbshr ( i , j , k ) = ( ekm ( i , j , k ) - numol ) * tdef2 / ( 2 * e120 ( i , j , k )) ! subtract molecular viscosity !    sbbuo(i,j,k)  = -(ekh(i,j,k)-numol*prandtlmoli)*grav/thvs*dthvdz(i,j,k)/ ( 2*e120(i,j,k))     ! subtract molecular diffusivity sbbuo ( i , j , k ) = - ( ekh ( i , j , k ) - numol * prandtlmoli ) * grav / thvs * dthvdz ( i , j , k ) / ( 2 * e120 ( i , j , k )) ! subtract molecular diffusivity and use thls instead of thvs (not defined) !    sbdiss(i,j,k) = - (ce1 + ce2*zlt(i,j,k)/delta(i,k)) * e120(i,j,k)**2 /(2.*damp*zlt(i,j,k))   ! add near-wall damping function ! added factor 2. for shear-driven flow sbdiss ( i , j , k ) = - 2. * ( ce1 + ce2 * zlt ( i , j , k ) / delta ( i , k )) * e120 ( i , j , k ) ** 2 / ( 2. * damp ( i , j , k ) * zlt ( i , j , k )) ! add near-wall damping function !! added f end do end do end do !     ----------------------------------------------end i,j,k-loop !    special treatment for lowest level do j = jb , je do i = ib , ie jp = j + 1 jm = j - 1 tdef2 = 2. * ( & (( u0 ( i + 1 , j , kb ) - u0 ( i , j , kb )) * dxfi ( i )) ** 2 & + (( v0 ( i , jp , kb ) - v0 ( i , j , kb )) * dyi ) ** 2 & + (( w0 ( i , j , kb + 1 ) - w0 ( i , j , kb )) * dzfi ( kb )) ** 2 ) tdef2 = tdef2 + ( 0.25 * ( w0 ( i + 1 , j , kb + 1 ) - w0 ( i - 1 , j , kb + 1 )) * dxfi ( i ) + & dudz ( i , j ) ) ** 2 tdef2 = tdef2 + 0.25 * ( & (( u0 ( i , jp , kb ) - u0 ( i , j , kb )) * dyi + ( v0 ( i , jp , kb ) - v0 ( i - 1 , jp , kb )) * dxfi ( i )) ** 2 & + (( u0 ( i , j , kb ) - u0 ( i , jm , kb )) * dyi + ( v0 ( i , j , kb ) - v0 ( i - 1 , j , kb )) * dxfi ( i )) ** 2 & + (( u0 ( i + 1 , j , kb ) - u0 ( i + 1 , jm , kb )) * dyi + ( v0 ( i + 1 , j , kb ) - v0 ( i , j , kb )) * dxfi ( i )) ** 2 & + (( u0 ( i + 1 , jp , kb ) - u0 ( i + 1 , j , kb )) * dyi + ( v0 ( i + 1 , jp , kb ) - v0 ( i , jp , kb )) * dxfi ( i )) ** 2 ) tdef2 = tdef2 + ( 0.25 * ( w0 ( i , jp , kb + 1 ) - w0 ( i , jm , kb + 1 )) * dyi + & dvdz ( i , j ) ) ** 2 ! **  Include shear and buoyancy production terms and dissipation ** sbshr ( i , j , kb ) = ekm ( i , j , kb ) * tdef2 / ( 2 * e120 ( i , j , kb )) sbbuo ( i , j , kb ) = - ekh ( i , j , kb ) * grav / thvf ( kb ) * dthvdz ( i , j , kb ) / ( 2 * e120 ( i , j , kb )) sbdiss ( i , j , kb ) = - ( ce1 + ce2 * zlt ( i , j , kb ) / delta ( i , kb )) * e120 ( i , j , kb ) ** 2 / ( 2. * zlt ( i , j , kb )) end do end do !    ------------------------------------------------ e12p ( ib : ie , jb : je , kb : ke ) = e12p ( ib : ie , jb : je , kb : ke ) + & sbshr ( ib : ie , jb : je , kb : ke ) + sbbuo ( ib : ie , jb : je , kb : ke ) + sbdiss ( ib : ie , jb : je , kb : ke ) !write(*,'(A,3(1pE9.2))') 'for check if called and e12p =', e12p(32,32,kb) return end subroutine sources subroutine diffc ( hi , hj , hk , putin , putout ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , dxh , dxhi , dxh2i , dxf , dxfi , dzf , dzfi , dyi , dy2i ,& dzhi , dzh2i , jmax , numol , prandtlmoli , lles use modmpi , only : myid implicit none integer , intent ( in ) :: hi !<size of halo in i integer , intent ( in ) :: hj !<size of halo in j integer , intent ( in ) :: hk !<size of halo in k real , intent ( in ) :: putin ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) real , intent ( inout ) :: putout ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) real cekh integer i , j , k , jm , jp , km , kp if ( lles ) then do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie putout ( i , j , k ) = putout ( i , j , k ) & + 0.5 * ( & ( ( ekh ( i + 1 , j , k ) * dxf ( i ) + ekh ( i , j , k ) * dxf ( i + 1 )) * ( putin ( i + 1 , j , k ) - putin ( i , j , k )) * dxh2i ( i + 1 ) & - ( ekh ( i , j , k ) * dxf ( i - 1 ) + ekh ( i - 1 , j , k ) * dxf ( i )) * ( putin ( i , j , k ) - putin ( i - 1 , j , k )) * dxh2i ( i )) * dxfi ( i ) & + & ( ( ekh ( i , jp , k ) + ekh ( i , j , k )) * ( putin ( i , jp , k ) - putin ( i , j , k )) & - ( ekh ( i , j , k ) + ekh ( i , jm , k )) * ( putin ( i , j , k ) - putin ( i , jm , k )) ) * dy2i & + & ( ( dzf ( kp ) * ekh ( i , j , k ) + dzf ( k ) * ekh ( i , j , kp )) & * ( putin ( i , j , kp ) - putin ( i , j , k )) * dzh2i ( kp ) & - & ( dzf ( km ) * ekh ( i , j , k ) + dzf ( k ) * ekh ( i , j , km )) & * ( putin ( i , j , k ) - putin ( i , j , km )) * dzh2i ( k ) ) * dzfi ( k ) & ) end do end do end do else ! DNS cekh = numol * prandtlmoli do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie putout ( i , j , k ) = putout ( i , j , k ) & + ( & ( cekh * ( putin ( i + 1 , j , k ) - putin ( i , j , k )) * dxhi ( i + 1 ) & - cekh * ( putin ( i , j , k ) - putin ( i - 1 , j , k )) * dxhi ( i )) * dxfi ( i ) & + & ( cekh * ( putin ( i , jp , k ) - putin ( i , j , k )) & - cekh * ( putin ( i , j , k ) - putin ( i , jm , k )) ) * dy2i & + & ( cekh * ( putin ( i , j , kp ) - putin ( i , j , k )) * dzhi ( kp ) & - cekh * ( putin ( i , j , k ) - putin ( i , j , km )) * dzhi ( k ) ) * dzfi ( k ) & ) end do end do end do end if ! lles=.true. end subroutine diffc subroutine diffe ( putout ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , dxf , dxfi , dxh2i , dzf , dzfi ,& dy2i , dzhi , dzh2i , jmax use modfields , only : e120 use modmpi , only : myid implicit none real , intent ( inout ) :: putout ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) integer :: i , j , k , jm , jp , km , kp do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie putout ( i , j , k ) = putout ( i , j , k ) & + 1.0 * ( & ( ( ekm ( i + 1 , j , k ) * dxf ( i ) + ekm ( i , j , k ) * dxf ( i + 1 )) * ( e120 ( i + 1 , j , k ) - e120 ( i , j , k )) * dxh2i ( i + 1 ) & - ( ekm ( i , j , k ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k ) * dxf ( i )) * ( e120 ( i , j , k ) - e120 ( i - 1 , j , k )) * dxh2i ( i )) * dxfi ( i ) & + & (( ekm ( i , jp , k ) + ekm ( i , j , k )) * ( e120 ( i , jp , k ) - e120 ( i , j , k )) & - ( ekm ( i , j , k ) + ekm ( i , jm , k )) * ( e120 ( i , j , k ) - e120 ( i , jm , k )) ) * dy2i & + & (( dzf ( kp ) * ekm ( i , j , k ) + dzf ( k ) * ekm ( i , j , kp )) & * ( e120 ( i , j , kp ) - e120 ( i , j , k )) * dzh2i ( kp ) & - ( dzf ( km ) * ekm ( i , j , k ) + dzf ( k ) * ekm ( i , j , km )) & * ( e120 ( i , j , k ) - e120 ( i , j , km )) * dzh2i ( k ) ) * dzfi ( k ) & ) end do end do end do end subroutine diffe subroutine diffu ( putout ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , kmax , dxhi , dxf , dxfi , lles ,& dzf , dzfi , dy , dyi , dy2i , dzhi , dzhiq , jmax , numol use modfields , only : u0 , v0 , w0 use modsurfdata , only : ustar use modmpi , only : myid implicit none real , intent ( inout ) :: putout ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) real :: emmo , emom , emop , empo real :: fu , dummy real :: ucu , upcu integer :: i , j , k , jm , jp , km , kp if ( lles ) then do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie emom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k ) * dxf ( i ) ) + & ! dx is non-equidistant dzf ( k ) * ( ekm ( i , j , km ) * dxf ( i - 1 ) + ekm ( i - 1 , j , km ) * dxf ( i ) ) ) * dxhi ( i ) * dzhiq ( k ) emop = ( dzf ( kp ) * ( ekm ( i , j , k ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k ) * dxf ( i ) ) + & ! dx is non-equidistant dzf ( k ) * ( ekm ( i , j , kp ) * dxf ( i - 1 ) + ekm ( i - 1 , j , kp ) * dxf ( i ) ) ) * dxhi ( i ) * dzhiq ( kp ) empo = 0.25 * ( ( ekm ( i , j , k ) + ekm ( i , jp , k )) * dxf ( i - 1 ) + ( ekm ( i - 1 , j , k ) + ekm ( i - 1 , jp , k )) * dxf ( i ) ) * dxhi ( i ) ! dx is non-equidistant emmo = 0.25 * ( ( ekm ( i , j , k ) + ekm ( i , jm , k )) * dxf ( i - 1 ) + ( ekm ( i - 1 , jm , k ) + ekm ( i - 1 , j , k )) * dxf ( i ) ) * dxhi ( i ) ! dx is non-equidistant ! Discretized diffusion term putout ( i , j , k ) = putout ( i , j , k ) & + & ( ekm ( i , j , k ) * ( u0 ( i + 1 , j , k ) - u0 ( i , j , k )) * dxfi ( i ) & - ekm ( i - 1 , j , k ) * ( u0 ( i , j , k ) - u0 ( i - 1 , j , k )) * dxfi ( i - 1 ) ) * 2. * dxhi ( i ) & + & ( empo * ( ( u0 ( i , jp , k ) - u0 ( i , j , k )) * dyi & + ( v0 ( i , jp , k ) - v0 ( i - 1 , jp , k )) * dxhi ( i )) & - emmo * ( ( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi & + ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dxhi ( i )) & ) * dyi & + & ( emop * ( ( u0 ( i , j , kp ) - u0 ( i , j , k )) * dzhi ( kp ) & + ( w0 ( i , j , kp ) - w0 ( i - 1 , j , kp )) * dxhi ( i )) & - emom * ( ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) & + ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dxhi ( i )) & ) * dzfi ( k ) end do end do end do else ! DNS do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie ! Discretized diffusion term putout ( i , j , k ) = putout ( i , j , k ) & + & ( numol * ( u0 ( i + 1 , j , k ) - u0 ( i , j , k )) * dxfi ( i ) & - numol * ( u0 ( i , j , k ) - u0 ( i - 1 , j , k )) * dxfi ( i - 1 ) ) * 2. * dxhi ( i ) & + & ( numol * ( ( u0 ( i , jp , k ) - u0 ( i , j , k )) * dyi & + ( v0 ( i , jp , k ) - v0 ( i - 1 , jp , k )) * dxhi ( i )) & - numol * ( ( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi & + ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dxhi ( i )) & ) * dyi & + & ( numol * ( ( u0 ( i , j , kp ) - u0 ( i , j , k )) * dzhi ( kp ) & + ( w0 ( i , j , kp ) - w0 ( i - 1 , j , kp )) * dxhi ( i )) & - numol * ( ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) & + ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dxhi ( i )) & ) * dzfi ( k ) end do end do end do end if ! lles end subroutine diffu subroutine diffv ( putout ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , dxf , dxhi , dxfi , dzf , dzfi , dyi ,& dy2i , dzhi , dzhiq , jmax , numol , lles use modfields , only : u0 , v0 , w0 use modsurfdata , only : ustar use modmpi , only : myid implicit none real , intent ( inout ) :: putout ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) real :: emmo , eomm , eomp , epmo real :: fv , vcv , vpcv integer :: i , j , k , jm , jp , km , kp if ( lles ) then do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie eomm = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i , jm , k ) ) + & dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i , jm , km ) ) ) * dzhiq ( k ) eomp = ( dzf ( kp ) * ( ekm ( i , j , k ) + ekm ( i , jm , k ) ) + & dzf ( k ) * ( ekm ( i , j , kp ) + ekm ( i , jm , kp ) ) ) * dzhiq ( kp ) emmo = 0.25 * ( ( ekm ( i , j , k ) + ekm ( i , jm , k )) * dxf ( i - 1 ) + ( ekm ( i - 1 , jm , k ) + ekm ( i - 1 , j , k )) * dxf ( i ) ) * dxhi ( i ) ! dx is non-equidistant epmo = 0.25 * ( ( ekm ( i , j , k ) + ekm ( i , jm , k )) * dxf ( i + 1 ) + ( ekm ( i + 1 , jm , k ) + ekm ( i + 1 , j , k )) * dxf ( i ) ) * dxhi ( i + 1 ) ! dx is non-equidistant ! discretized diffusion term putout ( i , j , k ) = putout ( i , j , k ) & + & ( epmo * ( ( v0 ( i + 1 , j , k ) - v0 ( i , j , k )) * dxhi ( i + 1 ) & + ( u0 ( i + 1 , j , k ) - u0 ( i + 1 , jm , k )) * dyi ) & - emmo * ( ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dxhi ( i ) & + ( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi ) & ) * dxfi ( i ) & ! = d/dx( Km*(dv/dx + du/dy) ) + & ( ekm ( i , j , k ) * ( v0 ( i , jp , k ) - v0 ( i , j , k )) & - ekm ( i , jm , k ) * ( v0 ( i , j , k ) - v0 ( i , jm , k )) ) * 2. * dy2i & ! = d/dy( 2*Km*(dv/dy) ) + & ( eomp * ( ( v0 ( i , j , kp ) - v0 ( i , j , k )) * dzhi ( kp ) & + ( w0 ( i , j , kp ) - w0 ( i , jm , kp )) * dyi ) & - eomm * ( ( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) & + ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi ) & ) * dzfi ( k ) ! = d/dz( Km*(dv/dz + dw/dy) ) end do end do end do else ! DNS do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie putout ( i , j , k ) = putout ( i , j , k ) & + & ( numol * ( ( v0 ( i + 1 , j , k ) - v0 ( i , j , k )) * dxhi ( i + 1 ) & + ( u0 ( i + 1 , j , k ) - u0 ( i + 1 , jm , k )) * dyi ) & - numol * ( ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dxhi ( i ) & + ( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi ) & ) * dxfi ( i ) & ! = d/dx( Km*(dv/dx + du/dy) ) + & ( numol * ( v0 ( i , jp , k ) - v0 ( i , j , k )) & - numol * ( v0 ( i , j , k ) - v0 ( i , jm , k )) ) * 2. * dy2i & ! = d/dy( 2*Km*(dv/dy) ) + & ( numol * ( ( v0 ( i , j , kp ) - v0 ( i , j , k )) * dzhi ( kp ) & + ( w0 ( i , j , kp ) - w0 ( i , jm , kp )) * dyi ) & - numol * ( ( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) & + ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi ) & ) * dzfi ( k ) ! = d/dz( Km*(dv/dz + dw/dy) ) end do end do end do end if end subroutine diffv subroutine diffw ( putout ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , kmax , dxf , dxhi , dxfi , dy ,& dyi , dy2i , dzf , dzfi , dzhi , dzhiq , jmax , numol , lles use modfields , only : u0 , v0 , w0 use modmpi , only : myid implicit none !***************************************************************** real , intent ( inout ) :: putout ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) real :: emom , eomm , eopm , epom integer :: i , j , k , jm , jp , km , kp if ( lles ) then do k = kb + 1 , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie emom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k ) * dxf ( i ) ) * dxhi ( i ) + & dzf ( k ) * ( ekm ( i , j , km ) * dxf ( i - 1 ) + ekm ( i - 1 , j , km ) * dxf ( i ) ) * dxhi ( i ) ) * dzhiq ( k ) eomm = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i , jm , k ) ) + & dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i , jm , km ) ) ) * dzhiq ( k ) eopm = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i , jp , k ) ) + & dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i , jp , km ) ) ) * dzhiq ( k ) epom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( i + 1 ) + ekm ( i + 1 , j , k ) * dxf ( i ) ) * dxhi ( i + 1 ) + & dzf ( k ) * ( ekm ( i , j , km ) * dxf ( i + 1 ) + ekm ( i + 1 , j , km ) * dxf ( i ) ) * dxhi ( i + 1 ) ) * dzhiq ( k ) ! discretized diffusion term putout ( i , j , k ) = putout ( i , j , k ) & + & ( epom * ( ( w0 ( i + 1 , j , k ) - w0 ( i , j , k )) * dxhi ( i + 1 ) & + ( u0 ( i + 1 , j , k ) - u0 ( i + 1 , j , km )) * dzhi ( k ) ) & - emom * ( ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dxhi ( i ) & + ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) ) & ) * dxfi ( i ) & + & ( eopm * ( ( w0 ( i , jp , k ) - w0 ( i , j , k )) * dyi & + ( v0 ( i , jp , k ) - v0 ( i , jp , km )) * dzhi ( k ) ) & - eomm * ( ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi & + ( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) ) & ) * dyi & + & ( ekm ( i , j , k ) * ( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) & - ekm ( i , j , km ) * ( w0 ( i , j , k ) - w0 ( i , j , km )) * dzfi ( km ) ) * 2. & * dzhi ( k ) end do end do end do else ! DNS do k = kb + 1 , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie ! discretized diffusion term putout ( i , j , k ) = putout ( i , j , k ) & + & ( numol * ( ( w0 ( i + 1 , j , k ) - w0 ( i , j , k )) * dxhi ( i + 1 ) & + ( u0 ( i + 1 , j , k ) - u0 ( i + 1 , j , km )) * dzhi ( k ) ) & - numol * ( ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dxhi ( i ) & + ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) ) & ) * dxfi ( i ) & + & ( numol * ( ( w0 ( i , jp , k ) - w0 ( i , j , k )) * dyi & + ( v0 ( i , jp , k ) - v0 ( i , jp , km )) * dzhi ( k ) ) & - numol * ( ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi & + ( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) ) & ) * dyi & + & ( numol * ( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) & - numol * ( w0 ( i , j , k ) - w0 ( i , j , km )) * dzfi ( km ) ) * 2. & * dzhi ( k ) end do end do end do end if end subroutine diffw end module modsubgrid","tags":"","loc":"sourcefile/modsubgrid.f90.html"},{"title":"advec_kappa.f90 – uDALES","text":"This file depends on sourcefile~~advec_kappa.f90~~EfferentGraph sourcefile~advec_kappa.f90 advec_kappa.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~advec_kappa.f90->sourcefile~modglobal.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~advec_kappa.f90->sourcefile~modfields.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~advec_kappa.f90->sourcefile~modibmdata.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions rlim Subroutines advecc_kappa Source Code advec_kappa.f90 Source Code !> \\file advec_kappa.f90 !!  Does advection with a kappa limiter scheme. !! \\par Revision list !! \\par Authors !! \\see Hundsdorfer et al 1995 !! !! For advection of scalars that need to be strictly monotone (for example chemically reacting species) the kappa scheme has been implemented: !! \\latexonly !! \\begin{eqnarray} !!  F_{i-\\frac{1}{2}}&#94;{\\kappa} &=& \\fav{u}_{i-\\frac{1}{2}} !!  \\left[\\phi_{i-1}+\\frac{1}{2}\\kappa_{i-\\frac{1}{2}}\\left(\\phi_{i-1}-\\phi_{i-2}\\right)\\right], !! \\end{eqnarrayl} !! in case $\\fav{u}>0$. $\\kappa_{i-\\smfrac{1}{2}}$ serves as a switch between higher order advection and first order upwind in case of strong upwind gradients of $\\phi$. !! \\endlatexonly !! This makes the scheme monotone, but also rather dissipative. !! !> Advection at cell center subroutine advecc_kappa ( hi , hj , hk , var , varp ) !  use modglobal, only : i1,i2,ih,j1,j2,jh,k1,kmax,dxi,dyi,dzi use modglobal , only : ib , ie , ihc , jb , je , jhc , kb , ke , khc , dxhci , dyi , dzhci , dxfc , dzfc , dxfci , dzfci , libm use modibmdata , only : nxwallsnorm , nywallsnorm , nzwallsnorm , xwallsnorm , & ywallsnorm , zwallsnorm , nywallsp , nywallsm , ywallsp , ywallsm use modfields , only : u0 , v0 , w0 implicit none real , external :: rlim integer , intent ( in ) :: hi !< size of halo in i integer , intent ( in ) :: hj !< size of halo in j integer , intent ( in ) :: hk !< size of halo in k real , dimension ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ), intent ( in ) :: var !< Input: the cell centered field real , dimension ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ), intent ( inout ) :: varp !< Output: the tendency real , dimension ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) :: duml ! 3d dummy variable: lower cell side real , dimension ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) :: dumu ! 3d dummy variable: upper cell side integer i , j , k , il , iu , jl , ju , kl , ku , n real :: cf , d1 , d2 dumu (:, :, :) = 0. duml (:, :, :) = 0. ! -d(uc)/dx (stretched grid) do k = kb , ke do j = jb , je do i = ib , ie + 1 if ( u0 ( i , j , k ) > 0 ) then d1 = ( var ( i - 1 , j , k ) - var ( i - 2 , j , k )) * dxhci ( i - 1 ) d2 = ( var ( i , j , k ) - var ( i - 1 , j , k )) * dxhci ( i ) cf = var ( i - 1 , j , k ) else d1 = ( var ( i , j , k ) - var ( i + 1 , j , k )) * dxhci ( i + 1 ) d2 = ( var ( i - 1 , j , k ) - var ( i , j , k )) * dxhci ( i ) cf = var ( i , j , k ) end if cf = cf + dxfc ( i ) * rlim ( d1 , d2 ) dumu ( i - 1 , j , k ) = - cf * u0 ( i , j , k ) * dxfci ( i - 1 ) !swapped the -1s here !tg3315 !now also swapped the signs... duml ( i , j , k ) = cf * u0 ( i , j , k ) * dxfci ( i ) end do end do end do varp (:,:,:) = varp (:,:,:) + dumu (:,:,:) + duml (:,:,:) dumu (:,:,:) = 0. duml (:,:,:) = 0. ! -d(vc)/dy (no stretched grid) do k = kb , ke do j = jb , je + 1 do i = ib , ie if ( v0 ( i , j , k ) > 0 ) then d1 = var ( i , j - 1 , k ) - var ( i , j - 2 , k ) d2 = var ( i , j , k ) - var ( i , j - 1 , k ) cf = var ( i , j - 1 , k ) else d1 = var ( i , j , k ) - var ( i , j + 1 , k ) d2 = var ( i , j - 1 , k ) - var ( i , j , k ) cf = var ( i , j , k ) end if cf = cf + rlim ( d1 , d2 ) duml ( i , j , k ) = cf * v0 ( i , j , k ) * dyi !tg3315 dumu ( i , j - 1 , k ) = - cf * v0 ( i , j , k ) * dyi end do end do end do varp (:,:,:) = varp (:,:,:) + dumu (:,:,:) + duml (:,:,:) dumu (:,:,:) = 0. duml (:,:,:) = 0. ! -d(wc)/dz (stretched grid) !  do k=kb,ke+1 do k = kb + 1 , ke + 1 do j = jb , je do i = ib , ie if ( w0 ( i , j , k ) > 0 ) then d1 = ( var ( i , j , k - 1 ) - var ( i , j , k - 2 )) * dzhci ( k - 1 ) d2 = ( var ( i , j , k ) - var ( i , j , k - 1 )) * dzhci ( k ) cf = var ( i , j , k - 1 ) else d1 = ( var ( i , j , k ) - var ( i , j , k + 1 )) * dzhci ( k + 1 ) d2 = ( var ( i , j , k - 1 ) - var ( i , j , k )) * dzhci ( k ) cf = var ( i , j , k ) end if cf = cf + dzfc ( k ) * rlim ( d1 , d2 ) duml ( i , j , k ) = cf * w0 ( i , j , k ) * dzfci ( k ) !tg3315 swapped dumu ( i , j , k - 1 ) = - cf * w0 ( i , j , k ) * dzfci ( k - 1 ) end do end do end do varp (:,:,:) = varp (:,:,:) + dumu (:,:,:) + duml (:,:,:) return end subroutine advecc_kappa !> Determination of the limiter function real function rlim ( d1 , d2 ) use modglobal , only : eps1 implicit none real , intent ( in ) :: d1 !< Scalar flux at 1.5 cells upwind real , intent ( in ) :: d2 !< Scalar flux at 0.5 cells upwind real ri , phir ri = ( d2 + eps1 ) / ( d1 + eps1 ) phir = max ( 0. , min ( 2. * ri , min ( 1. / 3. + 2. / 3. * ri , 2. ))) rlim = 0.5 * phir * d1 end function rlim","tags":"","loc":"sourcefile/advec_kappa.f90.html"},{"title":"modstartup.f90 – uDALES","text":"This file depends on sourcefile~~modstartup.f90~~EfferentGraph sourcefile~modstartup.f90 modstartup.f90 sourcefile~modpois.f90 modpois.f90 sourcefile~modstartup.f90->sourcefile~modpois.f90 sourcefile~modinlet.f90 modinlet.f90 sourcefile~modstartup.f90->sourcefile~modinlet.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~modstartup.f90->sourcefile~modsubgriddata.f90 sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~modstartup.f90->sourcefile~modsubgrid.f90 sourcefile~modsurfdata.f90 modsurfdata.f90 sourcefile~modstartup.f90->sourcefile~modsurfdata.f90 sourcefile~modthermodynamics.f90 modthermodynamics.f90 sourcefile~modstartup.f90->sourcefile~modthermodynamics.f90 sourcefile~modinletdata.f90 modinletdata.f90 sourcefile~modstartup.f90->sourcefile~modinletdata.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modstartup.f90->sourcefile~modmpi.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modstartup.f90->sourcefile~modfields.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modstartup.f90->sourcefile~modglobal.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~modstartup.f90->sourcefile~modboundary.f90 sourcefile~moddriver.f90 moddriver.f90 sourcefile~modstartup.f90->sourcefile~moddriver.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~modstartup.f90->sourcefile~modibmdata.f90 sourcefile~modforces.f90 modforces.f90 sourcefile~modstartup.f90->sourcefile~modforces.f90 sourcefile~modpois.f90->sourcefile~modmpi.f90 sourcefile~modpois.f90->sourcefile~modfields.f90 sourcefile~modpois.f90->sourcefile~modglobal.f90 sourcefile~modpois.f90->sourcefile~modboundary.f90 sourcefile~modinlet.f90->sourcefile~modsurfdata.f90 sourcefile~modinlet.f90->sourcefile~modinletdata.f90 sourcefile~modinlet.f90->sourcefile~modmpi.f90 sourcefile~modinlet.f90->sourcefile~modfields.f90 sourcefile~modinlet.f90->sourcefile~modglobal.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~modinlet.f90->sourcefile~modsave.f90 sourcefile~modsubgrid.f90->sourcefile~modsubgriddata.f90 sourcefile~modsubgrid.f90->sourcefile~modsurfdata.f90 sourcefile~modsubgrid.f90->sourcefile~modinletdata.f90 sourcefile~modsubgrid.f90->sourcefile~modmpi.f90 sourcefile~modsubgrid.f90->sourcefile~modfields.f90 sourcefile~modsubgrid.f90->sourcefile~modglobal.f90 sourcefile~modsubgrid.f90->sourcefile~modboundary.f90 sourcefile~modthermodynamics.f90->sourcefile~modsurfdata.f90 sourcefile~modthermodynamics.f90->sourcefile~modmpi.f90 sourcefile~modthermodynamics.f90->sourcefile~modfields.f90 sourcefile~modthermodynamics.f90->sourcefile~modglobal.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 sourcefile~modboundary.f90->sourcefile~modinlet.f90 sourcefile~modboundary.f90->sourcefile~modsubgriddata.f90 sourcefile~modboundary.f90->sourcefile~modsurfdata.f90 sourcefile~modboundary.f90->sourcefile~modinletdata.f90 sourcefile~modboundary.f90->sourcefile~modmpi.f90 sourcefile~modboundary.f90->sourcefile~modfields.f90 sourcefile~modboundary.f90->sourcefile~modglobal.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~moddriver.f90->sourcefile~modinletdata.f90 sourcefile~moddriver.f90->sourcefile~modmpi.f90 sourcefile~moddriver.f90->sourcefile~modfields.f90 sourcefile~moddriver.f90->sourcefile~modglobal.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~modforces.f90->sourcefile~modsurfdata.f90 sourcefile~modforces.f90->sourcefile~modmpi.f90 sourcefile~modforces.f90->sourcefile~modfields.f90 sourcefile~modforces.f90->sourcefile~modglobal.f90 sourcefile~modforces.f90->sourcefile~modibmdata.f90 sourcefile~modsave.f90->sourcefile~modsubgriddata.f90 sourcefile~modsave.f90->sourcefile~modsurfdata.f90 sourcefile~modsave.f90->sourcefile~modinletdata.f90 sourcefile~modsave.f90->sourcefile~modmpi.f90 sourcefile~modsave.f90->sourcefile~modfields.f90 sourcefile~modsave.f90->sourcefile~modglobal.f90 sourcefile~modsave.f90->sourcefile~modibmdata.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~modsave.f90->sourcefile~initfac.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~modstartup.f90~~AfferentGraph sourcefile~modstartup.f90 modstartup.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modstartup.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules modstartup Source Code modstartup.f90 Source Code !> \\file modstartup.f90 !!  Initializes the run !> !! Initializes the run. !> !! Modstartup reads the namelists and initial data, sets the fields and calls !! the inits of the other routines where necessary. Reading of the !! restart files also live in this module. !!  \\author Jasper Tomas, TU Delft !!  \\author Chiel van Heerwaarden, Wageningen U.R. !!  \\author Thijs Heus,MPI-M !!  \\todo documentation !!  \\par Revision list ! module modstartup implicit none ! private ! public :: startup,trestart save integer ( KIND = selected_int_kind ( 6 )) :: irandom = 0 !    * number to seed the randomnizer with integer :: krand = huge ( 0 ) ! returns the largest integer that is not an infinity real :: randu = 0.0 , randthl = 0.0 , randqt = 0.0 !    * uvw,thl and qt amplitude of randomnization contains subroutine startup !-----------------------------------------------------------------| !                                                                 | !     Reads all general options from namoptions                   | !                                                                 | !      Jasper Tomas                 31/03/2014                    | !      Chiel van Heerwaarden        15/06/2007                    | !      Thijs Heus                   15/06/2007                    | !-----------------------------------------------------------------| use modglobal , only : initglobal , iexpnr , runtime , dtmax , & lwarmstart , lstratstart , lfielddump , lreadscal , startfile , tfielddump , fieldvars , tsample , tstatsdump , trestart , & nsv , imax , jtot , kmax , xsize , ysize , xlat , xlon , xday , xtime , lwalldist , & lmoist , lcoriol , igrw_damp , geodamptime , ifnamopt , fname_options , & xS , yS , zS , SS , sigS , iwallmom , iwalltemp , iwallmoist , iwallscal , ipoiss , iadv_mom , iadv_tke , iadv_thl , iadv_qt , iadv_sv , courant , diffnr , ladaptive , author ,& linoutflow , lper2inout , libm , lnudge , tnudge , nnudge , lles , luoutflowr , lvoutflowr , luvolflowr , lvvolflowr , & uflowrate , vflowrate , lstoreplane , iplane , & lreadmean , iinletgen , inletav , lreadminl , Uinf , Vinf , linletRA , nblocks , & lscalrec , lSIRANEinout , lscasrc , lscasrcl , lscasrcr , lydump , lytdump , lxydump , lxytdump , lslicedump , ltdump , ltkedump , lzerogradtop ,& lzerogradtopscal , lbuoyancy , ltempeq , & lfixinlet , lfixutauin , pi , & thlsrc , ifixuinf , lvinf , tscale , ltempinout , lmoistinout , & lwallfunc , lprofforc , lchem , k1 , JNO2 , rv , rd , tnextEB , tEB , dtEB , bldT , wsoil , wgrmax , wwilt , wfc , skyLW , GRLAI , rsmin , nfcts , lEB , lwriteEBfiles , nwalllayers , lconstW , & BCxm , BCxT , BCxq , BCxs , BCym , BCyT , BCyq , BCys , & BCtopm , BCtopT , BCtopq , BCtops , BCbotm , BCbotT , BCbotq , BCbots , & idriver , tdriverstart , driverjobnr , dtdriver , driverstore use modsurfdata , only : z0 , z0h , wtsurf , wttop , wqtop , wqsurf , wsvsurf , wsvtop , wsvsurfdum , wsvtopdum , ps , thvs , thls , thl_top , qt_top , qts ! use modsurface,        only : initsurface use modfields , only : initfields , dpdx , ncname use modpois , only : initpois use modboundary , only : initboundary , ksp use modthermodynamics , only : initthermodynamics , lqlnr , chi_half use modsubgrid , only : initsubgrid use modmpi , only : comm3d , myid , mpi_integer , mpi_logical , my_real , mpierr , mpi_character use modinlet , only : initinlet use modinletdata , only : di , dr , di_test , dti , iangledeg , iangle use modibmdata , only : bctfxm , bctfxp , bctfym , bctfyp , bctfz use modforces , only : calcfluidvolumes use moddriver , only : initdriver implicit none integer :: ierr !declare namelists namelist / RUN / & iexpnr , lwarmstart , lstratstart , startfile , & runtime , dtmax , trestart , ladaptive , & irandom , randu , randthl , randqt , krand , & courant , diffnr , author , & libm , lles , & lper2inout , lwalldist , & lreadmean namelist / DOMAIN / & imax , jtot , kmax , xsize , ysize , & xlat , xlon , xday , xtime , ksp namelist / PHYSICS / & ps , igrw_damp , lmoist , lcoriol , lbuoyancy , ltempeq , & lprofforc , ifixuinf , lvinf , tscale , dpdx , & luoutflowr , lvoutflowr , luvolflowr , lvvolflowr , & uflowrate , vflowrate , & lnudge , tnudge , nnudge namelist / DYNAMICS / & lqlnr , ipoiss , & iadv_mom , iadv_tke , iadv_thl , iadv_qt , iadv_sv namelist / BC / & BCxm , BCxT , BCxq , BCxs , & BCym , BCyT , BCyq , BCys , & BCtopm , BCtopT , BCtopq , BCtops , & BCbotm , BCbotT , BCbotq , BCbots , & bctfxm , bctfxp , bctfym , bctfyp , bctfz , & wttop , thl_top , qt_top , qts , wsvsurfdum , wsvtopdum , & wtsurf , wqsurf , thls , z0 , z0h namelist / INLET / & Uinf , Vinf , di , dti , inletav , linletRA , & lstoreplane , lreadminl , lfixinlet , lfixutauin , & lwallfunc namelist / DRIVER / & idriver , tdriverstart , driverjobnr , dtdriver , & driverstore , iplane namelist / WALLS / & nblocks , nfcts , iwallmom , iwalltemp , iwallmoist , iwallscal namelist / ENERGYBALANCE / & lEB , lwriteEBfiles , lconstW , dtEB , bldT , wsoil , wgrmax , wwilt , wfc , & skyLW , GRLAI , rsmin , nwalllayers namelist / SCALARS / & lreadscal , lscasrc , lscasrcl , lscasrcr , & nsv , xS , yS , zS , SS , sigS namelist / CHEMISTRY / & lchem , k1 , JNO2 namelist / OUTPUT / & lfielddump , tfielddump , fieldvars , & ltdump , lydump , lytdump , lxydump , lxytdump , & lslicedump , ltkedump , tstatsdump , tsample if ( myid == 0 ) then if ( command_argument_count () >= 1 ) then call get_command_argument ( 1 , fname_options ) end if write ( * , * ) fname_options open ( ifnamopt , file = fname_options , status = 'old' , iostat = ierr ) if ( ierr /= 0 ) then write ( 0 , * ) 'ERROR: Namoptions does not exist' write ( 0 , * ) 'iostat error: ' , ierr stop 1 end if read ( ifnamopt , RUN , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions RUN' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif write ( 6 , RUN ) rewind ( ifnamopt ) read ( ifnamopt , DOMAIN , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions DOMAIN' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif write ( 6 , DOMAIN ) rewind ( ifnamopt ) read ( ifnamopt , PHYSICS , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions PHYSICS' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif write ( 6 , PHYSICS ) rewind ( ifnamopt ) read ( ifnamopt , DYNAMICS , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions DYNAMICS' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif write ( 6 , DYNAMICS ) rewind ( ifnamopt ) read ( ifnamopt , BC , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions BC' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif write ( 6 , BC ) rewind ( ifnamopt ) read ( ifnamopt , INLET , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions INLET' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif write ( 6 , INLET ) rewind ( ifnamopt ) read ( ifnamopt , DRIVER , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'Problem in namoptions DRIVER' write ( 0 , * ) 'iostat error: ' , ierr stop 'ERROR: Problem in namoptions DRIVER' endif write ( 6 , DRIVER ) rewind ( ifnamopt ) read ( ifnamopt , WALLS , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions WALLS' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif write ( 6 , WALLS ) rewind ( ifnamopt ) read ( ifnamopt , ENERGYBALANCE , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions EB' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif write ( 6 , ENERGYBALANCE ) rewind ( ifnamopt ) read ( ifnamopt , SCALARS , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions SCALARS' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif write ( 6 , SCALARS ) rewind ( ifnamopt ) read ( ifnamopt , CHEMISTRY , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions CHEMISTRY' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif write ( 6 , CHEMISTRY ) rewind ( ifnamopt ) read ( ifnamopt , OUTPUT , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions OUTPUT' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif write ( 6 , OUTPUT ) close ( ifnamopt ) end if thvs = thls * ( 1. + ( rv / rd - 1. ) * qts ) write ( * , * ) \"starting broadcast\" !broadcast namelists call MPI_BCAST ( iexpnr , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( lwarmstart , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lstratstart , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lfielddump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lreadscal , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch to read scalar pollutant fields (warm start) call MPI_BCAST ( lscasrc , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 call MPI_BCAST ( lscasrcl , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 call MPI_BCAST ( lscasrcr , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 call MPI_BCAST ( lbuoyancy , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for buoyancy force in modforces call MPI_BCAST ( ltempeq , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for solving adv/diff equation for temperature call MPI_BCAST ( lper2inout , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for restart periodic flow to inoutflow call MPI_BCAST ( libm , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for turning on/off IBM method call MPI_BCAST ( lnudge , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( nnudge , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( tnudge , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lwalldist , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for computing wall distances call MPI_BCAST ( lles , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for turning on/off LES functionality (subgrid model) call MPI_BCAST ( linletRA , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for turning on/off Running Average in inletgenerator call MPI_BCAST ( lfixinlet , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for keeping average inlet velocit and temp fixed at inlet (iinletgen=1,2) call MPI_BCAST ( lfixutauin , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for keeping utau fixed at inlet (iinletgen=1,2) call MPI_BCAST ( xS , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( yS , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( zS , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( SS , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( sigS , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( idriver , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) ! ae1212: Added switch for driver inlet simulation call MPI_BCAST ( tdriverstart , 1 , MY_REAL , 0 , comm3d , mpierr ) ! ae1212 call MPI_BCAST ( driverjobnr , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) ! ae1212 call MPI_BCAST ( dtdriver , 1 , MY_REAL , 0 , comm3d , mpierr ) ! ae1212 call MPI_BCAST ( driverstore , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) write ( * , * ) \"sec BC\" call MPI_BCAST ( BCxm , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxT , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxq , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxs , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCym , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCyT , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCyq , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCys , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCtopm , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCtopT , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCtopq , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCtops , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCbotm , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCbotT , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCbotq , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCbots , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) write ( * , * ) \"sec c\" call MPI_BCAST ( lwallfunc , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for reading mean inlet/recycle plane profiles (Uinl,Urec,Wrec) call MPI_BCAST ( lreadminl , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for reading mean inlet/recycle plane profiles (Uinl,Urec,Wrec) call MPI_BCAST ( iwalltemp , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) ! case (integer) for wall treatment for temperature (1=no wall function/fixed flux, 2=no wall function/fixed value, 3=uno) call MPI_BCAST ( iwallmoist , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) ! case (integer) for wall treatment for moisture (1=no wall function/fixed flux, 2=no wall function/fixed value, 3=uno) call MPI_BCAST ( iwallscal , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( iwallmom , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) ! case (integer) for wall treatment for momentum (1=no wall function, 2=werner-wengle, 3=uno) write ( * , * ) \"sec d\" call MPI_BCAST ( luoutflowr , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for turning on/off u-velocity correction for fixed mass outflow rate call MPI_BCAST ( lvoutflowr , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315: added switch for turning on/off v-velocity correction for fixed mass outflow rate call MPI_BCAST ( luvolflowr , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! bss166: added switch for turning on/off u-velocity correction for fixed volume flow rate call MPI_BCAST ( lvvolflowr , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! bss116: added switch for turning on/off v-velocity correction for fixed volume flow rate call MPI_BCAST ( lstoreplane , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for turning on/off for storing i-plane data to serve as inlet for future sim. call MPI_BCAST ( lreadmean , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for reading mean variables from means#MYID#.#EXPNR# call MPI_BCAST ( lydump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 added switch for writing statistics files call MPI_BCAST ( lytdump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 added switch for writing statistics files call MPI_BCAST ( lxydump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 added switch for writing statistics files call MPI_BCAST ( lxytdump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 added switch for writing statistics files call MPI_BCAST ( lslicedump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 added switch for writing statistics files call MPI_BCAST ( ltdump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 added switch for writing statistics files call MPI_BCAST ( ltkedump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 added switch for writing tke budget files call MPI_BCAST ( iplane , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) ! J.Tomas: ib+iplane is the i-plane that is stored if lstoreplane is .true. call MPI_BCAST ( startfile , 50 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( author , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( runtime , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( trestart , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( tfielddump , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( tsample , 1 , MY_REAL , 0 , comm3d , mpierr ) !tg3315 call MPI_BCAST ( tstatsdump , 1 , MY_REAL , 0 , comm3d , mpierr ) !tg3315 call MPI_BCAST ( tEB , 1 , MY_REAL , 0 , comm3d , mpierr ) tnextEB = dtEB call MPI_BCAST ( tnextEB , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dtmax , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( nsv , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( fieldvars , 50 , MPI_CHARACTER , 0 , comm3d , mpierr ) !call MPI_BCAST(nstat      ,1,MPI_INTEGER,0,comm3d,mpierr) !tg3315 !call MPI_BCAST(ncstat     ,80,MPI_CHARACTER,0,comm3d,mpierr) !tg3315 call MPI_BCAST ( ifixuinf , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( lvinf , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dpdx , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( tscale , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( imax , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( jtot , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( kmax , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( xsize , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ysize , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( xlat , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( xlon , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( xday , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( xtime , 1 , MY_REAL , 0 , comm3d , mpierr ) write ( * , * ) \"sec f\" call MPI_BCAST ( z0 , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( z0h , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bctfxm , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bctfxp , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bctfym , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bctfyp , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bctfz , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wtsurf , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wqsurf , 1 , MY_REAL , 0 , comm3d , mpierr ) allocate ( wsvsurf ( 1 : nsv )) wsvsurf = wsvsurfdum ( 1 : nsv ) call MPI_BCAST ( wsvsurf ( 1 : nsv ), nsv , MY_REAL , 0 , comm3d , mpierr ) allocate ( wsvtop ( 1 : nsv )) wsvtop = wsvtopdum ( 1 : nsv ) call MPI_BCAST ( wsvtop ( 1 : nsv ), nsv , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ps , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( thvs , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( thls , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( thl_top , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( qt_top , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( qts , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lmoist , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lcoriol , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lprofforc , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lchem , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( k1 , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( JNO2 , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( igrw_damp , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( geodamptime , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wttop , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wqtop , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( thlsrc , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( uflowrate , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( vflowrate , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( Uinf , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( Vinf , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( di , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dti , 1 , MY_REAL , 0 , comm3d , mpierr ) dr = di ! initial value is needed di_test = di ! initial value is needed write ( * , * ) \"sec g\" call MPI_BCAST ( iangledeg , 1 , MY_REAL , 0 , comm3d , mpierr ) iangle = iangledeg * pi / 18 0. call MPI_BCAST ( inletav , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lqlnr , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ksp , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nblocks , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) ! no. of blocks used in IBM call MPI_BCAST ( nfcts , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( lconstW , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lEB , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lwriteEBfiles , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wsoil , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wgrmax , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wwilt , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wfc , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dtEB , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bldT , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( skyLW , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( GRLAI , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( rsmin , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( nwalllayers , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( irandom , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( krand , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( randthl , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( randu , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( randqt , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ladaptive , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( courant , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( diffnr , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ipoiss , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( iadv_mom , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( iadv_tke , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( iadv_thl , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( iadv_qt , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( iadv_sv ( 1 : nsv ), nsv , MPI_INTEGER , 0 , comm3d , mpierr ) !write(*,*) \"sec h\" ! Allocate and initialize core modules call initglobal write ( * , * ) \"done initglobal\" call initfields write ( * , * ) \"done initfields\" call initboundary write ( * , * ) \"done initboundayi\" call initthermodynamics write ( * , * ) \"done initthermodynamics\" !!depreated!! ! call initsurface write ( * , * ) \"done initsurface\" call initsubgrid write ( * , * ) \"done initsubgrid\" call initpois write ( * , * ) \"done initpois\" call initinlet ! added by J. Tomas: initialize inlet generator write ( * , * ) \"done initinlet\" call initdriver ! added by ae1212: initialise driver inlet write ( * , * ) \"done initdriver\" call checkinitvalues write ( * , * ) \"done checkinitvalues\" write ( 6 , * ) 'Determine masking matrices' call createmasks ! determine walls/blocks write ( 6 , * ) 'Finished determining masking matrices' ! calculate fluid volume and outlet areas, needs masking matrices call calcfluidvolumes call readinitfiles write ( * , * ) \"done readinitfiles\" write ( * , * ) \"done startup\" call createscals write ( * , * ) \"done create scals\" end subroutine startup subroutine checkinitvalues !-----------------------------------------------------------------| !                                                                 | !      Thijs Heus   TU Delft  9/2/2006                            | !                                                                 | !     purpose.                                                    | !     --------                                                    | !                                                                 | !      checks whether crucial parameters are set correctly        | !                                                                 | !     interface.                                                  | !     ----------                                                  | !                                                                 | !     *checkinitvalues* is called from *program*.                 | !                                                                 | !-----------------------------------------------------------------| use modsurfdata , only : wtsurf , wqsurf , qts , ps use modglobal , only : imax , kmax , jtot , ysize , xsize , dxf , ib , ie ,& dtmax , runtime , startfile , lwarmstart , lstratstart ,& BCxm , BCxT , BCxq , BCxs , BCtopm , BCbotm ,& iinletgen , linoutflow , ltempeq , iwalltemp , iwallmom ,& ipoiss , POISS_FFT , POISS_CYC use modmpi , only : myid , nprocs , mpierr , comm3d , MPI_INTEGER , MPI_LOGICAL use modglobal , only : idriver implicit none real :: d ( 1 : imax - 1 ) logical :: inequi if ( mod ( jtot , nprocs ) /= 0 ) then if ( myid == 0 ) then write ( 0 , * ) 'STOP ERROR IN NUMBER OF PROCESSORS' write ( 0 , * ) 'nprocs must divide jtot!!! ' write ( 0 , * ) 'nprocs and jtot are: ' , nprocs , jtot end if call MPI_FINALIZE ( mpierr ) stop 1 end if if ( ipoiss == POISS_FFT ) then if ( mod ( imax , nprocs ) /= 0 ) then if ( myid == 0 ) then write ( 0 , * ) 'STOP ERROR IN NUMBER OF PROCESSORS' write ( 0 , * ) 'nprocs must divide imax!!! ' write ( 0 , * ) 'nprocs and imax are: ' , nprocs , imax end if call MPI_FINALIZE ( mpierr ) stop 1 end if end if if ( mod ( kmax , nprocs ) /= 0 ) then if ( myid == 0 ) then write ( 0 , * ) 'STOP ERROR IN NUMBER OF PROCESSORS' write ( 0 , * ) 'nprocs must divide kmax!!! ' write ( 0 , * ) 'nprocs and kmax are: ' , nprocs , kmax end if call MPI_FINALIZE ( mpierr ) stop 1 end if !Check Namoptions if ( runtime < 0 ) then write ( 0 , * ) 'ERROR: runtime out of range/not set' stop 1 end if if ( dtmax < 0 ) then write ( 0 , * ) 'ERROR: dtmax out of range/not set' stop 1 end if if ( ps < 0 ) then write ( 0 , * ) 'ERROR: psout of range/not set' stop 1 end if if ( xsize < 0 ) then write ( 0 , * ) 'ERROR: xsize out of range/not set' stop 1 end if if ( ysize < 0 ) then write ( 0 , * ) 'ERROR: ysize out of range/not set' stop 1 end if if (( lwarmstart ) . or . ( lstratstart )) then if ( startfile == '' ) then write ( 0 , * ) 'ERROR: no restartfile set' stop 1 end if end if ! Switch to ensure that neutral wall function is called when ltempeq=false and if iwalltemp==1 (constant flux and therefore wall temp is not resolved. if (( ltempeq . eqv . . false .) . or . ( iwalltemp == 1 )) then iwallmom = 3 BCbotm = 3 end if ! choosing inoutflow in x requires switches to be set ! tg3315 - these could be moved to init boundary if ( BCxm . eq . 2 ) then write ( * , * ) \"inoutflow conditions, setting appropriate switches (1)\" iinletgen = 1 BCxT = 3 !temperature is considered in inletgen & iolet BCxq = 3 !humidity is considered in iolet BCxs = 3 !scalars are considered in iolet BCtopm = 3 !velocity at top determined by topm linoutflow = . true . call MPI_BCAST ( iinletgen , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxT , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxq , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxs , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCtopm , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( linoutflow , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) else if ( BCxm . eq . 3 ) then write ( * , * ) \"inoutflow conditions, setting appropriate switches (2)\" iinletgen = 2 ! see modstartup for conditions that apply with inletgenerators ! move to modstartup BCxT = 3 !temperature is considered in inletgen & iolet BCxq = 3 !humidity is considered in iolet BCxs = 3 !scalars are considered in iolet BCtopm = 3 !velocity at top determined by topm linoutflow = . true . call MPI_BCAST ( iinletgen , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxT , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxq , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxs , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCtopm , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( linoutflow , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) else if ( BCxm . eq . 4 ) then write ( * , * ) \"inoutflow conditions, setting appropriate switches (0)\" iinletgen = 0 ! see modstartup for conditions that apply with inletgenerators ! move to modstartup BCxT = 3 !temperature is considered in inletgen & iolet BCxq = 3 !humidity is considered in iolet BCxs = 3 !scalars are considered in iolet BCtopm = 3 !velocity at top determined by topm linoutflow = . true . call MPI_BCAST ( iinletgen , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxT , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxq , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxs , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCtopm , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( linoutflow , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) else if ( BCxm . eq . 5 ) then write ( * , * ) \"inoutflow conditions and idriver, setting appropriate switches (0)\" iinletgen = 0 idriver = 2 BCxT = 3 !temperature is considered in inletgen & iolet BCxq = 3 !humidity is considered in iolet BCxs = 3 !scalars are considered in iolet BCtopm = 3 !velocity at top determined by topm linoutflow = . true . call MPI_BCAST ( iinletgen , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( idriver , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxT , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxq , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxs , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCtopm , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( linoutflow , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) end if ! check the Poisson solver setting w.r.t. x-grid d ( 1 : imax - 1 ) = dxf ( ib + 1 : ie ) - dxf ( ib : ie - 1 ) inequi = any ( abs ( d ) > dxf ( ib ) * 1e-5 ) if ((. not . inequi ) . and . ( ipoiss == POISS_CYC ) . and . (. not . linoutflow )) then write ( * , * ) \"WARNING: consider using FFT poisson solver for better performance!\" end if if (( ipoiss == POISS_FFT ) . and . ( inequi )) then write ( * , * ) \"ERROR: POISS_FFT requires equidistant grid. Aborting...\" call MPI_FINALIZE ( mpierr ) stop 1 end if end subroutine checkinitvalues subroutine readinitfiles use modfields , only : u0 , v0 , w0 , um , vm , wm , thlm , thl0 , thl0h , qtm , qt0 , qt0h , & ql0 , ql0h , thv0h , sv0 , svm , e12m , e120 , & dudxls , dudyls , dvdxls , dvdyls , dthldxls , dthldyls , & dqtdxls , dqtdyls , dqtdtls , dpdx , dpdxl , dpdyl , & wfls , whls , ug , vg , pgx , pgy , uprof , vprof , thlprof , qtprof , e12prof , svprof , & v0av , u0av , qt0av , ql0av , thl0av , qt0av , sv0av , exnf , exnh , presf , presh , rhof , & thlpcar , uav , thvh , thvf , IIc , IIcs , IIu , IIus , IIv , IIvs , IIw , IIws use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , khc , kmax , dtmax , dt , runtime , timeleft , timee , ntimee , ntrun , btime , dt_lim , nsv ,& zf , zh , dzf , dzh , rv , rd , grav , cp , rlv , pref0 , om23_gs , jgb , jge , Uinf , Vinf , dy , & rslabs , e12min , dzh , dtheta , dqt , dsv , cexpnr , ifinput , lwarmstart , lstratstart , trestart , numol , & ladaptive , tnextrestart , jmax , linoutflow , lper2inout , iinletgen , lreadminl , & uflowrate , vflowrate , ltempeq , prandtlmoli , freestreamav , & tnextfielddump , tfielddump , tsample , tstatsdump , startfile , lprofforc , lchem , k1 , JNO2 ,& idriver , dtdriver , driverstore , tdriverstart , tdriverdump use modsubgriddata , only : ekm , ekh use modsurfdata , only : wtsurf , wqsurf , wsvsurf , & thls , thvs , ps , qts , svs , sv_top ! use modsurface,        only : surface,dthldz use modboundary , only : boundary , tqaver use modmpi , only : slabsum , myid , comm3d , mpierr , my_real , avexy_ibm use modthermodynamics , only : thermodynamics , calc_halflev use modinletdata , only : Uinl , Urec , Wrec , u0inletbc , v0inletbc , w0inletbc , ubulk , irecy , Utav , Ttav , & uminletbc , vminletbc , wminletbc , u0inletbcold , v0inletbcold , w0inletbcold , & storeu0inletbc , storev0inletbc , storew0inletbc , nstepread , nfile , Tinl , & Trec , tminletbc , t0inletbcold , t0inletbc , storet0inletbc , utaui , ttaui , iangle ,& u0driver , v0driver , w0driver , e120driver , tdriver , thl0driver , qt0driver , storetdriver ,& storeu0driver , storev0driver , storew0driver , storee120driver , storethl0driver , storeqt0driver ,& nstepreaddriver use modinlet , only : readinletfile use moddriver , only : readdriverfile , initdriver , drivergen integer i , j , k , n real , allocatable :: height (:), th0av (:) real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) :: thv0 real , dimension ( kb : ke ) :: uaverage ! volume averaged u-velocity real , dimension ( kb : ke ) :: vaverage ! volume averaged v-velocity real , dimension ( kb : ke ) :: uaverager ! recycle plane real , dimension ( kb : ke ) :: uaveragei ! inlet plane real , dimension ( kb : ke ) :: taverager ! recycle plane real , dimension ( kb : ke ) :: taveragei ! inlet plane real , dimension ( kb : ke + 1 ) :: waverage real , dimension ( kb : ke + 1 ) :: uprofrot real , dimension ( kb : ke + 1 ) :: vprofrot real tv , ran , ran1 , vbulk character ( 80 ) chmess allocate ( height ( kb : ke + kh )) allocate ( th0av ( kb : ke + kh )) if ( lstratstart ) then ! Switch ! Read restart files as in lwarmstart call readrestartfiles um = u0 vm = v0 wm = w0 thlm = thl0 !do this before or just not? qtm = qt0 svm = sv0 e12m = e120 ! Overwrite thlm, thl0, qtm, qt0 from prof.inp.xxx if ( myid == 0 ) then open ( ifinput , file = 'prof.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess write ( * , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do k = kb , ke read ( ifinput , * ) & height ( k ), & thlprof ( k ), & qtprof ( k ), & uprof ( k ), & vprof ( k ), & e12prof ( k ) end do close ( ifinput ) write ( * , * ) 'height    thl     qt      u      v     e12' do k = ke , kb , - 1 write ( * , '(f7.1,2f8.1,3f7.1)' ) & height ( k ), & thlprof ( k ), & qtprof ( k ), & uprof ( k ), & vprof ( k ), & e12prof ( k ) end do end if !myid=0 ! MPI broadcast thl and qt call MPI_BCAST ( thlprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( qtprof , kmax , MY_REAL , 0 , comm3d , mpierr ) do k = kb , ke do j = jb - 1 , je + 1 do i = ib - 1 , ie + 1 thl0 ( i , j , k ) = thlprof ( k ) thlm ( i , j , k ) = thlprof ( k ) qt0 ( i , j , k ) = qtprof ( k ) qtm ( i , j , k ) = qtprof ( k ) end do end do end do !ILS13 reintroduced thv !tg3315 this part may wrong, could need to use call calc_halflev ! exnf = (presf/pref0)**(rd/cp)  !exner functions not in restart files ! anymore.. or at least not read ! exnh = (presh/pref0)**(rd/cp) !   write(*,*) \"exnf\",enf !   write(*,*) \"exnh\",exnh do k = kb , ke + kh do j = jb , je do i = ib , ie !write(*,*) \"thl0h\",thl0h(i,j,k) thv0h ( i , j , k ) = ( thl0h ( i , j , k ) + rlv * ql0h ( i , j , k ) / ( cp )) & * ( 1 + ( rv / rd - 1 ) * qt0h ( i , j , k ) - rv / rd * ql0h ( i , j , k )) end do end do end do do j = j , je do i = ib , ie do k = kb , ke + kh thv0 ( i , j , k ) = ( thl0 ( i , j , k ) + rlv * ql0 ( i , j , k ) / ( cp )) & * ( 1 + ( rv / rd - 1 ) * qt0 ( i , j , k ) - rv / rd * ql0 ( i , j , k )) end do end do end do thvh = 0. ! call slabsum(thvh,kb,ke,thv0h,ib-ih,ie+ih,jb-jh,je+jh,kb-kh,ke+kh,ib,ie,jb,je,kb,ke) ! redefine halflevel thv using calculated thv call avexy_ibm ( thvh ( kb : ke + kh ), thv0h ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. false .) ! thvh = thvh/rslabs thvf = 0.0 call avexy_ibm ( thvf ( kb : ke + kh ), thv0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) ! call slabsum(thvf,kb,ke,thv0,ib-ih,ie+ih,jb-jh,je+jh,kb-kh,ke+kh,ib,ie,jb,je,kb,ke) ! thvf = thvf/rslabs else !if not lstratstart if (. not . lwarmstart ) then !******************************************************************** !    1.0 prepare initial fields from files 'prof.inp' and 'scalar.inp' !    ---------------------------------------------------------------- !-------------------------------------------------------------------- !    1.1 read fields !----------------------------------------------------------------- dt = dtmax / 10 0. timee = 0. if ( myid == 0 ) then open ( ifinput , file = 'prof.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess write ( * , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do k = kb , ke read ( ifinput , * ) & height ( k ), & thlprof ( k ), & qtprof ( k ), & uprof ( k ), & vprof ( k ), & e12prof ( k ) end do ! Apply rotation in horizontal !write (6, *) 'iangle = ', iangle !uprofrot = uprof*cos(iangle) - vprof*sin(iangle) !vprofrot = vprof*cos(iangle) + uprof*sin(iangle) !uprof = uprofrot !vprof = vprofrot close ( ifinput ) write ( * , * ) 'height    thl     qt      u      v     e12' do k = ke , kb , - 1 write ( * , '(f7.1,2f8.1,3f7.1)' ) & height ( k ), & thlprof ( k ), & qtprof ( k ), & uprof ( k ), & vprof ( k ), & e12prof ( k ) end do if ( minval ( e12prof ( kb : ke )) < e12min ) then write ( * , * ) 'e12 value is zero (or less) in prof.inp' do k = kb , ke e12prof ( k ) = max ( e12prof ( k ), e12min ) end do end if end if ! end if myid==0 ! MPI broadcast numbers reading call MPI_BCAST ( thlprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( qtprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( uprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( vprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( e12prof , kmax , MY_REAL , 0 , comm3d , mpierr ) do k = kb , ke do j = jb - 1 , je + 1 do i = ib - 1 , ie + 1 thl0 ( i , j , k ) = thlprof ( k ) thlm ( i , j , k ) = thlprof ( k ) qt0 ( i , j , k ) = qtprof ( k ) qtm ( i , j , k ) = qtprof ( k ) u0 ( i , j , k ) = uprof ( k ) um ( i , j , k ) = uprof ( k ) v0 ( i , j , k ) = vprof ( k ) vm ( i , j , k ) = vprof ( k ) w0 ( i , j , k ) = 0.0 wm ( i , j , k ) = 0.0 e120 ( i , j , k ) = e12prof ( k ) e12m ( i , j , k ) = e12prof ( k ) !        ekm (i,j,k) = 0.0 !        ekh (i,j,k) = 0.0 ekm ( i , j , k ) = numol ekh ( i , j , k ) = numol end do end do end do ekh (:, :, ke + 1 ) = ekh (:, :, ke ) ! also for start up ! ILS13 30.11.17, added, not sure if necessary ! ILS13 30.11.1, commented do j = jb - jh , je + jh do i = ib - ih , ie + ih thl0 ( i , j , ke + 1 ) = thl0 ( i , j , ke ) thl0 ( i , j , kb - 1 ) = thl0 ( i , j , kb ) end do end do !! add random fluctuations krand = min ( krand , ke ) do k = kb , krand call randomnize ( um , k , randu , irandom , ih , jh ) end do do k = kb , krand call randomnize ( vm , k , randu , irandom , ih , jh ) end do do k = kb , krand call randomnize ( wm , k , randu , irandom , ih , jh ) end do !       do k=kb+1,ke-1 !       do j=jb,je !       do i=ib+1,ie-1 !         call random_number(ran) !         ran1 = -1. +2.*ran !         wm(i,j,k)=wm(i,j,k)+ 0.1*Uinf*ran1 !       end do !       end do !       end do ! !       do k=kb+1,ke-1 !       do j=jb,je !       do i=ib+2,ie-1 !         call random_number(ran) !         ran1 = -1. +2.*ran !         um(i,j,k)=um(i,j,k)+ 0.1*Uinf*ran1 !       end do !       end do !       end do ! !       do k=kb+1,ke-1 !       do j=jb,je !       do i=ib+1,ie-1 !         call random_number(ran) !         ran1 = -1. +2.*ran !         vm(i,j,k)=vm(i,j,k)+ 0.1*Uinf*ran1 !       end do !       end do !       end do u0 = um v0 = vm w0 = wm uaverage = 0. ! call slabsum(uaverage, kb, ke, um, ib - 1, ie + 1, jb - 1, je + 1, kb - 1, ke + 1, ib, ie, jb, je, kb, ke) do k = kb , ke uaverage ( k ) = uprof ( k ) * dzf ( k ) end do ubulk = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! averaged u-velocity inflow profile vaverage = 0. ! call slabsum(vaverage, kb, ke, vm, ib - 1, ie + 1, jb - 1, je + 1, kb - 1, ke + 1, ib, ie, jb, je, kb, ke) do k = kb , ke vaverage ( k ) = vprof ( k ) * dzf ( k ) end do vbulk = sum ( vaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! averaged u-velocity inflow profile ! Set average inlet profile to initial inlet profile in case of inletgenerator mode if ( iinletgen == 1 ) then uaverage = 0. call slabsum ( uaverage , kb , ke , um , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ie , jb , je , kb , ke ) do k = kb , ke uaverage ( k ) = uprof ( k ) * dzf ( k ) end do ubulk = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! volume-averaged u-velocity write ( 6 , * ) 'Modstartup: ubulk=' , ubulk Utav ( ib : ie , kb : ke ) = um ( ib : ie , jb , kb : ke ) Uinl = um ( ib , jb , kb : ke ) ! set the initial time-averaged inlet profile equal to um Urec = um ( ib , jb , kb : ke ) ! set the initial time-averaged inlet profile equal to um Wrec ( kb : ke + 1 ) = wm ( ib , jb , kb : ke + 1 ) ! set the initial time-averaged inlet profile equal to mean w-profile u0inletbcold ( jb : je , kb : ke ) = um ( ib , jb : je , kb : ke ) v0inletbcold ( jb : je , kb : ke ) = vm ( ib - 1 , jb : je , kb : ke ) w0inletbcold ( jb : je , kb : ke + 1 ) = wm ( ib - 1 , jb : je , kb : ke + 1 ) uminletbc ( jb : je , kb : ke ) = um ( ib , jb : je , kb : ke ) vminletbc ( jb : je , kb : ke ) = vm ( ib - 1 , jb : je , kb : ke ) wminletbc ( jb : je , kb : ke ) = wm ( ib - 1 , jb : je , kb : ke ) u0inletbc ( jb : je , kb : ke ) = um ( ib , jb : je , kb : ke ) v0inletbc ( jb : je , kb : ke ) = vm ( ib - 1 , jb : je , kb : ke ) w0inletbc ( jb : je , kb : ke + 1 ) = wm ( ib - 1 , jb : je , kb : ke + 1 ) utaui = sqrt ( abs ( 2 * numol * Uinl ( kb ) / dzf ( kb ))) ! average streamwise friction at inlet (need for first time step) if ( ltempeq ) then Ttav ( ib : ie , kb : ke ) = thlm ( ib : ie , jb , kb : ke ) ! set the initial time-averaged inlet profile equal to thlm Tinl = thlm ( ib , jb , kb : ke ) ! set the initial time-averaged inlet profile equal to thlm Trec = thlm ( ib , jb , kb : ke ) ! set the initial time-averaged inlet profile equal to thlm t0inletbcold ( jb : je , kb : ke ) = thlm ( ib - 1 , jb : je , kb : ke ) t0inletbc ( jb : je , kb : ke ) = thl0 ( ib - 1 , jb : je , kb : ke ) tminletbc ( jb : je , kb : ke ) = thlm ( ib - 1 , jb : je , kb : ke ) ttaui = numol * prandtlmoli * 2. * ( Tinl ( kb ) - thls ) / ( dzf ( kb ) * utaui ) ! average friction temp. at inlet (need for first time step) end if ! add random perturbations if ( myid == 0 ) then call random_number ( ran ) ran1 = - 1. + 2. * ran write ( 6 , * ) 'random=' , ran , ran1 call random_number ( ran ) ran1 = - 1. + 2. * ran write ( 6 , * ) 'random=' , ran , ran1 call random_number ( ran ) ran1 = - 1. + 2. * ran write ( 6 , * ) 'random=' , ran , ran1 call random_number ( ran ) ran1 = - 1. + 2. * ran write ( 6 , * ) 'random=' , ran , ran1 call random_number ( ran ) ran1 = - 1. + 2. * ran write ( 6 , * ) 'random=' , ran , ran1 call random_number ( ran ) ran1 = - 1. + 2. * ran write ( 6 , * ) 'random=' , ran , ran1 end if do k = kb + 1 , kb + 48 do j = jb , je do i = ib + 1 , ie - 1 call random_number ( ran ) ran1 = - 1. + 2. * ran wm ( i , j , k ) = wm ( i , j , k ) + 0.1 * Uinf * ran1 end do end do end do !       do k=kb+1,ke-1 do k = kb + 1 , kb + 48 do j = jb , je do i = ib + 2 , ie - 1 call random_number ( ran ) ran1 = - 1. + 2. * ran um ( i , j , k ) = um ( i , j , k ) + 0.1 * Uinf * ran1 end do end do end do !       do k=kb+1,ke-1 do k = kb + 1 , kb + 48 do j = jb , je do i = ib + 1 , ie - 1 call random_number ( ran ) ran1 = - 1. + 2. * ran vm ( i , j , k ) = vm ( i , j , k ) + 0.1 * Uinf * ran1 end do end do end do u0 = um v0 = vm w0 = wm else if ( iinletgen == 2 ) then nfile = nfile + 1 call readinletfile u0inletbc (:, :) = storeu0inletbc (:, :, nstepread ) v0inletbc (:, :) = storev0inletbc (:, :, nstepread ) w0inletbc (:, :) = storew0inletbc (:, :, nstepread ) uminletbc (:, :) = storeu0inletbc (:, :, nstepread ) vminletbc (:, :) = storev0inletbc (:, :, nstepread ) wminletbc (:, :) = storew0inletbc (:, :, nstepread ) ! determine bulk velocity call slabsum ( uaverage , kb , ke , u0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ie , jb , je , kb , ke ) uaverage = uaverage / (( ie - ib + 1 ) * ( jge - jgb + 1 )) ! this gives the i-j-averaged velocity (only correct for equidistant grid?) do k = kb , ke uaverage ( k ) = uaverage ( k ) * dzf ( k ) end do ubulk = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! volume-averaged u-velocity write ( 6 , * ) 'Modstartup: ubulk=' , ubulk elseif ( idriver == 2 ) then ! idriver call readdriverfile ! if(myid==0) then ! write(*,*) 'Driver inlet velocity' ! do n=1,driverstore ! write (*,'(f9.2,e20.12)') storetdriver(n),     storeu0driver(1,32,n) ! end do ! endif ! call slabsum(uaverage,kb,ke,u0,ib-1,ie+1,jb-1,je+1,kb-1,ke+1,ib,ie,jb,je,kb,ke) ! uaverage = uaverage / ((ie-ib+1)*(jge-jgb+1))  ! this gives the i-j-averaged velocity (only correct for equidistant grid?) call avexy_ibm ( uaverage ( kb : ke ), u0 ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIu ( ib : ie , jb : je , kb : ke ), IIus ( kb : ke ),. false .) do k = kb , ke uaverage ( k ) = uaverage ( k ) * dzf ( k ) end do ubulk = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) !volume-averaged u-velocity if ( myid == 0 ) then write ( 6 , * ) 'Modstartup: ubulk=' , ubulk end if elseif ( idriver == 1 ) then call drivergen end if !--------------------------------------------------------------- !  1.2 randomnize fields !--------------------------------------------------------------- !     if (iinletgen /= 2 .and. iinletgen /= 1) then !       write(6,*) 'randomnizing temperature!' !       krand  = min(krand,ke) !        do k = kb,ke !edited tg3315 krand --> ke !          call randomnize(thlm,k,randthl,irandom,ih,jh) !          call randomnize(thl0,k,randthl,irandom,ih,jh) !        end do !       end if svprof = 0. if ( myid == 0 ) then if ( nsv > 0 ) then open ( ifinput , file = 'scalar.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do k = kb , ke read ( ifinput , * ) & height ( k ), & ( svprof ( k , n ), n = 1 , nsv ) end do open ( ifinput , file = 'scalar.inp.' // cexpnr ) write ( 6 , * ) 'height   sv(1) --------- sv(nsv) ' do k = ke , kb , - 1 write ( 6 , * ) & height ( k ), & ( svprof ( k , n ), n = 1 , nsv ) end do end if end if ! end if myid==0 call MPI_BCAST ( svprof , ( ke + kh - ( kb - kh )) * nsv , MY_REAL , 0 , comm3d , mpierr ) do k = kb , ke do j = jb - 1 , je + 1 do i = ib - 1 , ie + 1 do n = 1 , nsv sv0 ( i , j , k , n ) = svprof ( k , n ) svm ( i , j , k , n ) = svprof ( k , n ) end do end do end do end do if ( nsv > 0 ) then !tg3315 set these variables here for now and repeat for warmstart allocate ( sv_top ( 1 : nsv )) sv_top (:) = svprof ( ke , 1 : nsv ) call MPI_BCAST ( sv_top , nsv , MY_REAL , 0 , comm3d , mpierr ) write ( * , * ) 'svprof' , svprof write ( * , * ) 'sv_top' , sv_top end if !do n = 1,nsv !  do j = jb - jhc, je + jhc !    do i = ib - ihc, ie + ihc !      svm(i, j, ke + 1, n) = svm(i, j, ke) !      sv0(i, j, kb - 1, n) = sv0(i, j, kb) !    end do !  end do !end do !----------------------------------------------------------------- !    2.2 Initialize surface layer !----------------------------------------------------------------- !ILS13 reintroduced thv !tg3315 this part may wrong, could need to use call calc_halflev ! exnf = (presf/pref0)**(rd/cp)  !exner functions not in restart files ! anymore.. or at least not read ! exnh = (presh/pref0)**(rd/cp) call boundary ! tg3315 17.10.17 having this in startup was causing issues for running with lmoist ! turned of when pot. temp = temp. call thermodynamics ! turned off when pot. temp = temp. call boundary call thermodynamics ! turned off when pot. temp = temp. else !if lwarmstart write ( * , * ) \"doing warmstart\" call readrestartfiles um = u0 vm = v0 wm = w0 thlm = thl0 qtm = qt0 svm = sv0 e12m = e120 ekm (:, :, :) = numol ekh (:, :, :) = numol * prandtlmoli !tg3315 added because wttop using ekh in modboundary which is called in startup ekh (:, :, ke + 1 ) = ekh (:, :, ke ) ! also for start up if ( idriver == 1 ) then !driverstore = (timeleft - tdriverstart)/dtdriver + 1 !if(myid==0) then !  write(*,*) 'driverstore: ', driverstore !end if call drivergen tdriverdump = tdriverstart endif !ILS13 reintroduced thv call calc_halflev ! exnf = (presf/pref0)**(rd/cp)  !exner functions not in restart files ! anymore.. or at least not read ! exnh = (presh/pref0)**(rd/cp) !   write(*,*) \"exnf\",enf !   write(*,*) \"exnh\",exnh do j = jb , je do i = ib , ie do k = kb , ke + kh !write(*,*) \"thl0h\",thl0h(i,j,k) thv0h ( i , j , k ) = ( thl0h ( i , j , k ) + rlv * ql0h ( i , j , k ) / ( cp )) & * ( 1 + ( rv / rd - 1 ) * qt0h ( i , j , k ) - rv / rd * ql0h ( i , j , k )) end do end do end do do j = j , je do i = ib , ie do k = kb , ke + kh thv0 ( i , j , k ) = ( thl0 ( i , j , k ) + rlv * ql0 ( i , j , k ) / ( cp )) & * ( 1 + ( rv / rd - 1 ) * qt0 ( i , j , k ) - rv / rd * ql0 ( i , j , k )) end do end do end do thvh = 0. ! call slabsum(thvh,kb,ke,thv0h,ib-ih,ie+ih,jb-jh,je+jh,kb-kh,ke+kh,ib,ie,jb,je,kb,ke) ! redefine halflevel thv using calculated thv call avexy_ibm ( thvh ( kb : ke + kh ), thv0h ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. false .) ! thvh = thvh/rslabs thvf = 0.0 call avexy_ibm ( thvf ( kb : ke + kh ), thv0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) ! call slabsum(thvf,kb,ke,thv0,ib-ih,ie+ih,jb-jh,je+jh,kb-kh,ke+kh,ib,ie,jb,je,kb,ke) ! thvf = thvf/rslabs ! Set average inlet profile to initial inlet profile in case of inletgenerator mode uaverage = 0. uaveragei = 0. uaverager = 0. waverage = 0. taveragei = 0. taverager = 0. if ( iinletgen == 1 ) then call slabsum ( uaveragei , kb , ke , u0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ib , jb , je , kb , ke ) call slabsum ( uaverager , kb , ke , u0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , irecy , irecy , jb , je , kb , ke ) call slabsum ( waverage , kb , ke + 1 , w0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ie , jb , je , kb , ke + 1 ) call slabsum ( uaverage , kb , ke , u0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ie , jb , je , kb , ke ) uaverage = uaverage / (( ie - ib + 1 ) * ( jge - jgb + 1 )) ! this gives the i-j-averaged velocity (only correct for equidistant grid?) uaveragei = uaveragei / ( jge - jgb + 1 ) ! this gives the j-averaged u-velocity at the inlet uaverager = uaverager / ( jge - jgb + 1 ) ! this gives the j-averaged u-velocity at the recycle plane waverage = waverage / (( ie - ib + 1 ) * ( jge - jgb + 1 )) ! this gives the i-j-averaged w-velocity (only correct for equidistant grid?) if ( ltempeq ) then call slabsum ( taveragei , kb , ke , thl0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ie , jb , je , kb , ke ) call slabsum ( taverager , kb , ke , thl0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , irecy - 1 , irecy - 1 , jb , je , kb , ke ) taveragei = taveragei / (( ie - ib + 1 ) * ( jge - jgb + 1 )) ! this gives the j-averaged temperature at the inlet taverager = taverager / ( jge - jgb + 1 ) ! this gives the j-averaged temperature at the recycle plane end if if (. not . lreadminl ) then if ( myid == 0 ) then write ( 6 , * ) 'uaverage(kb)=' , uaverage ( kb ) write ( 6 , * ) 'uaverage(ke)=' , uaverage ( ke ) write ( 6 , * ) 'waverage(ke)=' , waverage ( ke ) write ( 6 , * ) 'waverage(ke-20)=' , waverage ( ke - 20 ) write ( 6 , * ) 'taveragei(kb)=' , taveragei ( kb ) write ( 6 , * ) 'taveragei(ke)=' , taveragei ( ke ) end if Utav = 0. do i = ib , ie Utav ( i , :) = uaverage end do Uinl = uaverage ! set the initial time-averaged inlet profile equal to mean u-profile read from means write ( 6 , * ) 'Uinl(kb+10)=' , Uinl ( kb + 10 ) utaui = sqrt ( abs ( 2 * numol * Uinl ( kb ) / dzf ( kb ))) ! average streamwise friction at inlet (need for first time step) Urec = uaverage ! set the initial time-averaged inlet profile equal to mean u-profile Wrec ( kb : ke + 1 ) = waverage ( kb : ke + 1 ) ! set the initial time-averaged inlet profile equal to mean w-profile Wrec ( kb ) = 0. ! set the initial time-averaged inlet profile equal to zero if ( ltempeq ) then Ttav = 0. do i = ib , ie Ttav ( i , :) = taveragei (:) end do Tinl = taveragei Trec = taveragei ttaui = numol * prandtlmoli * 2. * ( Tinl ( kb ) - thls ) / ( dzf ( kb ) * utaui ) ! friction temp. at inlet (need at first time step) end if else ! -> lreadminl -> Uinl, Urec, Wrec already read call slabsum ( uaverage , kb , ke , u0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ie , jb , je , kb , ke ) uaverage = uaverage / (( ie - ib + 1 ) * ( jge - jgb + 1 )) ! this gives the i-j-averaged velocity (only correct for equidistant grid?) end if ! determine bulk velocity do k = kb , ke uaverage ( k ) = uaverage ( k ) * dzf ( k ) end do ubulk = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! volume-averaged u-velocity write ( 6 , * ) 'Modstartup: ubulk=' , ubulk do k = kb , ke do j = jb , je uminletbc ( j , k ) = um ( ib , j , k ) vminletbc ( j , k ) = vm ( ib - 1 , j , k ) u0inletbcold ( j , k ) = um ( ib , j , k ) v0inletbcold ( j , k ) = vm ( ib - 1 , j , k ) u0inletbc ( j , k ) = um ( ib , j , k ) v0inletbc ( j , k ) = vm ( ib - 1 , j , k ) end do end do do k = kb , ke + 1 do j = jb , je wminletbc ( j , k ) = wm ( ib - 1 , j , k ) w0inletbcold ( j , k ) = wm ( ib - 1 , j , k ) w0inletbc ( j , k ) = wm ( ib - 1 , j , k ) end do end do if ( ltempeq ) then do k = kb , ke do j = jb , je tminletbc ( j , k ) = thlm ( ib - 1 , j , k ) t0inletbcold ( j , k ) = thlm ( ib - 1 , j , k ) t0inletbc ( j , k ) = thlm ( ib - 1 , j , k ) end do end do end if write ( 6 , * ) 'uminletbc(jb,kb),um(ib,jb,kb)=' , uminletbc ( jb , kb ), um ( ib , jb , kb ) write ( 6 , * ) 'uminletbc(jb+1,kb+10),um(ib,jb+1,kb+10)=' , uminletbc ( jb + 1 , kb + 10 ), um ( ib , jb + 1 , kb + 10 ) write ( 6 , * ) 'uminletbc(je,kb+10),um(ib,je,kb+10)=' , uminletbc ( je , kb + 10 ), um ( ib , je , kb + 10 ) else if ( iinletgen == 2 ) then nfile = nfile + 1 write ( 6 , * ) 'Loading inletfile' call readinletfile u0inletbc (:, :) = storeu0inletbc (:, :, nstepread ) v0inletbc (:, :) = storev0inletbc (:, :, nstepread ) w0inletbc (:, :) = storew0inletbc (:, :, nstepread ) uminletbc (:, :) = storeu0inletbc (:, :, nstepread ) vminletbc (:, :) = storev0inletbc (:, :, nstepread ) wminletbc (:, :) = storew0inletbc (:, :, nstepread ) if ( ltempeq ) then t0inletbc (:, :) = storet0inletbc (:, :, nstepread ) tminletbc (:, :) = storet0inletbc (:, :, nstepread ) end if ! determine bulk velocity call slabsum ( uaverage , kb , ke , u0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ie , jb , je , kb , ke ) uaverage = uaverage / (( ie - ib + 1 ) * ( jge - jgb + 1 )) ! this gives the i-j-averaged velocity (only correct for equidistant grid?) do k = kb , ke uaverage ( k ) = uaverage ( k ) * dzf ( k ) end do ubulk = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! volume-averaged u-velocity write ( 6 , * ) 'Modstartup: ubulk=' , ubulk elseif ( idriver == 2 ) then ! idriver call readdriverfile call drivergen !call slabsum(uaverage,kb,ke,u0,ib-1,ie+1,jb-1,je+1,kb-1,ke+1,ib,ie,jb,je,kb,ke) !uaverage = uaverage / ((ie-ib+1)*(jge-jgb+1))  ! this gives the i-j-averaged velocity (only correct for equidistant grid?) call avexy_ibm ( uaverage ( kb : ke ), u0 ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIu ( ib : ie , jb : je , kb : ke ), IIus ( kb : ke ),. false .) do k = kb , ke uaverage ( k ) = uaverage ( k ) * dzf ( k ) end do ubulk = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) !volume-averaged u-velocity if ( myid == 0 ) then write ( 6 , * ) 'Modstartup: ubulk=' , ubulk end if end if ! iinletgen/idriver if ( lper2inout ) then ! if the restart starts from a periodic simulation to in/outflow, lper2inout should be set to .true. if ( myid == 0 ) then write ( 6 , * ) 'per2inout=.true. -> reading inlet profile from prof.inp.XXX and scalar.inp.XXX' open ( ifinput , file = 'prof.inp.' // cexpnr ) !  read the inlet profile from prof.inp read ( ifinput , '(a80)' ) chmess write ( * , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do k = kb , ke read ( ifinput , * ) & height ( k ), & thlprof ( k ), & qtprof ( k ), & uprof ( k ), & vprof ( k ), & e12prof ( k ) end do svprof = 0. if ( nsv > 0 ) then open ( ifinput , file = 'scalar.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do k = kb , ke read ( ifinput , * ) & height ( k ), & ( svprof ( k , n ), n = 1 , nsv ) end do open ( ifinput , file = 'scalar.inp.' // cexpnr ) write ( 6 , * ) 'height   sv(1) --------- sv(nsv) ' do k = ke , kb , - 1 write ( 6 , * ) & height ( k ), & ( svprof ( k , n ), n = 1 , nsv ) end do end if end if ! end if myid==0 ! MPI broadcast numbers reading call MPI_BCAST ( thlprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( uprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( vprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( e12prof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( qtprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( svprof , ( ke + kh - ( kb - kh )) * nsv , MY_REAL , 0 , comm3d , mpierr ) else if ( linoutflow ) then ! restart of inoutflow simulation: reproduce inlet boundary condition from restartfile do j = jb - 1 , je + 1 do k = kb , ke + 1 uprof ( k ) = u0 ( ib , j , k ) vprof ( k ) = ( v0 ( ib - 1 , j , k ) + v0 ( ib , j , k )) / 2 thlprof ( k ) = ( thl0 ( ib - 1 , j , k ) + thl0 ( ib , j , k )) / 2 qtprof ( k ) = ( qt0 ( ib - 1 , j , k ) + qt0 ( ib , j , k )) / 2 e12prof ( k ) = ( e120 ( ib - 1 , j , k ) + e120 ( ib , j , k )) / 2 do n = 1 , nsv svprof ( k , n ) = ( sv0 ( ib - 1 , j , k , n ) + sv0 ( ib , j , k , n )) / 2 enddo enddo enddo ! outlet bulk velocity call slabsum ( uaverage , kb , ke , u0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ie , jb , je , kb , ke ) uaverage = uaverage / (( ie - ib + 1 ) * ( jge - jgb + 1 )) ! this gives the i-j-averaged velocity (only correct for equidistant grid?) ! determine bulk velocity do k = kb , ke uaverage ( k ) = uaverage ( k ) * dzf ( k ) end do ubulk = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! volume-averaged u-velocity write ( 6 , * ) 'Modstartup: ubulk=' , ubulk else ! else per2per... read svprof regardless... ! tg3315 read svprof (but do not use regardless of above...) svprof = 0. if ( myid == 0 ) then if ( nsv > 0 ) then open ( ifinput , file = 'scalar.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do k = kb , ke read ( ifinput , * ) & height ( k ), & ( svprof ( k , n ), n = 1 , nsv ) end do open ( ifinput , file = 'scalar.inp.' // cexpnr ) write ( 6 , * ) 'height   sv(1) --------- sv(nsv) ' do k = ke , kb , - 1 write ( 6 , * ) & height ( k ), & ( svprof ( k , n ), n = 1 , nsv ) end do end if end if ! end if myid==0 call MPI_BCAST ( svprof , ( ke + kh - ( kb - kh )) * nsv , MY_REAL , 0 , comm3d , mpierr ) if ( nsv > 0 ) then !tg3315 set these variables here for now and repeat for warmstart allocate ( sv_top ( 1 : nsv )) sv_top (:) = svprof ( ke , 1 : nsv ) call MPI_BCAST ( sv_top , nsv , MY_REAL , 0 , comm3d , mpierr ) end if end if ! end if lper2inout u0av = 0.0 v0av = 0.0 thl0av = 0.0 qt0av = 0.0 th0av = 0.0 sv0av = 0. ! call slabsum(u0av  ,kb,ke+kh,u0(:,:,kb:ke+kh)  ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( u0av ( kb : ke + kh ), u0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIu ( ib : ie , jb : je , kb : ke + kh ), IIus ( kb : ke + kh ),. false .) ! call slabsum(v0av  ,kb,ke+kh,v0(:,:,kb:ke+kh)  ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( v0av ( kb : ke + kh ), v0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIv ( ib : ie , jb : je , kb : ke + kh ), IIvs ( kb : ke + kh ),. false .) ! call slabsum(thl0av,kb,ke+kh,thl0(:,:,kb:ke+kh),ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( thl0av ( kb : ke + kh ), thl0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) ! call slabsum(qt0av,kb,ke+kh,qt0(:,:,kb:ke+kh),ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( qt0av ( kb : ke + kh ), qt0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) do n = 1 , nsv ! call slabsum(sv0av(kb,n),kb,ke+kh,sv0(ib-ih,jb-jh,kb,n),ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( sv0av ( kb : ke + khc , n ), sv0 ( ib : ie , jb : je , kb : ke + khc , n ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + khc ), IIcs ( kb : ke + khc ),. false .) end do ! CvH - only do this for fixed timestepping. In adaptive dt comes from restartfile if (. not . ladaptive ) dt = dtmax !  call boundary end if ! lwarmstart end if ! not lstratstart !----------------------------------------------------------------- !    2.1 read and initialise fields !----------------------------------------------------------------- if ( myid == 0 ) then open ( ifinput , file = 'lscale.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess write ( 6 , * ) ' height  u_geo  v_geo  pgx  pgy  subs     ' & , '   dqtdx      dqtdy        dqtdtls     thl_rad ' do k = kb , ke read ( ifinput , * ) & height ( k ), & ug ( k ), & vg ( k ), & pgx ( k ), & pgy ( k ), & wfls ( k ), & dqtdxls ( k ), & dqtdyls ( k ), & dqtdtls ( k ), & thlpcar ( k ) end do close ( ifinput ) do k = ke , kb , - 1 write ( 6 , '(3f7.1,5e12.4)' ) & height ( k ), & ug ( k ), & vg ( k ), & pgx ( k ), & pgy ( k ), & wfls ( k ), & dqtdxls ( k ), & dqtdyls ( k ), & dqtdtls ( k ), & thlpcar ( k ) end do end if ! end myid==0 ! MPI broadcast variables read in call MPI_BCAST ( ug , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( vg , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( pgx , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( pgy , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wfls , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dqtdxls , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dqtdyls , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dqtdtls , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( thlpcar , kmax , MY_REAL , 0 , comm3d , mpierr ) !----------------------------------------------------------------- !    2.3 make large-scale horizontal pressure gradient !----------------------------------------------------------------- !******include rho if rho = rho(z) /= 1.0 *********** if ( lprofforc ) then !tg3315 do k = kb , ke dpdxl ( k ) = - pgx ( k ) - dpdx !-om23_gs*ug(k)-pgx(k)-dpdx dpdyl ( k ) = - pgy ( k ) end do else do k = kb , ke !dpdxl(k) =  om23_gs*vg(k) !dpdyl(k) = -om23_gs*ug(k) !dpdxl(k) =  -ug(k) !dpdyl(k) =  -vg(k) dpdxl ( k ) = om23_gs * vg ( k ) - pgx ( k ) - dpdx !corriolis forcing and pressure gradient dpdyl ( k ) = - om23_gs * ug ( k ) - pgy ( k ) end do endif !----------------------------------------------------------------- !    2.4 large-scale subsidence, reintroduced ILS13 05.06.2014 !----------------------------------------------------------------- whls ( kb ) = 0.0 do k = kb + 1 , ke whls ( k ) = ( wfls ( k ) * dzf ( k - 1 ) + wfls ( k - 1 ) * dzf ( k )) / ( 2 * dzh ( k )) end do whls ( ke + 1 ) = ( wfls ( ke ) + dzf ( ke ) * ( wfls ( ke ) - wfls ( ke - 1 )) / dzh ( ke )) ! tg3315 31/07/18 removed a 0.5 !    idtmax = floor(dtmax/tres) btime = timee !    timeleft=ceiling(runtime/tres) timeleft = runtime dt_lim = timeleft !    write(6,*) 'real(dt)*tres= ',rdt, ' dtmax/100= ',dtmax/100 if (( lwarmstart ) . or . ( lstratstart )) then ! tg3315 to have cumulative number on restart files read ( startfile ( 6 : 13 ), '(i4)' ) ntrun ! ntrun = ichar(startfile(6:13)) else ntrun = 0 end if ntimee = nint ( timee / dtmax ) tnextrestart = btime + trestart tnextfielddump = btime + tfielddump deallocate ( height , th0av ) !    call boundary end subroutine readinitfiles subroutine readrestartfiles use modsurfdata , only : ustar , thlflux , qtflux , svflux , dudz , dvdz , dthldz , dqtdz , ps , thls , qts , thvs , oblav , & wtsurf use modfields , only : u0 , v0 , w0 , thl0 , qt0 , ql0 , ql0h , qtav , qlav , e120 , dthvdz , presf , presh , sv0 , mindist , wall , & uav , vav , wav , uuav , vvav , wwav , uvav , uwav , vwav , svav , thlav , thl2av , sv2av , pres0 , svm , & svprof , viscratioav , thluav , thlvav , thlwav , svuav , svvav , svwav , presav , & uusgsav , vvsgsav , wwsgsav , uwsgsav , thlusgsav , thlwsgsav , svusgsav , svwsgsav , tkesgsav , & strain2av , nusgsav use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , dtheta , dqt , dsv , startfile , timee , totavtime , runavtime , & iexpnr , ntimee , rk3step , ifinput , nsv , runtime , dt , cexpnr , lreadmean , lreadminl , & totinletav , lreadscal , ltempeq , dzf , numol , prandtlmoli use modmpi , only : cmyid , myid use modsubgriddata , only : ekm use modinlet , only : zinterpolate1d , zinterpolatet1d , zinterpolatew1d , zinterpolate2d use modinletdata , only : Uinl , Urec , Wrec , Utav , Tinl , Trec , linuf , linuh , & kbin , kein , lzinzsim , utaui , Ttav , ttaui real , dimension ( ib : ie , jb : je , kb : ke ) :: dummy3d real , dimension ( ib : ie , kbin : kein ) :: Utavin real , dimension ( ib : ie , kbin : kein ) :: Ttavin real , dimension ( kbin : kein ) :: Uinlin real , dimension ( kbin : kein ) :: Urecin real , dimension ( kbin : kein ) :: Tinlin real , dimension ( kbin : kein ) :: Trecin real , dimension ( kbin : kein + 1 ) :: Wrecin character ( 50 ) :: name , name2 , name4 real dummy integer i , j , k , n !******************************************************************** !    1.0 Read initfiles !----------------------------------------------------------------- name = startfile name ( 5 : 5 ) = 'd' name ( 15 : 17 ) = cmyid write ( 6 , * ) 'loading ' , name open ( unit = ifinput , file = name , form = 'unformatted' , status = 'old' ) read ( ifinput ) ((( mindist ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke ) read ( ifinput ) (((( wall ( i , j , k , n ), i = ib , ie ), j = jb , je ), k = kb , ke ), n = 1 , 5 ) read ( ifinput ) ((( u0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( v0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( w0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( pres0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( thl0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( e120 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( ekm ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( qt0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( ql0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( ql0h ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) timee , dt close ( ifinput ) write ( 6 , * ) 'finished loading ' , name if (( nsv > 0 ) . and . ( lreadscal )) then name ( 5 : 5 ) = 's' write ( 6 , * ) 'loading ' , name open ( unit = ifinput , file = name , form = 'unformatted' ) read ( ifinput ) (((( sv0 ( i , j , k , n ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ), n = 1 , nsv ) read ( ifinput ) timee close ( ifinput ) write ( 6 , * ) 'finished loading ' , name elseif (( nsv > 0 ) . and . (. not . lreadscal )) then sv0 = 0. svprof = 0. end if ! read mean variables if asked for by lreadmean name2 = 'means   .' name2 ( 6 : 8 ) = cmyid name2 ( 10 : 12 ) = cexpnr if ( lreadmean ) then write ( 6 , * ) 'Reading meansXXX.XXX, proc = ' , myid open ( unit = ifinput , file = name2 , form = 'unformatted' ) read ( ifinput ) totavtime , nsv read ( ifinput ) ((( uav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( vav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( wav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( thlav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( qtav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( qlav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( presav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) (((( svav ( i , j , k , n ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ), n = 1 , nsv ) read ( ifinput ) ((( viscratioav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( uuav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( vvav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( wwav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( thl2av ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) (((( sv2av ( i , j , k , n ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ), n = 1 , nsv ) read ( ifinput ) ((( uvav ( i , j , k ), i = ib , ie + ih ), j = jb , je + jh ), k = kb , ke ) read ( ifinput ) ((( uwav ( i , j , k ), i = ib , ie + ih ), j = jb , je ), k = kb , ke + kh ) read ( ifinput ) ((( vwav ( i , j , k ), i = ib , ie ), j = jb , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( thluav ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke ) read ( ifinput ) ((( thlvav ( i , j , k ), i = ib , ie ), j = jb , je + jh ), k = kb , ke ) read ( ifinput ) ((( thlwav ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke + kh ) read ( ifinput ) (((( svuav ( i , j , k , n ), i = ib , ie ), j = jb , je ), k = kb , ke ), n = 1 , nsv ) read ( ifinput ) (((( svvav ( i , j , k , n ), i = ib , ie ), j = jb , je + jh ), k = kb , ke ), n = 1 , nsv ) read ( ifinput ) (((( svwav ( i , j , k , n ), i = ib , ie ), j = jb , je ), k = kb , ke + kh ), n = 1 , nsv ) close ( ifinput ) write ( 6 , * ) 'Total averaging time so far: ' , totavtime ! read <x'y'>_SGS to file. name2 = 'SGS__   .' name2 ( 6 : 8 ) = cmyid name2 ( 10 : 12 ) = cexpnr open ( unit = ifinput , file = name2 , form = 'unformatted' ) read ( ifinput ) dummy , dummy read ( ifinput ) ((( uusgsav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( vvsgsav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( wwsgsav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( uwsgsav ( i , j , k ), i = ib , ie + ih ), j = jb , je ), k = kb , ke + kh ) read ( ifinput ) ((( dummy3d ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke ) ! this is dissresav, which will be computed using other mean quantities read ( ifinput ) ((( tkesgsav ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke ) read ( ifinput ) ((( dummy3d ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke ) ! this is disssgsav, which will be computed using other mean quantities read ( ifinput ) ((( strain2av ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke ) ! <SijSij> (NOT <Sij><Sij> !!) (average over time) read ( ifinput ) ((( nusgsav ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke ) ! <nu_sgs> (average over time) read ( ifinput ) ((( thlusgsav ( i , j , k ), i = ib , ie + ih ), j = jb , je ), k = kb , ke ) read ( ifinput ) ((( thlwsgsav ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke + kh ) read ( ifinput ) (((( svusgsav ( i , j , k , n ), i = ib , ie + ih ), j = jb , je ), k = kb , ke ), n = 1 , nsv ) read ( ifinput ) (((( svwsgsav ( i , j , k , n ), i = ib , ie ), j = jb , je ), k = kb , ke + kh ), n = 1 , nsv ) close ( ifinput ) end if ! read mean profiles for inlet generator if ( lreadminl ) then if (. not . lzinzsim ) then name4 = 'meaninlet.   ' name4 ( 11 : 13 ) = cexpnr open ( unit = ifinput , file = name4 , form = 'unformatted' ) read ( ifinput ) totinletav ! interval of time-average read ( ifinput ) ( Uinlin ( k ), k = kbin , kein ) read ( ifinput ) ( Urecin ( k ), k = kbin , kein ) read ( ifinput ) ( Wrecin ( k ), k = kbin , kein + 1 ) read ( ifinput ) (( Utavin ( i , k ), i = ib , ie ), k = kbin , kein ) close ( ifinput ) call zinterpolate1d ( Uinlin , Uinl ) ! interpolate inlet profile to zgrid call zinterpolate1d ( Urecin , Urec ) call zinterpolatew1d ( Wrecin , Wrec ) call zinterpolate2d ( Utavin , Utav ) if ( ltempeq ) then name4 = 'tempinlet.   ' name4 ( 11 : 13 ) = cexpnr open ( unit = ifinput , file = name4 , form = 'unformatted' ) read ( ifinput ) totinletav ! interval of time-average read ( ifinput ) ( Tinlin ( k ), k = kbin , kein ) read ( ifinput ) ( Trecin ( k ), k = kbin , kein ) read ( ifinput ) (( Ttavin ( i , k ), i = ib , ie ), k = kbin , kein ) close ( ifinput ) call zinterpolatet1d ( Tinlin , Tinl ) call zinterpolatet1d ( Trecin , Trec ) call zinterpolate2d ( Ttavin , Ttav ) end if ! ltempeq else !lzinzsim=.true. -> inlet grid equals sim grid name4 = 'meaninlet.   ' name4 ( 11 : 13 ) = cexpnr open ( unit = ifinput , file = name4 , form = 'unformatted' ) read ( ifinput ) totinletav ! interval of time-average read ( ifinput ) ( Uinl ( k ), k = kb , ke ) read ( ifinput ) ( Urec ( k ), k = kb , ke ) read ( ifinput ) ( Wrec ( k ), k = kb , ke + 1 ) read ( ifinput ) (( Utav ( i , k ), i = ib , ie ), k = kb , ke ) close ( ifinput ) if ( ltempeq ) then name4 = 'tempinlet.   ' name4 ( 11 : 13 ) = cexpnr open ( unit = ifinput , file = name4 , form = 'unformatted' ) read ( ifinput ) totinletav ! interval of time-average read ( ifinput ) ( Tinl ( k ), k = kb , ke ) read ( ifinput ) ( Trec ( k ), k = kb , ke ) read ( ifinput ) (( Ttav ( i , k ), i = ib , ie ), k = kb , ke ) close ( ifinput ) end if ! ltempeq end if ! lzinzsim utaui = sqrt ( abs ( 2 * numol * Uinl ( kb ) / dzf ( kb ))) ! average streamwise friction at inlet (need for first time step) if ( ltempeq ) then ttaui = numol * prandtlmoli * 2. * ( Tinl ( kb ) - thls ) / ( dzf ( kb ) * utaui ) end if end if !(lreadminl) end subroutine readrestartfiles subroutine exitmodules use modfields , only : exitfields use modglobal , only : exitglobal use modmpi , only : exitmpi use modpois , only : exitpois use modsubgrid , only : exitsubgrid use modthermodynamics , only : exitthermodynamics use modinlet , only : exitinlet call exitthermodynamics call exitsubgrid call exitpois call exitfields call exitglobal call exitinlet call exitmpi end subroutine exitmodules subroutine randomnize ( field , klev , ampl , ir , ihl , jhl ) use modmpi , only : myid , nprocs use modglobal , only : ib , ie , imax , jmax , jb , je , kb , ke , kh integer ( KIND = selected_int_kind ( 6 )) :: imm , ia , ic , ir integer ihl , jhl integer i , j , klev integer m , mfac real ran , ampl real field ( ib - ihl : ie + ihl , jb - jhl : je + jhl , kb - kh : ke + kh ) parameter ( imm = 134456 , ia = 8121 , ic = 28411 ) if ( myid > 0 ) then mfac = myid * jmax * imax do m = 1 , mfac ir = mod (( ir ) * ia + ic , imm ) end do end if do j = jb , je do i = ib , ie ir = mod (( ir ) * ia + ic , imm ) ran = real ( ir ) / real ( imm ) field ( i , j , klev ) = field ( i , j , klev ) + ( ran - 0.5 ) * 2.0 * ampl end do end do if ( nprocs - 1 - myid > 0 ) then mfac = ( nprocs - 1 - myid ) * imax * jmax do m = 1 , mfac ir = mod (( ir ) * ia + ic , imm ) end do end if return end subroutine randomnize subroutine createmasks use modglobal , only : ib , ie , ih , ihc , jb , je , jh , jhc , kb , ke , kh , khc , rslabs , jmax , nblocks ,& ifinput , cexpnr , libm , jtot , block use modfields , only : IIc , IIu , IIv , IIw , IIuw , IIvw , IIuv , IIct , IIwt , IIut , IIuwt , IIvt ,& IIcs , IIus , IIuws , IIvws , IIuvs , IIvs , IIws , & um , u0 , vm , v0 , wm , w0 use modmpi , only : myid , comm3d , mpierr , MPI_INTEGER , MPI_DOUBLE_PRECISION , MY_REAL , nprocs , & cmyid , MPI_REAL8 , MPI_REAL4 , MPI_SUM , excjs ! use initfac, only:block integer k , n , il , iu , jl , ju , kl , ku integer :: IIcl ( kb : ke + khc ), IIul ( kb : ke + khc ), IIvl ( kb : ke + khc ), IIwl ( kb : ke + khc ), IIuwl ( kb : ke + khc ), IIvwl ( kb : ke + khc ), IIuvl ( kb : ke + khc ) integer :: IIcd ( ib : ie , kb : ke ) integer :: IIwd ( ib : ie , kb : ke ) integer :: IIuwd ( ib : ie , kb : ke ) integer :: IIud ( ib : ie , kb : ke ) integer :: IIvd ( ib : ie , kb : ke ) character ( 80 ) chmess , name2 ! II*l needn't be defined up to ke_khc, but for now would require large scale changes in modstatsdump so if works leave as is ! tg3315 04/07/18 if (. not . libm ) then IIc (:, :, :) = 1 IIu (:, :, :) = 1 IIv (:, :, :) = 1 IIw (:, :, :) = 1 IIuw (:, :, :) = 1 IIvw (:, :, :) = 1 IIuv (:, :, :) = 1 IIcs (:) = nint ( rslabs ) IIus (:) = nint ( rslabs ) IIvs (:) = nint ( rslabs ) IIws (:) = nint ( rslabs ) IIuws (:) = nint ( rslabs ) IIvws (:) = nint ( rslabs ) IIuvs (:) = nint ( rslabs ) IIct (:, :) = jtot IIut (:, :) = jtot IIvt (:, :) = jtot IIwt (:, :) = jtot IIuwt (:, :) = jtot return end if allocate ( block ( 1 : nblocks , 1 : 11 )) if ( myid == 0 ) then if ( nblocks > 0 ) then open ( ifinput , file = 'blocks.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do n = 1 , nblocks read ( ifinput , * ) & block ( n , 1 ), & block ( n , 2 ), & block ( n , 3 ), & block ( n , 4 ), & block ( n , 5 ), & block ( n , 6 ), & block ( n , 7 ), & block ( n , 8 ), & block ( n , 9 ), & block ( n , 10 ), & block ( n , 11 ) end do close ( ifinput ) do n = 1 , nblocks write ( 6 , * ) & n , & block ( n , 1 ), & block ( n , 2 ), & block ( n , 3 ), & block ( n , 4 ), & block ( n , 5 ), & block ( n , 6 ) end do end if !nblocks>0 end if !myid call MPI_BCAST ( block , 11 * nblocks , MPI_INTEGER , 0 , comm3d , mpierr ) ! Create masking matrices IIc = 1 ; IIu = 1 ; IIv = 1 ; IIct = 1 ; IIw = 1 ; IIuw = 1 ; IIvw = 1 ; IIuv = 1 ; IIwt = 1 ; IIut = 1 ; IIvt = 1 ; IIuwt = 1 ; IIcs = 1 ; IIus = 1 ; IIvs = 1 ; IIws = 1 ; IIuws = 1 ; IIvws = 1 ; IIuvs = 1 do n = 1 , nblocks il = block ( n , 1 ) iu = block ( n , 2 ) !kl = block(n, 5) kl = kb ! tg3315 changed as buildings for lEB must start at kb+1 not kb with no block below ku = block ( n , 6 ) jl = block ( n , 3 ) - myid * jmax ju = block ( n , 4 ) - myid * jmax if ( ju < jb - 1 . or . jl > je ) then cycle else if ( ju >= je ) then !tg3315 04/07/18 to avoid ju+1 when is last cell... if ( jl < jb ) jl = jb ju = je ! Masking matrices !tg3315 IIc ( il : iu , jl : ju , kl : ku ) = 0 IIu ( il : iu + 1 , jl : ju , kl : ku ) = 0 IIv ( il : iu , jl : ju , kl : ku ) = 0 IIw ( il : iu , jl : ju , kl : ku + 1 ) = 0 IIuw ( il : iu + 1 , jl : ju , kl : ku + 1 ) = 0 IIvw ( il : iu , jl : ju , kl : ku + 1 ) = 0 IIuv ( il : iu + 1 , jl : ju , kl : ku ) = 0 else if ( ju == jb - 1 ) then ! if end of block is in cell before proc IIv ( il : iu , jb , kl : ku ) = 0 IIvw ( il : iu , jb , kl : ku + 1 ) = 0 IIuv ( il : iu + 1 , jb , kl : ku ) = 0 else ! ju is in this proc... if ( jl < jb ) jl = jb ! Masking matrices !tg3315 IIc ( il : iu , jl : ju , kl : ku ) = 0 IIu ( il : iu + 1 , jl : ju , kl : ku ) = 0 IIv ( il : iu , jl : ju + 1 , kl : ku ) = 0 IIw ( il : iu , jl : ju , kl : ku + 1 ) = 0 IIuw ( il : iu + 1 , jl : ju , kl : ku + 1 ) = 0 IIvw ( il : iu , jl : ju + 1 , kl : ku + 1 ) = 0 IIuv ( il : iu + 1 , jl : ju + 1 , kl : ku ) = 0 end if ! ensure that ghost cells know where blocks are !tg3315 this is not necessary ! if (jl<jb+jh)  IIc(il:iu,je+jh,kl:ku) = 0 ! if (jl<jb+jhc) IIc(il:iu,je+jhc,kl:ku) = 0 ! if (ju>je-jh)  IIc(il:iu,jb-jh,kl:ku) = 0 ! if (ju>je-jhc) IIc(il:iu,jb-jhc,kl:ku) = 0 ! if (il<ib+ih)  IIc(ie+ih,jl:ju,kl:ku) = 0 ! if (il<ib+ihc) IIc(ie+ihc,jl:ju,kl:ku) = 0 ! if (iu>ie-ih)  IIc(ib-ih,jl:ju,kl:ku) = 0 ! if (iu>ie-ihc) IIc(ib-ihc,jl:ju,kl:ku) = 0 end if end do IIw (:, :, kb ) = 0 ; IIuw (:, :, kb ) = 0 ; IIvw (:, :, kb ) = 0 ! for correct ghost cells from adjacent processors !tg3315 ?unsure if this is correct ! tg3315 22/11/17 does not work because II is an integer and needs real numbers... !tg3315 not necessary !call excjs( IIc  , ib,ie,jb,je,kb,ke+khc,ihc,jhc) !call excjs( IIu  , ib,ie,jb,je,kb,ke+khc,ihc,jhc) !call excjs( IIv  , ib,ie,jb,je,kb,ke+khc,ihc,jhc) !call excjs( IIw  , ib,ie,jb,je,kb,ke+khc,ihc,jhc) do k = kb , ke + khc IIcl ( k ) = sum ( IIc ( ib : ie , jb : je , k )) IIul ( k ) = sum ( IIu ( ib : ie , jb : je , k )) IIvl ( k ) = sum ( IIv ( ib : ie , jb : je , k )) IIwl ( k ) = sum ( IIw ( ib : ie , jb : je , k )) IIuwl ( k ) = sum ( IIuw ( ib : ie , jb : je , k )) IIvwl ( k ) = sum ( IIvw ( ib : ie , jb : je , k )) IIuvl ( k ) = sum ( IIuv ( ib : ie , jb : je , k )) enddo call MPI_ALLREDUCE ( IIcl , IIcs , ke + khc - kb + 1 , MPI_INTEGER , & MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIul , IIus , ke + khc - kb + 1 , MPI_INTEGER , & MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIvl , IIvs , ke + khc - kb + 1 , MPI_INTEGER , & MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIwl , IIws , ke + khc - kb + 1 , MPI_INTEGER , & MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIuwl , IIuws , ke + khc - kb + 1 , MPI_INTEGER , & MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIvwl , IIvws , ke + khc - kb + 1 , MPI_INTEGER , & MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIuvl , IIuvs , ke + khc - kb + 1 , MPI_INTEGER , & MPI_SUM , comm3d , mpierr ) IIcd ( ib : ie , kb : ke ) = sum ( IIc ( ib : ie , jb : je , kb : ke ), DIM = 2 ) IIwd ( ib : ie , kb : ke ) = sum ( IIw ( ib : ie , jb : je , kb : ke ), DIM = 2 ) IIuwd ( ib : ie , kb : ke ) = sum ( IIuw ( ib : ie , jb : je , kb : ke ), DIM = 2 ) IIud ( ib : ie , kb : ke ) = sum ( IIu ( ib : ie , jb : je , kb : ke ), DIM = 2 ) IIvd ( ib : ie , kb : ke ) = sum ( IIv ( ib : ie , jb : je , kb : ke ), DIM = 2 ) call MPI_ALLREDUCE ( IIwd ( ib : ie , kb : ke ), IIwt ( ib : ie , kb : ke ), ( ke - kb + 1 ) * ( ie - ib + 1 ), MPI_INTEGER , MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIcd ( ib : ie , kb : ke ), IIct ( ib : ie , kb : ke ), ( ke - kb + 1 ) * ( ie - ib + 1 ), MPI_INTEGER , MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIuwd ( ib : ie , kb : ke ), IIuwt ( ib : ie , kb : ke ), ( ke - kb + 1 ) * ( ie - ib + 1 ), MPI_INTEGER , MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIud ( ib : ie , kb : ke ), IIut ( ib : ie , kb : ke ), ( ke - kb + 1 ) * ( ie - ib + 1 ), MPI_INTEGER , MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIvd ( ib : ie , kb : ke ), IIvt ( ib : ie , kb : ke ), ( ke - kb + 1 ) * ( ie - ib + 1 ), MPI_INTEGER , MPI_SUM , comm3d , mpierr ) ! masking matrix for switch if entire slab is blocks !if (IIcs(kb) == 0) then !  IIbl = 0 !else !  IIbl = 1 !end if !where (IIcs == 0) !IIcs = nint(rslabs) !endwhere !where (IIus == 0) !IIus = nint(rslabs) !endwhere !where (IIvs == 0) !IIvs = nint(rslabs) !endwhere !where (IIws == 0) !IIws = nint(rslabs) !endwhere !where (IIuws == 0) !IIuws = nint(rslabs) !endwhere !where (IIvws == 0) !IIvws = nint(rslabs) !endwhere ! use masking matrices to set 0 in blocks from start? tg3315 13/12/17 ! um(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) = IIu(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh)*um(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) ! vm(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) = IIv(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh)*vm(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) ! wm(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) = IIw(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh)*wm(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) ! u0 = um ! v0 = vm ! w0 = wm end subroutine createmasks end module modstartup","tags":"","loc":"sourcefile/modstartup.f90.html"},{"title":"modstatistics.f90 – uDALES","text":"This file depends on sourcefile~~modstatistics.f90~~EfferentGraph sourcefile~modstatistics.f90 modstatistics.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~modstatistics.f90->sourcefile~modsubgriddata.f90 sourcefile~modstat_nc.f90 modstat_nc.f90 sourcefile~modstatistics.f90->sourcefile~modstat_nc.f90 sourcefile~modsurfdata.f90 modsurfdata.f90 sourcefile~modstatistics.f90->sourcefile~modsurfdata.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modstatistics.f90->sourcefile~modfields.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modstatistics.f90->sourcefile~modglobal.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modstatistics.f90->sourcefile~modmpi.f90 sourcefile~modstat_nc.f90->sourcefile~modglobal.f90 sourcefile~modstat_nc.f90->sourcefile~modmpi.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~modstatistics.f90~~AfferentGraph sourcefile~modstatistics.f90 modstatistics.f90 sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~modstatsdump.f90->sourcefile~modstatistics.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules modstatistics Source Code modstatistics.f90 Source Code !> \\file modstatistics.f90 !!  Calculates field statistics to be written in modstatsdump.f90 !> !!  \\author Tom Grylls, ICL Dec 16 2016 ! !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! module modstatistics use modglobal , only : dt , ltkedump use modmpi , only : myid implicit none private PUBLIC :: genstats , tkestats save !NetCDF variables integer :: klow , khigh , i , j , k !  real    :: tsamplep,tstatsdumpp,tsample,tstatsdump contains !------------------------- !> Calculate general stats !------------------------- subroutine genstats ( tsamplep , tstatsdumpp , umint , vmint , wmint ) use modfields , only : um , up , vm , wm , thlm , uav , vav , wav , uuav , vvav , wwav , uvav , vwav , uwav , thlav , thlwav , thlthlav , & upupav , vpvpav , wpwpav , upvpav , upwpav , vpwpav , thlpwpav use modglobal , only : ib , ie , ih , jb , je , dy , jh , ke , kb , kh , rk3step , timee , cexpnr , tsample , tstatsdump ,& ltempeq , dxf , dzf , dzhi use modmpi , only : myid , cmyid , my_real , mpi_sum , mpierr , comm3d implicit none real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) :: umint real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) :: vmint real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) :: wmint real :: tstatsdumppi , tsamplep , tstatsdumpp integer :: km tstatsdumppi = 1. / tstatsdumpp !  if (lydump) then if (. not . rk3step == 3 ) return !      if (tsamplep > tsample) then !> Interpolate velocity fields to cell centers !        do k=kb-kh,ke !          do j=jb-jh,je+jh !            do i=ib-ih,ie+ih !              umint(i,j,k) = 0.5*(um(i,j,k)+um(i+1,j,k)) !              vmint(i,j,k) = 0.5*(vm(i,j,k)+vm(i,j+1,k)) !              wmint(i,j,k) = 0.5*(wm(i,j,k)+wm(i,j,k+1)) !            enddo !          enddo !        enddo do k = kb , ke do j = jb , je do i = ib , ie uav ( i , j , k ) = ( uav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + umint ( i , j , k ) * tsamplep ) * tstatsdumppi vav ( i , j , k ) = ( vav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + vmint ( i , j , k ) * tsamplep ) * tstatsdumppi wav ( i , j , k ) = ( wav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + wmint ( i , j , k ) * tsamplep ) * tstatsdumppi uuav ( i , j , k ) = ( uuav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + ( umint ( i , j , k ) ** 2 ) * tsamplep ) * tstatsdumppi vvav ( i , j , k ) = ( vvav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + ( vmint ( i , j , k ) ** 2 ) * tsamplep ) * tstatsdumppi wwav ( i , j , k ) = ( wwav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + ( wmint ( i , j , k ) ** 2 ) * tsamplep ) * tstatsdumppi uvav ( i , j , k ) = ( uvav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + umint ( i , j , k ) * vmint ( i , j , k ) * tsamplep ) * tstatsdumppi vwav ( i , j , k ) = ( vwav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + vmint ( i , j , k ) * wmint ( i , j , k ) * tsamplep ) * tstatsdumppi uwav ( i , j , k ) = ( uwav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + umint ( i , j , k ) * wmint ( i , j , k ) * tsamplep ) * tstatsdumppi if ( ltempeq ) then thlav ( i , j , k ) = ( thlav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + thlm ( i , j , k ) * tsamplep ) * tstatsdumppi thlwav ( i , j , k ) = ( thlwav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + thlm ( i , j , k ) * wmint ( i , j , k ) * tsamplep ) * tstatsdumppi thlthlav ( i , j , k ) = ( thlthlav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + ( thlm ( i , j , k ) ** 2 ) * tsamplep ) * tstatsdumppi end if end do end do end do upupav = uuav - uav ** 2 ! overline(u'u') = overline(uu) - U&#94;2 vpvpav = vvav - vav ** 2 ! overline(v'v') = overline(vv) - V&#94;2 wpwpav = wwav - wav ** 2 ! overline(w'w') = overline(ww) - W&#94;2 upvpav = uvav - uav * vav ! overline(u'v') = overline(uv) - U*V upwpav = uwav - uav * wav ! overline(u'w') = overline(uw) - U*W vpwpav = vwav - vav * wav ! overline(v'w') = overline(vw) - V*W ! thlw and svw: ib:ie jb:je kb:ke+1  (located on w-faces) !tg3315 BUT thlwav is on cell centre... do k = kb , ke + 1 km = k - 1 do j = jb , je do i = ib , ie thlpwpav ( i , j , k ) = thlwav ( i , j , k ) - & 0.5 * wav ( i , j , k ) * & ! no interpolation ( thlav ( i , j , km ) * dzf ( k ) + thlav ( i , j , k ) * dzf ( km )) * dzhi ( k ) ! interpolate thl to w-faces !              qlpwpav(i,j,k) = thlwav(i,j,k) - & !                                0.5 * wav(i,j,k) * & ! no interpolation !                               (qlav(i,j,km)*dzf(k) + qlav(i,j,k)*dzf(km))*dzhi(k) ! interpolate thl to w-faces !              qtpwpav(i,j,k) = qtwav(i,j,k) - & !                                0.5 * wav(i,j,k) * & ! no interpolation !                                (qtav(i,j,km)*dzf(k) + qtav(i,j,k)*dzf(km))*dzhi(k) ! interpolate thl to w-faces ! !              do n=1,nsv !                svpwpav(i,j,k,n) = svwav(i,j,k,n) - & !                                   0.5 * wav(i,j,k) * & ! no interpolation !                                   (svav(i,j,km,n)*dzf(k) + svav(i,j,k,n)*dzf(km))*dzhi(k) ! interpolate svav to w-faces !              end do end do end do end do !> generate time averaged stats for TKE budget and call subroutine final field values if ( ltkedump ) then call tkestats ( tsamplep , tstatsdumpp ) end if !        tsample = dt !     else !timestatsdumpp < tsample !       tsamplep = tsamplep + dt !      end if !    end if !  end if end subroutine genstats !------------------------- !> Calculate TKE budget terms !------------------------- subroutine tkestats ( tsamplep , tstatsdumpp ) ! change of variable names not yet translated across to here ! tg3315 30/11/17 use modfields , only : u0 , v0 , w0 , thlm , uyt , vyt , wyt , thlyt , pres0 ,& tvmx , tvmy , tvmz , strain2av , tsgsmx1 , tsgsmx2 , tsgsmy1 , tsgsmy2 ,& tsgsmz1 , tsgsmz2 , pres0 use modglobal , only : ib , ie , ih , jb , je , jgb , jge , dy , jh , ke , kb , kh , rk3step , cexpnr , tsample , tstatsdump , dzf , zh , dxf , dzf , numol ,& dzfi , dxfi , dyi , dy2i , dxfiq , dxhiq , dyiq , dzfi5 , dzh , dzf , dzhi , dzhiq , dxf , dxhi use modstat_nc , only : writestat_nc use modsurfdata , only : thls use modsubgriddata , only : ekm implicit none real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) :: tekm ! turbulent viscosity !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: emom !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: eomm !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: eopm !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: epom !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: emmo !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: eomp !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: epmo !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: emop !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: empo !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: tkesgs !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: nusgs !  real :: dummy integer i , j , k , im , ip , jm , jp , km , kp real tstatsdumppi , tsamplep , tstatsdumpp , strain2 , tkesgs , nusgs ,& emom , eomm , eopm , epom , emmo , eomp , epmo , emop , empo , dummy tekm (:,:,:) = ekm (:,:,:) - numol tstatsdumppi = 1. / tstatsdumpp !--------------------------------------- ! Viscous transport TKE !--------------------------------------- !> Time averaged viscous transport in x,y and z to be used to calculate the total viscous transport for TKE ! Tvmx at u-locations (ib:ih+ih:jb:je,kb:ke) ! This is similar to routine diffu time u_i do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie ip = i + 1 im = i - 1 dummy = u0 ( i , j , k ) * ( & ( numol * ( u0 ( i + 1 , j , k ) - u0 ( i , j , k )) * dxfi ( i ) & - numol * ( u0 ( i , j , k ) - u0 ( i - 1 , j , k )) * dxfi ( i - 1 ) ) * 2. * dxhi ( i ) & + & ( numol * ( ( u0 ( i , jp , k ) - u0 ( i , j , k )) * dyi & + ( v0 ( i , jp , k ) - v0 ( i - 1 , jp , k )) * dxhi ( i )) & - numol * ( ( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi & + ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dxhi ( i )) & ) * dyi & + & ( numol * ( ( u0 ( i , j , kp ) - u0 ( i , j , k )) * dzhi ( kp ) & + ( w0 ( i , j , kp ) - w0 ( i - 1 , j , kp )) * dxhi ( i )) & - numol * ( ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) & + ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dxhi ( i )) & ) * dzfi ( k ) ) tvmx ( i , j , k ) = ( tvmx ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * tsamplep ) * tstatsdumppi ! update average tvmx ! Tvmv at v-locations (ib:ih:jb:je+1,kb:ke) ! This is similar to routine diffv time v dummy = v0 ( i , j , k ) * ( & ( numol * ( ( v0 ( i + 1 , j , k ) - v0 ( i , j , k )) * dxhi ( i + 1 ) & + ( u0 ( i + 1 , j , k ) - u0 ( i + 1 , jm , k )) * dyi ) & - numol * ( ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dxhi ( i ) & + ( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi ) & ) * dxfi ( i ) & ! = d/dx( Km*(dv/dx + du/dy) ) + & ( numol * ( v0 ( i , jp , k ) - v0 ( i , j , k )) & - numol * ( v0 ( i , j , k ) - v0 ( i , jm , k )) ) * 2. * dy2i & ! = d/dy( 2*Km*(dv/dy) ) + & ( numol * ( ( v0 ( i , j , kp ) - v0 ( i , j , k )) * dzhi ( kp ) & + ( w0 ( i , j , kp ) - w0 ( i , jm , kp )) * dyi ) & - numol * ( ( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) & + ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi ) & ) * dzfi ( k ) ) ! = d/dz( Km*(dv/dz + dw/dy) ) tvmy ( i , j , k ) = ( tvmy ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * tsamplep ) * tstatsdumppi ! update average tvmy ! Tvmz at w-locations (ib:ih:jb:je,kb:ke+kh) ! This is similar to routine diffw time w dummy = w0 ( i , j , k ) * ( & ( numol * ( ( w0 ( i + 1 , j , k ) - w0 ( i , j , k )) * dxhi ( i + 1 ) & + ( u0 ( i + 1 , j , k ) - u0 ( i + 1 , j , km )) * dzhi ( k ) ) & - numol * ( ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dxhi ( i ) & + ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) ) & ) * dxfi ( i ) & + & ( numol * ( ( w0 ( i , jp , k ) - w0 ( i , j , k )) * dyi & + ( v0 ( i , jp , k ) - v0 ( i , jp , km )) * dzhi ( k ) ) & - numol * ( ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi & + ( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) ) & ) * dyi & + & ( numol * ( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) & - numol * ( w0 ( i , j , k ) - w0 ( i , j , km )) * dzfi ( km ) ) * 2. & * dzhi ( k ) ) tvmz ( i , j , k ) = ( tvmz ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * tsamplep ) * tstatsdumppi ! update average uwsgsav ! Compute stresses and fluxes at c.c. , also used in total viscous transport strain2 = ( & (( u0 ( ip , j , k ) - u0 ( i , j , k )) * dxfi ( i ) ) ** 2 + & (( v0 ( i , jp , k ) - v0 ( i , j , k )) * dyi ) ** 2 + & (( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) ) ** 2 ) strain2 = strain2 + 0.125 * ( & (( w0 ( i , j , kp ) - w0 ( im , j , kp )) * dxhi ( i ) + & ( u0 ( i , j , kp ) - u0 ( i , j , k )) * dzhi ( kp ) ) ** 2 + & (( w0 ( i , j , k ) - w0 ( im , j , k )) * dxhi ( i ) + & ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) ) ** 2 + & (( w0 ( ip , j , k ) - w0 ( i , j , k )) * dxhi ( ip ) + & ( u0 ( ip , j , k ) - u0 ( ip , j , km )) * dzhi ( k ) ) ** 2 + & (( w0 ( ip , j , kp ) - w0 ( i , j , kp )) * dxhi ( ip ) + & ( u0 ( ip , j , kp ) - u0 ( ip , j , k )) * dzhi ( kp ) ) ** 2 ) strain2 = strain2 + 0.125 * ( & (( u0 ( i , jp , k ) - u0 ( i , j , k )) * dyi + & ( v0 ( i , jp , k ) - v0 ( im , jp , k )) * dxhi ( i ) ) ** 2 + & (( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi + & ( v0 ( i , j , k ) - v0 ( im , j , k )) * dxhi ( i ) ) ** 2 + & (( u0 ( ip , j , k ) - u0 ( ip , jm , k )) * dyi + & ( v0 ( ip , j , k ) - v0 ( i , j , k )) * dxhi ( ip ) ) ** 2 + & (( u0 ( ip , jp , k ) - u0 ( ip , j , k )) * dyi + & ( v0 ( ip , jp , k ) - v0 ( i , jp , k )) * dxhi ( ip ) ) ** 2 ) strain2 = strain2 + 0.125 * ( & (( v0 ( i , j , kp ) - v0 ( i , j , k )) * dzhi ( kp ) + & ( w0 ( i , j , kp ) - w0 ( i , jm , kp )) * dyi ) ** 2 + & (( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) + & ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi ) ** 2 + & (( v0 ( i , jp , k ) - v0 ( i , jp , km )) * dzhi ( k ) + & ( w0 ( i , jp , k ) - w0 ( i , j , k )) * dyi ) ** 2 + & (( v0 ( i , jp , kp ) - v0 ( i , jp , k )) * dzhi ( kp ) + & ( w0 ( i , jp , kp ) - w0 ( i , j , kp )) * dyi ) ** 2 ) strain2av ( i , j , k ) = ( strain2av ( i , j , k ) * ( tstatsdumpp - tsamplep ) + strain2 * tsamplep ) * tstatsdumppi ! update average strain2av !-------------------------------------------------- !> SGS TKE !-------------------------------------------------- ! x-direction emom = ( dzf ( km ) * ( tekm ( i , j , k ) * dxf ( i - 1 ) + tekm ( i - 1 , j , k ) * dxf ( i ) ) + & ! dx is non-equidistant dzf ( k ) * ( tekm ( i , j , km ) * dxf ( i - 1 ) + tekm ( i - 1 , j , km ) * dxf ( i ) ) ) * dxhi ( i ) * dzhiq ( k ) emop = ( dzf ( kp ) * ( tekm ( i , j , k ) * dxf ( i - 1 ) + tekm ( i - 1 , j , k ) * dxf ( i ) ) + & ! dx is non-equidistant dzf ( k ) * ( tekm ( i , j , kp ) * dxf ( i - 1 ) + tekm ( i - 1 , j , kp ) * dxf ( i ) ) ) * dxhi ( i ) * dzhiq ( kp ) empo = 0.25 * ( ( tekm ( i , j , k ) + tekm ( i , jp , k )) * dxf ( i - 1 ) + ( tekm ( i - 1 , j , k ) + tekm ( i - 1 , jp , k )) * dxf ( i ) ) * dxhi ( i ) ! dx is non-equidistant emmo = 0.25 * ( ( tekm ( i , j , k ) + tekm ( i , jm , k )) * dxf ( i - 1 ) + ( tekm ( i - 1 , jm , k ) + tekm ( i - 1 , j , k )) * dxf ( i ) ) * dxhi ( i ) ! dx is non-equidistant !        dummy =  u0(i,j,k)*(                           & dummy = ( & ( tekm ( i , j , k ) * ( u0 ( i + 1 , j , k ) - u0 ( i , j , k )) * dxfi ( i ) & - tekm ( i - 1 , j , k ) * ( u0 ( i , j , k ) - u0 ( i - 1 , j , k )) * dxfi ( i - 1 ) ) * 2. * dxhi ( i ) & + & ( empo * ( ( u0 ( i , jp , k ) - u0 ( i , j , k )) * dyi & + ( v0 ( i , jp , k ) - v0 ( i - 1 , jp , k )) * dxhi ( i )) & - emmo * ( ( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi & + ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dxhi ( i )) & ) * dyi & + & ( emop * ( ( u0 ( i , j , kp ) - u0 ( i , j , k )) * dzhi ( kp ) & + ( w0 ( i , j , kp ) - w0 ( i - 1 , j , kp )) * dxhi ( i )) & - emom * ( ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) & + ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dxhi ( i )) & ) * dzfi ( k ) ) tsgsmx1 ( i , j , k ) = ( tsgsmx1 ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * u0 ( i , j , k ) * tsamplep ) * tstatsdumppi ! update average tsgsmx1 tsgsmx2 ( i , j , k ) = ( tsgsmx2 ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * tsamplep ) * tstatsdumppi ! update average tsgsmx2 ! y-direction eomm = ( dzf ( km ) * ( tekm ( i , j , k ) + tekm ( i , jm , k ) ) + & dzf ( k ) * ( tekm ( i , j , km ) + tekm ( i , jm , km ) ) ) * dzhiq ( k ) eomp = ( dzf ( kp ) * ( tekm ( i , j , k ) + tekm ( i , jm , k ) ) + & dzf ( k ) * ( tekm ( i , j , kp ) + tekm ( i , jm , kp ) ) ) * dzhiq ( kp ) emmo = 0.25 * ( ( tekm ( i , j , k ) + tekm ( i , jm , k )) * dxf ( i - 1 ) + ( tekm ( i - 1 , jm , k ) + tekm ( i - 1 , j , k )) * dxf ( i ) ) * dxhi ( i ) ! dx is non-equidistant epmo = 0.25 * ( ( tekm ( i , j , k ) + tekm ( i , jm , k )) * dxf ( i + 1 ) + ( tekm ( i + 1 , jm , k ) + tekm ( i + 1 , j , k )) * dxf ( i ) ) * dxhi ( i + 1 ) ! dx is non-equidistant !       dummy = v0(i,j,k) * (                            & dummy = ( & ( epmo * ( ( v0 ( i + 1 , j , k ) - v0 ( i , j , k )) * dxhi ( i + 1 ) & + ( u0 ( i + 1 , j , k ) - u0 ( i + 1 , jm , k )) * dyi ) & - emmo * ( ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dxhi ( i ) & + ( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi ) & ) * dxfi ( i ) & ! = d/dx( Km*(dv/dx + du/dy) ) + & ( tekm ( i , j , k ) * ( v0 ( i , jp , k ) - v0 ( i , j , k )) & - tekm ( i , jm , k ) * ( v0 ( i , j , k ) - v0 ( i , jm , k )) ) * 2. * dy2i & ! = d/dy( 2*Km*(dv/dy) ) + & ( eomp * ( ( v0 ( i , j , kp ) - v0 ( i , j , k )) * dzhi ( kp ) & + ( w0 ( i , j , kp ) - w0 ( i , jm , kp )) * dyi ) & - eomm * ( ( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) & + ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi ) & ) * dzfi ( k ) ) ! = d/dz( Km*(dv/dz + dw/dy) ) tsgsmy1 ( i , j , k ) = ( tsgsmy1 ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * v0 ( i , j , k ) * tsamplep ) * tstatsdumppi ! update average tsgsmy1  = <v*d/dxj(2*nu*S2j)> tsgsmy2 ( i , j , k ) = ( tsgsmy2 ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * tsamplep ) * tstatsdumppi ! update average tsgsmy2  = <d/dxj(2*nu*S2j)> ! z-direction emom = ( dzf ( km ) * ( tekm ( i , j , k ) * dxf ( i - 1 ) + tekm ( i - 1 , j , k ) * dxf ( i ) ) * dxhi ( i ) + & dzf ( k ) * ( tekm ( i , j , km ) * dxf ( i - 1 ) + tekm ( i - 1 , j , km ) * dxf ( i ) ) * dxhi ( i ) ) * dzhiq ( k ) eomm = ( dzf ( km ) * ( tekm ( i , j , k ) + tekm ( i , jm , k ) ) + & dzf ( k ) * ( tekm ( i , j , km ) + tekm ( i , jm , km ) ) ) * dzhiq ( k ) eopm = ( dzf ( km ) * ( tekm ( i , j , k ) + tekm ( i , jp , k ) ) + & dzf ( k ) * ( tekm ( i , j , km ) + tekm ( i , jp , km ) ) ) * dzhiq ( k ) epom = ( dzf ( km ) * ( tekm ( i , j , k ) * dxf ( i + 1 ) + tekm ( i + 1 , j , k ) * dxf ( i ) ) * dxhi ( i + 1 ) + & dzf ( k ) * ( tekm ( i , j , km ) * dxf ( i + 1 ) + tekm ( i + 1 , j , km ) * dxf ( i ) ) * dxhi ( i + 1 ) ) * dzhiq ( k ) !        dummy = w0(i,j,k) * (                                         & dummy = ( & ( epom * ( ( w0 ( i + 1 , j , k ) - w0 ( i , j , k )) * dxhi ( i + 1 ) & + ( u0 ( i + 1 , j , k ) - u0 ( i + 1 , j , km )) * dzhi ( k ) ) & - emom * ( ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dxhi ( i ) & + ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) ) & ) * dxfi ( i ) & + & ( eopm * ( ( w0 ( i , jp , k ) - w0 ( i , j , k )) * dyi & + ( v0 ( i , jp , k ) - v0 ( i , jp , km )) * dzhi ( k ) ) & - eomm * ( ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi & + ( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) ) & ) * dyi & + & ( tekm ( i , j , k ) * ( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) & - tekm ( i , j , km ) * ( w0 ( i , j , k ) - w0 ( i , j , km )) * dzfi ( km ) ) * 2. & * dzhi ( k )) tsgsmz1 ( i , j , k ) = ( tsgsmz1 ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * w0 ( i , j , k ) * tsamplep ) * tstatsdumppi ! update average tsgsmz1 = <w*d/dxj(2*nu*S3j)> tsgsmz2 ( i , j , k ) = ( tsgsmz2 ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * tsamplep ) * tstatsdumppi ! update average tsgsmz2 = <d/dxj(2*nu*S3j)> end do end do end do end subroutine tkestats end module modstatistics","tags":"","loc":"sourcefile/modstatistics.f90.html"},{"title":"advec_upw.f90 – uDALES","text":"This file depends on sourcefile~~advec_upw.f90~~EfferentGraph sourcefile~advec_upw.f90 advec_upw.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~advec_upw.f90->sourcefile~modglobal.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~advec_upw.f90->sourcefile~modfields.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines advecc_upw Source Code advec_upw.f90 Source Code !> \\file advec_upw.f90 !!  Does advection with a 1st order upwind scheme. !! \\par Revision list !! \\par Authors !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! !> Advection at cell center subroutine advecc_upw ( hi , hj , hk , putin , putout ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , dyi , dxfci , dzfci use modfields , only : u0 , v0 , w0 implicit none integer , intent ( in ) :: hi !< size of halo in i integer , intent ( in ) :: hj !< size of halo in j integer , intent ( in ) :: hk !< size of halo in k real , dimension ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ), intent ( in ) :: putin !< Input: the cell centered field real , dimension ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ), intent ( inout ) :: putout !< Output: the tendency real , allocatable , dimension (:, :, :) :: put integer :: i , j , k allocate ( put ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk )) do k = kb , ke do j = jb , je do i = ib , ie + 1 if ( u0 ( i , j , k ) > 0 ) then put ( i , j , k ) = putin ( i - 1 , j , k ) else put ( i , j , k ) = putin ( i , j , k ) endif enddo enddo enddo do k = kb , ke do j = jb , je do i = ib , ie putout ( i , j , k ) = putout ( i , j , k ) - & ( u0 ( i + 1 , j , k ) * put ( i + 1 , j , k ) - u0 ( i , j , k ) * put ( i , j , k )) * dxfci ( i ) enddo enddo enddo do k = kb , ke do j = jb , je + 1 do i = ib , ie if ( v0 ( i , j , k ) > 0 ) then put ( i , j , k ) = putin ( i , j - 1 , k ) else put ( i , j , k ) = putin ( i , j , k ) endif enddo enddo enddo do k = kb , ke do j = jb , je do i = ib , ie putout ( i , j , k ) = putout ( i , j , k ) - & ( v0 ( i , j + 1 , k ) * put ( i , j + 1 , k ) - v0 ( i , j , k ) * put ( i , j , k )) * dyi enddo enddo enddo do k = kb , ke + 1 do j = jb , je do i = ib , ie if ( w0 ( i , j , k ) > 0 ) then put ( i , j , k ) = putin ( i , j , k - 1 ) else put ( i , j , k ) = putin ( i , j , k ) endif enddo enddo enddo do k = kb , ke do j = jb , je do i = ib , ie putout ( i , j , k ) = putout ( i , j , k ) - & ( w0 ( i , j , k + 1 ) * put ( i , j , k + 1 ) - w0 ( i , j , k ) * put ( i , j , k )) * dzfci ( k ) enddo enddo enddo deallocate ( put ) end subroutine advecc_upw","tags":"","loc":"sourcefile/advec_upw.f90.html"},{"title":"modibmdata.f90 – uDALES","text":"Files dependent on this one sourcefile~~modibmdata.f90~~AfferentGraph sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~modibm.f90 modibm.f90 sourcefile~modibm.f90->sourcefile~modibmdata.f90 sourcefile~wf_gr.f90 wf_gr.f90 sourcefile~wf_gr.f90->sourcefile~modibmdata.f90 sourcefile~wf_uno.f90 wf_uno.f90 sourcefile~wf_uno.f90->sourcefile~modibmdata.f90 sourcefile~wfmneutral.f90 wfmneutral.f90 sourcefile~wfmneutral.f90->sourcefile~modibmdata.f90 sourcefile~advec_kappa.f90 advec_kappa.f90 sourcefile~advec_kappa.f90->sourcefile~modibmdata.f90 sourcefile~advec_2nd.f90 advec_2nd.f90 sourcefile~advec_2nd.f90->sourcefile~modibmdata.f90 sourcefile~advec_2nd.f90->sourcefile~modibm.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~modsave.f90->sourcefile~modibmdata.f90 sourcefile~modforces.f90 modforces.f90 sourcefile~modforces.f90->sourcefile~modibmdata.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~modstartup.f90->sourcefile~modibmdata.f90 sourcefile~modstartup.f90->sourcefile~modforces.f90 sourcefile~moddriver.f90 moddriver.f90 sourcefile~modstartup.f90->sourcefile~moddriver.f90 sourcefile~modinlet.f90 modinlet.f90 sourcefile~modstartup.f90->sourcefile~modinlet.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~modstartup.f90->sourcefile~modboundary.f90 sourcefile~modpois.f90 modpois.f90 sourcefile~modstartup.f90->sourcefile~modpois.f90 sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~modstartup.f90->sourcefile~modsubgrid.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~modinlet.f90->sourcefile~modsave.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modibm.f90 sourcefile~program.f90->sourcefile~modsave.f90 sourcefile~program.f90->sourcefile~modforces.f90 sourcefile~program.f90->sourcefile~modstartup.f90 sourcefile~program.f90->sourcefile~modboundary.f90 sourcefile~program.f90->sourcefile~modpois.f90 sourcefile~program.f90->sourcefile~modsubgrid.f90 sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~modboundary.f90->sourcefile~modinlet.f90 sourcefile~modpois.f90->sourcefile~modboundary.f90 sourcefile~modsubgrid.f90->sourcefile~modboundary.f90 sourcefile~modstatsdump.f90->sourcefile~modsubgrid.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules modibmdata Source Code modibmdata.f90 Source Code !! !!  \\author Jasper Tomas,TU Delft, 31 March 2014 !!  \\par Revision list !!  \\todo Documentation module modibmdata implicit none save integer , allocatable :: xwallsglobal (:,:) integer , allocatable :: ywallsglobal (:,:) integer , allocatable :: zwallsglobal (:,:) !    integer, allocatable :: block(:,:) integer , allocatable :: xwallsshear (:,:) integer , allocatable :: ywallsp (:,:) integer , allocatable :: ywallsm (:,:) integer , allocatable :: zwallsshear (:,:) integer , allocatable :: xwallsnorm (:,:) integer , allocatable :: ywallsnorm (:,:) integer , allocatable :: zwallsnorm (:,:) integer :: nxwall !number of local xwalls integer , allocatable :: ixwall (:) !index of block that is on local processor, used to determine local xwalls, ils13, 16.02.2017 integer :: nywall !number of local xwalls integer , allocatable :: iyminwall (:,:) !index of block that is on local processor, used to determine local xwalls, ils13, 16.02.2017 integer :: nyminwall !number of local xwalls integer , allocatable :: iywall (:) !index of block that is on local processor, used to determine local xwalls, ils13, 16.02.2017 integer :: nypluswall !number of local xwalls integer , allocatable :: iypluswall (:,:) !index of block that is on local processor, used to determine local xwalls, ils13, 16.02.2017 real , allocatable :: ibmxforce (:,:) ! spanwise- and time-averaged force by ibm method. real , allocatable :: ibmxforcevol (:,:) ! spanwise- and time-averaged force by ibm method (complete volume) real , allocatable :: ibmxforcevolp (:,:) ! spanwise- and time-averaged force by ibm method (complete volume minus dp/dx) ! real :: sumctm = 0. real :: bcTfluxA = 0. real :: bcqfluxA = 0. !fluxes for temperature and humidity at immersed boundaries real :: bctfxm = 0. real :: bctfxp = 0. real :: bctfym = 0. real :: bctfyp = 0. real :: bctfz = 0. real :: bcqfxm = 0. real :: bcqfxp = 0. real :: bcqfym = 0. real :: bcqfyp = 0. real :: bcqfz = 0. integer :: nxwallsnorm integer :: nywallsnorm integer :: nzwallsnorm integer :: nxwallsshear integer :: nywallsp integer :: nywallsm integer :: nzwallsshear integer :: offset = 1 !why do we need offset in modglobal? just use same value here to get some indeces right, ils13 20/03/2017 end module","tags":"","loc":"sourcefile/modibmdata.f90.html"},{"title":"wfmneutral.f90 – uDALES","text":"This file depends on sourcefile~~wfmneutral.f90~~EfferentGraph sourcefile~wfmneutral.f90 wfmneutral.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~wfmneutral.f90->sourcefile~modsubgriddata.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~wfmneutral.f90->sourcefile~modmpi.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~wfmneutral.f90->sourcefile~initfac.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~wfmneutral.f90->sourcefile~modglobal.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~wfmneutral.f90->sourcefile~modibmdata.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines wfmneutral Source Code wfmneutral.f90 Source Code SUBROUTINE wfmneutral ( hi , hj , hk , iout1 , iout2 , iomomflux , utang1 , utang2 , z0 , n , ind , wforient ) !wfmneutral !wf for momentum under neutral conditions !calculating wall function for momentum assuming neutral conditions !follow approach in wfuno !fluxes in m2/s2 USE modglobal , ONLY : dzf , dzfi , dzh2i , dzhi , dzhiq , dy , dyi , dy2i , dyi5 , dxf , dxh , dxfi , dxhi , dxh2i , ib , ie , jb , je , kb , ke , fkar , jmax , rk3step , kmax , jge , jgb USE modsubgriddata , ONLY : ekh , ekm USE modmpi , ONLY : myid USE initfac , ONLY : block USE modibmdata INTEGER i , j , k , jl , ju , kl , ku , il , iu , km , im , jm , ip , jp , kp REAL :: bcmomflux = 0. !temp storage for momentum flux REAL :: ctm = 0. !momentum transfer coefficient REAL :: dummy = 0. !for debugging REAL :: delta = 0. !distance from wall REAL :: logdz2 = 0. !log(delta/z0)**2 REAL :: utang1Int !Interpolated 1st tangential velocity component needed for stability calculation (to T location) REAL :: utang2Int !Interpolated 2nd tangential velocity component needed for stability calculation (to T location) REAL :: fkar2 = fkar ** 2 !fkar&#94;2, von Karman constant squared REAL :: emmo = 0. , epmo = 0. , epom = 0. , emom = 0. , eopm = 0. , eomm = 0. , empo = 0. INTEGER , INTENT ( in ) :: hi !<size of halo in i INTEGER , INTENT ( in ) :: hj !<size of halo in j INTEGER , INTENT ( in ) :: hk !<size of halo in k REAL , INTENT ( inout ) :: iout1 ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) !updated prognostic tangential velocity (component1) REAL , INTENT ( inout ) :: iout2 ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) !updated prognostic tangential velocity (component2) REAL , INTENT ( inout ) :: iomomflux ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !a field to save the momentum flux REAL , INTENT ( in ) :: z0 REAL , INTENT ( in ) :: utang1 ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !tangential velocity field REAL , INTENT ( in ) :: utang2 ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !second tangential velocity field INTEGER , INTENT ( in ) :: n ! number of the block, used to get i,j,k-indeces INTEGER , INTENT ( in ) :: ind ! in case of y-wall (case 3x & 4x) \"ind\" is used for j-index, otherwise this is irrelevant INTEGER , INTENT ( in ) :: wforient !orientation of the facet see below: !frist digit, orientation of wall, determines iteration indices !second digit, if for momentum or for scalar (necessary because of staggered grid -> which variable to interpolate) !xlow=1,xup=2,yup=3,ylow=4,z=5 !momentum=1 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CASES!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CASES FOR MOMENTUM!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SELECT CASE ( wforient ) CASE ( 11 ) !wfmneutral11, case 11 , west wall i = block ( n , 1 ) - 1 !fluid location (also where wall variables are stored) ip = i + 1 !inside wall, used for subtracting original diffusion term jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) + 1 ! starting j-index      !might cause problem when jl=1 ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) ! ending j-index     !might cause problem when ju=jmax kl = block ( n , 5 ) ! starting k-index ku = block ( n , 6 ) ! ending k-index delta = dxf ( i ) * 0.5 logdz2 = LOG ( delta / z0 ) ** 2 !v west DO k = kl , ku DO j = jl , ju utang1Int = utang1 ( i , j , k ) ctm = fkar2 / ( logdz2 ) dummy = ( utang1Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) epmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) * dxf ( ip ) + & ( ekm ( ip , j , k ) + ekm ( ip , j - 1 , k )) * dxf ( i )) * dxhi ( ip ) iout1 ( i , j , k ) = iout1 ( i , j , k ) - ( utang1 ( ip , j , k ) - utang1 ( i , j , k )) * epmo * dxhi ( ip ) * dxfi ( i ) - bcmomflux * dxfi ( i ) ! END DO END DO !v west edge south j = MAX ( block ( n , 3 ) - myid * jmax , 1 ) DO k = kl , ku utang1Int = utang1 ( i , j , k ) dummy = ( utang1Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) * 0.5 !only half since on edge of block (another half might come from another processor?) !   epmo = 0.5 * (ekm(ip,j,k)*dxf(i) + ekm(i,j,k)*dxf(ip)) * dxhi(ip) epmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) * dxf ( ip ) + & ( ekm ( ip , j , k ) + ekm ( ip , j - 1 , k )) * dxf ( i )) * dxhi ( ip ) iout1 ( i , j , k ) = iout1 ( i , j , k ) - (( utang1 ( ip , j , k ) - utang1 ( i , j , k )) * epmo * dxhi ( ip ) * dxfi ( i ) - bcmomflux * dxfi ( i )) * 0.5 ! remove standard diffusion apply only half of wall-flux since it's an edge !only half of the flux, since only half of the control-volume around v is touching this facet (other half is either in free air or touching another facet) END DO !v west edge north j = MIN ( block ( n , 4 ) - myid * jmax , jmax ) + 1 DO k = kl , ku utang1Int = utang1 ( i , j , k ) dummy = ( utang1Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) * 0.5 epmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) * dxf ( ip ) + & ( ekm ( ip , j , k ) + ekm ( ip , j - 1 , k )) * dxf ( i )) * dxhi ( ip ) iout1 ( i , j , k ) = iout1 ( i , j , k ) - (( utang1 ( ip , j , k ) - utang1 ( i , j , k )) * epmo * dxhi ( ip ) * dxfi ( i ) - bcmomflux * dxfi ( i )) * 0.5 ! %remove standard diffusion apply only half of wall-flux since it's an edge END DO !w west jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ! kl = block ( n , 5 ) + 1 ! DO k = kl , ku DO j = jl , ju utang2Int = utang2 ( i , j , k ) ctm = fkar2 / ( logdz2 ) dummy = ( utang2Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) epom = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) * dxf ( ip ) + ekm ( ip , j , k ) * dxf ( i )) * dxhi ( ip ) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) * dxf ( ip ) + ekm ( ip , j , k - 1 ) * dxf ( i )) * dxhi ( ip )) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) - ( utang2 ( ip , j , k ) - utang2 ( i , j , k )) * epom * dxhi ( ip ) * dxfi ( i ) - bcmomflux * dxfi ( i ) ! END DO END DO !w west top edge k = block ( n , 6 ) + 1 ! ending k-index km = k - 1 DO j = jl , ju utang2Int = utang2 ( i , j , k ) dummy = ( utang2Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) * 0.5 epom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( ip ) + ekm ( ip , j , k ) * dxf ( i )) * dxhi ( ip ) + & dzf ( k ) * ( ekm ( i , j , km ) * dxf ( ip ) + ekm ( ip , j , km ) * dxf ( i )) * dxhi ( ip )) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) - (( utang2 ( ip , j , k ) - utang2 ( i , j , k )) * epom * dxhi ( ip ) * dxfi ( i ) - bcmomflux * dxfi ( i )) * 0.5 ! END DO !w west bottom edge k = block ( n , 6 ) ! ending k-index if ( k . gt . 0 ) then km = k - 1 DO j = jl , ju utang2Int = utang2 ( i , j , k ) dummy = ( utang2Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) * 0.5 epom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( ip ) + ekm ( ip , j , k ) * dxf ( i )) * dxhi ( ip ) + & dzf ( k ) * ( ekm ( i , j , km ) * dxf ( ip ) + ekm ( ip , j , km ) * dxf ( i )) * dxhi ( ip )) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) - (( utang2 ( ip , j , k ) - utang2 ( i , j , k )) * epom * dxhi ( ip ) * dxfi ( i ) - bcmomflux * dxfi ( i )) * 0.5 ! END DO end if !!! case 21 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !wfmneutral 21 !wall in yz -> wf in x (=vertical), upper wall, east wall CASE ( 21 ) !v east i = block ( n , 2 ) + 1 !fluid im = i - 1 !inside block jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) + 1 ! starting j-index      !might cause problem when jl=1 ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) ! ending j-index     !might cause problem when ju=jmax kl = block ( n , 5 ) ! starting k-index ku = block ( n , 6 ) ! ending k-index delta = dxh ( i ) * 0.5 logdz2 = LOG ( delta / z0 ) ** 2 DO k = kl , ku DO j = jl , ju utang1Int = utang1 ( i , j , k ) ctm = fkar2 / ( logdz2 ) dummy = ( utang1Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) emmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) * dxf ( im ) + ( ekm ( im , j - 1 , k ) + ekm ( im , j , k )) * dxf ( i )) * dxhi ( i ) ! dx is non-equidistant iout1 ( i , j , k ) = iout1 ( i , j , k ) + ( utang1 ( i , j , k ) - utang1 ( im , j , k )) * emmo * dxhi ( i ) * dxfi ( i ) - bcmomflux * dxfi ( i ) ! END DO END DO !v east edge south j = MAX ( block ( n , 3 ) - myid * jmax , 1 ) DO k = kl , ku utang1Int = utang1 ( i , j , k ) dummy = ( utang1Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) * 0.5 emmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) * dxf ( im ) + ( ekm ( im , j - 1 , k ) + ekm ( im , j , k )) * dxf ( i )) * dxhi ( i ) ! dx is non-equidistant iout1 ( i , j , k ) = iout1 ( i , j , k ) + (( utang1 ( i , j , k ) - utang1 ( im , j , k )) * emmo * dxhi ( i ) * dxfi ( i ) - bcmomflux * dxfi ( i )) * 0.5 ! END DO !v east edge north j = MIN ( block ( n , 4 ) - myid * jmax , jmax ) + 1 ! DO k = kl , ku utang1Int = utang1 ( i , j , k ) dummy = ( utang1Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) * 0.5 emmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) * dxf ( im ) + ( ekm ( im , j - 1 , k ) + ekm ( im , j , k )) * dxf ( i )) * dxhi ( i ) ! dx is non-equidistant iout1 ( i , j , k ) = iout1 ( i , j , k ) + (( utang1 ( i , j , k ) - utang1 ( im , j , k )) * emmo * dxhi ( i ) * dxfi ( i ) - bcmomflux * dxfi ( i )) * 0.5 ! END DO !w east jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ! kl = block ( n , 5 ) + 1 ! DO k = kl , ku DO j = jl , ju utang2Int = utang2 ( i , j , k ) ctm = fkar2 / ( logdz2 ) dummy = ( utang2Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) emom = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) * dxf ( im ) + ekm ( im , j , k ) * dxf ( i )) * dxhi ( i ) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) * dxf ( im ) + ekm ( im , j , k - 1 ) * dxf ( i )) * dxhi ( i )) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) + ( utang2 ( i , j , k ) - utang2 ( im , j , k )) * emom * dxhi ( i ) * dxfi ( i ) - bcmomflux * dxfi ( i ) ! END DO END DO !w east edge top k = block ( n , 6 ) + 1 ! ending k-index DO j = jl , ju utang2Int = utang2 ( i , j , k ) dummy = ( utang2Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) * 0.5 emom = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) * dxf ( im ) + ekm ( im , j , k ) * dxf ( i )) * dxhi ( i ) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) * dxf ( im ) + ekm ( im , j , k - 1 ) * dxf ( i )) * dxhi ( i )) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) + (( utang2 ( i , j , k ) - utang2 ( im , j , k )) * emom * dxhi ( i ) * dxfi ( i ) - bcmomflux * dxfi ( i )) * 0.5 ! END DO !w east edge bot k = block ( n , 6 ) ! if ( k . gt . 0 ) then DO j = jl , ju utang2Int = utang2 ( i , j , k ) dummy = ( utang2Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) * 0.5 emom = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) * dxf ( im ) + ekm ( im , j , k ) * dxf ( i )) * dxhi ( i ) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) * dxf ( im ) + ekm ( im , j , k - 1 ) * dxf ( i )) * dxhi ( i )) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) + (( utang2 ( i , j , k ) - utang2 ( im , j , k )) * emom * dxhi ( i ) * dxfi ( i ) - bcmomflux * dxfi ( i )) * 0.5 ! END DO end if !!! case 31 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !wfuno 31 CASE ( 31 ) !wall in xz -> wf in y (=vertical) upper, north wall j = ind jm = j - 1 il = block ( n , 1 ) + 1 iu = block ( n , 2 ) kl = block ( n , 5 ) ku = block ( n , 6 ) delta = 0.5 * dy logdz2 = LOG ( delta / z0 ) ** 2 !u north DO k = kl , ku DO i = il , iu utang1Int = utang1 ( i , j , k ) ctm = fkar2 / ( logdz2 ) dummy = ( utang1Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi emmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , jm , k )) * dxf ( i - 1 ) + ( ekm ( i - 1 , jm , k ) + ekm ( i - 1 , j , k )) * dxf ( i )) * dxhi ( i ) iout1 ( i , j , k ) = iout1 ( i , j , k ) + ( utang1 ( i , j , k ) - utang1 ( i , jm , k )) * emmo * dy2i - bcmomflux * dyi ! END DO END DO !u north east edge i = block ( n , 2 ) + 1 DO k = kl , ku utang1Int = utang1 ( i , j , k ) dummy = ( utang1Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi5 emmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , jm , k )) * dxf ( i - 1 ) + ( ekm ( i - 1 , jm , k ) + ekm ( i - 1 , j , k )) * dxf ( i )) * dxhi ( i ) iout1 ( i , j , k ) = iout1 ( i , j , k ) + (( utang1 ( i , j , k ) - utang1 ( i , jm , k )) * emmo * dy2i - bcmomflux * dyi ) * 0.5 ! END DO !u north west edge i = block ( n , 1 ) DO k = kl , ku utang1Int = utang1 ( i , j , k ) dummy = ( utang1Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi5 emmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , jm , k )) * dxf ( i - 1 ) + ( ekm ( i - 1 , jm , k ) + ekm ( i - 1 , j , k )) * dxf ( i )) * dxhi ( i ) iout1 ( i , j , k ) = iout1 ( i , j , k ) + (( utang1 ( i , j , k ) - utang1 ( i , jm , k )) * emmo * dy2i - bcmomflux * dyi ) * 0.5 ! END DO !w north il = block ( n , 1 ) ! kl = block ( n , 5 ) + 1 ! DO k = kl , ku DO i = il , iu utang2Int = utang2 ( i , j , k ) ctm = fkar2 / ( logdz2 ) dummy = ( utang2Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi eomm = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , jm , k )) + dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , jm , k - 1 ))) * dzhiq ( k ) ! dz is non-eqidistant iout2 ( i , j , k ) = iout2 ( i , j , k ) + ( utang2 ( i , j , k ) - utang2 ( i , jm , k )) * eomm * dy2i - bcmomflux * dyi ! END DO END DO !w north edge top k = block ( n , 6 ) + 1 DO i = il , iu utang2Int = utang2 ( i , j , k ) dummy = ( utang2Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi5 eomm = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , jm , k )) + dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , jm , k - 1 ))) * dzhiq ( k ) ! dz is non-eqidistant iout2 ( i , j , k ) = iout2 ( i , j , k ) + (( utang2 ( i , j , k ) - utang2 ( i , jm , k )) * eomm * dy2i - bcmomflux * dyi ) * 0.5 ! END DO !w north edge bot k = block ( n , 6 ) if ( k . gt . 0 ) then DO i = il , iu utang2Int = utang2 ( i , j , k ) dummy = ( utang2Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi5 eomm = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , jm , k )) + dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , jm , k - 1 ))) * dzhiq ( k ) ! dz is non-eqidistant iout2 ( i , j , k ) = iout2 ( i , j , k ) + (( utang2 ( i , j , k ) - utang2 ( i , jm , k )) * eomm * dy2i - bcmomflux * dyi ) * 0.5 ! END DO end if !!! case 41 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!` !wfuno41 CASE ( 41 ) !wall in xz -> wf in y (=vertical) lower, south wall j = ind jp = j + 1 il = block ( n , 1 ) + 1 iu = block ( n , 2 ) kl = block ( n , 5 ) ku = block ( n , 6 ) delta = 0.5 * dy logdz2 = LOG ( delta / z0 ) ** 2 DO k = kl , ku DO i = il , iu utang1Int = utang1 ( i , j , k ) ctm = fkar2 / ( logdz2 ) dummy = ( utang1Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi empo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , jp , k )) * dxf ( i - 1 ) + & ( ekm ( i - 1 , j , k ) + ekm ( i - 1 , jp , k )) * dxf ( i )) * dxhi ( i ) ! dx is non-equidistant iout1 ( i , j , k ) = iout1 ( i , j , k ) - ( utang1 ( i , jp , k ) - utang1 ( i , j , k )) * empo * dy2i - bcmomflux * dyi ! END DO END DO !u south edge west i = block ( n , 1 ) DO k = kl , ku utang1Int = utang1 ( i , j , k ) dummy = ( utang1Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi5 empo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , jp , k )) * dxf ( i - 1 ) + & ( ekm ( i - 1 , j , k ) + ekm ( i - 1 , jp , k )) * dxf ( i )) * dxhi ( i ) ! dx is non-equidistant iout1 ( i , j , k ) = iout1 ( i , j , k ) - (( utang1 ( i , jp , k ) - utang1 ( i , j , k )) * empo * dy2i - bcmomflux * dyi ) * 0.5 ! END DO !u south edge east i = block ( n , 2 ) + 1 DO k = kl , ku utang1Int = utang1 ( i , j , k ) dummy = ( utang1Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi5 empo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , jp , k )) * dxf ( i - 1 ) + & ( ekm ( i - 1 , j , k ) + ekm ( i - 1 , jp , k )) * dxf ( i )) * dxhi ( i ) ! dx is non-equidistant iout1 ( i , j , k ) = iout1 ( i , j , k ) - (( utang1 ( i , jp , k ) - utang1 ( i , j , k )) * empo * dy2i - bcmomflux * dyi ) * 0.5 ! END DO !w south il = block ( n , 1 ) ! kl = block ( n , 5 ) + 1 ! DO k = kl , ku DO i = il , iu utang2Int = utang2 ( i , j , k ) ctm = fkar2 / ( logdz2 ) dummy = ( utang2Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi eopm = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , jp , k )) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , jp , k - 1 ))) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) - ( utang2 ( i , jp , k ) - utang2 ( i , j , k )) * eopm * dy2i - bcmomflux * dyi ! END DO END DO !w south edge top k = block ( n , 6 ) + 1 DO i = il , iu utang2Int = utang2 ( i , j , k ) dummy = ( utang2Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi5 eopm = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , jp , k )) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , jp , k - 1 ))) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) - (( utang2 ( i , jp , k ) - utang2 ( i , j , k )) * eopm * dy2i - bcmomflux * dyi ) * 0.5 ! END DO !w south edge bot k = block ( n , 6 ) if ( k . gt . 0 ) then DO i = il , iu utang2Int = utang2 ( i , j , k ) !call function repeatedly dummy = ( utang2Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi5 eopm = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , jp , k )) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , jp , k - 1 ))) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) - (( utang2 ( i , jp , k ) - utang2 ( i , j , k )) * eopm * dy2i - bcmomflux * dyi ) * 0.5 ! END DO end if !!!! case 51 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !wfuno51 CASE ( 51 ) !wall in xy -> wf in z (=horizontal), top wall k = block ( n , 6 ) + 1 !block location if (. not .( k . gt . kmax )) then km = k - 1 !shear velocity location il = block ( n , 1 ) + 1 iu = block ( n , 2 ) jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) delta = 0.5 * dzf ( k ) logdz2 = LOG ( delta / z0 ) ** 2 DO j = jl , ju DO i = il , iu utang1Int = utang1 ( i , j , k ) ctm = fkar2 / ( logdz2 ) dummy = ( utang1Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) emom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k ) * dxf ( i )) + & dzf ( k ) * ( ekm ( i , j , km ) * dxf ( i - 1 ) + ekm ( i - 1 , j , km ) * dxf ( i ))) * dxhi ( i ) * dzhiq ( k ) iout1 ( i , j , k ) = iout1 ( i , j , k ) + ( utang1 ( i , j , k ) - utang1 ( i , j , km )) * emom * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k ) ! END DO END DO !u top edge west i = block ( n , 1 ) DO j = jl , ju utang1Int = utang1 ( i , j , k ) dummy = ( utang1Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) * 0.5 emom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k ) * dxf ( i )) + & dzf ( k ) * ( ekm ( i , j , km ) * dxf ( i - 1 ) + ekm ( i - 1 , j , km ) * dxf ( i ))) * dxhi ( i ) * dzhiq ( k ) iout1 ( i , j , k ) = iout1 ( i , j , k ) + (( utang1 ( i , j , k ) - utang1 ( i , j , km )) * emom * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k )) * 0.5 ! END DO !u top edge east DO j = jl , ju utang1Int = utang1 ( i , j , k ) dummy = ( utang1Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) * 0.5 emom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k ) * dxf ( i )) + & dzf ( k ) * ( ekm ( i , j , km ) * dxf ( i - 1 ) + ekm ( i - 1 , j , km ) * dxf ( i ))) * dxhi ( i ) * dzhiq ( k ) iout1 ( i , j , k ) = iout1 ( i , j , k ) + (( utang1 ( i , j , k ) - utang1 ( i , j , km )) * emom * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k )) * 0.5 ! END DO !v il = block ( n , 1 ) jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) + 1 DO j = jl , ju DO i = il , iu utang2Int = utang2 ( i , j , k ) ctm = fkar2 / ( logdz2 ) dummy = ( utang2Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) eomm = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) + dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i , j - 1 , km ))) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) + ( utang2 ( i , j , k ) - utang2 ( i , j , km )) * eomm * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k ) ! END DO END DO !v top edge south j = MAX ( block ( n , 3 ) - myid * jmax , 1 ) DO i = il , iu utang2Int = utang2 ( i , j , k ) dummy = ( utang2Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) * 0.5 eomm = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) + dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i , j - 1 , km ))) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) + (( utang2 ( i , j , k ) - utang2 ( i , j , km )) * eomm * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k )) * 0.5 ! END DO !v top edge north j = MIN ( block ( n , 4 ) - myid * jmax , jmax ) + 1 DO i = il , iu utang2Int = utang2 ( i , j , k ) dummy = ( utang2Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) * 0.5 eomm = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) + dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i , j - 1 , km ))) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) + (( utang2 ( i , j , k ) - utang2 ( i , j , km )) * eomm * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k )) * 0.5 ! END DO end if !!!!!!!!!!!!!!!SPECIAL CASES FOR THE SURFACE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !can actually be made redundant and just be replaced by standard horizontal case (doesn't really matter though) CASE ( 91 ) !surface momentum flux k = kb ! km = k - 1 ! il = ib iu = ie jl = jb ju = je delta = 0.5 * dzf ( k ) !might need attention on streched grids! as well as the dzfi when updating up logdz2 = LOG ( delta / z0 ) ** 2 DO j = jl , ju !u component DO i = il , iu utang1Int = utang1 ( i , j , k ) ctm = fkar2 / ( logdz2 ) dummy = ( utang1Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) emom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k ) * dxf ( i )) + & ! dx is non-equidistant dzf ( k ) * ( ekm ( i , j , km ) * dxf ( i - 1 ) + ekm ( i - 1 , j , km ) * dxf ( i ))) * dxhi ( i ) * dzhiq ( k ) iout1 ( i , j , k ) = iout1 ( i , j , k ) + ( utang1 ( i , j , k ) - utang1 ( i , j , km )) * emom * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k ) ! END DO END DO DO j = jl , ju !v component DO i = il , iu utang2Int = utang2 ( i , j , k ) ctm = fkar2 / ( logdz2 ) dummy = ( utang2Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) eomm = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) + dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i , j - 1 , km ))) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) + ( utang2 ( i , j , k ) - utang2 ( i , j , km )) * eomm * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k ) ! END DO END DO END SELECT END SUBROUTINE wfmneutral","tags":"","loc":"sourcefile/wfmneutral.f90.html"},{"title":"modforces.f90 – uDALES","text":"This file depends on sourcefile~~modforces.f90~~EfferentGraph sourcefile~modforces.f90 modforces.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~modforces.f90->sourcefile~modibmdata.f90 sourcefile~modsurfdata.f90 modsurfdata.f90 sourcefile~modforces.f90->sourcefile~modsurfdata.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modforces.f90->sourcefile~modfields.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modforces.f90->sourcefile~modglobal.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modforces.f90->sourcefile~modmpi.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~modforces.f90~~AfferentGraph sourcefile~modforces.f90 modforces.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~modstartup.f90->sourcefile~modforces.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modforces.f90 sourcefile~program.f90->sourcefile~modstartup.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules modforces Source Code modforces.f90 Source Code !> \\file modforces.f90 !!  Calculates the other forces and sources in the equations. !> !!  Calculates the other forces and sources in the equations. !> !!  This includes the large scale forcings, the coriolis and the subsidence !!  \\author Jasper Tomas, TU Delft  March 31 2014 !!  \\author Pier Siebesma, K.N.M.I. !!  \\author Stephan de Roode,TU Delft !!  \\author Chiel van Heerwaarden, Wageningen U.R. !!  \\author Thijs Heus,MPI-M !!  \\par Revision list !!  Only the routine 'forces' is used !!  \\todo Documentation !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! module modforces !Calculates additional forces and large scale tendencies implicit none save private public :: forces , coriolis , lstend , fixuinf1 , fixuinf2 , fixthetainf ,& detfreestream , detfreestrtmp , nudge ,& masscorr , uoutletarea , voutletarea , fluidvolume , calcfluidvolumes contains subroutine forces !-----------------------------------------------------------------| !                                                                 | !      Hans Cuijpers   I.M.A.U.                                   | !      Pier Siebesma   K.N.M.I.     06/01/1995                    | !                                                                 | !     purpose.                                                    | !     --------                                                    | !                                                                 | !      Calculates all other terms in the N-S equation,            | !      except for the diffusion and advection terms.              | !                                                                 | !**   interface.                                                  | !     ----------                                                  | !                                                                 | !     *forces* is called from *program*.                          | !                                                                 | !-----------------------------------------------------------------| !  use modglobal, only : i1,j1,kmax,dzh,dzf,grav use modglobal , only : ib , ie , jb , je , kb , ke , kh , dzhi , dzf , grav , lbuoyancy use modfields , only : u0 , v0 , w0 , up , vp , wp , thv0h , dpdxl , dpdyl , thlp , thlpcar , thvh use modibmdata , only : nxwallsnorm , xwallsnorm use modsurfdata , only : thvs use modmpi , only : myid implicit none real thvsi integer i , j , k , n , jm , jp , km , kp if ( lbuoyancy ) then !ILS13 replace thvsi by thvh ! thvsi = 1./thvsi !write(*,*) 'thvh',thvh do k = kb + 1 , ke do j = jb , je do i = ib , ie up ( i , j , k ) = up ( i , j , k ) - dpdxl ( k ) vp ( i , j , k ) = vp ( i , j , k ) - dpdyl ( k ) wp ( i , j , k ) = wp ( i , j , k ) + grav * ( thv0h ( i , j , k ) - thvh ( k )) / thvh ( k ) end do end do end do else do k = kb + 1 , ke do j = jb , je do i = ib , ie up ( i , j , k ) = up ( i , j , k ) - dpdxl ( k ) vp ( i , j , k ) = vp ( i , j , k ) - dpdyl ( k ) ! IS+HJ      wp(i,j,k) = wp(i,j,k) end do end do end do end if !     ---------------------------------------------- !     add radiative heating to potential temperature !     ---------------------------------------------- do k = kb , ke do j = jb , je do i = ib , ie thlp ( i , j , k ) = thlp ( i , j , k ) + thlpcar ( k ) end do end do end do !     -------------------------------------------- !     special treatment for lowest full level: k=1 !     -------------------------------------------- do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie up ( i , j , kb ) = up ( i , j , kb ) - dpdxl ( kb ) vp ( i , j , kb ) = vp ( i , j , kb ) - dpdyl ( kb ) wp ( i , j , kb ) = 0.0 end do end do !     ----------------------------------------------end i,j-loop return end subroutine forces subroutine detfreestream ( freestream ) use modglobal , only : ib , ie , jb , je , kb , ke , kh , dxf , xh , dt ,& Uinf , lvinf , dy use modfields , only : u0 , dpdxl , dgdt , dpdx , v0 use modmpi , only : myid , comm3d , mpierr , mpi_sum , my_real , nprocs implicit none real , intent ( out ) :: freestream real utop , vtop , dum integer i , j if ( lvinf ) then vtop = 0. do j = jb , je do i = ib , ie vtop = vtop + 0.5 * ( v0 ( i , j , ke ) + u0 ( i , j + 1 , ke )) * dy end do end do vtop = vtop / ( ( je - jb + 1 ) * ( xh ( ie + 1 ) - xh ( ib ) ) ) call MPI_ALLREDUCE ( vtop , dum , 1 , MY_REAL , MPI_SUM , comm3d , mpierr ) freestream = dum / nprocs else utop = 0. do j = jb , je do i = ib , ie !dum=0.5*(u0(i,j,ke)+u0(i+1,j,ke))*dxf(i) !utop = utop + dum utop = utop + 0.5 * ( u0 ( i , j , ke ) + u0 ( i + 1 , j , ke )) * dxf ( i ) end do end do utop = utop / ( ( je - jb + 1 ) * ( xh ( ie + 1 ) - xh ( ib ) ) ) call MPI_ALLREDUCE ( utop , dum , 1 , MY_REAL , MPI_SUM , comm3d , mpierr ) freestream = dum / nprocs !write(*,*) \"myid,utop,dum,freestream\",myid,utop,dum,freestream end if end subroutine detfreestream subroutine detfreestrtmp ( freestrtmp ) use modglobal , only : ib , ie , jb , je , kb , ke , kh , dxf , xh , dt ,& Uinf use modfields , only : thl0 , dpdxl , dgdt , dpdx use modmpi , only : myid , comm3d , mpierr , mpi_sum , my_real , nprocs implicit none real , intent ( out ) :: freestrtmp real ttop integer i , j ttop = 0. do j = jb , je do i = ib , ie ttop = ttop + thl0 ( i , j , ke ) * dxf ( i ) end do end do ttop = ttop / ( ( je - jb + 1 ) * ( xh ( ie + 1 ) - xh ( ib ) ) ) call MPI_ALLREDUCE ( ttop , freestrtmp , 1 , MY_REAL , MPI_SUM , comm3d , mpierr ) freestrtmp = freestrtmp / nprocs end subroutine detfreestrtmp subroutine fixuinf2 use modglobal , only : ib , ie , jb , je , kb , ke , kh , dxf , xh , dt ,& Uinf , ifixuinf , tscale , timee , rk3step , inletav ,& freestreamav , freestrtmpav , ltempeq use modsurfdata , only : thl_top use modfields , only : u0 , thl0 , dpdxl , dgdt , dpdx , thlsrcdt use modmpi , only : myid , comm3d , mpierr , mpi_sum , my_real , nprocs implicit none real utop , freestream , freestrtmp , rk3coef integer i , j utop = 0. if (( ifixuinf == 2 ) . and . ( rk3step == 3 )) then call detfreestream ( freestream ) freestreamav = freestream * dt / inletav + ( 1. - dt / inletav ) * freestreamav ! Write some statistics to monitoring file ! if (myid==0) then !   open(unit=11,file='freestr.txt',position='append') !   write(11,3002) timee,freestream,freestreamav !   3002      format (13(6e14.6)) !   close(11) ! endif !    dgdt =  (1./tscale) * (freestream - Uinf) !    dgdt =  (1./dt) * (freestreamav - Uinf) dgdt = ( 1. / tscale ) * ( freestreamav - Uinf ) ! plus sign because dpdx is SUBTRACTED from Navier-Stokes eqs !    dgdt =  (1./inletav) * (freestreamav - Uinf) !    if (ltempeq) then  !tg3315 commented !      call detfreestrtmp(freestrtmp) !      freestrtmpav=  freestrtmp*dt/inletav + (1.-dt/inletav)*freestrtmpav !      thlsrcdt = -(1./tscale) * (freestrtmpav - thl_top)   ! minus sign because thlsr is ADDED to Navier-Stokes eqs. !      if (myid==0) then !        open(unit=11,file='theta_top.txt',position='append') !        write(11,3009) timee,freestrtmp,freestrtmpav !3009    format (13(6e20.12)) !        close(11) !      endif !    end if end if end subroutine fixuinf2 subroutine fixuinf1 use modglobal , only : ib , ie , jb , je , kb , ke , kh , dxf , xh , dt ,& Uinf , Vinf , ifixuinf , tscale , timee , rk3step , inletav ,& freestreamav , lvinf use modfields , only : u0 , dpdxl , dgdt , dpdx , up , vp use modmpi , only : myid , comm3d , mpierr , mpi_sum , my_real , nprocs implicit none real utop , freestream , rk3coef integer i , j , k utop = 0. if (( ifixuinf == 1 ) . and . ( rk3step == 3 )) then ! rk3coef = dt / (4. - dble(rk3step)) ! do j =jb,je !   do i =ib,ie !     utop = utop + 0.5*(u0(i,j,ke)+u0(i+1,j,ke))*dxf(i) !   end do ! end do ! utop = utop / ( (je-jb+1)*(xh(ie+1)-xh(ib) ) ) ! call MPI_ALLREDUCE(utop,    freestream,1,MY_REAL,MPI_SUM,comm3d,mpierr) ! freestream = freestream / nprocs ! Write some statistics to monitoring file ! if (myid==0 .and. rk3step==3) then ! ! dpdxl(:) = dpdx + (1./rk3coef) * (freestream - Uinf) ! dpdxl(:) = dpdx + (1./dt) * (freestream - Uinf) call detfreestream ( freestream ) ! write(*,*) \"freestream\",freestream if ( lvinf ) then do k = kb , ke do i = ib , ie do j = jb , je vp ( i , j , k ) = vp ( i , j , k ) - ( 1. / dt ) * ( freestream - Vinf ) enddo enddo enddo else do k = kb , ke do j = jb , je do i = ib , ie up ( i , j , k ) = up ( i , j , k ) - ( 1. / dt ) * ( freestream - Uinf ) enddo enddo enddo endif ! if (myid==0) then !   write(*,*), \"freestream\", freestream !   write(*,*), \"Uinf\", Uinf !   open(unit=11,file='freestr.txt',position='append') !   write(11,3003) timee,freestream !   3003    format (13(6e20.12)) !   close(11) !   open(unit=11,file='dpdx___.txt',position='append') !   write(11,3002) timee,dpdxl(kb),dpdxl(kb)-dpdx !   3002    format (13(6e20.12)) !   close(11) ! endif end if end subroutine fixuinf1 subroutine fixthetainf use modglobal , only : ib , ie , jb , je , kb , ke , kh , dxf , xh , dt ,& Uinf , ifixuinf , tscale , timee , rk3step , inletav ,& freestreamav , thlsrc , ltempeq use modfields , only : thl0 use modmpi , only : myid , comm3d , mpierr , mpi_sum , my_real , nprocs use modsurfdata , only : thl_top implicit none real ttop , freestreamtheta , rk3coef integer i , j ttop = 0. ! if (ifixuinf==1 .and. rk3step==3 .and. ltempeq) then !tg3315 commented !   rk3coef = dt / (4. - dble(rk3step)) !   do j =jb,je !     do i =ib,ie !       ttop = ttop + thl0(i,j,ke)*dxf(i) !     end do !   end do !   ttop = ttop / ( (je-jb+1)*(xh(ie+1)-xh(ib) ) ) !   call MPI_ALLREDUCE(ttop,    freestreamtheta,1,MY_REAL,MPI_SUM,comm3d,mpierr) !   freestreamtheta = freestreamtheta / nprocs !   thlsrc = -(1./dt) * (freestreamtheta - thl_top) !     if (myid==0) then !       open(unit=11,file='theta_top.txt',position='append') !       write(11,3003) timee,freestreamtheta !       3003    format (13(6e20.12)) !       close(11) !       open(unit=11,file='thlsrc.txt',position='append') !       write(11,3002) timee,thlsrc !       3002    format (13(6e20.12)) !       close(11) !     endif ! end if end subroutine fixthetainf subroutine masscorr !> correct the velocities to get prescribed flow rate use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , dzf , dxf , dy , dt , rk3step ,& uflowrate , vflowrate , linoutflow ,& luoutflowr , lvoutflowr , luvolflowr , lvvolflowr use modfields , only : um , up , vm , vp , uout , uouttot , udef , vout , vouttot , vdef ,& uoutarea , voutarea , fluidvol , IIu , IIv use modmpi , only : myid , comm3d , mpierr , nprocs , MY_REAL , sumy_ibm real , dimension ( ib : ie , kb : ke ) :: uvol real , dimension ( ib : ie , kb : ke ) :: uvolold real , dimension ( ib : ie , kb : ke ) :: vvol real , dimension ( ib : ie , kb : ke ) :: vvolold real , dimension ( kb : ke ) :: uoutold real , dimension ( kb : ke ) :: voutold real rk3coef , rk3coefi ,& uoutflow , voutflow ,& uflowrateold , vflowrateold integer i , j , k if ((. not . linoutflow ) . and . ( luoutflowr )) then rk3coef = dt / ( 4. - dble ( rk3step )) rk3coefi = 1 / rk3coef udef = 0. uout = 0. uoutflow = 0. uoutold = 0. ! integrate u fixed at outlet ie along y call sumy_ibm ( uout , up ( ie , jb : je , kb : ke ) * dy , ie , ie , jb , je , kb , ke , IIu ( ie , jb : je , kb : ke )) ! u tendency at previous time step call sumy_ibm ( uoutold , um ( ie , jb : je , kb : ke ) * dy , ie , ie , jb , je , kb , ke , IIu ( ie , jb : je , kb : ke )) ! u at previous time step ! integrate u in z do k = kb , ke uout ( k ) = rk3coef * uout ( k ) * dzf ( k ) uoutold ( k ) = uoutold ( k ) * dzf ( k ) end do uoutflow = sum ( uout ( kb : ke )) uflowrateold = sum ( uoutold ( kb : ke )) ! average over outflow area uoutflow = uoutflow / uoutarea uflowrateold = uflowrateold / uoutarea ! flow correction to match outflow rate udef = uflowrate - ( uoutflow + uflowrateold ) do k = kb , ke do j = jb , je do i = ib , ie up ( i , j , k ) = up ( i , j , k ) + udef * rk3coefi end do end do end do ! bss116 calculate uouttot which is used in modboundary. ! this really should be in the routine directly! uouttot = sum ( uout ( kb : ke )) ! mass flow rate at outlet elseif ((. not . linoutflow ) . and . ( luvolflowr )) then rk3coef = dt / ( 4. - dble ( rk3step )) rk3coefi = 1 / rk3coef udef = 0. uout = 0. uoutflow = 0. uoutold = 0. uvol = 0. uvolold = 0. ! integrate u in y call sumy_ibm ( uvol , up ( ib : ie , jb : je , kb : ke ) * dy , ib , ie , jb , je , kb , ke , IIu ( ib : ie , jb : je , kb : ke )) ! u tendency at previous time step call sumy_ibm ( uvolold , um ( ib : ie , jb : je , kb : ke ) * dy , ib , ie , jb , je , kb , ke , IIu ( ib : ie , jb : je , kb : ke )) ! u at previous time step ! integrate u in x do k = kb , ke uout ( k ) = sum ( uvol ( ib : ie , k ) * dxf ( ib : ie )) uoutold ( k ) = sum ( uvolold ( ib : ie , k ) * dxf ( ib : ie )) end do ! integrate u in z do k = kb , ke uout ( k ) = rk3coef * uout ( k ) * dzf ( k ) uoutold ( k ) = uoutold ( k ) * dzf ( k ) end do uoutflow = sum ( uout ( kb : ke )) uflowrateold = sum ( uoutold ( kb : ke )) ! average over fluid volume uoutflow = uoutflow / fluidvol uflowrateold = uflowrateold / fluidvol ! flow correction to match outflow rate udef = uflowrate - ( uoutflow + uflowrateold ) do k = kb , ke do j = jb , je do i = ib , ie up ( i , j , k ) = up ( i , j , k ) + udef * rk3coefi end do end do end do end if if ((. not . linoutflow ) . and . ( lvoutflowr )) then rk3coef = dt / ( 4. - dble ( rk3step )) rk3coefi = 1 / rk3coef vdef = 0. vout = 0. voutflow = 0. voutold = 0. ! integrate v fixed at outlet je along x if ( myid == nprocs - 1 ) then do k = kb , ke vout ( k ) = sum ( vp ( ib : ie , je , k ) * IIv ( ib : ie , je , k ) * dxf ( ib : ie )) ! v tendency at previous time step voutold ( k ) = sum ( vm ( ib : ie , je , k ) * IIv ( ib : ie , je , k ) * dxf ( ib : ie )) ! v at previous time step end do end if call MPI_BCAST ( vout , ke - kb + 1 , MY_REAL , nprocs - 1 , comm3d , mpierr ) call MPI_BCAST ( voutold , ke - kb + 1 , MY_REAL , nprocs - 1 , comm3d , mpierr ) ! integrate v in z do k = kb , ke vout ( k ) = rk3coef * vout ( k ) * dzf ( k ) voutold ( k ) = voutold ( k ) * dzf ( k ) end do voutflow = sum ( vout ( kb : ke )) vflowrateold = sum ( voutold ( kb : ke )) ! average over outflow area voutflow = voutflow / voutarea vflowrateold = vflowrateold / voutarea ! flow correction to match outflow rate vdef = vflowrate - ( voutflow + vflowrateold ) do k = kb , ke do j = jb , je do i = ib , ie vp ( i , j , k ) = vp ( i , j , k ) + vdef * rk3coefi end do end do end do elseif ((. not . linoutflow ) . and . ( lvvolflowr )) then rk3coef = dt / ( 4. - dble ( rk3step )) rk3coefi = 1 / rk3coef vdef = 0. vout = 0. voutflow = 0. voutold = 0. vvol = 0. vvolold = 0. ! integrate v in y call sumy_ibm ( vvol , vp ( ib : ie , jb : je , kb : ke ) * dy , ib , ie , jb , je , kb , ke , IIv ( ib : ie , jb : je , kb : ke )) ! v tendency at previous time step call sumy_ibm ( vvolold , vm ( ib : ie , jb : je , kb : ke ) * dy , ib , ie , jb , je , kb , ke , IIv ( ib : ie , jb : je , kb : ke )) ! v at previous time step ! integrate v in x do k = kb , ke vout ( k ) = sum ( vvol ( ib : ie , k ) * dxf ( ib : ie )) voutold ( k ) = sum ( vvolold ( ib : ie , k ) * dxf ( ib : ie )) end do ! integrate v in z do k = kb , ke vout ( k ) = rk3coef * vout ( k ) * dzf ( k ) voutold ( k ) = voutold ( k ) * dzf ( k ) end do voutflow = sum ( vout ( kb : ke )) vflowrateold = sum ( voutold ( kb : ke )) ! average over fluid volume voutflow = voutflow / fluidvol vflowrateold = vflowrateold / fluidvol ! flow correction to match outflow rate vdef = vflowrate - ( voutflow + vflowrateold ) do k = kb , ke do j = jb , je do i = ib , ie vp ( i , j , k ) = vp ( i , j , k ) + vdef * rk3coefi end do end do end do end if end subroutine masscorr subroutine uoutletarea ( area ) ! calculates outlet area of domain for u-velocity excluding blocks use modglobal , only : ib , ie , jb , je , kb , ke , dy , dzf use modfields , only : IIc use modmpi , only : sumy_ibm implicit none real , intent ( out ) :: area real , dimension ( kb : ke ) :: sumy integer k sumy = 0. ! integrate fluid area at outflow plane in y call sumy_ibm ( sumy , IIc ( ie , jb : je , kb : ke ) * dy , ie , ie , jb , je , kb , ke , IIc ( ie , jb : je , kb : ke )) ! integrate fluid area at outflow plane in z do k = kb , ke sumy ( k ) = sumy ( k ) * dzf ( k ) end do area = sum ( sumy ( kb : ke )) end subroutine uoutletarea subroutine voutletarea ( area ) ! calculates outlet area of domain for v-velocity excluding blocks use modglobal , only : ib , ie , jb , je , kb , ke , dxf , dzf use modfields , only : IIc use modmpi , only : myid , comm3d , mpierr , nprocs , MY_REAL implicit none real , intent ( out ) :: area real , dimension ( kb : ke ) :: sumx integer k sumx = 0. ! integrate fluid area at outflow plane in x if ( myid == nprocs - 1 ) then do k = kb , ke sumx ( k ) = sum ( IIc ( ib : ie , je , k ) * dxf ( ib : ie )) end do end if call MPI_BCAST ( sumx , ke - kb + 1 , MY_REAL , nprocs - 1 , comm3d , mpierr ) ! integrate fluid area at outflow plane in z do k = kb , ke sumx ( k ) = sumx ( k ) * dzf ( k ) end do area = sum ( sumx ( kb : ke )) end subroutine voutletarea subroutine fluidvolume ( volume ) ! calculates fluid volume of domain excluding blocks use modglobal , only : ib , ie , jb , je , kb , ke , dy , dxf , dzf use modfields , only : IIc use modmpi , only : sumy_ibm implicit none real , intent ( out ) :: volume real , dimension ( ib : ie , kb : ke ) :: sumy real , dimension ( kb : ke ) :: sumxy integer k sumy = 0. sumxy = 0. ! integrate fluid volume in y call sumy_ibm ( sumy , IIc ( ib : ie , jb : je , kb : ke ) * dy , ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke )) ! integrate fluid area in x do k = kb , ke sumxy ( k ) = sum ( sumy ( ib : ie , k ) * dxf ( ib : ie )) end do ! integrate fluid area in z volume = sum ( sumxy ( kb : ke ) * dzf ( kb : ke )) end subroutine fluidvolume subroutine calcfluidvolumes !> calculates fluid volume and outlet areas, excluding blocks !> and saves it to variables from modfields use modfields , only : uoutarea , voutarea , fluidvol implicit none real :: volume ! calculate outlet area call uoutletarea ( volume ) uoutarea = volume ! calculate outlet area call voutletarea ( volume ) voutarea = volume ! calculate fluid volume call fluidvolume ( volume ) fluidvol = volume end subroutine calcfluidvolumes subroutine coriolis !-----------------------------------------------------------------| !                                                                 | !      Thijs Heus TU Delft                                        | !                                                                 | !     purpose.                                                    | !     --------                                                    | !                                                                 | !      Calculates the Coriolis force.                             | !                                                                 | !**   interface.                                                  | !     ----------                                                  | !                                                                 | !     *coriolis* is called from *program*.                        | !                                                                 | !-----------------------------------------------------------------| ! use modglobal, only : i1,j1,kmax,dzh,dzf,om22,om23 use modglobal , only : ib , ie , jb , je , kb , ke , kh , dzh , dzf , om22 , om23 , lcoriol , lprofforc , timee use modfields , only : u0 , v0 , w0 , up , vp , wp , ug , vg use modmpi , only : myid implicit none integer i , j , k , jm , jp , km , kp real , dimension ( kb : ke + kh ) :: ugg real om23g if ( lcoriol ) then ! if (myid==0) then !   write(*,*) \"up before coriol\",up(3,3,ke) ! end if do k = kb + 1 , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie up ( i , j , k ) = up ( i , j , k ) & + (( v0 ( i , j , k ) + v0 ( i , jp , k ) + v0 ( i - 1 , j , k ) + v0 ( i - 1 , jp , k )) * om23 * 0.25 ) & - (( w0 ( i , j , k ) + w0 ( i , j , kp ) + w0 ( i - 1 , j , kp ) + w0 ( i - 1 , j , k )) * om22 * 0.25 ) vp ( i , j , k ) = vp ( i , j , k ) & - (( u0 ( i , j , k ) + u0 ( i , jm , k ) + u0 ( i + 1 , jm , k ) + u0 ( i + 1 , j , k )) * om23 * 0.25 ) wp ( i , j , k ) = wp ( i , j , k ) + (( ( dzf ( km ) * ( u0 ( i , j , k ) + u0 ( i + 1 , j , k ) ) & + dzf ( k ) * ( u0 ( i , j , km ) + u0 ( i + 1 , j , km )) ) / dzh ( k ) ) & * om22 * 0.25 ) end do end do ! -------------------------------------------end i&j-loop end do ! -------------------------------------------end k-loop ! -------------------------------------------- ! special treatment for lowest full level: k=1 ! -------------------------------------------- do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie up ( i , j , kb ) = up ( i , j , kb ) & + ( v0 ( i , j , kb ) + v0 ( i , jp , kb ) + v0 ( i - 1 , j , kb ) + v0 ( i - 1 , jp , kb )) * om23 * 0.25 & - ( w0 ( i , j , kb ) + w0 ( i , j , kb + 1 ) + w0 ( i - 1 , j , kb + 1 ) + w0 ( i - 1 , j , kb )) * om22 * 0.25 vp ( i , j , kb ) = vp ( i , j , kb ) & - ( u0 ( i , j , kb ) + u0 ( i , jm , kb ) + u0 ( i + 1 , jm , kb ) + u0 ( i + 1 , j , kb )) * om23 * 0.25 wp ( i , j , kb ) = 0.0 end do end do ! ----------------------------------------------end i,j-loop ! if (myid==0) then !   write(*,*) \"up after coriol\",up(3,3,ke) ! end if elseif ( lprofforc ) then ugg (:) = ug (:) om23g = om23 do k = kb + 1 , ke do j = jb , je do i = ib , ie up ( i , j , k ) = up ( i , j , k ) + om23g * ( ugg ( k ) - u0 ( i , j , k )) enddo enddo enddo ! -------------------------------------------- ! special treatment for lowest full level: k=1 ! -------------------------------------------- do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie up ( i , j , kb ) = up ( i , j , kb ) + om23g * ( ugg ( kb ) - u0 ( i , j , kb )) enddo enddo ! if (myid==0) then !   write(*,*) \"up after profforc\",up(3,3,ke) ! end if endif !lcoriol and lprofforc return end subroutine coriolis subroutine lstend !-----------------------------------------------------------------| !                                                                 | !*** *lstend*  calculates large-scale tendencies                  | !                                                                 | !      Pier Siebesma   K.N.M.I.     06/01/1995                    | !                                                                 | !     purpose.                                                    | !     --------                                                    | !                                                                 | !     calculates and adds large-scale tendencies due to           | !     large scale advection and subsidence.                       | !                                                                 | !**   interface.                                                  | !     ----------                                                  | !                                                                 | !             *lstend* is called from *program*.                  | !                                                                 | !-----------------------------------------------------------------| use modglobal , only : ib , ie , jb , je , kb , ke , kh , dzh , nsv , lmomsubs use modfields , only : up , vp , thlp , qtp , svp ,& whls , u0av , v0av , thl0av , qt0av , sv0av ,& dudxls , dudyls , dvdxls , dvdyls , dthldxls , dthldyls , dqtdxls , dqtdyls , dqtdtls use modmpi , only : myid implicit none integer k , n real subs_thl , subs_qt , subs_u , subs_v , subs_sv ! if (ltimedep) then !   ! call ls ! end if ! if (myid==0) then !   write(*,*) \"up before lstend\",up(3,3,ke) ! end if ! 1. DETERMINE LARGE SCALE TENDENCIES !    -------------------------------- ! 1.1 lowest model level above surface : only downward component subs_u = 0. subs_v = 0. subs_thl = 0. subs_qt = 0. subs_sv = 0. k = kb if ( whls ( k + 1 ). lt . 0 ) then !neglect effect of mean ascending on tendencies at the lowest full level subs_thl = whls ( k + 1 ) * ( thl0av ( k + 1 ) - thl0av ( k )) / dzh ( k + 1 ) ! tg3315 ils13 bss116 31/07/18 Dales 4.0 multiplies these by 0.5. To reduce subsidence towards the ground? Have removed subs_qt = whls ( k + 1 ) * ( qt0av ( k + 1 ) - qt0av ( k ) ) / dzh ( k + 1 ) if ( lmomsubs ) then subs_u = whls ( k + 1 ) * ( u0av ( k + 1 ) - u0av ( k ) ) / dzh ( k + 1 ) subs_v = whls ( k + 1 ) * ( v0av ( k + 1 ) - v0av ( k ) ) / dzh ( k + 1 ) endif do n = 1 , nsv subs_sv = whls ( k + 1 ) * ( sv0av ( k + 1 , n ) - sv0av ( k , n ) ) / dzh ( k + 1 ) ! svp(2:i1,2:j1,1,n) = svp(2:i1,2:j1,1,n)-subs_sv svp ( ib : ie , jb : je , kb , n ) = svp ( ib : ie , jb : je , kb , n ) - subs_sv enddo endif thlp ( ib : ie , jb : je , k ) = thlp ( ib : ie , jb : je , k ) - u0av ( k ) * dthldxls ( k ) - v0av ( k ) * dthldyls ( k ) - subs_thl qtp ( ib : ie , jb : je , k ) = qtp ( ib : ie , jb : je , k ) - u0av ( k ) * dqtdxls ( k ) - v0av ( k ) * dqtdyls ( k ) - subs_qt + dqtdtls ( k ) up ( ib : ie , jb : je , k ) = up ( ib : ie , jb : je , k ) - u0av ( k ) * dudxls ( k ) - v0av ( k ) * dudyls ( k ) - subs_u vp ( ib : ie , jb : je , k ) = vp ( ib : ie , jb : je , k ) - u0av ( k ) * dvdxls ( k ) - v0av ( k ) * dvdyls ( k ) - subs_v ! 1.2 other model levels twostream do k = kb + 1 , ke if ( whls ( k + 1 ). lt . 0 ) then !downwind scheme for subsidence subs_thl = whls ( k + 1 ) * ( thl0av ( k + 1 ) - thl0av ( k )) / dzh ( k + 1 ) subs_qt = whls ( k + 1 ) * ( qt0av ( k + 1 ) - qt0av ( k )) / dzh ( k + 1 ) do n = 1 , nsv subs_sv = whls ( k + 1 ) * ( sv0av ( k + 1 , n ) - sv0av ( k , n )) / dzh ( k + 1 ) svp ( ib : ie , jb : je , k , n ) = svp ( ib : ie , jb : je , k , n ) - subs_sv enddo if ( lmomsubs ) then subs_u = whls ( k + 1 ) * ( u0av ( k + 1 ) - u0av ( k )) / dzh ( k + 1 ) subs_v = whls ( k + 1 ) * ( v0av ( k + 1 ) - v0av ( k )) / dzh ( k + 1 ) endif else !downwind scheme for mean upward motions subs_thl = whls ( k ) * ( thl0av ( k ) - thl0av ( k - 1 )) / dzh ( k ) subs_qt = whls ( k ) * ( qt0av ( k ) - qt0av ( k - 1 )) / dzh ( k ) do n = 1 , nsv subs_sv = whls ( k ) * ( sv0av ( k , n ) - sv0av ( k - 1 , n )) / dzh ( k ) svp ( ib : ie , jb : je , k , n ) = svp ( ib : ie , jb : je , k , n ) - subs_sv enddo if ( lmomsubs ) then subs_u = whls ( k ) * ( u0av ( k ) - u0av ( k - 1 )) / dzh ( k ) subs_v = whls ( k ) * ( v0av ( k ) - v0av ( k - 1 )) / dzh ( k ) endif endif thlp ( ib : ie , jb : je , k ) = thlp ( ib : ie , jb : je , k ) - u0av ( k ) * dthldxls ( k ) - v0av ( k ) * dthldyls ( k ) - subs_thl qtp ( ib : ie , jb : je , k ) = qtp ( ib : ie , jb : je , k ) - u0av ( k ) * dqtdxls ( k ) - v0av ( k ) * dqtdyls ( k ) - subs_qt + dqtdtls ( k ) up ( ib : ie , jb : je , k ) = up ( ib : ie , jb : je , k ) - u0av ( k ) * dudxls ( k ) - v0av ( k ) * dudyls ( k ) - subs_u vp ( ib : ie , jb : je , k ) = vp ( ib : ie , jb : je , k ) - u0av ( k ) * dvdxls ( k ) - v0av ( k ) * dvdyls ( k ) - subs_v enddo return end subroutine lstend subroutine nudge use modglobal , only : kb , ke , lmoist , ltempeq , lnudge , tnudge , nnudge , numol , nsv use modfields , only : thlp , qtp , svp , sv0av , thl0av , qt0av use modmpi , only : myid implicit none integer :: k real :: numoli numoli = 1 / numol if ( lnudge . eqv . . false .) return if ( nsv > 0 ) then do k = ke - nnudge , ke svp (:,:, k , 1 ) = svp (:,:, k , 1 ) - ( sv0av ( k , 1 ) - 0. ) / ( tnudge / 2 + ( ke - k ) * tnudge / nnudge ) end do end if if ( ltempeq ) then do k = ke - nnudge , ke thlp (:,:, k ) = thlp (:,:, k ) - ( thl0av ( k ) - 288 ) / ( tnudge / 2 + ( ke - k ) * tnudge / nnudge ) end do end if !ltempeq if ( lmoist ) then do k = ke - nnudge , ke qtp (:,:, k ) = qtp (:,:, k ) - ( qt0av ( k ) - 0. ) / ( tnudge / 2 + ( ke - k ) * tnudge / nnudge ) end do end if !lmoist end subroutine nudge end module modforces","tags":"","loc":"sourcefile/modforces.f90.html"},{"title":"modmpi.f90 – uDALES","text":"Files dependent on this one sourcefile~~modmpi.f90~~AfferentGraph sourcefile~modmpi.f90 modmpi.f90 sourcefile~modpois.f90 modpois.f90 sourcefile~modpois.f90->sourcefile~modmpi.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~modpois.f90->sourcefile~modboundary.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modpois.f90->sourcefile~modglobal.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modpois.f90->sourcefile~modfields.f90 sourcefile~modibm.f90 modibm.f90 sourcefile~modibm.f90->sourcefile~modmpi.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~modibm.f90->sourcefile~initfac.f90 sourcefile~modibm.f90->sourcefile~modglobal.f90 sourcefile~modibm.f90->sourcefile~modfields.f90 sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~modsubgrid.f90->sourcefile~modmpi.f90 sourcefile~modsubgrid.f90->sourcefile~modboundary.f90 sourcefile~modsubgrid.f90->sourcefile~modglobal.f90 sourcefile~modsubgrid.f90->sourcefile~modfields.f90 sourcefile~advec_2nd.f90 advec_2nd.f90 sourcefile~advec_2nd.f90->sourcefile~modmpi.f90 sourcefile~advec_2nd.f90->sourcefile~modibm.f90 sourcefile~advec_2nd.f90->sourcefile~initfac.f90 sourcefile~advec_2nd.f90->sourcefile~modglobal.f90 sourcefile~advec_2nd.f90->sourcefile~modfields.f90 sourcefile~modboundary.f90->sourcefile~modmpi.f90 sourcefile~moddriver.f90 moddriver.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~modinlet.f90 modinlet.f90 sourcefile~modboundary.f90->sourcefile~modinlet.f90 sourcefile~modboundary.f90->sourcefile~modglobal.f90 sourcefile~modboundary.f90->sourcefile~modfields.f90 sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~modstatsdump.f90->sourcefile~modmpi.f90 sourcefile~modstatsdump.f90->sourcefile~modsubgrid.f90 sourcefile~modstatsdump.f90->sourcefile~modglobal.f90 sourcefile~modstat_nc.f90 modstat_nc.f90 sourcefile~modstatsdump.f90->sourcefile~modstat_nc.f90 sourcefile~modstatistics.f90 modstatistics.f90 sourcefile~modstatsdump.f90->sourcefile~modstatistics.f90 sourcefile~modstatsdump.f90->sourcefile~modfields.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~modsave.f90->sourcefile~modmpi.f90 sourcefile~modsave.f90->sourcefile~initfac.f90 sourcefile~modsave.f90->sourcefile~modglobal.f90 sourcefile~modsave.f90->sourcefile~modfields.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~modstartup.f90->sourcefile~modmpi.f90 sourcefile~modstartup.f90->sourcefile~modpois.f90 sourcefile~modstartup.f90->sourcefile~modsubgrid.f90 sourcefile~modstartup.f90->sourcefile~modboundary.f90 sourcefile~modstartup.f90->sourcefile~moddriver.f90 sourcefile~modforces.f90 modforces.f90 sourcefile~modstartup.f90->sourcefile~modforces.f90 sourcefile~modstartup.f90->sourcefile~modinlet.f90 sourcefile~modstartup.f90->sourcefile~modglobal.f90 sourcefile~modthermodynamics.f90 modthermodynamics.f90 sourcefile~modstartup.f90->sourcefile~modthermodynamics.f90 sourcefile~modstartup.f90->sourcefile~modfields.f90 sourcefile~modchecksim.f90 modchecksim.f90 sourcefile~modchecksim.f90->sourcefile~modmpi.f90 sourcefile~modchecksim.f90->sourcefile~modglobal.f90 sourcefile~modchecksim.f90->sourcefile~modfields.f90 sourcefile~wf_uno.f90 wf_uno.f90 sourcefile~wf_uno.f90->sourcefile~modmpi.f90 sourcefile~wf_uno.f90->sourcefile~initfac.f90 sourcefile~wf_uno.f90->sourcefile~modglobal.f90 sourcefile~modeb.f90 modEB.f90 sourcefile~modeb.f90->sourcefile~modmpi.f90 sourcefile~modeb.f90->sourcefile~initfac.f90 sourcefile~modeb.f90->sourcefile~modglobal.f90 sourcefile~modeb.f90->sourcefile~modstat_nc.f90 sourcefile~moddriver.f90->sourcefile~modmpi.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~moddriver.f90->sourcefile~modglobal.f90 sourcefile~moddriver.f90->sourcefile~modfields.f90 sourcefile~modforces.f90->sourcefile~modmpi.f90 sourcefile~modforces.f90->sourcefile~modglobal.f90 sourcefile~modforces.f90->sourcefile~modfields.f90 sourcefile~modinlet.f90->sourcefile~modmpi.f90 sourcefile~modinlet.f90->sourcefile~modsave.f90 sourcefile~modinlet.f90->sourcefile~modglobal.f90 sourcefile~modinlet.f90->sourcefile~modfields.f90 sourcefile~tstep.f90 tstep.f90 sourcefile~tstep.f90->sourcefile~modmpi.f90 sourcefile~tstep.f90->sourcefile~modglobal.f90 sourcefile~tstep.f90->sourcefile~modfields.f90 sourcefile~modchem.f90 modchem.f90 sourcefile~tstep.f90->sourcefile~modchem.f90 sourcefile~wfmneutral.f90 wfmneutral.f90 sourcefile~wfmneutral.f90->sourcefile~modmpi.f90 sourcefile~wfmneutral.f90->sourcefile~initfac.f90 sourcefile~wfmneutral.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 sourcefile~scalsource.f90 scalsource.f90 sourcefile~scalsource.f90->sourcefile~modmpi.f90 sourcefile~scalsource.f90->sourcefile~initfac.f90 sourcefile~scalsource.f90->sourcefile~modglobal.f90 sourcefile~scalsource.f90->sourcefile~modfields.f90 sourcefile~wf_gr.f90 wf_gr.f90 sourcefile~wf_gr.f90->sourcefile~modmpi.f90 sourcefile~wf_gr.f90->sourcefile~initfac.f90 sourcefile~wf_gr.f90->sourcefile~modglobal.f90 sourcefile~modfielddump.f90 modfielddump.f90 sourcefile~modfielddump.f90->sourcefile~modmpi.f90 sourcefile~modfielddump.f90->sourcefile~modglobal.f90 sourcefile~modfielddump.f90->sourcefile~modstat_nc.f90 sourcefile~modfielddump.f90->sourcefile~modfields.f90 sourcefile~modstat_nc.f90->sourcefile~modmpi.f90 sourcefile~modstat_nc.f90->sourcefile~modglobal.f90 sourcefile~modthermodynamics.f90->sourcefile~modmpi.f90 sourcefile~modthermodynamics.f90->sourcefile~modglobal.f90 sourcefile~modthermodynamics.f90->sourcefile~modfields.f90 sourcefile~modstatistics.f90->sourcefile~modmpi.f90 sourcefile~modstatistics.f90->sourcefile~modglobal.f90 sourcefile~modstatistics.f90->sourcefile~modstat_nc.f90 sourcefile~modstatistics.f90->sourcefile~modfields.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modmpi.f90 sourcefile~program.f90->sourcefile~modpois.f90 sourcefile~program.f90->sourcefile~modibm.f90 sourcefile~program.f90->sourcefile~modsubgrid.f90 sourcefile~program.f90->sourcefile~modboundary.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 sourcefile~program.f90->sourcefile~modsave.f90 sourcefile~program.f90->sourcefile~modstartup.f90 sourcefile~program.f90->sourcefile~modchecksim.f90 sourcefile~program.f90->sourcefile~modeb.f90 sourcefile~program.f90->sourcefile~modforces.f90 sourcefile~program.f90->sourcefile~initfac.f90 sourcefile~program.f90->sourcefile~modglobal.f90 sourcefile~program.f90->sourcefile~modfielddump.f90 sourcefile~program.f90->sourcefile~modstat_nc.f90 sourcefile~program.f90->sourcefile~modthermodynamics.f90 sourcefile~advec_upw.f90 advec_upw.f90 sourcefile~advec_upw.f90->sourcefile~modglobal.f90 sourcefile~advec_upw.f90->sourcefile~modfields.f90 sourcefile~advection.f90 advection.f90 sourcefile~advection.f90->sourcefile~modglobal.f90 sourcefile~advection.f90->sourcefile~modfields.f90 sourcefile~advec_kappa.f90 advec_kappa.f90 sourcefile~advec_kappa.f90->sourcefile~modglobal.f90 sourcefile~advec_kappa.f90->sourcefile~modfields.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modchem.f90->sourcefile~modglobal.f90 sourcefile~modchem.f90->sourcefile~modfields.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules modmpi Source Code modmpi.f90 Source Code !> \\file modmpi.f90 !!  Layer to deal with the parallelization. !> !!  Layer to deal with the parallelization. !> !!  \\author Matthieu Pourquie, TU Delft !!  \\par Revision list !!  \\todo Documentation !!  \\todo 2D/3D parallelization !!  \\todo Include interfaces for MPI_ALLREDUCE, MPI_ALLTOALL, MPI_BCAST, !! MPI_SENDRECV to get rid of pure mpi calls in the code !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! module modmpi use mpi implicit none save integer comm3d integer nbrtop integer nbrbottom integer myid integer nprocs integer mpierr integer my_real real CPU_program !end time real CPU_program0 !start time character ( 3 ) :: cmyid contains subroutine initmpi implicit none integer dims ( 1 ) logical periods ( 1 ) integer periods2 ( 1 ) call MPI_INIT ( mpierr ) MY_REAL = MPI_DOUBLE_PRECISION !MPI_REAL8 should be the same.. call MPI_COMM_RANK ( MPI_COMM_WORLD , myid , mpierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , nprocs , mpierr ) ! Specify the # procs in each direction. ! specifying a 0 means that MPI will try to find a useful # procs in ! the corresponding  direction, ! specifying 1 means only 1 processor in this direction, meaning that ! we have in fact a grid of (at most) 2 dimensions left. This is used ! when we want the array index range in 1 particular direction to be ! present on all processors in the grid dims ( 1 ) = 0 ! directions 1 and 2 are chosen periodic periods ( 1 ) = . true . ! Soares 20080115 periods2 ( 1 ) = 1 ! find suitable # procs in each direction call MPI_DIMS_CREATE ( nprocs , 1 , dims , mpierr ) ! create the Cartesian communicator, denoted by the integer comm3d ! BUG - Thijs, Harm !call MPI_CART_CREATE(MPI_COMM_WORLD, 1, dims, periods,.false., & !                    comm3d, ierr ) call MPI_CART_CREATE ( MPI_COMM_WORLD , 1 , dims , periods ,. true ., & comm3d , mpierr ) ! Soares 20080115 !     call MPI_CART_CREATE(MPI_COMM_WORLD, 1, dims, periods2,1, & !                         comm3d, mpierr ) ! Get my processor number in this communicator call MPI_COMM_RANK ( comm3d , myid , mpierr ) ! when applying boundary conditions, we need to know which processors ! are neighbours in all 3 directions ! these are determined with the aid of the MPI routine MPI_CART_SHIFT, call MPI_CART_SHIFT ( comm3d , 0 , 1 , nbrbottom , nbrtop , mpierr ) ! determine some useful MPI datatypes for sending/receiving data write ( cmyid , '(i3.3)' ) myid if ( myid == 0 ) then CPU_program0 = MPI_Wtime () end if write ( * , * ) 'nprocs = ' , nprocs end subroutine initmpi !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine exitmpi implicit none if ( myid == 0 ) then CPU_program = MPI_Wtime () - CPU_program0 write ( 6 , * ) 'TOTAL CPU time = ' , CPU_program end if call MPI_Comm_free ( comm3d , mpierr ) call MPI_FINALIZE ( mpierr ) end subroutine exitmpi subroutine barrou () implicit none call MPI_BARRIER ( comm3d , mpierr ) return end subroutine barrou subroutine excj ( a , sx , ex , sy , ey , sz , ez ) implicit none integer sx , ex , sy , ey , sz , ez real a ( sx : ex , sy : ey , sz : ez ) integer iiget , status ( MPI_STATUS_SIZE ) integer ii , i , k real , allocatable , dimension (:) :: buffj1 , buffj2 , buffj3 , buffj4 iiget = ( ex - sx + 1 ) * ( ez - sz + 1 ) allocate ( buffj1 ( iiget ),& buffj2 ( iiget ),& buffj3 ( iiget ),& buffj4 ( iiget )) if ( nbrtop /= MPI_PROC_NULL ) then do k = sz , ez do i = sx , ex ii = i - sx + 1 + ( k - sz ) * ( ex - sx + 1 ) buffj1 ( ii ) = a ( i , ey - 1 , k ) enddo enddo endif call MPI_SENDRECV ( buffj1 , ii , MY_REAL , nbrtop , 4 , & buffj2 , iiget , MY_REAL , nbrbottom , 4 , & comm3d , status , mpierr ) if ( nbrbottom /= MPI_PROC_NULL ) then do k = sz , ez do i = sx , ex ii = i - sx + 1 + ( k - sz ) * ( ex - sx + 1 ) a ( i , sy , k ) = buffj2 ( ii ) enddo enddo endif !   call barrou() if ( nbrbottom /= MPI_PROC_NULL ) then do k = sz , ez do i = sx , ex ii = i - sx + 1 + ( k - sz ) * ( ex - sx + 1 ) buffj3 ( ii ) = a ( i , sy + 1 , k ) enddo enddo endif call MPI_SENDRECV ( buffj3 , ii , MY_REAL , nbrbottom , 5 , & buffj4 , iiget , MY_REAL , nbrtop , 5 , & comm3d , status , mpierr ) if ( nbrtop /= MPI_PROC_NULL ) then do k = sz , ez do i = sx , ex ii = i - sx + 1 + ( k - sz ) * ( ex - sx + 1 ) a ( i , ey , k ) = buffj4 ( ii ) enddo enddo endif !   call barrou() deallocate ( buffj1 , buffj2 , buffj3 , buffj4 ) return end subroutine excj ! tg3315 - does some transfer of ghost cell information in the y-direction. ! nbrbottom is cpu below and nbrtop is cpu above ! MPI_PROC_NULL = -2??? subroutine excjs ( a , sx , ex , sy , ey , sz , ez , ih , jh ) implicit none integer sx , ex , sy , ey , sz , ez , ih , jh real a ( sx - ih : ex + ih , sy - jh : ey + jh , sz : ez ) integer status ( MPI_STATUS_SIZE ), iiget integer ii , i , j , k real , allocatable , dimension (:) :: buffj1 , buffj2 , buffj3 , buffj4 iiget = jh * ( ex - sx + 1 + 2 * ih ) * ( ez - sz + 1 ) allocate ( buffj1 ( iiget ),& buffj2 ( iiget ),& buffj3 ( iiget ),& buffj4 ( iiget )) if ( nbrtop /= MPI_PROC_NULL ) then ii = 0 do j = 1 , jh do k = sz , ez do i = sx - ih , ex + ih ii = ii + 1 buffj1 ( ii ) = a ( i , ey - j + 1 , k ) ! tg3315 buffj1 is je-jhc ghost cells on myid enddo enddo enddo endif call MPI_SENDRECV ( buffj1 , ii , MY_REAL , nbrtop , 4 , & buffj2 , iiget , MY_REAL , nbrbottom , 4 , & comm3d , status , mpierr ) ! tg3315 sends this to nbrtop and pulls buffj2 from nbrbottom! send and receive process that is good for executing chain shifts. if ( nbrbottom /= MPI_PROC_NULL ) then ii = 0 do j = 1 , jh do k = sz , ez do i = sx - ih , ex + ih ii = ii + 1 a ( i , sy - j , k ) = buffj2 ( ii ) ! set the previous ghost cells to buffj2 (last cells of nbrbottom I think) enddo enddo enddo endif !   call barrou() ! repeats this process for other way round if ( nbrbottom /= MPI_PROC_NULL ) then ii = 0 do j = 1 , jh do k = sz , ez do i = sx - ih , ex + ih ii = ii + 1 buffj3 ( ii ) = a ( i , sy + j - 1 , k ) enddo enddo enddo endif call MPI_SENDRECV ( buffj3 , ii , MY_REAL , nbrbottom , 5 , & buffj4 , iiget , MY_REAL , nbrtop , 5 , & comm3d , status , mpierr ) if ( nbrtop /= MPI_PROC_NULL ) then ii = 0 do j = 1 , jh do k = sz , ez do i = sx - ih , ex + ih ii = ii + 1 a ( i , ey + j , k ) = buffj4 ( ii ) enddo enddo enddo endif !   call barrou() deallocate ( buffj1 , buffj2 , buffj3 , buffj4 ) return end subroutine excjs subroutine slabsum ( aver , ks , kf , var , ib , ie , jb , je , kb , ke , ibs , ies , jbs , jes , kbs , kes ) implicit none integer :: ks , kf integer :: ib , ie , jb , je , kb , ke , ibs , ies , jbs , jes , kbs , kes real :: aver ( ks : kf ) real :: var ( ib : ie , jb : je , kb : ke ) real :: averl ( ks : kf ) real :: avers ( ks : kf ) integer :: k averl = 0. avers = 0. do k = kbs , kes averl ( k ) = sum ( var ( ibs : ies , jbs : jes , k )) enddo call MPI_ALLREDUCE ( averl , avers , kf - ks + 1 , MY_REAL , & MPI_SUM , comm3d , mpierr ) aver = aver + avers return end subroutine slabsum subroutine avexy_ibm ( aver , var , ib , ie , jb , je , kb , ke , ih , jh , kh , II , IIs , lnan ) implicit none integer :: ib , ie , jb , je , kb , ke , ih , jh , kh real :: aver ( kb : ke + kh ) real :: var ( ib : ie , jb : je , kb : ke + kh ) integer :: II ( ib : ie , jb : je , kb : ke + kh ) integer :: IIs ( kb : ke + kh ) integer :: IId ( kb : ke + kh ) real :: averl ( kb : ke + kh ) real :: avers ( kb : ke + kh ) integer :: k logical :: lnan averl = 0. avers = 0. do k = kb , ke + kh averl ( k ) = sum ( var ( ib : ie , jb : je , k ) * II ( ib : ie , jb : je , k )) enddo IId = IIs ! tg3315 22.03.19 - if not calculating stats and all blocks on lowest layer... ! should not be necessary but value at kb is used in modthermo so reasonable value must ! be assigned. Potentially should leave as before and only account for in modthermo... if ((. not . lnan ) . and . ( IId ( kb ) == 0 )) then averl ( kb ) = sum ( var ( ib : ie , jb : je , kb )) IId ( kb ) = IId ( ke ) end if call MPI_ALLREDUCE ( averl , avers , ke + kh - kb + 1 , MY_REAL , & MPI_SUM , comm3d , mpierr ) where ( IId == 0 ) aver = - 99 9. elsewhere aver = avers / IId endwhere return end subroutine avexy_ibm subroutine slabsumi ( aver , iis , iif , var , ib , ie , jb , je , kb , ke , ibs , ies , jbs , jes , kbs , kes ) implicit none integer :: iis , iif integer :: ib , ie , jb , je , kb , ke , ibs , ies , jbs , jes , kbs , kes real :: aver ( iis : iif ) real :: var ( ib : ie , jb : je , kb : ke ) real :: averl ( iis : iif ) real :: avers ( iis : iif ) integer :: i averl = 0. avers = 0. do i = ibs , ies averl ( i ) = sum ( var ( i , jbs : jes , kbs : kes )) enddo call MPI_ALLREDUCE ( averl , avers , iif - iis + 1 , MY_REAL , & MPI_SUM , comm3d , mpierr ) aver = aver + avers return end subroutine slabsumi !Could make this so it has cases like if the input is 1,2 or 3D... subroutine avey_ibm ( aver , var , ib , ie , jb , je , kb , ke , II , IIt ) implicit none integer :: ib , ie , jb , je , kb , ke real :: aver ( ib : ie , kb : ke ) real :: avero ( ib : ie , kb : ke ) real :: var ( ib : ie , jb : je , kb : ke ) integer :: II ( ib : ie , jb : je , kb : ke ) integer :: IIt ( ib : ie , kb : ke ) logical :: lytdump , lnan avero = 0. aver = 0. avero = sum ( var ( ib : ie , jb : je , kb : ke ) * II ( ib : ie , jb : je , kb : ke ), DIM = 2 ) call MPI_ALLREDUCE ( avero ( ib : ie , kb : ke ), aver ( ib : ie , kb : ke ), ( ke - kb + 1 ) * ( ie - ib + 1 ), MY_REAL , MPI_SUM , comm3d , mpierr ) where ( IIt == 0 ) aver = - 99 9. elsewhere aver = aver / IIt endwhere end subroutine avey_ibm subroutine sumy_ibm ( sumy , var , ib , ie , jb , je , kb , ke , II ) ! This routine sums up a variable over the y direction, ! only including the fluid cells. implicit none integer :: ib , ie , jb , je , kb , ke real :: sumy ( ib : ie , kb : ke ) real :: sumproc ( ib : ie , kb : ke ) real :: var ( ib : ie , jb : je , kb : ke ) integer :: II ( ib : ie , jb : je , kb : ke ) sumproc = 0. sumy = 0. sumproc = sum ( var ( ib : ie , jb : je , kb : ke ) * II ( ib : ie , jb : je , kb : ke ), DIM = 2 ) call MPI_ALLREDUCE ( sumproc ( ib : ie , kb : ke ), sumy ( ib : ie , kb : ke ), ( ke - kb + 1 ) * ( ie - ib + 1 ), MY_REAL , MPI_SUM , comm3d , mpierr ) end subroutine sumy_ibm end module","tags":"","loc":"sourcefile/modmpi.f90.html"},{"title":"wf_gr.f90 – uDALES","text":"This file depends on sourcefile~~wf_gr.f90~~EfferentGraph sourcefile~wf_gr.f90 wf_gr.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~wf_gr.f90->sourcefile~modsubgriddata.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~wf_gr.f90->sourcefile~modmpi.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~wf_gr.f90->sourcefile~initfac.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~wf_gr.f90->sourcefile~modglobal.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~wf_gr.f90->sourcefile~modibmdata.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines wfGR Source Code wf_gr.f90 Source Code SUBROUTINE wfGR ( hi , hj , hk , ioq , ioqflux , icth , obcqfluxA , qcell , qwall , hurel , resc , ress , n , ind , wforient ) !wfGR USE modglobal , ONLY : dzf , dzfi , dzh2i , dzhi , dzhiq , dy , dyi , dy2i , dyi5 , dxf , dxh , dxfi , dxhi , dxh2i , ib , ie , jb , je , kb , ke , fkar , grav , jmax , rk3step USE modsubgriddata , ONLY : ekh USE modmpi , ONLY : myid USE initfac , ONLY : block USE modibmdata INTEGER i , j , k , jl , ju , kl , ku , il , iu , km , im , jm , ip , jp , kp REAL :: bcqflux = 0. !temp storage for temperature flux REAL :: bcmomflux = 0. !temp storage for momentum flux REAL :: dummy = 0. !for debugging REAL :: delta = 0. !distance from wall REAL :: fkar2 = fkar ** 2 !fkar&#94;2, von Karman constant squared REAL :: emmo = 0. , epmo = 0. , epom = 0. , emom = 0. , eopm = 0. , eomm = 0. , empo = 0. REAL :: umin = 0.0001 !m&#94;2/s&#94;2 REAL :: cveg = 0.8 !hardcoded for now, !fraction of GR covered in vegetation, should be made into a proper model parameter (-> modglobal) INTEGER , INTENT ( in ) :: hi !<size of halo in i INTEGER , INTENT ( in ) :: hj !<size of halo in j INTEGER , INTENT ( in ) :: hk !<size of halo in k REAL , INTENT ( out ) :: obcqfluxA ; !temperature flux of entire wall facet (double sum over indeces) [Km/s] REAL , INTENT ( inout ) :: ioq ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) !updated prognostic temperature REAL , INTENT ( inout ) :: ioqflux ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !a field to save the momentum flux REAL , INTENT ( in ) :: icth ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) ; !heat transfer coefficient, used to calculate moisture flux REAL , INTENT ( in ) :: qcell ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !Temperature of fluid cell !       real, intent(in)    :: Troof(ib:ie,jb:je,kb:ke)  !Temperature of horizontal surfaces (also includes roads) REAL , INTENT ( in ) :: qwall REAL , INTENT ( in ) :: hurel REAL , INTENT ( in ) :: resc REAL , INTENT ( in ) :: ress INTEGER , INTENT ( in ) :: n ! number of the block, used to get i,j,k-indeces INTEGER , INTENT ( in ) :: ind ! in case of y-wall (case 3x & 4x) \"ind\" is used for j-index, otherwise this is irrelevant INTEGER , INTENT ( in ) :: wforient !frist digit, orientation of wall, determines iteration idices and if Twall or Troof is used obcqfluxA = 0. !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CASES!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CASES FOR SCALARS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SELECT CASE ( wforient ) CASE ( 12 ) !wall in yz -> wf in x (=vertical), lower wall, west wall i = block ( n , 1 ) - 1 !wall property and fluid index ip = i + 1 !index to remove subgrid flux jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ! starting j-index ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) ! ending j-index kl = block ( n , 5 ) ! starting k-index ku = block ( n , 6 ) ! ending k-index delta = dxf ( i ) * 0.5 ! DO k = kl , ku DO j = jl , ju bcqflux = min ( 0. , cveg * ( qcell ( i , j , k ) - qwall ) * 1 / ( 1 / icth ( i , j , k ) + resc ) + ( 1 - cveg ) * ( qcell ( i , j , k ) - qwall * hurel ) * 1 / ( 1 / icth ( i , j , k ) + ress )) obcqfluxA = obcqfluxA + bcqflux ioqflux ( i , j , k ) = ioqflux ( i , j , k ) + bcqflux * dxfi ( i ) ioq ( i , j , k ) = ioq ( i , j , k ) - 0.5 * ( ekh ( ip , j , k ) * dxf ( i ) + ekh ( i , j , k ) * dxf ( ip )) * ( qcell ( ip , j , k ) - qcell ( i , j , k )) * dxh2i ( ip ) * dxfi ( i ) - bcqflux * dxfi ( i ) ! END DO END DO !!! case 22 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! CASE ( 22 ) i = block ( n , 2 ) + 1 ! im = i - 1 ! jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ! starting j-index ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) ! ending j-index kl = block ( n , 5 ) ! starting k-index ku = block ( n , 6 ) ! ending k-index delta = dxh ( i ) * 0.5 DO k = kl , ku DO j = jl , ju !dq * 1/res, where res is in [s/m] bcqflux = min ( 0. , cveg * ( qcell ( i , j , k ) - qwall ) * 1 / ( 1 / icth ( i , j , k ) + resc ) + ( 1 - cveg ) * ( qcell ( i , j , k ) - qwall * hurel ) * 1 / ( 1 / icth ( i , j , k ) + ress )) obcqfluxA = obcqfluxA + bcqflux ioqflux ( i , j , k ) = ioqflux ( i , j , k ) + bcqflux * dxfi ( i ) ioq ( i , j , k ) = ioq ( i , j , k ) + 0.5 * ( ekh ( i , j , k ) * dxf ( im ) + ekh ( im , j , k ) * dxf ( i )) * ( qcell ( i , j , k ) - qcell ( im , j , k )) * dxh2i ( i ) * dxfi ( i ) - bcqflux * dxfi ( i ) END DO END DO !!! case 32 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! CASE ( 32 ) !wall in xz -> wf in y (=vertical) upper, north wall j = ind jm = j - 1 il = block ( n , 1 ) iu = block ( n , 2 ) kl = block ( n , 5 ) ku = block ( n , 6 ) DO k = kl , ku DO i = il , iu bcqflux = min ( 0. , cveg * ( qcell ( i , j , k ) - qwall ) * 1 / ( 1 / icth ( i , j , k ) + resc ) + ( 1 - cveg ) * ( qcell ( i , j , k ) - qwall * hurel ) * 1 / ( 1 / icth ( i , j , k ) + ress )) obcqfluxA = obcqfluxA + bcqflux ioqflux ( i , j , k ) = ioqflux ( i , j , k ) + bcqflux * dyi ioq ( i , j , k ) = ioq ( i , j , k ) + ( & 0.5 * ( ekh ( i , j , k ) + ekh ( i , jm , k )) * ( qcell ( i , j , k ) - qcell ( i , jm , k ))) * dy2i & - bcqflux * dyi END DO END DO !!! case 42 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! CASE ( 42 ) !wall in xz -> wf in y (=vertical) lower, south wall j = ind jp = j + 1 il = block ( n , 1 ) iu = block ( n , 2 ) kl = block ( n , 5 ) ku = block ( n , 6 ) DO k = kl , ku DO i = il , iu bcqflux = min ( 0. , cveg * ( qcell ( i , j , k ) - qwall ) * 1 / ( 1 / icth ( i , j , k ) + resc ) + ( 1 - cveg ) * ( qcell ( i , j , k ) - qwall * hurel ) * 1 / ( 1 / icth ( i , j , k ) + ress )) obcqfluxA = obcqfluxA + bcqflux ioqflux ( i , j , k ) = ioqflux ( i , j , k ) + bcqflux * dyi ioq ( i , j , k ) = ioq ( i , j , k ) - & 0.5 * ( ekh ( i , jp , k ) + ekh ( i , j , k )) * ( qcell ( i , jp , k ) - qcell ( i , j , k )) * dy2i & - bcqflux * dyi END DO END DO !!! case 52 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! CASE ( 52 ) !wall in xy -> wf in z (=horizontal), top wall k = block ( n , 6 ) + 1 !block location km = k - 1 ! il = block ( n , 1 ) iu = block ( n , 2 ) jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) delta = dzf ( k ) * 0.5 DO j = jl , ju DO i = il , iu bcqflux = min ( 0. , cveg * ( qcell ( i , j , k ) - qwall ) * 1 / ( 1 / icth ( i , j , k ) + resc ) + ( 1 - cveg ) * ( qcell ( i , j , k ) - qwall * hurel ) * 1 / ( 1 / icth ( i , j , k ) + ress )) obcqfluxA = obcqfluxA + bcqflux ioqflux ( i , j , k ) = ioqflux ( i , j , k ) + bcqflux * dzfi ( k ) ioq ( i , j , k ) = ioq ( i , j , k ) & + 0.5 * ( dzf ( km ) * ekh ( i , j , k ) + dzf ( k ) * ekh ( i , j , km )) * ( qcell ( i , j , k ) - qcell ( i , j , km )) * dzh2i ( k ) * dzfi ( k ) & - bcqflux * dzfi ( k ) END DO END DO END SELECT END SUBROUTINE wfGR","tags":"","loc":"sourcefile/wf_gr.f90.html"},{"title":"modchecksim.f90 – uDALES","text":"This file depends on sourcefile~~modchecksim.f90~~EfferentGraph sourcefile~modchecksim.f90 modchecksim.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modchecksim.f90->sourcefile~modglobal.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modchecksim.f90->sourcefile~modfields.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~modchecksim.f90->sourcefile~modsubgriddata.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modchecksim.f90->sourcefile~modmpi.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~modchecksim.f90~~AfferentGraph sourcefile~modchecksim.f90 modchecksim.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modchecksim.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules modchecksim Source Code modchecksim.f90 Source Code !> \\file modchecksim.f90 !!  Monitors Courant and Peclet numbers, and divergence. !> !!  Monitors Courant and Peclet numbers, and divergence. !> !!  These numbers are put out to screen either every tcheck seconds, or every time step (if tcheck=0). !!  \\autor Jasper Tomas, TU Delft, June 4th 2015 !!  \\author Thijs Heus,MPI-M !!  \\author Hans Cuijpers, KNMI !!  \\par Revision list !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! ! module modchecksim use modglobal , only : longint implicit none private public initchecksim , checksim real :: tcheck = 0. !integer(kind=longint) :: tnext = 3600.,itcheck real :: tnext = 0. real :: dtmn = 0. , ndt = 0. save contains !> Initializing Checksim. Read out the namelist, initializing the variables subroutine initchecksim use modglobal , only : ifnamopt , fname_options , dtmax , ladaptive , btime use modmpi , only : myid , my_real , comm3d , mpierr implicit none integer :: ierr namelist / NAMCHECKSIM / & tcheck if ( myid == 0 ) then open ( ifnamopt , file = fname_options , status = 'old' , iostat = ierr ) read ( ifnamopt , NAMCHECKSIM , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions NAMCHECKSIM' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif write ( 6 , NAMCHECKSIM ) close ( ifnamopt ) if ((. not . ladaptive ) . and . ( tcheck < dtmax )) then tcheck = dtmax end if end if call MPI_BCAST ( tcheck , 1 , MY_REAL , 0 , comm3d , mpierr ) !    itcheck = floor(tcheck/tres) tnext = tcheck + btime end subroutine initchecksim !>Run checksim. Timekeeping, and output subroutine checksim use modglobal , only : timee , rk3step , dt_lim , dt use modmpi , only : myid implicit none character ( 20 ) :: timeday if ( timee == 0.0 ) return if ( rk3step /= 3 ) return dtmn = dtmn + dt ; ndt = ndt + 1. if ( timee < tnext ) return tnext = tnext + tcheck dtmn = dtmn / ndt if ( myid == 0 ) then call date_and_time ( time = timeday ) write ( * , * ) '=================================================================' write ( * , '(3A,F9.2,A,F12.9)' ) 'Time of Day: ' , timeday ( 1 : 10 ), '    Time of Simulation: ' , timee , '    dt: ' , dtmn end if call calccourant call calcdiffnr call chkdiv dtmn = 0. ndt = 0. end subroutine checksim !>      Calculates the courant number as in max(w)*deltat/deltaz subroutine calccourant use modglobal , only : ib , ie , jb , je , kb , ke , kh , dxhi , dyi , dzhi , dt , timee use modfields , only : um , vm , wm use modmpi , only : myid , comm3d , mpierr , mpi_max , my_real implicit none real :: courtotl , courtot integer :: i , j , k courtotl = 0.0 courtot = 0.0 do k = kb , ke do j = jb , je do i = ib , ie courtotl = max ( courtotl ,( um ( i , j , k ) * dxhi ( i ) + vm ( i , j , k ) * dyi + wm ( i , j , k ) * dzhi ( k )) * dtmn ) end do end do end do call MPI_ALLREDUCE ( courtotl , courtot , 1 , MY_REAL , MPI_MAX , comm3d , mpierr ) if ( myid == 0 ) then write ( * , '(A,ES10.2)' ) 'Courant numbers (x,y,z,tot):' , courtot end if return end subroutine calccourant !> Calculates the diffusion number as max(ekm) *deltat/deltax**2 subroutine calcdiffnr use modglobal , only : ib , ie , jb , je , kb , ke , kh , dxh2i , dy2i , dzh , dt , timee use modsubgriddata , only : ekm , ekh use modmpi , only : myid , comm3d , mpierr , mpi_max , my_real implicit none real diffnrtotl , diffnrtot integer :: i , j , k diffnrtotl = 0. diffnrtot = 0. do k = kb , ke do j = jb , je do i = ib , ie !      diffnrtotl = max(diffnrtotl,  ekm(i,j,k)*(1/dzh(k)**2 + dxh2i(i) + dy2i)*dtmn )  ! or should I interpolate ekm to the correct position? diffnrtotl = max ( diffnrtotl , ekm ( i , j , k ) * ( 1 / dzh ( k ) ** 2 + dxh2i ( i ) + dy2i ) * dtmn , & ekh ( i , j , k ) * ( 1 / dzh ( k ) ** 2 + dxh2i ( i ) + dy2i ) * dtmn ) ! or should I interpolate ekm to the correct position? end do end do end do call MPI_ALLREDUCE ( diffnrtotl , diffnrtot , 1 , MY_REAL , MPI_MAX , comm3d , mpierr ) if ( myid == 0 ) then write ( 6 , '(A,ES10.2)' ) 'Diffusion number:' , diffnrtot end if return end subroutine calcdiffnr !ils13, 13.08.18: currently unused, not called !> tg3315 27/02/18 - was not outputting cell Peclet number so added this to give cell Reynolds number subroutine calcreyn use modglobal , only : ib , ie , jb , je , ke , kb , dy , dxh , dzh use modfields , only : u0 , v0 , w0 use modmpi , only : myid , comm3d , mpi_sum , mpi_max , my_real , mpierr use modsubgriddata , only : ekm , ekh implicit none real reyntotl , reyntot integer :: i , j , k reyntotl = 0. reyntot = 0. do k = kb , ke do j = jb , je do i = ib , ie reyntotl = max ( reyntotl , u0 ( i , j , k ) * dxh ( i ) / ekm ( i , j , k ), v0 ( i , j , k ) * dy / ekm ( i , j , k ), & w0 ( i , j , k ) * dzh ( k ) / ekm ( i , j , k )) ! or should I interpolate ekm to the correct position? end do end do end do call MPI_ALLREDUCE ( reyntotl , reyntot , 1 , MY_REAL , MPI_MAX , comm3d , mpierr ) if ( myid == 0 ) then write ( 6 , '(A,ES10.2)' ) 'Cell Reynolds number:' , reyntot end if end subroutine calcreyn !> Checks local and total divergence subroutine chkdiv use modglobal , only : ib , ie , jb , je , ke , kb , dxf , dxfi , dy , dzf use modfields , only : u0 , v0 , w0 !,divergentie use modmpi , only : myid , comm3d , mpi_sum , mpi_max , my_real , mpierr implicit none real div , divmax , divtot real divmaxl , divtotl integer i , j , k divmax = 0. divtot = 0. divmaxl = 0. divtotl = 0. do k = kb , ke do j = jb , je do i = ib , ie div = & ( u0 ( i + 1 , j , k ) - u0 ( i , j , k ) ) * dxfi ( i ) + & ( v0 ( i , j + 1 , k ) - v0 ( i , j , k ) ) / dy + & ( w0 ( i , j , k + 1 ) - w0 ( i , j , k ) ) / dzf ( k ) !      divergentie(i,j,k)=div divmaxl = max ( divmaxl , abs ( div )) divtotl = divtotl + div * dxf ( i ) * dy * dzf ( k ) end do end do end do call MPI_ALLREDUCE ( divtotl , divtot , 1 , MY_REAL , & MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( divmaxl , divmax , 1 , MY_REAL , & MPI_MAX , comm3d , mpierr ) if ( myid == 0 ) then write ( 6 , '(A,2ES11.2)' ) 'divmax, divtot = ' , divmax , divtot end if return end subroutine chkdiv end module modchecksim","tags":"","loc":"sourcefile/modchecksim.f90.html"},{"title":"modfields.f90 – uDALES","text":"This file depends on sourcefile~~modfields.f90~~EfferentGraph sourcefile~modfields.f90 modfields.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~modfields.f90~~AfferentGraph sourcefile~modfields.f90 modfields.f90 sourcefile~modpois.f90 modpois.f90 sourcefile~modpois.f90->sourcefile~modfields.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~modpois.f90->sourcefile~modboundary.f90 sourcefile~modibm.f90 modibm.f90 sourcefile~modibm.f90->sourcefile~modfields.f90 sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~modsubgrid.f90->sourcefile~modfields.f90 sourcefile~modsubgrid.f90->sourcefile~modboundary.f90 sourcefile~advection.f90 advection.f90 sourcefile~advection.f90->sourcefile~modfields.f90 sourcefile~advec_2nd.f90 advec_2nd.f90 sourcefile~advec_2nd.f90->sourcefile~modfields.f90 sourcefile~advec_2nd.f90->sourcefile~modibm.f90 sourcefile~modboundary.f90->sourcefile~modfields.f90 sourcefile~moddriver.f90 moddriver.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~modinlet.f90 modinlet.f90 sourcefile~modboundary.f90->sourcefile~modinlet.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~modsave.f90->sourcefile~modfields.f90 sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~modstatsdump.f90->sourcefile~modfields.f90 sourcefile~modstatsdump.f90->sourcefile~modsubgrid.f90 sourcefile~modstatistics.f90 modstatistics.f90 sourcefile~modstatsdump.f90->sourcefile~modstatistics.f90 sourcefile~modchem.f90 modchem.f90 sourcefile~modchem.f90->sourcefile~modfields.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~modstartup.f90->sourcefile~modfields.f90 sourcefile~modstartup.f90->sourcefile~modpois.f90 sourcefile~modstartup.f90->sourcefile~modsubgrid.f90 sourcefile~modstartup.f90->sourcefile~modboundary.f90 sourcefile~modstartup.f90->sourcefile~moddriver.f90 sourcefile~modforces.f90 modforces.f90 sourcefile~modstartup.f90->sourcefile~modforces.f90 sourcefile~modstartup.f90->sourcefile~modinlet.f90 sourcefile~modthermodynamics.f90 modthermodynamics.f90 sourcefile~modstartup.f90->sourcefile~modthermodynamics.f90 sourcefile~modchecksim.f90 modchecksim.f90 sourcefile~modchecksim.f90->sourcefile~modfields.f90 sourcefile~moddriver.f90->sourcefile~modfields.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~modforces.f90->sourcefile~modfields.f90 sourcefile~modinlet.f90->sourcefile~modfields.f90 sourcefile~modinlet.f90->sourcefile~modsave.f90 sourcefile~tstep.f90 tstep.f90 sourcefile~tstep.f90->sourcefile~modfields.f90 sourcefile~tstep.f90->sourcefile~modchem.f90 sourcefile~scalsource.f90 scalsource.f90 sourcefile~scalsource.f90->sourcefile~modfields.f90 sourcefile~advec_upw.f90 advec_upw.f90 sourcefile~advec_upw.f90->sourcefile~modfields.f90 sourcefile~modfielddump.f90 modfielddump.f90 sourcefile~modfielddump.f90->sourcefile~modfields.f90 sourcefile~advec_kappa.f90 advec_kappa.f90 sourcefile~advec_kappa.f90->sourcefile~modfields.f90 sourcefile~modthermodynamics.f90->sourcefile~modfields.f90 sourcefile~modstatistics.f90->sourcefile~modfields.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modpois.f90 sourcefile~program.f90->sourcefile~modibm.f90 sourcefile~program.f90->sourcefile~modsubgrid.f90 sourcefile~program.f90->sourcefile~modboundary.f90 sourcefile~program.f90->sourcefile~modsave.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 sourcefile~program.f90->sourcefile~modstartup.f90 sourcefile~program.f90->sourcefile~modchecksim.f90 sourcefile~program.f90->sourcefile~modforces.f90 sourcefile~program.f90->sourcefile~modfielddump.f90 sourcefile~program.f90->sourcefile~modthermodynamics.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules modfields Source Code modfields.f90 Source Code !> \\file modfields.f90 !!  Declares, allocates and initializes the 3D fields !> !!  Declares, allocates and initializes the 3D fields !> module modfields implicit none save ! Prognostic variables real , allocatable :: worksave (:) !<   Used in POISR! real , allocatable :: um (:,:,:) !<   x-component of velocity at time step t-1 real , allocatable :: vm (:,:,:) !<   y-component of velocity at time step t-1 real , allocatable :: wm (:,:,:) !<   z-component of velocity at time step t-1 real , allocatable :: thlm (:,:,:) !<   liq. water pot. temperature at time step t-1 real , allocatable :: e12m (:,:,:) !<   turb. kin. energy at time step t-1 real , allocatable :: qtm (:,:,:) !<   total specific humidity at time step t real , allocatable , target :: u0 (:,:,:) !<   x-component of velocity at time step t real , allocatable , target :: v0 (:,:,:) !<   y-component of velocity at time step t real , allocatable , target :: w0 (:,:,:) !<   z-component of velocity at time step t real , allocatable , target :: pres0 (:,:,:) !<   pressure at time step t real , allocatable , target :: thl0 (:,:,:) !<   liq. water pot. temperature at time step t real , allocatable :: thl0h (:,:,:) !<   3d-field of theta_l at half levels for kappa scheme real , allocatable :: qt0h (:,:,:) !<  3d-field of q_tot   at half levels for kappa scheme real , allocatable :: e120 (:,:,:) !<   turb. kin. energy at time step t real , allocatable , target :: qt0 (:,:,:) !<   total specific humidity at time step t real , allocatable :: up (:,:,:) !<   tendency of um real , allocatable :: vp (:,:,:) !<   tendency of vm real , allocatable :: wp (:,:,:) !<   tendency of wm real , allocatable :: thlp (:,:,:) !<   tendency of thlm real , allocatable :: e12p (:,:,:) !<   tendency of e12m real , allocatable :: qtp (:,:,:) !<   tendency of qtm real , allocatable :: svm (:,:,:,:) !<  scalar sv(n) at time step t-1 real , allocatable , target :: sv0 (:,:,:,:) !<  scalar sv(n) at time step t real , allocatable :: svp (:,:,:,:) !<  tendency of sv(n) real , allocatable :: svpp (:,:,:,:) ! Diagnostic variables real , allocatable :: mindist (:,:,:) !< minimal distance of cell center to a wall real , allocatable :: shear (:,:,:,:) !<   wall shear (last rank indicates the type of shear componenten (uym, uyp, etc.) real , allocatable :: momfluxb (:,:,:) !< fields for the wallfluxes of total momentum real , allocatable :: tfluxb (:,:,:) !< heat real , allocatable :: qfluxb (:,:,:) !< and moisture real , allocatable :: cth (:,:,:) !< heat transfer coefficient !tg3315 added variables (statistics, masking and others) integer , allocatable :: IIc (:,:,:) !< Masking matrix for blocks at cell centres integer , allocatable :: IIu (:,:,:) !< Masking matrix for blocks at x-direction half cells integer , allocatable :: IIv (:,:,:) !< Masking matrix for blocks at y-direction half cells integer , allocatable :: IIw (:,:,:) !< Masking matrix for blocks at z-direction half cells integer , allocatable :: IIuw (:,:,:) !< Masking matrix for blocks at x-and z-direction half cells integer , allocatable :: IIvw (:,:,:) !< Masking matrix for blocks at y- and z-direction half cells integer , allocatable :: IIuv (:,:,:) !< Masking matrix for blocks at x- and y-direction half cells integer , allocatable :: IIct (:,:) !< 2-D Masking matrix for blocks at cell centre that span 1:jtot integer , allocatable :: IIwt (:,:) !< 2-D Masking matrix for blocks at z-direction half cells that span 1:jtot integer , allocatable :: IIuwt (:,:) !< 2-D Masking matrix for blocks at x- and z-direction half cells that span 1:jtot integer , allocatable :: IIut (:,:) !< 2-D Masking matrix for blocks at x-direction half cells that span 1:jtot integer , allocatable :: IIvt (:,:) !< 2-D Masking matrix for blocks at y-direction half cells that span 1:jtot integer , allocatable :: IIcs (:) !< 1-D Masking matrix for blocks at cell centres that span ib:ie and 1:jtot integer , allocatable :: IIus (:) !< 1-D Masking matrix for blocks at x-direction half cells that span ib:ie and 1:jtot integer , allocatable :: IIvs (:) !< 1-D Masking matrix for blocks at y-direction half cells that span ib:ie and 1:jtot integer , allocatable :: IIws (:) !< 1-D Masking matrix for blocks at z-direction half cells that span ib:ie and 1:jtot integer , allocatable :: IIuws (:) !< 1-D Masking matrix for blocks at x- and z-direction half cells that span ib:ie and 1:jtot integer , allocatable :: IIvws (:) !< 1-D Masking matrix for blocks at y- and z-direction half cells that span ib:ie and 1:jtot integer , allocatable :: IIuvs (:) !< 1-D Masking matrix for blocks at x- and y-direction half cells that span ib:ie and 1:jtot !  integer              :: IIbl = 1          !< Switch for if layer at kb is all blocks ! statistical fields following notation \"[statistical name][averaging directions - x,y,z,t][position in grid - i,j,k]\" real , allocatable :: uyt (:,:) real , allocatable :: uytik (:,:) real , allocatable :: vyt (:,:) real , allocatable :: wyt (:,:) real , allocatable :: wytik (:,:) real , allocatable :: thlyt (:,:) real , allocatable :: qtyt (:,:) real , allocatable :: thlytk (:,:) real , allocatable :: sca1yt (:,:) real , allocatable :: sca2yt (:,:) real , allocatable :: sca3yt (:,:) real , allocatable :: thlsgsyt (:,:) real , allocatable :: qtsgsyt (:,:) real , allocatable :: usgsyt (:,:) real , allocatable :: wsgsyt (:,:) real , allocatable :: sv1sgsyt (:,:) real , allocatable :: sv2sgsyt (:,:) real , allocatable :: sv3sgsyt (:,:) real , allocatable :: uxyt (:) real , allocatable :: vxyt (:) real , allocatable :: wxyt (:) real , allocatable :: thlxyt (:) real , allocatable :: qtxyt (:) real , allocatable :: pxyt (:) ! bss116 real , allocatable :: usgsxyt (:) real , allocatable :: thlsgsxyt (:) real , allocatable :: vsgsxyt (:) real , allocatable :: uwtik (:,:,:) real , allocatable :: wthltk (:,:,:) real , allocatable :: wqttk (:,:,:) real , allocatable :: thlthlt (:,:,:) real , allocatable :: qtqtt (:,:,:) real , allocatable :: sv1sv1t (:,:,:) real , allocatable :: sv2sv2t (:,:,:) real , allocatable :: sv3sv3t (:,:,:) real , allocatable :: sv4sv4t (:,:,:) ! real, allocatable :: sv1max(:,:,:) ! real, allocatable :: sv2max(:,:,:) ! real, allocatable :: sv3max(:,:,:) ! real, allocatable :: sv4max(:,:,:) real , allocatable :: PSSt (:,:,:) real , allocatable :: uutc (:,:,:) real , allocatable :: vvtc (:,:,:) real , allocatable :: wwtc (:,:,:) real , allocatable :: vwtjk (:,:,:) real , allocatable :: uvtij (:,:,:) real , allocatable :: utik (:,:,:) real , allocatable :: wtik (:,:,:) real , allocatable :: vtjk (:,:,:) real , allocatable :: wtjk (:,:,:) real , allocatable :: utij (:,:,:) real , allocatable :: vtij (:,:,:) real , allocatable :: wmt (:,:,:) real , allocatable :: thltk (:,:,:) real , allocatable :: qttk (:,:,:) real , allocatable :: thlt (:,:,:) real , allocatable :: utc (:,:,:) real , allocatable :: vtc (:,:,:) real , allocatable :: wtc (:,:,:) real , allocatable :: vmt (:,:,:) real , allocatable :: umt (:,:,:) real , allocatable :: sv1t (:,:,:) real , allocatable :: sv2t (:,:,:) real , allocatable :: sv3t (:,:,:) real , allocatable :: sv4t (:,:,:) real , allocatable :: sv1tk (:,:,:) real , allocatable :: sv2tk (:,:,:) real , allocatable :: sv3tk (:,:,:) real , allocatable :: sv4tk (:,:,:) real , allocatable :: wsv1tk (:,:,:) real , allocatable :: wsv2tk (:,:,:) real , allocatable :: wsv3tk (:,:,:) real , allocatable :: wsv4tk (:,:,:) real , allocatable :: sv1sgst (:,:,:) real , allocatable :: sv2sgst (:,:,:) real , allocatable :: sv3sgst (:,:,:) real , allocatable :: sv4sgst (:,:,:) real , allocatable :: qtt (:,:,:) ! bss116 real , allocatable :: pt (:,:,:) ! bss116 real , allocatable :: slice (:,:) real , allocatable :: slice2 (:,:) real , allocatable :: slice3 (:,:) real , allocatable :: slice4 (:,:) real , allocatable :: slice5 (:,:) real , allocatable :: slice6 (:,:) real , allocatable :: slice7 (:,:) real , allocatable :: slice8 (:,:) ! fields for scalar sources real , allocatable :: scar (:,:) real , allocatable :: scarl (:,:) real , allocatable :: uav (:,:,:) !<   time-averaged u-velocity real , allocatable :: vav (:,:,:) !<   time-averaged u-velocity real , allocatable :: wav (:,:,:) !<   time-averaged u-velocity real , allocatable :: thlav (:,:,:) !<   time-averaged liquid temperature real , allocatable :: qtav (:,:,:) !<   time-averaged specific humidity real , allocatable :: qlav (:,:,:) !<   time-averaged liquid water real , allocatable :: presav (:,:,:) !<   time-averaged pressure real , allocatable :: svav (:,:,:,:) !<   time-averaged scalar concentration real , allocatable :: viscratioav (:,:,:) !<   time-averaged viscosity ratio; turb viscosity / molecular viscosity real , allocatable :: umint (:,:,:) !<   um interpolated to cell-center real , allocatable :: vmint (:,:,:) !<   vm interpolated to cell-center real , allocatable :: wmint (:,:,:) !<   wm interpolated to cell-center real , allocatable :: thl2av (:,:,:) !<   time-average: liquid temperature squared real , allocatable :: ql2av (:,:,:) !<   time-average: liquid temperature squared real , allocatable :: qt2av (:,:,:) !<   time-average: liquid temperature squared real , allocatable :: sv2av (:,:,:,:) !<   time-average: scalar concentration squared real , allocatable :: uuav (:,:,:) !<   time-average: u-velocity squared real , allocatable :: vvav (:,:,:) !<   time-average: v-velocity squared real , allocatable :: wwav (:,:,:) !<   time-average: w-velocity squared real , allocatable :: uvav (:,:,:) !<   time-average: u-velocity times v-velocity real , allocatable :: uwav (:,:,:) !<   time-average: u-velocity times fluctuation real , allocatable :: vwav (:,:,:) !<   time-average: v-velocity times w-velocity real , allocatable :: thluav (:,:,:) !<   time-average: thl times u-velocity real , allocatable :: thlvav (:,:,:) !<   time-average: thl times v-velocity real , allocatable :: thlwav (:,:,:) !<   time-average: thl times w-velocity real , allocatable :: thlthlav (:,:,:) !<   time-average: thl times thl real , allocatable :: qluav (:,:,:) !<   time-average: ql times u-velocity real , allocatable :: qlvav (:,:,:) !<   time-average: ql times v-velocity real , allocatable :: qlwav (:,:,:) !<   time-average: ql times w-velocity real , allocatable :: qtuav (:,:,:) !<   time-average: qt times u-velocity real , allocatable :: qtvav (:,:,:) !<   time-average: qt times v-velocity real , allocatable :: qtwav (:,:,:) !<   time-average: qt times w-velocity real , allocatable :: svuav (:,:,:,:) !<   time-average: sv times u-velocity real , allocatable :: svvav (:,:,:,:) !<   time-average: sv times v-velocity real , allocatable :: svwav (:,:,:,:) !<   time-average: sv times w-velocity !  real, allocatable :: tekm(:,:,:)     !tekm = ekm - numol !tg3315 real , allocatable :: upupav (:,:,:) !<   time-average: u'u' real , allocatable :: vpvpav (:,:,:) !<   time-average: v'v' real , allocatable :: wpwpav (:,:,:) !<   time-average: w'w' real , allocatable :: thlpthlpav (:,:,:) !<   time-average: thl'thl' real , allocatable :: qlpqlpav (:,:,:) !<   time-average: ql'ql' real , allocatable :: qtpqtpav (:,:,:) !<   time-average: thl'thl' real , allocatable :: svpsvpav (:,:,:,:) !<   time-average: sv'sv' real , allocatable :: upvpav (:,:,:) !<   time-average: u'v' real , allocatable :: upwpav (:,:,:) !<   time-average: u'w' real , allocatable :: vpwpav (:,:,:) !<   time-average: v'w' real , allocatable :: thlpupav (:,:,:) !<   time-average: thl'u' real , allocatable :: thlpvpav (:,:,:) !<   time-average: thl'v' real , allocatable :: thlpwpav (:,:,:) !<   time-average: thl'w' real , allocatable :: qlpupav (:,:,:) !<   time-average: ql'u' real , allocatable :: qlpvpav (:,:,:) !<   time-average: ql'v' real , allocatable :: qlpwpav (:,:,:) !<   time-average: ql'w' real , allocatable :: qtpupav (:,:,:) !<   time-average: qt'u' real , allocatable :: qtpvpav (:,:,:) !<   time-average: qt'v' real , allocatable :: qtpwpav (:,:,:) !<   time-average: qt'w' real , allocatable :: svpupav (:,:,:,:) !<   time-average: sv'u' real , allocatable :: svpvpav (:,:,:,:) !<   time-average: sv'v' real , allocatable :: svpwpav (:,:,:,:) !<   time-average: sv'w' ! SGS fields real , allocatable :: uusgsav (:,:,:) !<   time-average subgrid contribution (estimate) real , allocatable :: vvsgsav (:,:,:) !<   time-average subgrid contribution (estimate) real , allocatable :: wwsgsav (:,:,:) !<   time-average subgrid contribution (estimate) real , allocatable :: uwsgsav (:,:,:) !<   time-average subgrid contribution (estimate) real , allocatable :: thlusgsav (:,:,:) !<   time-average subgrid contribution (estimate) real , allocatable :: thlwsgsav (:,:,:) !<   time-average subgrid contribution (estimate) real , allocatable :: qlusgsav (:,:,:) !<   time-average subgrid contribution (estimate) real , allocatable :: qlwsgsav (:,:,:) !<   time-average subgrid contribution (estimate) real , allocatable :: qtusgsav (:,:,:) !<   time-average subgrid contribution (estimate) real , allocatable :: qtwsgsav (:,:,:) !<   time-average subgrid contribution (estimate) real , allocatable :: svusgsav (:,:,:,:) !<   time-average subgrid contribution (estimate) real , allocatable :: svwsgsav (:,:,:,:) !<   time-average subgrid contribution (estimate) real , allocatable :: tkesgsav (:,:,:) !<   time-average subgrid turbulence kinetic energy real , allocatable :: nusgsav (:,:,:) !<   time-average subgrid viscosity ! Resolved dissipation 'terms' real , allocatable :: strain2av (:,:,:) !<   <Sij*Sij> used to compute <Sij'*Sij'> = <Sij*Sij> - <S>ij*<S>ij real , allocatable :: disssgsav (:,:,:) !<   mean subgrid dissipation: <nu_sgs*2.*Sij*Sij> !<   which is used for resolved dissipation = nu*2*<Sij'*Sij'> ! TKE budget terms: real , allocatable :: tvmx (:,:,:) !<   needed for viscous transport: <u*d/dxj(2*nu*S1j)> real , allocatable :: tvmy (:,:,:) !<   needed for viscous transport: <v*d/dxj(2*nu*S2j)> real , allocatable :: tvmz (:,:,:) !<   needed for viscous transport: <w*d/dxj(2*nu*S3j)> real , allocatable :: tpm (:,:,:) !<   needed for transport by pressure fluctuations real , allocatable :: ttmx (:,:,:) !<   needed for transport by turb. vel. fluctuations real , allocatable :: ttmy (:,:,:) !<   needed for transport by turb. vel. fluctuations real , allocatable :: ttmz (:,:,:) !<   needed for transport by turb. vel. fluctuations real , allocatable :: tsgsmx1 (:,:,:) !<   needed for transport by subgrid x = <u*d/dxj(2*nu_t*S1j)> real , allocatable :: tsgsmy1 (:,:,:) !<   needed for transport by subgrid y = <v*d/dxj(2*nu_t*S2j)> real , allocatable :: tsgsmz1 (:,:,:) !<   needed for transport by subgrid z = <w*d/dxj(2*nu_t*S3j)> real , allocatable :: tsgsmx2 (:,:,:) !<   needed for transport by subgrid x = <d/dxj(2*nu_t*S1j)> real , allocatable :: tsgsmy2 (:,:,:) !<   needed for transport by subgrid y = <d/dxj(2*nu_t*S2j)> real , allocatable :: tsgsmz2 (:,:,:) !<   needed for transport by subgrid z = <d/dxj(2*nu_t*S3j)> ! TKE budget results (written to files): real , allocatable :: t_vav (:,:,:) !<   viscous transport real , allocatable :: t_sgsav (:,:,:) !<   transport by subgrid real , allocatable :: t_pav (:,:,:) !<   transport by pressure fluctuations real , allocatable :: t_tav (:,:,:) !<   transport by by turb. vel. fluctuations real , allocatable :: p_tav (:,:,:) !<   production by shear real , allocatable :: p_bav (:,:,:) !<   production/destruction by buoyancy real , allocatable :: d_sgsav (:,:,:) !<   dissipation by subgrid real , allocatable :: tkeadv (:,:,:) !<   advection of tke ! TKE budget results (written to tkedump): !tg3315 real , allocatable :: t_v (:) !<   viscous transport real , allocatable :: t_sgs (:) !<   transport by subgrid real , allocatable :: t_p (:) !<   transport by pressurefluctuations real , allocatable :: t_t (:) !<   transport by by turb. vel. fluctuations real , allocatable :: p_t (:) !<   production by shear real , allocatable :: p_b (:) !<   production/destruction by buoyancy real , allocatable :: d_sgs (:) !<   dissipation by subgrid real , allocatable :: adv (:) !<   advection of tke real , allocatable , target :: ql0 (:,:,:) !<   liquid water content real , allocatable :: thv0h (:,:,:) !<   theta_v at half level real , allocatable :: whls (:) !<   large scale vert velocity at half levels real , allocatable :: presf (:) !<   hydrostatic pressure at full level real , allocatable :: presh (:) !<   hydrostatic pressure at half level real , allocatable :: exnf (:) !<   hydrostatic exner function at full level real , allocatable :: exnh (:) !<   hydrostatic exner function at half level real , allocatable :: thvf (:) !<   hydrostatic exner function at full level real , allocatable :: thvh (:) !<   hydrostatic exner function at half level real , allocatable :: rhof (:) !<   slab averaged density at full level real , allocatable :: qt0av (:) !<   slab averaged q_tot real , allocatable :: ql0av (:) !<   slab averaged q_liq real , allocatable :: thl0av (:) !<   slab averaged th_liq real , allocatable :: u0av (:) !<   slab averaged u real , allocatable :: v0av (:) !<   slab averaged v real , allocatable :: ug (:) !<   geostrophic u-wind real , allocatable :: vg (:) !<   geostrophic v-wind real , allocatable :: pgx (:) !<   driving pressure gradient in x, this is dp/dx [(\\Delta p) / (\\Delta x)] across one cell, already divided by \\rho -> in units of [m/s&#94;2] real , allocatable :: pgy (:) !<   driving pressure gradient in y [m/s&#94;2] real , allocatable :: dpdxl (:) !<   large scale pressure x-gradient [m/s&#94;2] real , allocatable :: dpdyl (:) !<   large scale pressure y-gradient [m/s&#94;2] real , allocatable :: dthldxls (:) !<   large scale x-gradient of th_liq real , allocatable :: dthldyls (:) !<   large scale y-gradient of th_liq real , allocatable :: dqtdxls (:) !<   large scale x-gradient of q_tot real , allocatable :: dqtdyls (:) !<   large scale y-gradient of q_tot real , allocatable :: dqtdtls (:) !<   large scale y-gradient of q_tot real , allocatable :: dudxls (:) !<   large scale x-gradient of u real , allocatable :: dudyls (:) !<   large scale y-gradient of u real , allocatable :: dvdxls (:) !<   large scale x-gradient of v real , allocatable :: dvdyls (:) !<   large scale y-gradient of v real , allocatable :: wfls (:) !<   large scale y-gradient of v real , allocatable :: ql0h (:,:,:) real , allocatable :: dthvdz (:,:,:) !<   theta_v at half level real , allocatable :: thlprof (:) !<   initial thl-profile real , allocatable :: qtprof (:) !<   initial qt-profile real , allocatable :: uprof (:) !<   initial u-profile real , allocatable :: vprof (:) !<   initial v-profile real , allocatable :: e12prof (:) !<   initial subgrid TKE profile real , allocatable :: sv0av (:,:) !<   slab average of sv(n) real , allocatable :: svprof (:,:) !<   initial sv(n)-profile real , allocatable :: qlprof (:) real , allocatable :: thlpcar (:) !< prescribed radiatively forced thl tendency real , allocatable :: SW_up_TOA (:,:), SW_dn_TOA (:,:), LW_up_TOA (:,:), LW_dn_TOA (:,:) real , allocatable :: uout (:) !< height average outlet velocity (used in convective outflow BC) real , allocatable :: wout (:) !< j-averaged top velocity real , allocatable :: friction (:) !< skin-friction coeff: from y-line-averaged shear real , allocatable :: momthick (:) !< momentum thickness: y-line average real , allocatable :: displthick (:) !< displacement thickness: y-line average real :: uouttot !< area-averaged outflow velocity (used in convective outflow BC) real :: wouttot !< area-averaveraged top velocity real :: udef real :: vdef real , allocatable :: vout (:) real :: vouttot real :: thlsrcdt ! thlsrc -> thlsrcdt is used to solve 1-order ODE for thlsrc real :: dgdt ! g = dp/dx -> dgdt is used to solve 1-order ODE for dpdx real :: dpdx = 0. ! dpdx given in namoptions real :: uoutarea !< area of domain u-outlet real :: voutarea !< area of domain v-outlet real :: fluidvol !< fluid volume (excluding blocks) character ( 80 ), allocatable :: ncname (:,:) character ( 80 ), allocatable :: ncstaty (:,:) character ( 80 ), allocatable :: ncstatyt (:,:) character ( 80 ), allocatable :: ncstattke (:,:) character ( 80 ), allocatable :: ncstatxy (:,:) character ( 80 ), allocatable :: ncstatxyt (:,:) character ( 80 ), allocatable :: ncstatslice (:,:) character ( 80 ), allocatable :: ncstatt (:,:) integer , allocatable :: wall (:,:,:,:) !< wall(ic,jc,kc,1-5) gives the global indices of the wall closest to cell center ic,jc,kc. The 4th and 5th integer gives the corresponding shear components contains !> Allocate and initialize the prognostic variables subroutine initfields use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , nsv , jtot , imax , jmax , kmax ,& ihc , jhc , khc !, iadv_kappa,iadv_sv ! Allocation of prognostic variables implicit none allocate ( worksave ( 2 * imax * jmax * kmax )) allocate ( um ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( vm ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( wm ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( thlm ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( e12m ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qtm ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( u0 ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( v0 ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( w0 ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( pres0 ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( thl0 ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( thl0h ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qt0h ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( e120 ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qt0 ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( ql0 ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( up ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( vp ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( wp ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( thlp ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( e12p ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( qtp ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( svm ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb - khc : ke + khc , nsv )) allocate ( sv0 ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb - khc : ke + khc , nsv )) allocate ( svp ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc , nsv )) allocate ( svpp ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc , 1 )) ! Allocation of diagnostic variables allocate ( mindist ( ib : ie , jb : je , kb : ke )) allocate ( thv0h ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( whls ( kb : ke + kh )) allocate ( presf ( kb : ke + kh )) allocate ( presh ( kb : ke + kh )) allocate ( exnf ( kb : ke + kh )) allocate ( exnh ( kb : ke + kh )) allocate ( thvf ( kb : ke + kh )) allocate ( thvh ( kb : ke + kh )) allocate ( rhof ( kb : ke + kh )) allocate ( qt0av ( kb : ke + kh )) allocate ( ql0av ( kb : ke + kh )) allocate ( thl0av ( kb : ke + kh )) allocate ( u0av ( kb : ke + kh )) allocate ( v0av ( kb : ke + kh )) allocate ( ug ( kb : ke + kh )) allocate ( vg ( kb : ke + kh )) allocate ( pgx ( kb : ke + kh )) allocate ( pgy ( kb : ke + kh )) allocate ( dpdxl ( kb : ke + kh )) allocate ( dpdyl ( kb : ke + kh )) allocate ( dthldxls ( kb : ke + kh )) allocate ( dthldyls ( kb : ke + kh )) allocate ( dqtdxls ( kb : ke + kh )) allocate ( dqtdyls ( kb : ke + kh )) allocate ( dqtdtls ( kb : ke + kh )) allocate ( dudxls ( kb : ke + kh )) allocate ( dudyls ( kb : ke + kh )) allocate ( dvdxls ( kb : ke + kh )) allocate ( dvdyls ( kb : ke + kh )) allocate ( wfls ( kb : ke + kh )) allocate ( ql0h ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( dthvdz ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( thlprof ( kb : ke + kh )) allocate ( qtprof ( kb : ke + kh )) allocate ( qlprof ( kb : ke + kh )) allocate ( uprof ( kb : ke + kh )) allocate ( vprof ( kb : ke + kh )) allocate ( e12prof ( kb : ke + kh )) allocate ( sv0av ( kb : ke + khc , nsv )) allocate ( svprof ( kb : ke + kh , nsv )) allocate ( thlpcar ( kb : ke + kh )) allocate ( uout ( kb : ke )) ! height average outlet velocity (used in convective outflow BC) allocate ( vout ( kb : ke )) allocate ( wout ( ib : ie )) ! j -averaged top velocity allocate ( friction ( ib : ie )) ! line-averaged (along j) skin friction allocate ( momthick ( ib : ie )) ! line-averaged (along j) momentum thickness allocate ( displthick ( ib : ie )) ! line-averaged (along j) displacement thickness allocate ( SW_up_TOA ( ib - ih : ie + ih , jb - jh : je + jh )) allocate ( SW_dn_TOA ( ib - ih : ie + ih , jb - jh : je + jh )) allocate ( LW_up_TOA ( ib - ih : ie + ih , jb - jh : je + jh )) allocate ( LW_dn_TOA ( ib - ih : ie + ih , jb - jh : je + jh )) ! allocate averaged variables allocate ( uav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( vav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( wav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( thlav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qtav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qlav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( presav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( svav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh , 1 : nsv )) allocate ( viscratioav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( IIc ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc )) allocate ( IIu ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc )) allocate ( IIv ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc )) allocate ( IIw ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc )) allocate ( IIuw ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc )) allocate ( IIvw ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc )) allocate ( IIuv ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc )) allocate ( IIct ( ib : ie , kb : ke )) allocate ( IIwt ( ib : ie , kb : ke )) allocate ( IIuwt ( ib : ie , kb : ke )) allocate ( IIut ( ib : ie , kb : ke )) allocate ( IIvt ( ib : ie , kb : ke )) allocate ( IIcs ( kb : ke + khc )) allocate ( IIus ( kb : ke + khc )) allocate ( IIvs ( kb : ke + khc )) allocate ( IIws ( kb : ke + khc )) allocate ( IIuws ( kb : ke + khc )) allocate ( IIvws ( kb : ke + khc )) allocate ( IIuvs ( kb : ke + khc )) allocate ( uyt ( ib : ie , kb : ke )) allocate ( uytik ( ib : ie , kb : ke )) allocate ( vyt ( ib : ie , kb : ke )) allocate ( wyt ( ib : ie , kb : ke )) allocate ( wytik ( ib : ie , kb : ke )) allocate ( thlyt ( ib : ie , kb : ke )) allocate ( qtyt ( ib : ie , kb : ke )) allocate ( thlytk ( ib : ie , kb : ke )) allocate ( sca1yt ( ib : ie , kb : ke )) allocate ( sca2yt ( ib : ie , kb : ke )) allocate ( sca3yt ( ib : ie , kb : ke )) allocate ( usgsyt ( ib : ie , kb : ke )) allocate ( thlsgsyt ( ib : ie , kb : ke )) allocate ( qtsgsyt ( ib : ie , kb : ke )) allocate ( wsgsyt ( ib : ie , kb : ke )) allocate ( sv1sgsyt ( ib : ie , kb : ke )) allocate ( sv2sgsyt ( ib : ie , kb : ke )) allocate ( sv3sgsyt ( ib : ie , kb : ke )) allocate ( uxyt ( kb : ke + kh )) allocate ( vxyt ( kb : ke + kh )) allocate ( wxyt ( kb : ke + kh )) allocate ( thlxyt ( kb : ke + kh )) allocate ( qtxyt ( kb : ke + kh )) allocate ( pxyt ( kb : ke + kh )) allocate ( usgsxyt ( kb : ke + kh )) allocate ( thlsgsxyt ( kb : ke + kh )) allocate ( vsgsxyt ( kb : ke + kh )) allocate ( uwtik ( ib : ie , jb : je , kb : ke + kh )) allocate ( wthltk ( ib : ie , jb : je , kb : ke + kh )) allocate ( wqttk ( ib : ie , jb : je , kb : ke + kh )) allocate ( thlthlt ( ib : ie , jb : je , kb : ke + kh )) allocate ( qtqtt ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv1sv1t ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv2sv2t ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv3sv3t ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv4sv4t ( ib : ie , jb : je , kb : ke + kh )) ! allocate(sv1max(ib:ie,jb:je,kb:ke+kh)) ! allocate(sv2max(ib:ie,jb:je,kb:ke+kh)) ! allocate(sv3max(ib:ie,jb:je,kb:ke+kh)) ! allocate(sv4max(ib:ie,jb:je,kb:ke+kh)) allocate ( PSSt ( ib : ie , jb : je , kb : ke + kh )) allocate ( uutc ( ib : ie , jb : je , kb : ke + kh )) allocate ( vvtc ( ib : ie , jb : je , kb : ke + kh )) allocate ( wwtc ( ib : ie , jb : je , kb : ke + kh )) allocate ( vwtjk ( ib : ie , jb : je , kb : ke + kh )) allocate ( uvtij ( ib : ie , jb : je , kb : ke + kh )) allocate ( utik ( ib : ie , jb : je , kb : ke + kh )) allocate ( wtik ( ib : ie , jb : je , kb : ke + kh )) allocate ( vtjk ( ib : ie , jb : je , kb : ke + kh )) allocate ( wtjk ( ib : ie , jb : je , kb : ke + kh )) allocate ( utij ( ib : ie , jb : je , kb : ke + kh )) allocate ( vtij ( ib : ie , jb : je , kb : ke + kh )) allocate ( wmt ( ib : ie , jb : je , kb : ke + kh )) allocate ( thltk ( ib : ie , jb : je , kb : ke + kh )) allocate ( qttk ( ib : ie , jb : je , kb : ke + kh )) allocate ( thlt ( ib : ie , jb : je , kb : ke + kh )) allocate ( utc ( ib : ie , jb : je , kb : ke + kh )) allocate ( vtc ( ib : ie , jb : je , kb : ke + kh )) allocate ( wtc ( ib : ie , jb : je , kb : ke + kh )) allocate ( umt ( ib : ie , jb : je , kb : ke + kh )) allocate ( vmt ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv1t ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv2t ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv3t ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv4t ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv1tk ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv2tk ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv3tk ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv4tk ( ib : ie , jb : je , kb : ke + kh )) allocate ( wsv1tk ( ib : ie , jb : je , kb : ke + kh )) allocate ( wsv2tk ( ib : ie , jb : je , kb : ke + kh )) allocate ( wsv3tk ( ib : ie , jb : je , kb : ke + kh )) allocate ( wsv4tk ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv1sgst ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv2sgst ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv3sgst ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv4sgst ( ib : ie , jb : je , kb : ke + kh )) allocate ( qtt ( ib : ie , jb : je , kb : ke + kh )) allocate ( pt ( ib : ie , jb : je , kb : ke + kh )) allocate ( slice ( ib : ie , jb : je )) allocate ( slice2 ( ib : ie , jb : je )) allocate ( slice3 ( ib : ie , jb : je )) allocate ( slice4 ( ib : ie , jb : je )) allocate ( slice5 ( ib : ie , jb : je )) allocate ( slice6 ( ib : ie , jb : je )) allocate ( slice7 ( ib : ie , jb : je )) allocate ( slice8 ( ib : ie , jb : je )) allocate ( scar ( ib : ie , jb : jtot )) allocate ( scarl ( ib : ie , jb : je )) allocate ( thl2av ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( ql2av ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qt2av ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( sv2av ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh , 1 : nsv )) allocate ( umint ( ib : ie , jb : je , kb : ke )) allocate ( vmint ( ib : ie , jb : je , kb : ke )) allocate ( wmint ( ib : ie , jb : je , kb : ke )) allocate ( uuav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( vvav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( wwav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( uvav ( ib : ie + ih , jb : je + jh , kb : ke )) allocate ( uwav ( ib : ie + ih , jb : je , kb : ke + kh )) allocate ( vwav ( ib : ie , jb : je + jh , kb : ke + kh )) allocate ( thluav ( ib : ie + ih , jb : je , kb : ke )) allocate ( thlvav ( ib : ie , jb : je + jh , kb : ke )) allocate ( thlwav ( ib : ie , jb : je , kb : ke + kh )) allocate ( thlthlav ( ib : ie , jb : je , kb : ke + kh )) allocate ( qluav ( ib : ie + ih , jb : je , kb : ke )) allocate ( qlvav ( ib : ie , jb : je + jh , kb : ke )) allocate ( qlwav ( ib : ie , jb : je , kb : ke + kh )) allocate ( qtuav ( ib : ie + ih , jb : je , kb : ke )) allocate ( qtvav ( ib : ie , jb : je + jh , kb : ke )) allocate ( qtwav ( ib : ie , jb : je , kb : ke + kh )) allocate ( svuav ( ib : ie + ih , jb : je , kb : ke , 1 : nsv )) allocate ( svvav ( ib : ie , jb : je + jh , kb : ke , 1 : nsv )) allocate ( svwav ( ib : ie , jb : je , kb : ke + kh , 1 : nsv )) ! <x'x> ( = <xx> -<x><x> ) allocate ( upupav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( vpvpav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( wpwpav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( upvpav ( ib : ie + ih , jb : je + jh , kb : ke )) allocate ( upwpav ( ib : ie + ih , jb : je , kb : ke + kh )) allocate ( vpwpav ( ib : ie , jb : je + jh , kb : ke + kh )) allocate ( thlpthlpav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( thlpupav ( ib : ie + ih , jb : je , kb : ke )) allocate ( thlpvpav ( ib : ie , jb : je + jh , kb : ke )) allocate ( thlpwpav ( ib : ie , jb : je , kb : ke + kh )) allocate ( qlpqlpav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qlpupav ( ib : ie + ih , jb : je , kb : ke )) allocate ( qlpvpav ( ib : ie , jb : je + jh , kb : ke )) allocate ( qlpwpav ( ib : ie , jb : je , kb : ke + kh )) allocate ( qtpqtpav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qtpupav ( ib : ie + ih , jb : je , kb : ke )) allocate ( qtpvpav ( ib : ie , jb : je + jh , kb : ke )) allocate ( qtpwpav ( ib : ie , jb : je , kb : ke + kh )) allocate ( svpsvpav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh , 1 : nsv )) allocate ( svpupav ( ib : ie + ih , jb : je , kb : ke , 1 : nsv )) allocate ( svpvpav ( ib : ie , jb : je + jh , kb : ke , 1 : nsv )) allocate ( svpwpav ( ib : ie , jb : je , kb : ke + kh , 1 : nsv )) ! Subgrid allocate ( uusgsav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( vvsgsav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( wwsgsav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( uwsgsav ( ib : ie + ih , jb : je , kb : ke + kh )) allocate ( thlusgsav ( ib : ie + ih , jb : je , kb : ke )) allocate ( thlwsgsav ( ib : ie , jb : je , kb : ke + kh )) allocate ( qlusgsav ( ib : ie + ih , jb : je , kb : ke )) allocate ( qlwsgsav ( ib : ie , jb : je , kb : ke + kh )) allocate ( qtusgsav ( ib : ie + ih , jb : je , kb : ke )) allocate ( qtwsgsav ( ib : ie , jb : je , kb : ke + kh )) allocate ( tkesgsav ( ib : ie , jb : je , kb : ke )) allocate ( svusgsav ( ib : ie + ih , jb : je , kb : ke , 1 : nsv )) allocate ( svwsgsav ( ib : ie , jb : je , kb : ke + kh , 1 : nsv )) allocate ( nusgsav ( ib : ie , jb : je , kb : ke )) ! resolved dissipation allocate ( strain2av ( ib : ie , jb : je , kb : ke )) allocate ( disssgsav ( ib : ie , jb : je , kb : ke )) ! TKE budget terms allocate ( tvmx ( ib : ie + 1 , jb : je , kb : ke )) allocate ( tvmy ( ib : ie , jb - 1 : je + 1 , kb : ke )) allocate ( tvmz ( ib : ie , jb : je , kb : ke + 1 )) allocate ( tpm ( ib : ie , jb : je , kb : ke )) allocate ( ttmx ( ib : ie + 1 , jb : je , kb : ke )) allocate ( ttmy ( ib : ie , jb - 1 : je + 1 , kb : ke )) allocate ( ttmz ( ib : ie , jb : je , kb : ke + 1 )) allocate ( tsgsmx1 ( ib : ie + 1 , jb : je , kb : ke )) allocate ( tsgsmy1 ( ib : ie , jb - 1 : je + 1 , kb : ke )) allocate ( tsgsmz1 ( ib : ie , jb : je , kb : ke + 1 )) allocate ( tsgsmx2 ( ib : ie + 1 , jb : je , kb : ke )) allocate ( tsgsmy2 ( ib : ie , jb - 1 : je + 1 , kb : ke )) allocate ( tsgsmz2 ( ib : ie , jb : je , kb : ke + 1 )) allocate ( t_pav ( ib : ie , jb : je , kb : ke )) allocate ( t_vav ( ib : ie , jb : je , kb : ke )) allocate ( t_tav ( ib : ie , jb : je , kb : ke )) allocate ( t_sgsav ( ib : ie , jb : je , kb : ke )) allocate ( p_tav ( ib : ie , jb : je , kb : ke )) allocate ( p_bav ( ib : ie , jb : je , kb : ke )) allocate ( d_sgsav ( ib : ie , jb : je , kb : ke )) allocate ( tkeadv ( ib : ie , jb : je , kb : ke )) allocate ( t_p ( kb : ke )) allocate ( t_v ( kb : ke )) allocate ( t_t ( kb : ke )) allocate ( t_sgs ( kb : ke )) allocate ( p_t ( kb : ke )) allocate ( p_b ( kb : ke )) allocate ( d_sgs ( kb : ke )) allocate ( adv ( kb : ke )) ! allocate wall shear-stress terms (immersed boundaries) allocate ( shear ( ib - 1 : ie + 1 , jb - 1 : je + 1 , kb - 1 : ke + 1 , 0 : 12 )) ! halo is set to 1 !     allocate(shear(ib:ie,jb-1:je+1,kb:ke,12) allocate ( momfluxb ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) !  write(*,*) \"allocate momfluxb, indeces:\",ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh allocate ( tfluxb ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qfluxb ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( cth ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) momfluxb = 0. ; tfluxb = 0. ; qfluxb = 0. ; cth = 0. allocate ( wall ( ib : ie , jb : je , kb : ke , 5 )) ! um = 0. ; u0 = 0. ; up = 0. vm = 0. ; v0 = 0. ; vp = 0. wm = 0. ; w0 = 0. ; wp = 0. pres0 = 0. ; thlm = 0. ; thl0 = 0. ; thlp = 0. qtm = 0. ; qt0 = 0. ; qtp = 0. e12m = 0. ; e120 = 0. ; e12p = 0. svm = 0. ; sv0 = 0. ; svp = 0. ; svpp = 0. ql0 = 0. ; qt0h = 0. ; thv0h = 0. ; thl0h = 0. ; mindist = 1.0e10 ; presf = 0. ; presh = 0. ; exnf = 1. ; exnh = 0. ; thvf = 0. ; thvh = 0. ; rhof = 0. ! OG !Exner function should be called in startup and just be initialised here qt0av = 0. ; ql0av = 0. ; thl0av = 0. ; u0av = 0. ; v0av = 0. ; sv0av = 0. thlprof = 0. ; qtprof = 0. ; qlprof = 0. ; uprof = 0. ; vprof = 0. ; e12prof = 0. ; svprof = 0. ug = 0. ; vg = 0. ; pgx = 0. ; pgy = 0. ; dpdxl = 0. ; dpdyl = 0. ; wfls = 0. ; whls = 0. ; thlpcar = 0. ; uout = 0. ; vout = 0. ; wout = 0. ; udef = 0. ; vdef = 0. ; uouttot = 0. ; wouttot = 0. ; vouttot = 0. dthldxls = 0. ; dthldyls = 0. ; dqtdxls = 0. ; dqtdyls = 0. ; dudxls = 0. ; dudyls = 0. ; dvdxls = 0. ; dvdyls = 0. dthvdz = 0. SW_up_TOA = 0. ; SW_dn_TOA = 0. ; LW_up_TOA = 0. ; LW_dn_TOA = 0. uyt = 0. ; uytik = 0. ; vyt = 0. ; wyt = 0. ; wytik = 0. ; thlyt = 0. ; qtyt = 0. ; thlytk = 0. ; sca1yt = 0. ; sca2yt = 0. ; sca3yt = 0. ; thlsgsyt = 0. ; wsgsyt = 0. ; qtsgsyt = 0. ; sv1sgsyt = 0. ; sv2sgsyt = 0. ; sv3sgsyt = 0. usgsyt = 0. uxyt = 0. ; vxyt = 0. ; wxyt = 0. ; thlxyt = 0. ; qtxyt = 0. ; pxyt = 0. ; usgsxyt = 0. ; vsgsxyt = 0. ; thlsgsxyt = 0. ; uwtik = 0. ; wthltk = 0. ; wqttk = 0. ; thlthlt = 0. ; qtqtt = 0. ; sv1sv1t = 0. ; sv2sv2t = 0. ; sv3sv3t = 0. ; sv4sv4t = 0. ; uutc = 0. ; vvtc = 0. ; wwtc = 0. ; vwtjk = 0. ; uvtij = 0. ; utik = 0. ; wtik = 0. ; wtjk = 0. ; vtjk = 0. ; utij = 0. ; vtij = 0. ; wmt = 0. ; thltk = 0. ; qttk = 0. ; thlt = 0. ; slice = 0. ; slice2 = 0. ; slice3 = 0. ; slice4 = 0. ; slice5 = 0. ; utc = 0. ; vtc = 0. ; wtc = 0. slice6 = 0. ; slice7 = 0. ; slice8 = 0. ; umt = 0. ; vmt = 0. ; sv1t = 0. ; sv2t = 0. ; sv3t = 0. ; sv4t = 0. ; sv1tk = 0. ; sv2tk = 0. ; sv3tk = 0. ; sv4tk = 0. wsv1tk = 0. ; wsv2tk = 0. ; wsv3tk = 0. ; wsv4tk = 0. ; sv1sgst = 0. ; sv2sgst = 0. ; sv3sgst = 0. ; sv4sgst = 0. ; qtt = 0. ; pt = 0. PSSt = 0. !sv1max = 0.; sv2max = 0.; sv3max = 0.; sv4max = 0. scar = 0. ; scarl = 0. IIc = 1 ; IIu = 1 ; IIv = 1 ; IIct = 1 ; IIw = 1 ; IIuw = 1 ; IIvw = 1 ; IIuwt = 1 ; IIut = 1 ; IIvt = 1 ; IIwt = 1 ; IIcs = 1 ; IIus = 1 ; IIvs = 1 ; IIws = 1 ; IIuws = 1 ; IIvws = 1 ; IIuw = 1 ; IIuvs = 1 uav = 0. ; vav = 0. ; wav = 0. ; thlav = 0. ; qtav = 0. ; svav = 0. ; viscratioav = 0. ; uuav = 0. ; vvav = 0. wwav = 0. ; uvav = 0. ; uwav = 0. ; vwav = 0. ; sv2av = 0. ; thl2av = 0. ; ql2av = 0. ; qt2av = 0. ; presav = 0. thluav = 0. ; thlvav = 0. ; thlwav = 0. ; thlthlav = 0. ; svuav = 0. ; svvav = 0. ; svwav = 0. shear = 0. upupav = 0. ; vpvpav = 0. ; wpwpav = 0. ; thlpthlpav = 0. ; qlpqlpav = 0. ; qtpqtpav = 0. ; svpsvpav = 0. ; upvpav = 0. ; upwpav = 0. ; vpwpav = 0. thlpupav = 0. ; thlpvpav = 0. ; thlpwpav = 0. ; qlpupav = 0. ; qlpvpav = 0. ; qlpwpav = 0. ; qtpwpav = 0. ; qtpvpav = 0. ; qtpupav = 0. ; svpupav = 0. ; svpvpav = 0. ; svpwpav = 0. umint = 0. ; vmint = 0. ; wmint = 0. ! SGS uusgsav = 0. ; vvsgsav = 0. ; wwsgsav = 0. ; uwsgsav = 0. ; thlusgsav = 0. ; thlwsgsav = 0. ; qlusgsav = 0. ; qlwsgsav = 0. ; qtwsgsav = 0. ; qtusgsav = 0. ; svusgsav = 0. ; svwsgsav = 0. ; tkesgsav = 0. ; nusgsav = 0. ! Resolved dissipation strain2av = 0. ! Subgrid dissipation disssgsav = 0. ! TKE budget t_vav = 0. ; tvmx = 0. ; tvmy = 0. ; tvmz = 0. ; tpm = 0. ; ttmx = 0. ; ttmy = 0. ; ttmz = 0. ; t_sgsav = 0. ; p_tav = 0. tsgsmx1 = 0. ; tsgsmy1 = 0. ; tsgsmz1 = 0. ; tsgsmx2 = 0. ; tsgsmy2 = 0. ; tsgsmz2 = 0. t_pav = 0. ; t_tav = 0. ; p_bav = 0. ; d_sgsav = 0. ; tkeadv = 0. ; t_p = 0. ; t_v = 0. ; t_t = 0. ; t_sgs = 0. ; p_t = 0. ; p_b = 0. ; d_sgs = 0. ; adv = 0. ! domain fluid volume and area calculations uoutarea = 0. ; voutarea = 0. ; fluidvol = 0. end subroutine initfields !> Deallocate the fields subroutine exitfields implicit none deallocate ( um , vm , wm , thlm , e12m , qtm , u0 , v0 , w0 , pres0 , thl0 , thl0h , qt0h , e120 , qt0 ) deallocate ( up , vp , wp , thlp , e12p , qtp ) deallocate ( svm , sv0 , svp , svpp ) deallocate ( ql0 , ql0h , thv0h , dthvdz , whls , presf , presh , exnf , exnh , thvf , thvh , rhof , qt0av , ql0av , thl0av , u0av , v0av ) deallocate ( ug , vg , pgx , pgy , dpdxl , dpdyl , dthldxls , dthldyls , dqtdxls , dqtdyls , dqtdtls , dudxls , dudyls , dvdxls , dvdyls , wfls ) deallocate ( thlprof , qtprof , uprof , vprof , e12prof , sv0av , svprof ) deallocate ( thlpcar ) deallocate ( momfluxb , tfluxb , qfluxb , cth ) deallocate ( SW_up_TOA , SW_dn_TOA , LW_up_TOA , LW_dn_TOA ) end subroutine exitfields end module modfields","tags":"","loc":"sourcefile/modfields.f90.html"},{"title":"modEB.f90 – uDALES","text":"This file depends on sourcefile~~modeb.f90~~EfferentGraph sourcefile~modeb.f90 modEB.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modeb.f90->sourcefile~modglobal.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modeb.f90->sourcefile~modmpi.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~modeb.f90->sourcefile~initfac.f90 sourcefile~modstat_nc.f90 modstat_nc.f90 sourcefile~modeb.f90->sourcefile~modstat_nc.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 sourcefile~modstat_nc.f90->sourcefile~modglobal.f90 sourcefile~modstat_nc.f90->sourcefile~modmpi.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~modeb.f90~~AfferentGraph sourcefile~modeb.f90 modEB.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modeb.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules modEB Source Code modEB.f90 Source Code !!> \\file modEB.f90 !!!  Energy balance on facets ! !> !!  \\author Ivo Suter ! ! module modEB use modglobal implicit none public :: EB , initEB , intqH , updateGR integer :: nstatT = 2 , nstatEB = 5 , ncidT , ncidEB , nrecT = 0 , nrecEB = 0 character ( 80 ), allocatable :: ncstatT (:,:), ncstatEB (:,:) character ( 80 ) :: Tname = \"facT.xxx.nc\" , EBname = 'facEB.xxx.nc' character ( 80 ), dimension ( 1 , 4 ) :: tncstatT , tncstatEB real , allocatable :: varsT (:,:,:), varsEB (:,:) save contains !functions to invert matrices pure function matinv3 ( A ) result ( B ) !pure makes sure that no variable outside the function can possibly be changed !! calculates the inverse of a 3×3 matrix. real , intent ( in ) :: A ( 3 , 3 ) !! matrix real :: B ( 3 , 3 ) !! inverse matrix real :: detinv !inverse determinant of the matrix detinv = 1 / ( A ( 1 , 1 ) * A ( 2 , 2 ) * A ( 3 , 3 ) - A ( 1 , 1 ) * A ( 2 , 3 ) * A ( 3 , 2 ) & - A ( 1 , 2 ) * A ( 2 , 1 ) * A ( 3 , 3 ) + A ( 1 , 2 ) * A ( 2 , 3 ) * A ( 3 , 1 ) & + A ( 1 , 3 ) * A ( 2 , 1 ) * A ( 3 , 2 ) - A ( 1 , 3 ) * A ( 2 , 2 ) * A ( 3 , 1 )) !inverse of the matrix B ( 1 , 1 ) = + detinv * ( A ( 2 , 2 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 2 )) B ( 2 , 1 ) = - detinv * ( A ( 2 , 1 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 1 )) B ( 3 , 1 ) = + detinv * ( A ( 2 , 1 ) * A ( 3 , 2 ) - A ( 2 , 2 ) * A ( 3 , 1 )) B ( 1 , 2 ) = - detinv * ( A ( 1 , 2 ) * A ( 3 , 3 ) - A ( 1 , 3 ) * A ( 3 , 2 )) B ( 2 , 2 ) = + detinv * ( A ( 1 , 1 ) * A ( 3 , 3 ) - A ( 1 , 3 ) * A ( 3 , 1 )) B ( 3 , 2 ) = - detinv * ( A ( 1 , 1 ) * A ( 3 , 2 ) - A ( 1 , 2 ) * A ( 3 , 1 )) B ( 1 , 3 ) = + detinv * ( A ( 1 , 2 ) * A ( 2 , 3 ) - A ( 1 , 3 ) * A ( 2 , 2 )) B ( 2 , 3 ) = - detinv * ( A ( 1 , 1 ) * A ( 2 , 3 ) - A ( 1 , 3 ) * A ( 2 , 1 )) B ( 3 , 3 ) = + detinv * ( A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 )) end function pure function matinv4 ( A ) result ( B ) !! calculates the inverse of a 4×4 matrix. real , intent ( in ) :: A ( 4 , 4 ) !! matrix real :: B ( 4 , 4 ) !! inverse matrix real :: detinv !inverse determinant of the matrix detinv = & 1 / ( A ( 1 , 1 ) * ( A ( 2 , 2 ) * ( A ( 3 , 3 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 3 )) + A ( 2 , 3 ) * ( A ( 3 , 4 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 4 )) + A ( 2 , 4 ) * ( A ( 3 , 2 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 2 )))& - A ( 1 , 2 ) * ( A ( 2 , 1 ) * ( A ( 3 , 3 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 3 )) + A ( 2 , 3 ) * ( A ( 3 , 4 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 4 )) + A ( 2 , 4 ) * ( A ( 3 , 1 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 1 )))& + A ( 1 , 3 ) * ( A ( 2 , 1 ) * ( A ( 3 , 2 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 2 )) + A ( 2 , 2 ) * ( A ( 3 , 4 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 4 )) + A ( 2 , 4 ) * ( A ( 3 , 1 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 1 )))& - A ( 1 , 4 ) * ( A ( 2 , 1 ) * ( A ( 3 , 2 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 2 )) + A ( 2 , 2 ) * ( A ( 3 , 3 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 3 )) + A ( 2 , 3 ) * ( A ( 3 , 1 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 1 )))) !inverse of the matrix B ( 1 , 1 ) = detinv * ( A ( 2 , 2 ) * ( A ( 3 , 3 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 3 )) + A ( 2 , 3 ) * ( A ( 3 , 4 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 4 )) + A ( 2 , 4 ) * ( A ( 3 , 2 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 2 ))) B ( 2 , 1 ) = detinv * ( A ( 2 , 1 ) * ( A ( 3 , 4 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 4 )) + A ( 2 , 3 ) * ( A ( 3 , 1 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 1 )) + A ( 2 , 4 ) * ( A ( 3 , 3 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 3 ))) B ( 3 , 1 ) = detinv * ( A ( 2 , 1 ) * ( A ( 3 , 2 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 2 )) + A ( 2 , 2 ) * ( A ( 3 , 4 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 4 )) + A ( 2 , 4 ) * ( A ( 3 , 1 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 1 ))) B ( 4 , 1 ) = detinv * ( A ( 2 , 1 ) * ( A ( 3 , 3 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 3 )) + A ( 2 , 2 ) * ( A ( 3 , 1 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 1 )) + A ( 2 , 3 ) * ( A ( 3 , 2 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 2 ))) B ( 1 , 2 ) = detinv * ( A ( 1 , 2 ) * ( A ( 3 , 4 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 4 )) + A ( 1 , 3 ) * ( A ( 3 , 2 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 2 )) + A ( 1 , 4 ) * ( A ( 3 , 3 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 3 ))) B ( 2 , 2 ) = detinv * ( A ( 1 , 1 ) * ( A ( 3 , 3 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 3 )) + A ( 1 , 3 ) * ( A ( 3 , 4 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 4 )) + A ( 1 , 4 ) * ( A ( 3 , 1 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 1 ))) B ( 3 , 2 ) = detinv * ( A ( 1 , 1 ) * ( A ( 3 , 4 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 4 )) + A ( 1 , 2 ) * ( A ( 3 , 1 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 1 )) + A ( 1 , 4 ) * ( A ( 3 , 2 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 2 ))) B ( 4 , 2 ) = detinv * ( A ( 1 , 1 ) * ( A ( 3 , 2 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 2 )) + A ( 1 , 2 ) * ( A ( 3 , 3 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 3 )) + A ( 1 , 3 ) * ( A ( 3 , 1 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 1 ))) B ( 1 , 3 ) = detinv * ( A ( 1 , 2 ) * ( A ( 2 , 3 ) * A ( 4 , 4 ) - A ( 2 , 4 ) * A ( 4 , 3 )) + A ( 1 , 3 ) * ( A ( 2 , 4 ) * A ( 4 , 2 ) - A ( 2 , 2 ) * A ( 4 , 4 )) + A ( 1 , 4 ) * ( A ( 2 , 2 ) * A ( 4 , 3 ) - A ( 2 , 3 ) * A ( 4 , 2 ))) B ( 2 , 3 ) = detinv * ( A ( 1 , 1 ) * ( A ( 2 , 4 ) * A ( 4 , 3 ) - A ( 2 , 3 ) * A ( 4 , 4 )) + A ( 1 , 3 ) * ( A ( 2 , 1 ) * A ( 4 , 4 ) - A ( 2 , 4 ) * A ( 4 , 1 )) + A ( 1 , 4 ) * ( A ( 2 , 3 ) * A ( 4 , 1 ) - A ( 2 , 1 ) * A ( 4 , 3 ))) B ( 3 , 3 ) = detinv * ( A ( 1 , 1 ) * ( A ( 2 , 2 ) * A ( 4 , 4 ) - A ( 2 , 4 ) * A ( 4 , 2 )) + A ( 1 , 2 ) * ( A ( 2 , 4 ) * A ( 4 , 1 ) - A ( 2 , 1 ) * A ( 4 , 4 )) + A ( 1 , 4 ) * ( A ( 2 , 1 ) * A ( 4 , 2 ) - A ( 2 , 2 ) * A ( 4 , 1 ))) B ( 4 , 3 ) = detinv * ( A ( 1 , 1 ) * ( A ( 2 , 3 ) * A ( 4 , 2 ) - A ( 2 , 2 ) * A ( 4 , 3 )) + A ( 1 , 2 ) * ( A ( 2 , 1 ) * A ( 4 , 3 ) - A ( 2 , 3 ) * A ( 4 , 1 )) + A ( 1 , 3 ) * ( A ( 2 , 2 ) * A ( 4 , 1 ) - A ( 2 , 1 ) * A ( 4 , 2 ))) B ( 1 , 4 ) = detinv * ( A ( 1 , 2 ) * ( A ( 2 , 4 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 4 )) + A ( 1 , 3 ) * ( A ( 2 , 2 ) * A ( 3 , 4 ) - A ( 2 , 4 ) * A ( 3 , 2 )) + A ( 1 , 4 ) * ( A ( 2 , 3 ) * A ( 3 , 2 ) - A ( 2 , 2 ) * A ( 3 , 3 ))) B ( 2 , 4 ) = detinv * ( A ( 1 , 1 ) * ( A ( 2 , 3 ) * A ( 3 , 4 ) - A ( 2 , 4 ) * A ( 3 , 3 )) + A ( 1 , 3 ) * ( A ( 2 , 4 ) * A ( 3 , 1 ) - A ( 2 , 1 ) * A ( 3 , 4 )) + A ( 1 , 4 ) * ( A ( 2 , 1 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 1 ))) B ( 3 , 4 ) = detinv * ( A ( 1 , 1 ) * ( A ( 2 , 4 ) * A ( 3 , 2 ) - A ( 2 , 2 ) * A ( 3 , 4 )) + A ( 1 , 2 ) * ( A ( 2 , 1 ) * A ( 3 , 4 ) - A ( 2 , 4 ) * A ( 3 , 1 )) + A ( 1 , 4 ) * ( A ( 2 , 2 ) * A ( 3 , 1 ) - A ( 2 , 1 ) * A ( 3 , 2 ))) B ( 4 , 4 ) = detinv * ( A ( 1 , 1 ) * ( A ( 2 , 2 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 2 )) + A ( 1 , 2 ) * ( A ( 2 , 3 ) * A ( 3 , 1 ) - A ( 2 , 1 ) * A ( 3 , 3 )) + A ( 1 , 3 ) * ( A ( 2 , 1 ) * A ( 3 , 2 ) - A ( 2 , 2 ) * A ( 3 , 1 ))) end function function gaussji ( c , d , n ) result ( a ) !Linear equation solution by Gauss-Jordan elimination, used to find inverse of matrix c. !possibly slow for large \"c\" (LAPACK better?) !c needs to be square and have dimension n !c(1:n,1:n) is an input matrix stored in an array of physical dimensions n by n. !d(1:n,1:n) is an input matrix containing the n by n identity matrix. !On  output, a(1:n,1:n) (and b(1:n,1:n)) are the inverse of c !Parameter: NMAX is  the  largest  anticipated  value  of n. INTEGER :: n real , intent ( in ) :: c ( n , n ) !WILL BE OVERWRITTEN!! real , intent ( in ) :: d ( n , n ) real :: a ( n , n ), b ( n , n ) INTEGER , PARAMETER :: NMAX = 50 INTEGER :: m , i , icol , irow , j , k , l , ll , indxc ( NMAX ), indxr ( NMAX ), ipiv ( NMAX ) !The integer arrays ipiv, indxr, and indxc are  used for bookkeeping  on the pivoting. REAL :: big , dum , pivinv a = c b = d m = n do j = 1 , n ipiv ( j ) = 0 end do do i = 1 , n !This  is  the  main  loop  over  the  columns  to  be  reduced. big = 0. do j = 1 , n !This  is  the  outer  loop  of  the  search  for  a  pivot  element. if ( ipiv ( j ) . ne . 1 ) then do k = 1 , n if ( ipiv ( k ) . eq . 0 ) then if ( abs ( a ( j , k )) . ge . big ) then big = abs ( a ( j , k )) irow = j icol = k endif !else if (ipiv(k).gt.1) then !pause 'singular matrix in gaussj' end if end do end if end do ipiv ( icol ) = ipiv ( icol ) + 1 !We  now  have  the  pivot  element,  so  we  interchange  rows,  if  needed,  to  put  the  pivot !element  on  the  diagonal.  The  columns  are  not  physically  interchanged,  only  relabeled: !indxc(i), the column of the ith pivot element, is the ith column that is reduced, while !indxr(i) is  the  row in  which  that  pivot  element  was  originally  located.  If !indxr(i) /= indxc(i) there  is  an  implied  column  interchange.  With  this  form  of  bookkeeping,  the !solution b's  will  end  up  in  the  correct  order,  and  the  inverse  matrix  will  be  scrambled by  columns if ( irow . ne . icol ) then do l = 1 , n dum = a ( irow , l ) a ( irow , l ) = a ( icol , l ) a ( icol , l ) = dum end do do l = 1 , m dum = b ( irow , l ) b ( irow , l ) = b ( icol , l ) b ( icol , l ) = dum enddo endif !We are now ready to divide the pivot row by the pivot element, located at irow and icol. indxr ( i ) = irow indxc ( i ) = icol !if (a(icol,icol).eq.0.) pause 'singular matrix in gaussj' pivinv = 1. / a ( icol , icol ) a ( icol , icol ) = 1. do l = 1 , n a ( icol , l ) = a ( icol , l ) * pivinv end do do l = 1 , m b ( icol , l ) = b ( icol , l ) * pivinv end do do ll = 1 , n !Next,  we  reduce  the  rows, except for the  pivot  one, of course. if ( ll . ne . icol ) then dum = a ( ll , icol ) a ( ll , icol ) = 0. do l = 1 , n a ( ll , l ) = a ( ll , l ) - a ( icol , l ) * dum end do do l = 1 , m b ( ll , l ) = b ( ll , l ) - b ( icol , l ) * dum end do end if end do end do !This is the end of the main loop over columns of the reduction. do l = n , 1 , - 1 !It  only  remains  to  unscramble  the  solution  in  view !of  the  column  interchanges.  We  do  this  by  in- !terchanging pairs of columns in the reverse order !that the permutation was built  up. if ( indxr ( l ) . ne . indxc ( l )) then do k = 1 , n dum = a ( k , indxr ( l )) a ( k , indxr ( l )) = a ( k , indxc ( l )) a ( k , indxc ( l )) = dum end do end if end do return !And  we  are  done. END function gaussji subroutine intqH !time integration of heat and latent heat from facets use modglobal , only : nfcts , dt , rk3step , lEB use initfac , only : faccth , fachfsum , fachf , fachfi , facef , facefi , facefsum use modmpi , only : nprocs , myid , comm3d , mpierr , mpi_sum , my_real real :: dummy integer :: n if (. not . lEB ) return if ( rk3step . eq . 3 ) then !sum over all processors since a facet can be split onto more than one processor fachfsum = 0. facefsum = 0. call MPI_ALLREDUCE ( fachf ( 1 : nfcts ), fachfsum ( 1 : nfcts ), nfcts , MY_REAL , MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( facef ( 1 : nfcts ), facefsum ( 1 : nfcts ), nfcts , MY_REAL , MPI_SUM , comm3d , mpierr ) if ( myid == 0 ) then !time summation of total facet heatlux (will be divided by dtEB in EB to get time mean flux) do n = 1 , nfcts fachfi ( n ) = fachfi ( n ) + dt * fachfsum ( n ) !sum up the fluxes over time facefi ( n ) = facefi ( n ) + dt * facefsum ( n ) end do end if end if fachf = 0. fachfsum = 0. facefsum = 0. facef = 0. end subroutine intqH subroutine initEB !initialise everything necessary to calculate the energy balance use modglobal , only : AM , BM , CM , DM , EM , FM , GM , HM , IDM , inAM , bb , w , dumv , Tdash , bldT , nfcts , nwalllayers use initfac , only : facdi , faccp , faclami , fackappa , netsw , facem , fachf , facef , fachfi , facT , facLWin , facain , facefi , facwsoil , facf , facets , facTdash , facqsat , facf , fachurel use modmpi , only : myid , comm3d , mpierr , MPI_INTEGER , MPI_DOUBLE_PRECISION , MY_REAL , nprocs , cmyid , MPI_REAL8 , MPI_REAL4 , MPI_SUM use modstat_nc , only : open_nc , define_nc , ncinfo , writestat_dims_nc integer :: i , j , k , l , m , n real :: dum allocate ( AM ( 1 : nwalllayers + 1 , 1 : nwalllayers + 1 )) allocate ( inAM ( 1 : nwalllayers + 1 , 1 : nwalllayers + 1 )) allocate ( CM ( 1 : nwalllayers + 1 , 1 : nwalllayers + 1 )) allocate ( bb ( 1 : nwalllayers + 1 )) allocate ( BM ( 1 : nwalllayers + 1 , 1 : nwalllayers + 1 )) allocate ( DM ( 1 : nwalllayers + 1 , 1 : nwalllayers + 1 )) allocate ( EM ( 1 : nwalllayers + 1 , 1 : nwalllayers + 1 )) allocate ( FM ( 1 : nwalllayers + 1 , 1 : nwalllayers + 1 )) allocate ( GM ( 1 : nwalllayers + 1 , 1 : nwalllayers + 1 )) allocate ( HM ( 1 : nwalllayers + 1 , 1 : nwalllayers + 1 )) allocate ( IDM ( 1 : nwalllayers + 1 , 1 : nwalllayers + 1 )) allocate ( w ( 1 : nwalllayers + 1 )) allocate ( dumv ( 1 : nwalllayers + 1 )) allocate ( Tdash ( 1 : nwalllayers + 1 )) write ( * , * ) \"nwalllayers\" , nwalllayers BM = 0. ; DM = 0. ; EM = 0. ; FM = 0. ; GM = 0. ; HM = 0. ; w = 0. ; dumv = 0. ; Tdash = 0. ; AM = 0. ; inAM = 0. ; CM = 0. ; IDM = 0. ; bb = 0. do j = 1 , nwalllayers + 1 IDM ( j , j ) = 1.0 end do !Fortran is column major, i.e. left dimensions should be iterated first ! e.g.  (1,1)->(2,1)->(3,1)->(1,2)->... since they are next to each other on memory !first index moves \"up and down\" second \"left and right\" (as always) m = 1 ; !position along columns do j = 2 , nwalllayers + 1 AM ( j , m ) = 0.5 AM ( j , m + 1 ) = 0.5 m = m + 1 end do AM ( 1 , 1 ) = 1.0 if ( nwalllayers == 3 ) then inAM = matinv4 ( AM ) !!alternatively !inAM=matinv3(AM) !!or else inAM = gaussji ( AM , IDM , nwalllayers + 1 ) end if ! write facet temperatures to facT.xxx.nc, and energies to facEB.xxx.nc if ( lwriteEBfiles ) then Tname ( 6 : 8 ) = cexpnr EBname ( 7 : 9 ) = cexpnr allocate ( ncstatT ( nstatT , 4 )) call ncinfo ( tncstatT ( 1 ,:), 't' , 'Time' , 's' , 'time' ) call ncinfo ( ncstatT ( 1 ,:), 'T' , 'Temperature' , 'K' , 'flt' ) call ncinfo ( ncstatT ( 2 ,:), 'dTdz' , 'Temperature gradient' , 'K/m' , 'flt' ) allocate ( ncstatEB ( nstatEB , 4 )) call ncinfo ( tncstatEB ( 1 ,:), 't' , 'Time' , 's' , 'time' ) call ncinfo ( ncstatEB ( 1 ,:), 'netsw' , 'Shortwave radiation' , 'W' , 'ft' ) call ncinfo ( ncstatEB ( 2 ,:), 'LWin' , 'Longwave radiation' , 'W' , 'ft' ) call ncinfo ( ncstatEB ( 3 ,:), 'hf' , 'Sensible heat flux' , 'W' , 'ft' ) call ncinfo ( ncstatEB ( 4 ,:), 'ef' , 'Latent heat flux' , 'W' , 'ft' ) call ncinfo ( ncstatEB ( 5 ,:), 'WGR' , 'Moisture?' , 'W' , 'ft' ) if ( myid == 0 ) then call open_nc ( Tname , ncidT , nrecT , nfcts = nfcts , nlyrs = nwalllayers + 1 ) call open_nc ( EBname , ncidEB , nrecEB , nfcts = nfcts ) if ( nrecT == 0 ) then call define_nc ( ncidT , 1 , tncstatT ) call writestat_dims_nc ( ncidT ) end if if ( nrecT == 0 ) then call define_nc ( ncidEB , 1 , tncstatEB ) call writestat_dims_nc ( ncidEB ) end if call define_nc ( ncidT , nstatT , ncstatT ) call define_nc ( ncidEB , nstatEB , ncstatEB ) endif !myid==0 end if end subroutine initEB subroutine calclw !calculate the longwave exchange between facets use modglobal , only : nfcts , boltz , skyLW use initfac , only : facem , vf , svf , faca , facT , facLWin , facets integer :: n , m real :: ltemp = 0. do n = 1 , nfcts if ( facets ( n , 2 ) < - 100 ) then !it's a bounding wall, no need to update incoming longwave cycle else ltemp = 0. do m = 1 , nfcts !for n, sum over all other m facets ltemp = ltemp + vf ( m , n ) * faca ( m ) / faca ( n ) * facem ( m ) * boltz * facT ( m , 1 ) ** 4 ![W/m2] end do facLWin ( n ) = ( ltemp + svf ( n ) * skyLW ) * facem ( n ) end if end do end subroutine calclw subroutine updateGR !updates soil and vegetation resistance to evaporation !updates soil moisture ! ! based on ERA40 surface scheme ! van den Hurk 2000 ! plants ! E = max(0,vegetation% * rhoa * (qa-qsat(TGR)) * 1/(rc+ra)) !no dew!! ! rc=rsmin/LAI*f1(K)*f2(WGS)*f3(D)*f4(T) ! ra,qa,qsat ! f3(D) is 1 for small plants ! bare soil ! E = max(0,(1-vegetation%) * rhoa * (qa-qsat(TGR)*hu) * (1/(rs+ra)) use modglobal , only : nfcts , rlv , rlvi , rhoa , cp , wfc , wwilt , wsoil , rsmin , GRLAI , tEB , rsmax , lconstW use initfac , only : netSW , faccth , fachurel , faclGR , facwsoil , facf , facef , facT , facefi , facqsat , facdi , facain , qsat integer :: n real :: vfraction = 0.8 !fraction of GR covered in vegetation, should be made into a proper model parameter (-> modglobal) real :: dum do n = 1 , nfcts if ( faclGR ( n )) then !facefi is actually the accumulated moisture flux, has to be converted to energy flux to calculate temperature !yet actually the moisture flux is needed for water budget, i.e. currently many operations cancel each other e.g. X*Lv/Lv !facefi is the sum over all gridcells of a facet, thus has to be averaged by dividing by number of cells in that facet !units of facefi are kgW/kgA*m/s facefi ( n ) = facefi ( n ) / tEB / facain ( n ) * rhoa * rlv !mean heat flux since last EB calculation (time average) if (. not . lconstW ) then !remove water from soil facwsoil ( n ) = max ( facwsoil ( n ) + facefi ( n ) * tEB * rlvi * facdi ( n , 1 ), 0. ) !ils13, careful this assumes water only being present in the first layer!!! end if !update canopy resistance used in wf_gr fachurel ( n ) = max ( min ( 1.0 , 0.5 * ( 1.0 - cos ( 3.14159 * facwsoil ( n ) / wfc ))), 0. ) !relative humidity above soil facf ( n , 1 ) = 1. / min ( 1.0 , ( 0.004 * netSW ( n ) + 0.05 ) / ( 0.81 * ( 0.004 * netSW ( n ) + 1 ))) !f1 facf ( n , 2 ) = 1. / min ( max ( 0.001 , ( facwsoil ( n ) - wwilt ) / ( wfc - wwilt )), 1.0 ) !f2 !f3 drops out because it is for high vegetation only facf ( n , 3 ) = 1. / max (( 1 - 0.0016 * ( 298 - facT ( n , 1 )) ** 2 ), 0.001 ) !f4 !store resistance for plants facf ( n , 4 ) = min ( rsmin / GRLAI * facf ( n , 1 ) * facf ( n , 2 ) * facf ( n , 3 ), rsmax ) !store resistance for soil facf ( n , 5 ) = min ( rsmin * facf ( n , 2 ), rsmax ) dum = facT ( n , 1 ) facqsat ( n ) = qsat ( dum ) end if end do end subroutine updateGR subroutine EB !calculates the energy balance for every facet use modglobal , only : nfcts , boltz , tEB , AM , BM , CM , DM , EM , FM , GM , HM , inAM , bb , w , dumv , Tdash , timee , tnextEB , rk3step , rhoa , cp , lEB , ntrun , lwriteEBfiles , nwalllayers use initfac , only : faclami , netsw , facem , fachf , facef , fachfi , facT , facLWin , facain , facefi , facf , facets , facTdash , facqsat , facwsoil , facf , fachurel , facd , facdi , fackappa use modmpi , only : myid , comm3d , mpierr , MPI_INTEGER , MPI_DOUBLE_PRECISION , MY_REAL , nprocs , cmyid , MPI_REAL8 , MPI_REAL4 , MPI_SUM use modstat_nc , only : writestat_nc , writestat_1D_nc , writestat_2D_nc real :: ca = 0. , cb = 0. , cc = 0. , cd = 0. , ce = 0. , cf = 0. real :: ab = 0. integer :: l , n , m , i , j character ( 19 ) name if (. not . ( lEB )) return !calculate latent heat flux from vegetation and soil call intqH !calculate energy balance, update facet temperature and soil moisture if (( rk3step . eq . 3 ) . and . ( timee . ge . tnextEB )) then if ( myid . eq . 0 ) then tEB = timee - tEB !time since last calculation of energy balance write ( * , * ) \"doing EB, time since last EB:\" , tEB !calculate time mean, facet area mean latent heat flux and update green roof !ILS13 02.05.18 ABOUT updateGR: convert latent heatflux E properly should be done before temperature calculatation. BUT the rest of updateGR should be done after! !update green roof call updateGR !get longwave fluxes for all facets call calclw !get time mean, facet area mean sensible heat flux do n = 1 , nfcts fachfi ( n ) = fachfi ( n ) / tEB / facain ( n ) * rhoa * cp !mean heat flux since last EB calculation (time average) !since fachf is the sum over all cells making up a facet we need to divide by the number of cells, assuming a given density to convert to W/m2 end do !solve the system: !see Suter 2018 !A * T'= bb + B * T,   where T' = dT/dz !C * d/dtT + D d/dtT'= e * T' ! !-> T(n+1)=(F-G*dt)&#94;-1*(F*T+w*dt) !where F=(C + D*A&#94;-1*B), G=(E*A&#94;-1*B), w=(E*A&#94;-1*bb) do n = 1 , nfcts if ( facets ( n , 2 ) < - 100 ) then !it's a bounding wall, no reason to do energy balance cycle else !calculate wallflux and update surface temperature !! define time dependent fluxes ab = faclami ( n , 1 ) * boltz * facem ( n ) * ( facT ( n , 1 ) ** 3 ) ! ab*T is the Stefan-Boltzman law bb ( 1 ) = - faclami ( n , 1 ) * ( netsw ( n ) + facLWin ( n ) + fachfi ( n ) + facefi ( n )) !net surface flux !!define the matrices to solve wall heat flux !! CREATE MATRICES BASED ON WALL PROPERTIES i = 1 ; m = 0 ; !position along columns, placeholder for layerindex since only 3 layers implemented (initfac.f90) do j = 1 , nwalllayers m = min ( j , 3 ) !!CARE!!! ONLY 3 LAYERS ARE CURRENTLY BEING READ FROM INPUT FILES. PROPERTIES OF LAYER 3 ARE USED FOR SUBSEQUENT LAYERS!!! ca = facdi ( n , m ) BM ( j + 1 , i ) =- ca BM ( j + 1 , i + 1 ) = ca EM ( j , i ) =- fackappa ( n , m ) EM ( j , i + 1 ) = fackappa ( n , m + 1 ) cb = facd ( n , m ) / 2 CM ( j , i ) = cb CM ( j , i + 1 ) = cb ca = cb ** 2 * 0.33333333 DM ( j , i ) = ca DM ( j , i + 1 ) =- ca i = i + 1 end do CM ( nwalllayers + 1 , nwalllayers + 1 ) = 1.0 BM ( 1 , 1 ) = ab w = matmul ( EM , matmul ( inAM , bb )) * tEB !easier than loop and sum HM = matmul ( inAM , BM ) FM = CM + matmul ( DM , HM ) GM = matmul ( EM , HM ) HM = FM - GM * tEB if ( nwalllayers == 3 ) then GM = matinv4 ( HM ) else GM = gaussji ( HM , IDM , nwalllayers + 1 ) end if !instead of inverting matrix HM and multiplying by GM (=HM&#94;-1) it would be waster to do a  left matrix division HM\\x is faster than (HM&#94;-1)*x dumv = matmul ( GM , ( matmul ( FM , facT ( n ,:)) + w )) facT ( n , :) = dumv !calculate Temperature gradient dT/dz=>Tdash so we can output it !ground heat flux = lambda dT/dz w = matmul ( BM , dumv ) facTdash ( n , :) = matmul ( inAM , ( bb + w )) end if end do if ( lwriteEBfiles ) then if ( myid == 0 ) then allocate ( varsT ( nfcts , nwalllayers + 1 , nstatT )) varsT (:,:, 1 ) = facT ( 1 : nfcts , 1 : nwalllayers + 1 ) varsT (:,:, 2 ) = facTdash ( 1 : nfcts , 1 : nwalllayers + 1 ) call writestat_nc ( ncidT , 1 , tncstatT ,( / timee / ), nrecT ,. true .) call writestat_2D_nc ( ncidT , nstatT , ncstatT , varsT , nrecT , nfcts , nwalllayers + 1 ) deallocate ( varsT ) allocate ( varsEB ( nfcts , nstatEB )) varsEB (:, 1 ) = netsw ( 1 : nfcts ) varsEB (:, 2 ) = facLWin ( 1 : nfcts ) varsEB (:, 3 ) = fachfi ( 1 : nfcts ) varsEB (:, 4 ) = facefi ( 1 : nfcts ) varsEB (:, 5 ) = facwsoil ( 1 : nfcts ) call writestat_nc ( ncidEB , 1 , tncstatEB ,( / timee / ), nrecEB ,. true .) call writestat_1D_nc ( ncidEB , nstatEB , ncstatEB , varsEB , nrecEB , nfcts ) deallocate ( varsEB ) endif !myid !            if (lwriteEBfiles) then !               name = 'tEB____________.txt' !               open (unit=11, file=name, position='append') !               write (11, '(1(F10.4,:,\",\"))') tEB !               close (11) !               name = 'dummy__________.csv' !               write (name(6:15), '(F10.4)') timee !               write (name(1:5), '(A5)') 'netsw' !               open (unit=11, file=name, position='append') !               write (11, '(249(F10.4,:,\",\"))') netsw(1:nfcts) !               close (11) !               write (name(1:5), '(A5)') 'LWin_' !               open (unit=11, file=name, position='append') !               write (11, '(249(F10.4,:,\",\"))') facLWin(1:nfcts) !               close (11) !               write (name(1:5), '(A5)') 'hf___' !               open (unit=11, file=name, position='append') !               write (11, '(249(F10.4,:,\",\"))') fachfi(1:nfcts) !               close (11) !               write (name(1:5), '(A5)') 'ef___' !               open (unit=11, file=name, position='append') !               write (11, '(249(F10.4,:,\",\"))') facefi(1:nfcts) !               close (11) !               write (name(1:5), '(A5)') 'WGR__' !               open (unit=11, file=name, position='append') !               write (11, '(249(F10.4,:,\",\"))') facwsoil(1:nfcts) !               close (11) !               write (name(1:5), '(A5)') 'facT1' !               open (unit=11, file=name, position='append') !               write (11, '(249(F10.4,:,\",\"))') facT(1:nfcts, 1) !               close (11) !               write (name(1:5), '(A5)') 'facT2' !               open (unit=11, file=name, position='append') !               write (11, '(249(F10.4,:,\",\"))') facT(1:nfcts, 2) !               close (11) !               write (name(1:5), '(A5)') 'facT3' !               open (unit=11, file=name, position='append') !               write (11, '(249(F10.4,:,\",\"))') facT(1:nfcts, 3) !               close (11) !               write (name(1:5), '(A5)') 'faTd1' !               open (unit=11, file=name, position='append') !               write (11, '(249(F10.4,:,\",\"))') facTdash(1:nfcts, 1) !               write (name(1:5), '(A5)') 'faTd2' !               open (unit=11, file=name, position='append') !               write (11, '(249(F10.4,:,\",\"))') facTdash(1:nfcts, 2) !               write (name(1:5), '(A5)') 'faTd3' !               open (unit=11, file=name, position='append') !               write (11, '(249(F10.4,:,\",\"))') facTdash(1:nfcts, 3) !               close (11) !               write (name(1:5), '(A5)') 'faTd4' !               open (unit=11, file=name, position='append') !               write (11, '(249(F10.4,:,\",\"))') facTdash(1:nfcts, 4) !               close (11) end if tEB = timee !set time of last calculation of energy balance to current time tnextEB = NINT (( timee + dtEB )) * 1.0 !rounded to nearest integer  (e.g. if current time is 10.013s and dtEb=10s, then the next energy balance will be calculated at t>=20s) write ( * , * ) \"time, time next EB\" , timee , tnextEB do n = 1 , nfcts fachfi ( n ) = 0. facefi ( n ) = 0. end do end if !myid==0 write ( * , * ) \"bcasting facT\" call MPI_BCAST ( facT ( 0 : nfcts , 1 : nwalllayers + 1 ), ( nwalllayers + 1 ) * ( nfcts + 1 ), MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( tnextEB , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facqsat ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facf ( 0 : nfcts , 1 : 5 ), ( nfcts + 1 ) * 5 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( fachurel ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facwsoil ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) end if !time>tnextEB end subroutine EB end module modEB","tags":"","loc":"sourcefile/modeb.f90.html"},{"title":"tstep.f90 – uDALES","text":"This file depends on sourcefile~~tstep.f90~~EfferentGraph sourcefile~tstep.f90 tstep.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~tstep.f90->sourcefile~modsubgriddata.f90 sourcefile~modinletdata.f90 modinletdata.f90 sourcefile~tstep.f90->sourcefile~modinletdata.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~tstep.f90->sourcefile~modfields.f90 sourcefile~modchem.f90 modchem.f90 sourcefile~tstep.f90->sourcefile~modchem.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~tstep.f90->sourcefile~modglobal.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~tstep.f90->sourcefile~modmpi.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modchem.f90->sourcefile~modfields.f90 sourcefile~modchem.f90->sourcefile~modglobal.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines tstep_update tstep_integrate Source Code tstep.f90 Source Code !> \\file tstep.f90 !!  Performs the time integration !> !!  Performs the time integration !> !! Tstep uses adaptive timestepping and 3rd order Runge Kutta time integration. !! The adaptive timestepping chooses it's delta_t according to the courant number !! and the diffusion number, depending on the advection scheme in use. !! !!  \\author Jasper Tomas, TU Delft !!  \\author Chiel van Heerwaarden, Wageningen University !!  \\author Thijs Heus,MPI-M !! \\see Wicker and Skamarock 2002 !!  \\par Revision list !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! !> Determine time step size dt in initialization and update time variables !! !! The size of the timestep Delta t is determined adaptively, and is limited by both the Courant-Friedrichs-Lewy criterion CFL !! \\latexonly !! \\begin{equation} !! \\CFL = \\mr{max}\\left(\\left|\\frac{u_i \\Delta t}{\\Delta x_i}\\right|\\right), !! \\end{equation} !! and the diffusion number $d$. The timestep is further limited by the needs of other modules, e.g. the statistics. !! \\endlatexonly subroutine tstep_update use modglobal , only : ib , ie , jb , je , rk3step , timee , runtime , dtmax , dt , ntimee , ntrun , courant , diffnr ,& kb , ke , dxh , dxhi , dxh2i , dyi , dy2i , dzh , dt_lim , ladaptive , timeleft , dt , lwarmstart ,& dzh2i , tEB , tnextEB , dtEB use modfields , only : um , vm , wm use modsubgriddata , only : ekm , ekh use modmpi , only : myid , comm3d , mpierr , mpi_max , my_real implicit none integer :: i , j , k , imin , kmin real , save :: courtot =- 1. , diffnrtot =- 1. real :: courtotl , courold , diffnrtotl , diffnrold !  logical,save  :: spinup=.true. logical , save :: spinup = . false . if ( lwarmstart ) spinup = . false . rk3step = mod ( rk3step , 3 ) + 1 if ( rk3step == 1 ) then ! Initialization if ( spinup ) then write ( 6 , * ) '!spinup!' if ( ladaptive ) then courold = courtot diffnrold = diffnrtot courtotl = 0. diffnrtotl = 0. do k = kb , ke do j = jb , je do i = ib , ie courtotl = max ( courtotl ,( abs ( um ( i , j , k )) * dxhi ( i ) + abs ( vm ( i , j , k )) * dyi + abs ( wm ( i , j , k )) / dzh ( k )) * dt ) !          diffnrtotl = max(diffnrtotl,  ekm(i,j,k)*(1/dzh(k)**2 + dxh2i(i) + dy2i)*dt ) diffnrtotl = max ( diffnrtotl , ekm ( i , j , k ) * ( dzh2i ( k ) + dxh2i ( i ) + dy2i ) * dt , & ekh ( i , j , k ) * ( dzh2i ( k ) + dxh2i ( i ) + dy2i ) * dt ) end do end do end do call MPI_ALLREDUCE ( courtotl , courtot , 1 , MY_REAL , MPI_MAX , comm3d , mpierr ) call MPI_ALLREDUCE ( diffnrtotl , diffnrtot , 1 , MY_REAL , MPI_MAX , comm3d , mpierr ) if ( diffnrold > 0 ) then dt = min ( dtmax , dt * courant / courtot , dt * diffnr / diffnrtot ) if (( abs ( courtot - courold ) / courold < 0.1 ) . and . ( abs ( diffnrtot - diffnrold ) / diffnrold < 0.1 )) then spinup = . false . end if end if dt = dt dt_lim = timeleft timee = timee + dt timeleft = timeleft - dt ntimee = ntimee + 1 ntrun = ntrun + 1 else dt = 2 * dt if ( dt >= dtmax ) then dt = dtmax spinup = . false . end if end if ! Normal time loop else !spinup = .false. if ( ladaptive ) then courtotl = 0. diffnrtotl = 1e-5 do k = kb , ke do j = jb , je do i = ib , ie courtotl = max ( courtotl ,( abs ( um ( i , j , k )) * dxhi ( i ) + abs ( vm ( i , j , k )) * dyi + abs ( wm ( i , j , k )) / dzh ( k )) * dt ) diffnrtotl = max ( diffnrtotl , ekm ( i , j , k ) * ( dzh2i ( k ) + dxh2i ( i ) + dy2i ) * dt ,& ekh ( i , j , k ) * ( dzh2i ( k ) + dxh2i ( i ) + dy2i ) * dt ) !          if (diffnrtotl ==  ekh(i,j,k)*(dzh2i(k) + dxh2i(i) + dy2i)*dt) then !           imin = i !           kmin = k !          end if end do end do end do !     write(6,*) 'Peclet criterion at proc,i,k = ', myid,imin,kmin call MPI_ALLREDUCE ( courtotl , courtot , 1 , MY_REAL , MPI_MAX , comm3d , mpierr ) call MPI_ALLREDUCE ( diffnrtotl , diffnrtot , 1 , MY_REAL , MPI_MAX , comm3d , mpierr ) if ( courtot <= 0 ) then write ( 6 , * ) 'courtot=0!' end if if ( diffnrtot <= 0 ) then write ( 6 , * ) 'diffnrtot=0!' end if dt = min ( dtmax , dt * courant / courtot , dt * diffnr / diffnrtot ) timeleft = timeleft - dt dt_lim = timeleft timee = timee + dt ntimee = ntimee + 1 ntrun = ntrun + 1 else dt = dtmax ntimee = ntimee + 1 ntrun = ntrun + 1 timee = timee + dt timeleft = timeleft - dt end if end if end if end subroutine tstep_update !> Time integration is done by a third order Runge-Kutta scheme. !! !! \\latexonly !! With $f&#94;n(\\phi&#94;n)$ the right-hand side of the appropriate equation for variable !! $\\phi=\\{\\fav{u},\\fav{v},\\fav{w},e&#94;{\\smfrac{1}{2}},\\fav{\\varphi}\\}$, $\\phi&#94;{n+1}$ !! at $t+\\Delta t$ is calculated in three steps: !! \\begin{eqnarray} !! \\phi&#94;{*} &=&\\phi&#94;n + \\frac{\\Delta t}{3}f&#94;n(\\phi&#94;n)\\nonumber\\\\\\\\ !! \\phi&#94;{**} &=&\\phi&#94;{n} + \\frac{\\Delta t}{2}f&#94;{*}(\\phi&#94;{*})\\nonumber\\\\\\\\ !! \\phi&#94;{n+1} &=&\\phi&#94;{n} + \\Delta t f&#94;{**}(\\phi&#94;{**}), !! \\end{eqnarray} !! with the asterisks denoting intermediate time steps. !! \\endlatexonly !! \\see Wicker and Skamarock, 2002 subroutine tstep_integrate use modglobal , only : ib , ie , jb , jgb , je , kb , ke , nsv , dt , rk3step , e12min , lmoist , timee , ntrun ,& linoutflow , iinletgen , ltempeq , idriver ,& dzf , dzhi , dzf , dxhi , dxf , ifixuinf , thlsrc , lchem use modmpi , only : cmyid , myid , nprocs use modfields , only : u0 , um , up , v0 , vm , vp , w0 , wm , wp ,& thl0 , thlm , thlp , qt0 , qtm , qtp , e120 , e12m , e12p , sv0 , svm , svp , uouttot ,& wouttot , dpdxl , dgdt , momfluxb , tfluxb , qfluxb use modinletdata , only : totalu , di_test , dr , thetar , thetai , displ , irecy , & dti_test , dtr , thetati , thetatr , q0 , lmoi , lmor , utaui , utaur ,& storetdriver , nstepread , nstepreaddriver , irecydriver use modsubgriddata , only : loneeqn , ekm , ekh use modchem , only : chem implicit none integer i , j , k , n , m real rk3coef , rk3coefi rk3coef = dt / ( 4. - dble ( rk3step )) rk3coefi = 1. / rk3coef if ( ifixuinf == 2 ) then dpdxl (:) = dpdxl (:) + dgdt * rk3coef !    if(ltempeq) then !      thlsrc = thlsrc + thlsrcdt*rk3coef !    end if !    write(6,*) 'dpdx = ', dpdxl(kb) end if if ( loneeqn ) then do k = kb , ke do j = jb , je do i = ib , ie u0 ( i , j , k ) = um ( i , j , k ) + rk3coef * up ( i , j , k ) v0 ( i , j , k ) = vm ( i , j , k ) + rk3coef * vp ( i , j , k ) w0 ( i , j , k ) = wm ( i , j , k ) + rk3coef * wp ( i , j , k ) e120 ( i , j , k ) = e12m ( i , j , k ) + rk3coef * e12p ( i , j , k ) e120 ( i , j , k ) = max ( e12min , e120 ( i , j , k )) e12m ( i , j , k ) = max ( e12min , e12m ( i , j , k )) do n = 1 , nsv sv0 ( i , j , k , n ) = svm ( i , j , k , n ) + rk3coef * svp ( i , j , k , n ) enddo enddo enddo end do else do k = kb , ke do j = jb , je do i = ib , ie u0 ( i , j , k ) = um ( i , j , k ) + rk3coef * up ( i , j , k ) v0 ( i , j , k ) = vm ( i , j , k ) + rk3coef * vp ( i , j , k ) w0 ( i , j , k ) = wm ( i , j , k ) + rk3coef * wp ( i , j , k ) do n = 1 , nsv sv0 ( i , j , k , n ) = svm ( i , j , k , n ) + rk3coef * svp ( i , j , k , n ) enddo enddo enddo enddo end if if ( lchem . and . rk3coef == dt ) then call chem end if if ( ltempeq ) then ! if (myid==0) then ! write(*,*) \"thlp(20,1,46)\",thlp(20,1,46) ! end if do k = kb , ke do j = jb , je do i = ib , ie thl0 ( i , j , k ) = thlm ( i , j , k ) + rk3coef * thlp ( i , j , k ) enddo enddo enddo end if if ( lmoist ) then do k = kb , ke do j = jb , je do i = ib , ie qt0 ( i , j , k ) = qtm ( i , j , k ) + rk3coef * qtp ( i , j , k ) enddo enddo enddo end if if ( linoutflow ) then if (( iinletgen == 0 ) . and . ( idriver /= 2 )) then u0 ( ie + 1 , jb : je , kb : ke ) = um ( ie + 1 , jb : je , kb : ke ) + rk3coef * up ( ie + 1 , jb : je , kb : ke ) else u0 ( ib - 1 , jb : je , kb : ke ) = um ( ib - 1 , jb : je , kb : ke ) + rk3coef * up ( ib - 1 , jb : je , kb : ke ) u0 ( ie + 1 , jb : je , kb : ke ) = um ( ie + 1 , jb : je , kb : ke ) + rk3coef * up ( ie + 1 , jb : je , kb : ke ) end if end if !up to here !  Write some statistics to monitoring file if (( myid == 0 ) . and . ( rk3step == 3 )) then open ( unit = 11 , file = 'monitor' // cmyid // '.txt' , position = 'append' ) if ( iinletgen == 1 ) then write ( 11 , 3001 ) timee elseif ( idriver == 1 ) then write ( 11 , '(I4)' ) nstepreaddriver write ( 11 , 3001 ) timee , u0 ( irecydriver , 1 , 32 ) ! elseif (idriver == 2) then ! write(11, '(I4)') nstepreaddriver ! write(11, 3001) timee, storetdriver(nstepreaddriver), u0(irecydriver, 1, 32) else write ( 11 , 3001 ) timee end if 3001 format ( 13 ( 6e14 . 6 )) close ( 11 ) if ( ifixuinf == 2 ) then open ( unit = 11 , file = 'dpdx___.txt' , position = 'append' ) write ( 11 , 3002 ) timee , dpdxl ( kb ) 3002 format ( 13 ( 6e20 . 12 )) close ( 11 ) if ( ltempeq ) then open ( unit = 11 , file = 'thlsrc.txt' , position = 'append' ) write ( 11 , 3002 ) timee , thlsrc 3003 format ( 13 ( 6e20 . 12 )) close ( 11 ) end if end if endif up = 0. vp = 0. wp = 0. thlp = 0. svp = 0. e12p = 0. qtp = 0. if ( rk3step == 3 ) then um = u0 vm = v0 wm = w0 thlm = thl0 e12m = e120 svm = sv0 qtm = qt0 end if end subroutine tstep_integrate","tags":"","loc":"sourcefile/tstep.f90.html"},{"title":"moddriver.f90 – uDALES","text":"This file depends on sourcefile~~moddriver.f90~~EfferentGraph sourcefile~moddriver.f90 moddriver.f90 sourcefile~modinletdata.f90 modinletdata.f90 sourcefile~moddriver.f90->sourcefile~modinletdata.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~moddriver.f90->sourcefile~modfields.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~moddriver.f90->sourcefile~modglobal.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~moddriver.f90->sourcefile~modmpi.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modsave.f90->sourcefile~modinletdata.f90 sourcefile~modsave.f90->sourcefile~modfields.f90 sourcefile~modsave.f90->sourcefile~modglobal.f90 sourcefile~modsave.f90->sourcefile~modmpi.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~modsave.f90->sourcefile~modsubgriddata.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~modsave.f90->sourcefile~modibmdata.f90 sourcefile~modsurfdata.f90 modsurfdata.f90 sourcefile~modsave.f90->sourcefile~modsurfdata.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~modsave.f90->sourcefile~initfac.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~moddriver.f90~~AfferentGraph sourcefile~moddriver.f90 moddriver.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~modstartup.f90->sourcefile~moddriver.f90 sourcefile~modstartup.f90->sourcefile~modboundary.f90 sourcefile~modpois.f90 modpois.f90 sourcefile~modstartup.f90->sourcefile~modpois.f90 sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~modstartup.f90->sourcefile~modsubgrid.f90 sourcefile~modpois.f90->sourcefile~modboundary.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modboundary.f90 sourcefile~program.f90->sourcefile~modstartup.f90 sourcefile~program.f90->sourcefile~modpois.f90 sourcefile~program.f90->sourcefile~modsubgrid.f90 sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 sourcefile~modsubgrid.f90->sourcefile~modboundary.f90 sourcefile~modstatsdump.f90->sourcefile~modsubgrid.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules moddriver Source Code moddriver.f90 Source Code !! moddriverinlet.f90 contains the set up for creating a driver simulation to use an inlet conditions for a following simulation/ !! This creates a realistic turbulent inlet profiles as necessary. !! The fields are extracted from a specified plane and stored in !! respective files. These files are then used to create inlet !! conditions for a following simualtion. Fields are linearly !! interpolated in time where necessary. !! Code set up is adapted from modinlet.f90 since similar processes are involved !! \\author Anton Esmail-Yakas, Imperial College London, August 5th 2017. !! Edited by tg3315, ICL, May 2019. !! \\todo Documentation !!       Remove unecessary \"use\" variables !!       Remove unecessary commented lines module moddriver use modinletdata implicit none save public :: initdriver , exitdriver , readdriverfile , drivergen contains subroutine initdriver use modglobal , only : ih , ib , ie , jh , jb , je , kb , ke , kh , jhc , khc , idriver , iplane , xf , lstoreplane , nstore , Uinf , ltempeq , lmoist , pi , zf , zh , driverstore , tdriverstart , tdriverdump , timeleft , dtdriver , nsv , timee use modfields , only : um use modmpi , only : myid , nprocs implicit none real :: pfi , epsi integer :: k if ( idriver == 1 ) then if ( tdriverstart < timee ) then write ( 0 , * ) 'ERROR: tdriverstart must be greater than the elapsed time at the start of the simulation' stop 1 end if tdriverdump = tdriverstart endif if ( idriver == 1 ) then allocate ( storetdriver ( 1 : driverstore )) allocate ( storeu0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storeumdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storev0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storevmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storew0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storewmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) !allocate(storee120driver(jb-jh:je+jh,kb-kh:ke+kh,1:driverstore)) !allocate(storee12mdriver(jb-jh:je+jh,kb-kh:ke+kh,1:driverstore)) if ( ltempeq ) then allocate ( storethl0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storethlmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) end if if ( lmoist ) then allocate ( storeqt0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storeqtmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) end if if ( nsv > 0 ) then allocate ( storesv0driver ( jb - jhc : je + jhc , kb - khc : ke + khc , 1 : nsv , 1 : driverstore )) allocate ( storesvmdriver ( jb - jhc : je + jhc , kb - khc : ke + khc , 1 : nsv , 1 : driverstore )) end if irecydriver = iplane !+ib        ! index of recycle plane from driver simulation equals iplane (read from namoptions) else if ( idriver == 2 ) then allocate ( storetdriver ( 1 : driverstore )) allocate ( storeu0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storeumdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storev0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storevmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storew0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storewmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) !allocate(storee120driver(jb-jh:je+jh,kb-kh:ke+kh,1:driverstore)) !allocate(storee12mdriver(jb-jh:je+jh,kb-kh:ke+kh,1:driverstore)) allocate ( u0driver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( v0driver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( w0driver ( jb - jh : je + jh , kb - kh : ke + kh )) !allocate(e120driver(jb-jh:je+jh,kb-kh:ke+kh)) allocate ( umdriver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( vmdriver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( wmdriver ( jb - jh : je + jh , kb - kh : ke + kh )) !allocate(e12mdriver(jb-jh:je+jh,kb-kh:ke+kh)) if ( ltempeq ) then allocate ( storethl0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storethlmdriver ( jb - jh : je + kh , kb - kh : ke + kh , 1 : driverstore )) allocate ( thl0driver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( thlmdriver ( jb - jh : je + jh , kb - kh : ke + kh )) end if if ( lmoist ) then allocate ( storeqt0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storeqtmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( qt0driver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qtmdriver ( jb - jh : je + jh , kb - kh : ke + kh )) end if if ( nsv > 0 ) then allocate ( storesv0driver ( jb - jhc : je + jhc , kb - khc : ke + khc , 1 : nsv , 1 : driverstore )) allocate ( storesvmdriver ( jb - jhc : je + jhc , kb - khc : ke + khc , 1 : nsv , 1 : driverstore )) allocate ( sv0driver ( jb - jhc : je + jhc , kb - khc : ke + khc , 1 : nsv )) allocate ( svmdriver ( jb - jhc : je + jhc , kb - khc : ke + khc , 1 : nsv )) end if irecydriver = iplane !+ib else return end if end subroutine initdriver subroutine drivergen use modglobal , only : ib , ie , jb , je , jgb , jge , kb , ke , zf , zh , dzf , dzhi , timee , btime , totavtime , rk3step ,& dt , numol , iplane , lles , idriver , inletav , runavtime , Uinf , lwallfunc , linletRA ,& totinletav , lstoreplane , nstore , driverstore , prandtlmoli , numol , grav , lbuoyancy ,& lfixinlet , lfixutauin , tdriverstart , dtdriver , tdriverdump , ltempeq , lmoist , nsv use modfields , only : u0 , v0 , w0 , e120 , thl0 , qt0 , wm , uprof use modsave , only : writerestartfiles use modmpi , only : slabsum , myid implicit none real :: inlrec ! time of last inlet record real :: elapsrec ! time elapsed in this inlet record real :: dtint ! dt for linear interpolation REAL * 8 , PARAMETER :: eps = 1 d - 3 integer i , j , k , kk , kdamp , x if ( idriver == 1 ) then ! if (.not. (rk3step==3)) return if (. not . ( timee >= tdriverstart )) return if (. not . ( timee >= tdriverdump )) return if ( nstepreaddriver >= driverstore ) return if ( nstepreaddriver == 0 ) then ! tdriverdump = timee tdriverdump = tdriverstart ! tdriverstart = timee   !Update tdriverstart to the actual recorded value if (( myid == 0 ) . and . ( rk3step == 3 )) then write ( 6 , * ) '==================================================================' write ( 6 , * ) '*** Starting to write data for driver simulation ***' write ( 6 , * ) 'Driver recording variables:' write ( 6 , '(A,F9.2,A,I4,A,F12.9)' ) ' Starting time: ' , tdriverdump , ' Stored time steps: ' , driverstore , '     Inlet record intervals: ' , dtdriver write ( 6 , * ) '==================================================================' end if end if if ( rk3step == 3 ) then nstepreaddriver = nstepreaddriver + 1 tdriverdump = tdriverdump + dtdriver ! storetinlet(nstepreaddriver) = timee - tdriverstart call writedriverfile end if elseif ( idriver == 2 ) then ! if (.not. rk3step==1) return if ( timee > maxval ( storetdriver )) then if ( myid == 0 ) then write ( 0 , '(A,F9.2,A,F9.2)' ) 'timee: ' , timee , '     Final inlet driver time:' , maxval ( storetdriver ) write ( 0 , '(A,I4,A,I4)' ) 'Inlet driver step: ' , nstepreaddriver , '     Total inlet driver steps:' , driverstore end if stop 'Time in simulation has exceeded the inlet information - no more inlet data available!' end if x = minloc ( abs ( storetdriver - timee ), 1 ) elapsrec = storetdriver ( x ) - timee if ( myid == 0 ) then ! if(rk3step==1) then ! write(6,*) '============ Inlet interpolating =============' ! write(6,*) 'Inlet interpolation time = ', elapsrec ! write(6,'(A,F9.4)') 'Inlet driver time stamp (x)  = ', storetdriver(x) ! write(6,'(A,F9.4)') 'Inlet driver time stamp (x+1) = ', storetdriver(x+1) ! write(6,'(A,F9.4)') 'Inlet driver time stamp (x-1) = ', storetdriver(x-1) ! write(6,'(A,E20.12)') 'Reading driver velocity: storeu0driver(je,ke,x) = ', storeu0driver(je,ke,x) ! write(6,*) 'Inlet step = ',nstepreaddriver ! end if end if if ( abs ( elapsrec ) < eps ) then if (( myid == 0 ) . and . ( rk3step == 1 )) then write ( * , '(A,I5,A,F10.3,A)' ) '======= Inputs loaded from driver tstep ' , x , ' (at ' , storetdriver ( x ), 's) =======' end if u0driver (:,:) = storeu0driver (:,:, x ) v0driver (:,:) = storev0driver (:,:, x ) w0driver (:,:) = storew0driver (:,:, x ) !e120driver(:,:) = storee120driver(:,:,x) if ( ltempeq ) then thl0driver (:,:) = storethl0driver (:,:, x ) end if if ( lmoist ) then qt0driver (:,:) = storeqt0driver (:,:, x ) end if if ( nsv > 0 ) then sv0driver (:,:,:) = storesv0driver (:,:,:, x ) end if nstepreaddriver = x elseif (( elapsrec > 0. ) . and . ( x == 1 )) then if (( myid == 0 ) . and . ( rk3step == 1 )) then write ( * , '(A,F10.3,A)' ) '======= Inputs loaded from the proceeding driver tstep 1 (at ' , storetdriver ( x ), 's) =======' end if u0driver (:,:) = storeu0driver (:,:, x ) v0driver (:,:) = storev0driver (:,:, x ) w0driver (:,:) = storew0driver (:,:, x ) ! e120driver(:,:) = storee120driver(:,:,x) if ( ltempeq ) then thl0driver (:,:) = storethl0driver (:,:, x ) end if if ( lmoist ) then qt0driver (:,:) = storeqt0driver (:,:, x ) end if if ( nsv > 0 ) then sv0driver (:,:,:) = storesv0driver (:,:,:, x ) end if nstepreaddriver = x elseif ( elapsrec < 0. ) then if (( myid == 0 ) . and . ( rk3step == 1 )) then write ( * , '(A,I5,A,F10.3,A,I5,A,F10.3,A)' ) '======= Inputs interpolated from driver tsteps ' , x , ' (' , storetdriver ( x ), ' s) and ' , x + 1 , ' (' , storetdriver ( x + 1 ), ' s) =======' end if dtint = ( timee - storetdriver ( x )) / ( storetdriver ( x + 1 ) - storetdriver ( x )) ! if(myid==0) then ! write(6,'(A,I4)') 'x: ', x ! write(6,'(A,F9.4)') 'dtint: ', dtint ! write(6,'(A,E20.12)') 'storeu0driver(1,32,x): ', storeu0driver(1,32,x) ! write(6,'(A,E20.12)') 'storeu0driver(1,32,x+1): ', storeu0driver(1,32,x+1) ! write(6,'(A,E20.12)') 'u0driver(1,32): ',  storeu0driver(1,32,x) + (storeu0driver(1,32,x+1)-storeu0driver(1,32,x))*dtint ! end if u0driver (:,:) = storeu0driver (:,:, x ) + ( storeu0driver (:,:, x + 1 ) - storeu0driver (:,:, x )) * dtint v0driver (:,:) = storev0driver (:,:, x ) + ( storev0driver (:,:, x + 1 ) - storev0driver (:,:, x )) * dtint w0driver (:,:) = storew0driver (:,:, x ) + ( storew0driver (:,:, x + 1 ) - storew0driver (:,:, x )) * dtint ! e120driver(:,:) = storee120driver(:,:,x) + (storee120driver(:,:,x+1)-storee120driver(:,:,x))*dtint if ( ltempeq ) then thl0driver (:,:) = storethl0driver (:,:, x ) + ( storethl0driver (:,:, x + 1 ) - storethl0driver (:,:, x )) * dtint end if if ( lmoist ) then qt0driver (:,:) = storeqt0driver (:,:, x ) + ( storeqt0driver (:,:, x + 1 ) - storeqt0driver (:,:, x )) * dtint end if if ( nsv > 0 ) then sv0driver (:,:,:) = storesv0driver (:,:,:, x ) + ( storesv0driver (:,:,:, x + 1 ) - storesv0driver (:,:,:, x )) * dtint end if nstepreaddriver = x elseif ( elapsrec > 0. ) then if (( myid == 0 ) . and . ( rk3step == 1 )) then write ( * , '(A,I5,A,F10.3,A,I5,A,F10.3,A)' ) '======= Inputs interpolated from driver tsteps ' , x , ' (' , storetdriver ( x ), ' s) and ' , x - 1 , ' (' , storetdriver ( x - 1 ), ' s) =======' end if dtint = ( timee - storetdriver ( x - 1 )) / ( storetdriver ( x ) - storetdriver ( x - 1 )) u0driver (:,:) = storeu0driver (:,:, x - 1 ) + ( storeu0driver (:,:, x ) - storeu0driver (:,:, x - 1 )) * dtint v0driver (:,:) = storev0driver (:,:, x - 1 ) + ( storev0driver (:,:, x ) - storev0driver (:,:, x - 1 )) * dtint w0driver (:,:) = storew0driver (:,:, x - 1 ) + ( storew0driver (:,:, x ) - storew0driver (:,:, x - 1 )) * dtint ! e120driver(:,:) = storee120driver(:,:,x-1) + (storee120driver(:,:,x)-storee120driver(:,:,x-1))*dtint if ( ltempeq ) then thl0driver (:,:) = storethl0driver (:,:, x - 1 ) + ( storethl0driver (:,:, x ) - storethl0driver (:,:, x - 1 )) * dtint end if if ( lmoist ) then qt0driver (:,:) = storeqt0driver (:,:, x - 1 ) + ( storeqt0driver (:,:, x ) - storeqt0driver (:,:, x - 1 )) * dtint end if if ( nsv > 0 ) then sv0driver (:,:,:) = storesv0driver (:,:,:, x - 1 ) + ( storesv0driver (:,:,:, x ) - storesv0driver (:,:,:, x - 1 )) * dtint end if nstepreaddriver = x end if ! if(myid==0) then ! write(6,'(A,F9.4)') 'Simulation time: ', timee ! write(6,'(A,F9.4)') 'dtint: ', dtint ! write(6,*) 'Velocities interpolated:' ! write(6,'(A,e20.12)') 'storeu0driver(je,ke,x-1): ', storeu0driver(je,ke,x-1) ! write(6,'(A,e20.12)') 'storeu0driver(je,ke,x): ', storeu0driver(je,ke,x) ! write(6,'(A,e20.12)') 'storeu0driver(je,ke,x+1): ', storeu0driver(je,ke,x+1) ! write(6,'(A,e20.12)') 'Interpolated inlet velocity (jb,20): ', u0driver(jb,20) ! write(6,*) 'Temperatures interpolated:' ! write(6,'(A,e20.12)') 'storethl0driver(je,20,x-1): ', storethl0driver(jb,20,x-1) ! write(6,'(A,e20.12)') 'storethl0driver(je,20,x): ', storethl0driver(jb,20,x) ! write(6,'(A,e20.12)') 'storethl0driver(je,20,x+1): ', storethl0driver(jb,20,x+1) ! write(6,'(A,e20.12)') 'Interpolated inlet temperature (jb,20): ', thl0driver(jb,20) ! end if ! umdriver = u0driver   ! MAYBE ITS BETTER TO WRITE THE M VARIABLES TO FILE TOO AND JUST READ THEM - THOUGH CURRENTLY THIS IS NOT DONE FOR RESTART FILES?? ae1212 ! vmdriver = v0driver   ! EDIT READ AND WRITE INLET FILES (AND CHECK MODBOUNDARY & MODSURFACE) TO INCLUDE M VARIABLES ! wmdriver = w0driver ! thlmdriver = thl0driver ! qtmdriver = qt0driver if ( rk3step == 1 ) then umdriver = u0driver vmdriver = v0driver wmdriver = w0driver !e12mdriver = e120driver if ( ltempeq ) then thlmdriver = thl0driver end if if ( lmoist ) then qtmdriver = qt0driver end if if ( nsv > 0 ) then svmdriver = sv0driver end if end if else return end if ! idrivergen end subroutine drivergen subroutine writedriverfile use modglobal , only : timee , tdriverstart , ib , ie , ih , jb , je , jh , kb , ke , kh , cexpnr , ifoutput , nstore , ltempeq , lmoist , driverstore , nsv use modfields , only : u0 , v0 , w0 , e120 , thl0 , qt0 , um , sv0 use modmpi , only : cmyid , myid use modinletdata , only : storetdriver , storeu0driver , storev0driver , storew0driver , storethl0driver , storeqt0driver ,& storesv0driver , nfile , nstepreaddriver implicit none integer :: fileid , IOS integer :: i , j , k , n integer :: filesizet , filesizev , filesizetest1 , filesizetest2 , filesizes character ( 15 ) :: name logical :: lexist real , allocatable :: arraysizetest (:,:) allocate ( arraysizetest ( jb - jh : je + jh , kb - kh : ke + kh )) inquire ( iolength = filesizet )( timee - tdriverstart ) ! inquire(iolength=filesizetest1)(timee) ! inquire(iolength=filesizetest2)u0(1,1,1) inquire ( iolength = filesizev ) u0 ( irecydriver ,:,:) inquire ( iolength = filesizes ) sv0 ( irecydriver ,:,:,:) !! ! if((myid==0) .and. (nstepreaddriver==1)) then ! write(6,*) 'inquire iolength ', filesizet ! write(6,*) 'inquire iolength test', filesizetest1 ! write(6,*) 'inquire iolength test u', filesizetest2 ! end if ! inquire(iolength=filesizetest1)arraysizetest(:,:) ! filesizetest2 = (je-jb+2*jh)*(ke-kb+2*kh) ! if((myid==0) .and. (nstepreaddriver==1)) then ! write(6,*) 'je,jb,jh,ke,kb,kh', je,jb,jh,ke,kb,kh ! write(6,*) 'inquire iolength test 1 ', filesizetest1 ! write(6,*) 'inquire iolength test 2', filesizetest2 ! write(6,*) 'inquire iolength', filesizev ! end if if ( myid == 0 ) then write ( 6 , * ) '============ Writing driver files ============' write ( * , * ) 'Driver timestep: ' , nstepreaddriver end if if ( myid == 0 ) then name = 'tdriver_   .' name ( 9 : 11 ) = cmyid name ( 13 : 15 ) = cexpnr ! name(15:18)= '.txt' inquire ( file = name , exist = lexist ) if ( lexist ) then ! write(6,*) 'Writing Time stamp to file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , access = 'direct' , recl = filesizet , action = 'write' ) else ! write(6,*) 'Creating Time stamp driver file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'replace' , access = 'direct' , recl = filesizet , action = 'write' , IOSTAT = IOS ) ! if (IOS > 0) then ! write(6,*) 'IOS = ',IOS ! endif end if ! write(*,*) 'filesizet', filesizet ! write(ifoutput)  ( storetdriver (n),  n=1,nstore) ! write(6,'(A,F9.2)') 'Writing time stamp to file: ', timee-tdriverstart write ( 11 , rec = nstepreaddriver ) ( timee - tdriverstart ) close ( unit = 11 ) write ( * , * ) 'Driver time:' , timee - tdriverstart end if name = 'udriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cmyid name ( 13 : 15 ) = cexpnr ! name(15:18)= '.txt' inquire ( file = name , exist = lexist ) if ( lexist ) then ! write(6,*) 'Writing Inlet u-velocity to file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , access = 'direct' , recl = filesizev , action = 'write' ) else ! write(6,*) 'Creating Inlet u-velocity inlet file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'replace' , access = 'direct' , recl = filesizev , action = 'write' ) end if ! write(ifoutput)  (((storeu0driver (j,k,n),j=jb,je),k=kb,ke),  n=1,nstore) ! Nested implied do-loop !if(myid==0) then !write(6,'(A,e20.12)') 'Writing u0 to file. u0(irecydriver,je,ke)', u0(irecydriver,je,ke) !write(6,'(A,e20.12)') 'u0(irecydriver,jb,kb)', u0(irecydriver,jb,kb) !write(6,'(A,e20.12)') 'Writing thl0 to file. thl0(irecydriver-1,je,ke)', thl0(irecydriver-1,je,ke) !write(6,'(A,e20.12)') 'thl0(irecydriver-1,jb,kb)', thl0(irecydriver-1,jb,kb) ! write(6,*) 'irecydriver, je, ke, ib, jb, kb', irecydriver, je, ke, ib, jb, kb !end if write ( 11 , rec = nstepreaddriver ) ( u0 ( irecydriver ,:,:)) close ( unit = 11 ) name = 'vdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cmyid name ( 13 : 15 ) = cexpnr ! name(15:18)= '.txt' inquire ( file = name , exist = lexist ) if ( lexist ) then ! write(6,*) 'Writing Inlet v-velocity to file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'write' , access = 'direct' , recl = filesizev ) else ! write(6,*) 'Creating v-velocity inlet file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'replace' , access = 'direct' , recl = filesizev , action = 'write' ) end if ! write(ifoutput)  (((storev0driver (j,k,n),j=jb,je),k=kb,ke),  n=1,nstore) ! '(F8.4)' write ( 11 , rec = nstepreaddriver ) ( v0 ( irecydriver ,:,:)) !tg3315 removed irecydriver-1 close ( unit = 11 ) name = 'wdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cmyid name ( 13 : 15 ) = cexpnr ! name(15:18)= '.txt' inquire ( file = name , exist = lexist ) if ( lexist ) then ! write(6,*) 'Writing Inlet w-velocity to file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'write' , access = 'direct' , recl = filesizev ) else ! write(6,*) 'Creating w-velocity inlet file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'replace' , access = 'direct' , recl = filesizev , action = 'write' ) end if ! write(ifoutput)  (((storew0driver (j,k,n),j=jb,je),k=kb,ke+1),n=1,nstore) write ( 11 , rec = nstepreaddriver ) ( w0 ( irecydriver ,:,:)) !tg3315 removed irecydriver-1 close ( unit = 11 ) ! name = 'edriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile ! name(9:11)= cmyid ! name(13:15)= cexpnr ! name(15:18)= '.txt' ! inquire(file=name,exist=lexist) ! if (lexist) then ! write(6,*) 'Writing Inlet w-velocity to file: ', name ! open(unit=11,file=name,form='unformatted',status='old',action='write',access='direct',recl=filesizev) ! else ! write(6,*) 'Creating w-velocity inlet file: ', name ! open(unit=11,file=name,form='unformatted',status='replace',access='direct',recl=filesizev,action='write') ! end if ! write(ifoutput)  (((storew0driver (j,k,n),j=jb,je),k=kb,ke+1),n=1,nstore) ! write(11,rec=nstepreaddriver)  (e120(irecydriver,:,:)) !tg3315 removed irecydriver-1 ! close (unit=11) if ( ltempeq ) then name = 'hdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cmyid name ( 13 : 15 ) = cexpnr ! name(15:18)= '.txt' inquire ( file = name , exist = lexist ) if ( lexist ) then ! write(6,*) 'Writing Inlet temperature to file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'write' , access = 'direct' , recl = filesizev ) else ! write(6,*) 'Creating temperature inlet file: ', name ! write(6,*) 'Creating w-velocity inlet file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'replace' , access = 'direct' , recl = filesizev , action = 'write' ) end if ! write(ifoutput)  (((storew0driver (j,k,n),j=jb,je),k=kb,ke+1),n=1,nstore) write ( 11 , rec = nstepreaddriver ) ( thl0 ( irecydriver ,:,:)) !tg3315 removed irecydriver-1 close ( unit = 11 ) end if if ( lmoist ) then name = 'qdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cmyid name ( 13 : 15 ) = cexpnr ! name(15:18)= '.txt' inquire ( file = name , exist = lexist ) if ( lexist ) then ! write(6,*) 'Writing Inlet temperature to file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'write' , access = 'direct' , recl = filesizev ) else ! write(6,*) 'Creating temperature inlet file: ', name ! write(6,*) 'Creating w-velocity inlet file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'replace' , access = 'direct' , recl = filesizev , action = 'write' ) end if ! write(ifoutput)  (((storew0driver (j,k,n),j=jb,je),k=kb,ke+1),n=1,nstore) write ( 11 , rec = nstepreaddriver ) ( qt0 ( irecydriver ,:,:)) !tg3315 removed irecydriver-1 close ( unit = 11 ) end if if ( nsv > 0 ) then name = 'sdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cmyid name ( 13 : 15 ) = cexpnr ! name(15:18)= '.txt' inquire ( file = name , exist = lexist ) if ( lexist ) then ! write(6,*) 'Writing Inlet temperature to file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'write' , access = 'direct' , recl = filesizes ) else ! write(6,*) 'Creating temperature inlet file: ', name ! write(6,*) 'Creating w-velocity inlet file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'replace' , access = 'direct' , recl = filesizes , action = 'write' ) end if ! write(ifoutput)  (((storew0driver (j,k,n),j=jb,je),k=kb,ke+1),n=1,nstore) write ( 11 , rec = nstepreaddriver ) ( sv0 ( irecydriver ,:,:,:)) !tg3315 removed irecydriver-1 close ( unit = 11 ) end if end subroutine writedriverfile subroutine readdriverfile use modfields , only : u0 , sv0 use modglobal , only : ib , jb , je , jmax , kb , ke , kh , jhc , khc , cexpnr , ifinput , driverstore , ltempeq , lmoist , zh , jgb , jge , jh , driverjobnr , nsv , timee , tdriverstart use modmpi , only : cmyid , myid , nprocs , slabsum , excjs use modinletdata , only : storetdriver , storeu0driver , storev0driver , storew0driver , storethl0driver , storeqt0driver , storesv0driver , nfile implicit none integer :: filen , filee integer :: fileid , IOS , filesize , filesizes integer :: j , k , m , n , js , jf , jfdum , jsdum character ( 24 ) :: name if ( myid == 0 ) then write ( * , * ) '========================================================================' write ( * , * ) '*** Reading precursor driver simulation ***' end if name = 'tdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = '000' ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr inquire ( file = name , size = filesize ) if ( myid == 0 ) then write ( 6 , * ) 'Reading time stamps: ' , name write ( 6 , * ) 'driverstore: ' , driverstore write ( 6 , * ) 'File size of time in bytes (/8) = ' , filesize endif ! driverstore = driverstore/4. ! write(6,*) 'driverstore: ', driverstore inquire ( iolength = filesize )( timee - tdriverstart ) open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize , IOSTAT = IOS ) if ( myid == 0 ) then if ( IOS > 0 ) then write ( 6 , * ) 'IOS = ' , IOS endif endif do n = 1 , driverstore read ( 11 , rec = n , IOSTAT = IOS ) storetdriver ( n ) if ( myid == 0 ) then if ( IOS > 0 ) then write ( 6 , * ) 'IOS = ' , IOS elseif ( IOS < 0 ) then write ( 6 , * ) 'n =' , n end if write ( 6 , '(A,e20.12)' ) ' Reading t:' , storetdriver ( n ) end if end do storetdriver = storetdriver + timee !tg3315 added in case using a warmstart... close ( unit = 11 ) ! write(*,*) 'storetdriver', storetdriver ! end if name = 'udriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cmyid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr write ( 6 , * ) 'Reading Driver u-velocity: ' , name ! inquire(file=name,recl=filesize) inquire ( iolength = filesize ) u0 ( ib ,:,:) write ( 6 , * ) 'record length ' , filesize open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize ) do n = 1 , driverstore read ( 11 , rec = n ) (( storeu0driver ( j , k , n ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) ! if(myid==0) then ! write(6, '(A,e20.12)') 'Reading u(irecydriver, jb, kb)', storeu0driver(jb,kb,n) ! endif end do ! if(myid==0) then ! do k=ke,kb,-1 !   write(6, '(A,e20.12)') 'Reading u(ib,1,:)', storeu0driver(jb,k,1) ! end do ! end if close ( unit = 11 ) name = 'vdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cmyid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr write ( 6 , * ) 'Reading Driver v-velocity: ' , name ! inquire(file=name,recl=filesize) ! inquire(iolength=filesize)u0(ib,:,:) open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize ) do n = 1 , driverstore read ( 11 , rec = n ) (( storev0driver ( j , k , n ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) end do close ( unit = 11 ) name = 'wdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cmyid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr write ( 6 , * ) 'Reading Driver w-velocity: ' , name ! inquire(file=name,recl=filesize) ! inquire(iolength=filesize)u0(ib,:,:) open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize ) do n = 1 , driverstore read ( 11 , rec = n ) (( storew0driver ( j , k , n ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) end do close ( unit = 11 ) !name = 'edriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile ! name(9:11)= cmyid ! write (name(18:20)  ,'(i3.3)') filen ! write (name(13:15)   ,'(i3.3)') driverjobnr ! write(6,*) 'Reading Driver turbulent kinetic energy: ', name ! inquire(file=name,recl=filesize) ! inquire(iolength=filesize)u0(ib,:,:) ! open(unit=11,file=name,form='unformatted',status='old',action='read',access='direct',recl=filesize) ! do n = 1,driverstore ! read(11,rec=n)  ((storee120driver (j,k,n),j=jb-jh,je+jh),k=kb-kh,ke+kh) ! enddo ! close (unit=11) if ( ltempeq ) then name = 'hdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cmyid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr write ( 6 , * ) 'Reading Driver temperature: ' , name ! inquire(file=name,recl=filesize) open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize ) do n = 1 , driverstore read ( 11 , rec = n ) (( storethl0driver ( j , k , n ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) end do !if(myid==0) then !  do k=ke,kb,-1 !    write(6, '(A,e20.12)') 'Reading thl0(ib,1,:)', storethl0driver(jb,k,1) !  end do !end if close ( unit = 11 ) end if if ( lmoist ) then name = 'qdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cmyid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr write ( 6 , * ) 'Reading Driver moisture: ' , name ! inquire(file=name,recl=filesize) open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize ) do n = 1 , driverstore read ( 11 , rec = n ) (( storeqt0driver ( j , k , n ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) end do close ( unit = 11 ) end if if ( nsv > 0 ) then name = 'sdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cmyid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr write ( 6 , * ) 'Reading Driver scalar: ' , name ! inquire(file=name,recl=filesize) inquire ( iolength = filesizes ) sv0 ( ib ,:,:,:) open ( unit = 12 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesizes ) do n = 1 , driverstore read ( 12 , rec = n ) ((( storesv0driver ( j , k , m , n ), j = jb - jhc , je + jhc ), k = kb - khc , ke + khc ), m = 1 , nsv ) end do close ( unit = 12 ) end if end subroutine readdriverfile subroutine exitdriver use modglobal , only : idriver , lstoreplane , ltempeq , lmoist , nsv if ( idriver == 1 ) then if ( lstoreplane ) then deallocate ( storetdriver , storeu0driver , storev0driver , storew0driver ) !,storee120driver) if ( ltempeq ) then deallocate ( storethl0driver ) end if if ( lmoist ) then deallocate ( storeqt0driver ) end if if ( nsv > 0 ) then deallocate ( storesv0driver ) end if end if else if ( idriver == 2 ) then deallocate ( storetdriver , storeu0driver , storev0driver , storew0driver , u0driver , v0driver , w0driver ) !,e120driver,storee120driver) if ( ltempeq ) then deallocate ( storethl0driver , thl0driver ) end if if ( lmoist ) then deallocate ( storeqt0driver , qt0driver ) end if if ( nsv > 0 ) then deallocate ( storesv0driver , sv0driver ) end if end if end subroutine exitdriver end module","tags":"","loc":"sourcefile/moddriver.f90.html"},{"title":"wf_uno.f90 – uDALES","text":"This file depends on sourcefile~~wf_uno.f90~~EfferentGraph sourcefile~wf_uno.f90 wf_uno.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~wf_uno.f90->sourcefile~modsubgriddata.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~wf_uno.f90->sourcefile~modmpi.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~wf_uno.f90->sourcefile~initfac.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~wf_uno.f90->sourcefile~modglobal.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~wf_uno.f90->sourcefile~modibmdata.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions unom Subroutines wfuno unoh Source Code wf_uno.f90 Source Code SUBROUTINE wfuno ( hi , hj , hk , iout1 , iout2 , iot , iomomflux , iotflux , iocth , obcTfluxA , utang1 , utang2 , Tcell , Twall , z0 , z0h , n , ind , wforient ) !wfuno !calculating wall function for momentum and scalars following Cai2012&Uno1995, extension of Louis 1979 method to rough walls !fluxes in m2/s2 and Km/s USE modglobal , ONLY : dzf , dzfi , dzh2i , dzhi , dzhiq , dy , dyi , dy2i , dyi5 , dxf , dxh , dxfi , dxhi , dxh2i , ib , ie , jb , je , kb , ke , fkar , grav , jmax , rk3step , kmax , jge , jgb USE modsubgriddata , ONLY : ekh , ekm USE modmpi , ONLY : myid USE initfac , ONLY : block USE modibmdata REAL , EXTERNAL :: unom INTEGER i , j , k , jl , ju , kl , ku , il , iu , km , im , jm , ip , jp , kp REAL :: Ribl0 = 0. !initial guess of Ribl based on Ts REAL :: bcTflux = 0. !temp storage for temperature flux REAL :: bcmomflux = 0. !temp storage for momentum flux REAL :: ctm = 0. !momentum transfer coefficient REAL :: cth = 0. !heat transfer coefficient REAL :: dummy = 0. !for debugging REAL :: delta = 0. !distance from wall REAL :: logdz = 0. !log(delta/z0) REAL :: logdzh = 0. !log(delta/z0h) REAL :: logzh = 0. !log(z0/z0h) REAL :: sqdz = 0. !sqrt(delta/z0) REAL :: utang1Int !Interpolated 1st tangential velocity component needed for stability calculation (to T location) REAL :: utang2Int !Interpolated 2nd tangential velocity component needed for stability calculation (to T location) REAL :: utangInt !Interpolated absolute tangential velocity REAL :: dT !Temperature difference between wall and cell REAL :: fkar2 = fkar ** 2 !fkar&#94;2, von Karman constant squared REAL :: emmo = 0. , epmo = 0. , epom = 0. , emom = 0. , eopm = 0. , eomm = 0. , empo = 0. REAL :: umin = 0.0001 !m&#94;2/s&#94;2 INTEGER , INTENT ( in ) :: hi !<size of halo in i INTEGER , INTENT ( in ) :: hj !<size of halo in j INTEGER , INTENT ( in ) :: hk !<size of halo in k REAL , INTENT ( out ) :: obcTfluxA !temperature flux of entire wall facet (double sum over indeces) [Km/s] REAL , INTENT ( inout ) :: iout1 ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) !updated prognostic tangential velocity (component1) REAL , INTENT ( inout ) :: iout2 ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) !updated prognostic tangential velocity (component2) REAL , INTENT ( inout ) :: iot ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) !updated prognostic temperature REAL , INTENT ( inout ) :: iomomflux ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !a field to save the momentum flux REAL , INTENT ( inout ) :: iotflux ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !a field to save the heat flux REAL , INTENT ( inout ) :: iocth ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !heat transfer coefficient, used to calculate moisture flux REAL , INTENT ( in ) :: Tcell ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !Temperature of fluid cell REAL , INTENT ( in ) :: Twall !Temperature of surfaces !SINCE EVERY WALL HAS PRECISELY ONE TEMPERATURE (at the outside). CAREFUL IF THIS EVER CHANGES (i.e. multiple EB facets per wall) REAL , INTENT ( in ) :: z0 REAL , INTENT ( in ) :: z0h REAL , INTENT ( in ) :: utang1 ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !tangential velocity field REAL , INTENT ( in ) :: utang2 ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !second tangential velocity field INTEGER , INTENT ( in ) :: n ! number of the block, used to get i,j,k-indeces INTEGER , INTENT ( in ) :: ind ! in case of y-wall (case 3x & 4x) \"ind\" is used for j-index, otherwise this is irrelevant INTEGER , INTENT ( in ) :: wforient !orientation of the facet see below: !frist digit, orientation of wall, determines iteration indices !second digit, if for momentum or for scalar (necessary because of staggered grid -> which variable to interpolate) !xlow=1,xup=2,yup=3,ylow=4,z=5 !momentum=1,scalar=2 obcTfluxA = 0. !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CASES!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CASES FOR SCALARS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SELECT CASE ( wforient ) CASE ( 12 ) !wall in yz -> wf in x (=vertical), lower wall, west wall !wfuno12, case 12 i = block ( n , 1 ) - 1 !wall property and fluid index ip = i + 1 !index to remove subgrid flux jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ! starting j-index ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) ! ending j-index kl = block ( n , 5 ) ! starting k-index ku = block ( n , 6 ) ! ending k-index delta = dxf ( i ) * 0.5 ! logdz = LOG ( delta / z0 ) logdzh = LOG ( delta / z0h ) logzh = LOG ( z0 / z0h ) sqdz = SQRT ( delta / z0 ) DO k = kl , ku DO j = jl , ju utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j + 1 , k )) * 0.5 utang2Int = ( utang2 ( i , j , k ) + utang2 ( i , j , k + 1 )) * 0.5 utangInt = max (( utang1Int ** 2 + utang2Int ** 2 ), umin ) dT = ( Tcell ( i , j , k ) - Twall ) Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri call unoh ( bcTflux , cth , logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field obcTfluxA = obcTfluxA + bcTflux iocth ( i , j , k ) = cth iotflux ( i , j , k ) = iotflux ( i , j , k ) + bcTflux * dxfi ( i ) iot ( i , j , k ) = iot ( i , j , k ) - 0.5 * ( ekh ( ip , j , k ) * dxf ( i ) + ekh ( i , j , k ) * dxf ( ip )) * ( Tcell ( ip , j , k ) - Tcell ( i , j , k )) * dxh2i ( ip ) * dxfi ( i ) - bcTflux * dxfi ( i ) ! END DO END DO !!! case 22 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !wfuno22 !wall in yz -> wf in x (=vertical), upper wall, east wall CASE ( 22 ) i = block ( n , 2 ) + 1 ! im = i - 1 ! jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ! starting j-index ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) ! ending j-index kl = block ( n , 5 ) ! starting k-index ku = block ( n , 6 ) ! ending k-index delta = dxh ( i ) * 0.5 logdz = LOG ( delta / z0 ) logdzh = LOG ( delta / z0h ) logzh = LOG ( z0 / z0h ) sqdz = SQRT ( delta / z0 ) DO k = kl , ku DO j = jl , ju utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j + 1 , k )) * 0.5 utang2Int = ( utang2 ( i , j , k ) + utang2 ( i , j , k + 1 )) * 0.5 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = ( Tcell ( i , j , k ) - Twall ) Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri call unoh ( bcTflux , cth , logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field obcTfluxA = obcTfluxA + bcTflux iotflux ( i , j , k ) = iotflux ( i , j , k ) + bcTflux * dxfi ( i ) iocth ( i , j , k ) = cth iot ( i , j , k ) = iot ( i , j , k ) + 0.5 * ( ekh ( i , j , k ) * dxf ( im ) + ekh ( im , j , k ) * dxf ( i )) * ( Tcell ( i , j , k ) - Tcell ( im , j , k )) * dxh2i ( i ) * dxfi ( i ) - bcTflux * dxfi ( i ) END DO END DO !!! case 32 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !wfuno32 CASE ( 32 ) !wall in xz -> wf in y (=vertical) upper, north wall j = ind jm = j - 1 il = block ( n , 1 ) iu = block ( n , 2 ) kl = block ( n , 5 ) ku = block ( n , 6 ) delta = 0.5 * dy logdz = LOG ( delta / z0 ) logdzh = LOG ( delta / z0h ) logzh = LOG ( z0 / z0h ) sqdz = SQRT ( delta / z0 ) DO k = kl , ku DO i = il , iu utang1Int = ( utang1 ( i , j , k ) + utang1 ( i + 1 , j , k )) * 0.5 utang2Int = ( utang2 ( i , j , k ) + utang2 ( i , j , k + 1 )) * 0.5 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = ( Tcell ( i , j , k ) - Twall ) Ribl0 = grav * delta * dT / ( Twall * utangInt ) ! call unoh ( bcTflux , cth , logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) obcTfluxA = obcTfluxA + bcTflux iotflux ( i , j , k ) = iotflux ( i , j , k ) + bcTflux * dyi iocth ( i , j , k ) = cth iot ( i , j , k ) = iot ( i , j , k ) + ( & 0.5 * ( ekh ( i , j , k ) + ekh ( i , jm , k )) * ( Tcell ( i , j , k ) - Tcell ( i , jm , k ))) * dy2i & - bcTflux * dyi END DO END DO !!! case 42 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !wfuno42 CASE ( 42 ) !wall in xz -> wf in y (=vertical) lower, south wall j = ind jp = j + 1 il = block ( n , 1 ) iu = block ( n , 2 ) kl = block ( n , 5 ) ku = block ( n , 6 ) delta = 0.5 * dy logdz = LOG ( delta / z0 ) logdzh = LOG ( delta / z0h ) logzh = LOG ( z0 / z0h ) sqdz = SQRT ( delta / z0 ) DO k = kl , ku DO i = il , iu utang1Int = ( utang1 ( i , j , k ) + utang1 ( i + 1 , j , k )) * 0.5 utang2Int = ( utang2 ( i , j , k ) + utang2 ( i , j , k + 1 )) * 0.5 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = ( Tcell ( i , j , k ) - Twall ) Ribl0 = grav * delta * dT / ( Twall * utangInt ) ! call unoh ( bcTflux , cth , logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) obcTfluxA = obcTfluxA + bcTflux iotflux ( i , j , k ) = iotflux ( i , j , k ) + bcTflux * dyi iocth ( i , j , k ) = cth iot ( i , j , k ) = iot ( i , j , k ) - & 0.5 * ( ekh ( i , jp , k ) + ekh ( i , j , k )) * ( Tcell ( i , jp , k ) - Tcell ( i , j , k )) * dy2i & - bcTflux * dyi END DO END DO !!! case 52 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !wfuno52 CASE ( 52 ) !wall in xy -> wf in z (=horizontal), top wall k = block ( n , 6 ) + 1 !block location if (. not .( k . gt . kmax )) then km = k - 1 ! il = block ( n , 1 ) iu = block ( n , 2 ) jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) delta = dzf ( k ) * 0.5 logdz = LOG ( delta / z0 ) logdzh = LOG ( delta / z0h ) logzh = LOG ( z0 / z0h ) sqdz = SQRT ( delta / z0 ) DO j = jl , ju DO i = il , iu utang1Int = ( utang1 ( i , j , k ) + utang1 ( i + 1 , j , k )) * 0.5 utang2Int = ( utang2 ( i , j , k ) + utang2 ( i , j + 1 , k )) * 0.5 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = ( Tcell ( i , j , k ) - Twall ) Ribl0 = grav * delta * dT / ( Twall * utangInt ) ! call unoh ( bcTflux , cth , logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) obcTfluxA = obcTfluxA + bcTflux iotflux ( i , j , k ) = iotflux ( i , j , k ) + bcTflux * dzfi ( k ) iocth ( i , j , k ) = cth iot ( i , j , k ) = iot ( i , j , k ) & + 0.5 * ( dzf ( km ) * ekh ( i , j , k ) + dzf ( k ) * ekh ( i , j , km )) * ( Tcell ( i , j , k ) - Tcell ( i , j , km )) * dzh2i ( k ) * dzfi ( k ) & - bcTflux * dzfi ( k ) END DO END DO end if !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CASES FOR MOMENTUM!!!!!!!!!!!!!!!!!!!!!!!!!!!!! CASE ( 11 ) !wfuno11, case 11 , west wall i = block ( n , 1 ) - 1 !fluid location (also where wall variables are stored) ip = i + 1 !inside wall, used for subtracting original diffusion term jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) + 1 ! starting j-index      !might cause problem when jl=1 ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) ! ending j-index     !might cause problem when ju=jmax kl = block ( n , 5 ) ! starting k-index ku = block ( n , 6 ) ! ending k-index delta = dxf ( i ) * 0.5 logdz = LOG ( delta / z0 ) logdzh = LOG ( delta / z0h ) logzh = LOG ( z0 / z0h ) sqdz = SQRT ( delta / z0 ) !v west DO k = kl , ku DO j = jl , ju utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i , j , k + 1 ) + utang2 ( i , j - 1 , k ) + utang2 ( i , j - 1 , k + 1 )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = (( Tcell ( i , j , k ) + Tcell ( i , j - 1 , k )) - ( Twall + Twall )) * 0.5 Ribl0 = grav * delta * dT * 2 / (( Twall + Twall ) * utangInt ) !Eq. 6, guess initial Ri ctm = unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field dummy = ( utang1Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) epmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) * dxf ( ip ) + & ( ekm ( ip , j , k ) + ekm ( ip , j - 1 , k )) * dxf ( i )) * dxhi ( ip ) iout1 ( i , j , k ) = iout1 ( i , j , k ) - ( utang1 ( ip , j , k ) - utang1 ( i , j , k )) * epmo * dxhi ( ip ) * dxfi ( i ) - bcmomflux * dxfi ( i ) ! END DO END DO !v west edge south j = MAX ( block ( n , 3 ) - myid * jmax , 1 ) DO k = kl , ku utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i , j , k + 1 ) + utang2 ( i , j - 1 , k ) + utang2 ( i , j - 1 , k + 1 )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j , k ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang1Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) * 0.5 !only half since on edge of block (another half might come from another processor?) !   epmo = 0.5 * (ekm(ip,j,k)*dxf(i) + ekm(i,j,k)*dxf(ip)) * dxhi(ip) epmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) * dxf ( ip ) + & ( ekm ( ip , j , k ) + ekm ( ip , j - 1 , k )) * dxf ( i )) * dxhi ( ip ) iout1 ( i , j , k ) = iout1 ( i , j , k ) - (( utang1 ( ip , j , k ) - utang1 ( i , j , k )) * epmo * dxhi ( ip ) * dxfi ( i ) - bcmomflux * dxfi ( i )) * 0.5 ! remove standard diffusion apply only half of wall-flux since it's an edge !only half of the flux, since only half of the control-volume around v is touching this facet (other half is either in free air or touching another facet) END DO !v west edge north j = MIN ( block ( n , 4 ) - myid * jmax , jmax ) + 1 DO k = kl , ku utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i , j , k + 1 ) + utang2 ( i , j - 1 , k ) + utang2 ( i , j - 1 , k + 1 )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j - 1 , k ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang1Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) * 0.5 epmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) * dxf ( ip ) + & ( ekm ( ip , j , k ) + ekm ( ip , j - 1 , k )) * dxf ( i )) * dxhi ( ip ) iout1 ( i , j , k ) = iout1 ( i , j , k ) - (( utang1 ( ip , j , k ) - utang1 ( i , j , k )) * epmo * dxhi ( ip ) * dxfi ( i ) - bcmomflux * dxfi ( i )) * 0.5 ! %remove standard diffusion apply only half of wall-flux since it's an edge END DO !w west jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ! kl = block ( n , 5 ) + 1 ! DO k = kl , ku DO j = jl , ju utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j + 1 , k ) + utang1 ( i , j + 1 , k - 1 ) + utang1 ( i , j , k - 1 )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = (( Tcell ( i , j , k ) + Tcell ( i , j , k - 1 )) - ( Twall + Twall )) * 0.5 Ribl0 = grav * delta * dT * 2 / (( Twall + Twall ) * utangInt ) !Eq. 6, guess initial Ri ctm = unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field dummy = ( utang2Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) epom = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) * dxf ( ip ) + ekm ( ip , j , k ) * dxf ( i )) * dxhi ( ip ) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) * dxf ( ip ) + ekm ( ip , j , k - 1 ) * dxf ( i )) * dxhi ( ip )) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) - ( utang2 ( ip , j , k ) - utang2 ( i , j , k )) * epom * dxhi ( ip ) * dxfi ( i ) - bcmomflux * dxfi ( i ) ! END DO END DO !w west top edge k = block ( n , 6 ) + 1 ! ending k-index km = k - 1 DO j = jl , ju utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j + 1 , k ) + utang1 ( i , j + 1 , k - 1 ) + utang1 ( i , j , k - 1 )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j , k - 1 ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang2Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) * 0.5 epom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( ip ) + ekm ( ip , j , k ) * dxf ( i )) * dxhi ( ip ) + & dzf ( k ) * ( ekm ( i , j , km ) * dxf ( ip ) + ekm ( ip , j , km ) * dxf ( i )) * dxhi ( ip )) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) - (( utang2 ( ip , j , k ) - utang2 ( i , j , k )) * epom * dxhi ( ip ) * dxfi ( i ) - bcmomflux * dxfi ( i )) * 0.5 ! END DO !w west bottom edge k = block ( n , 6 ) ! ending k-index if ( k . gt . 0 ) then km = k - 1 DO j = jl , ju utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j + 1 , k ) + utang1 ( i , j + 1 , k - 1 ) + utang1 ( i , j , k - 1 )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j , k - 1 ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang2Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) * 0.5 epom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( ip ) + ekm ( ip , j , k ) * dxf ( i )) * dxhi ( ip ) + & dzf ( k ) * ( ekm ( i , j , km ) * dxf ( ip ) + ekm ( ip , j , km ) * dxf ( i )) * dxhi ( ip )) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) - (( utang2 ( ip , j , k ) - utang2 ( i , j , k )) * epom * dxhi ( ip ) * dxfi ( i ) - bcmomflux * dxfi ( i )) * 0.5 ! END DO end if !!! case 21 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !wfuno 21 !wall in yz -> wf in x (=vertical), upper wall, east wall CASE ( 21 ) !v east i = block ( n , 2 ) + 1 !fluid im = i - 1 !inside block jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) + 1 ! starting j-index      !might cause problem when jl=1 ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) ! ending j-index     !might cause problem when ju=jmax kl = block ( n , 5 ) ! starting k-index ku = block ( n , 6 ) ! ending k-index delta = dxh ( i ) * 0.5 logdz = LOG ( delta / z0 ) logdzh = LOG ( delta / z0h ) logzh = LOG ( z0 / z0h ) sqdz = SQRT ( delta / z0 ) DO k = kl , ku DO j = jl , ju utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i , j , k + 1 ) + utang2 ( i , j - 1 , k ) + utang2 ( i , j - 1 , k + 1 )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = (( Tcell ( i , j , k ) + Tcell ( i , j - 1 , k )) - ( Twall + Twall )) * 0.5 Ribl0 = grav * delta * dT * 2 / (( Twall + Twall ) * utangInt ) !Eq. 6, guess initial Ri !call function repeatedly ctm = unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field dummy = ( utang1Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) emmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) * dxf ( im ) + ( ekm ( im , j - 1 , k ) + ekm ( im , j , k )) * dxf ( i )) * dxhi ( i ) ! dx is non-equidistant iout1 ( i , j , k ) = iout1 ( i , j , k ) + ( utang1 ( i , j , k ) - utang1 ( im , j , k )) * emmo * dxhi ( i ) * dxfi ( i ) - bcmomflux * dxfi ( i ) ! END DO END DO !v east edge south j = MAX ( block ( n , 3 ) - myid * jmax , 1 ) DO k = kl , ku utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i , j , k + 1 ) + utang2 ( i , j - 1 , k ) + utang2 ( i , j - 1 , k + 1 )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j , k ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang1Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) * 0.5 emmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) * dxf ( im ) + ( ekm ( im , j - 1 , k ) + ekm ( im , j , k )) * dxf ( i )) * dxhi ( i ) ! dx is non-equidistant iout1 ( i , j , k ) = iout1 ( i , j , k ) + (( utang1 ( i , j , k ) - utang1 ( im , j , k )) * emmo * dxhi ( i ) * dxfi ( i ) - bcmomflux * dxfi ( i )) * 0.5 ! END DO !v east edge north j = MIN ( block ( n , 4 ) - myid * jmax , jmax ) + 1 ! DO k = kl , ku utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i , j , k + 1 ) + utang2 ( i , j - 1 , k ) + utang2 ( i , j - 1 , k + 1 )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j - 1 , k ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang1Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) * 0.5 emmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) * dxf ( im ) + ( ekm ( im , j - 1 , k ) + ekm ( im , j , k )) * dxf ( i )) * dxhi ( i ) ! dx is non-equidistant iout1 ( i , j , k ) = iout1 ( i , j , k ) + (( utang1 ( i , j , k ) - utang1 ( im , j , k )) * emmo * dxhi ( i ) * dxfi ( i ) - bcmomflux * dxfi ( i )) * 0.5 ! END DO !w east jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ! kl = block ( n , 5 ) + 1 ! DO k = kl , ku DO j = jl , ju utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j + 1 , k ) + utang1 ( i , j + 1 , k - 1 ) + utang1 ( i , j , k - 1 )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = (( Tcell ( i , j , k ) + Tcell ( i , j , k - 1 )) - ( Twall + Twall )) * 0.5 Ribl0 = grav * delta * dT * 2 / (( Twall + Twall ) * utangInt ) !Eq. 6, guess initial Ri ctm = unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field dummy = ( utang2Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) emom = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) * dxf ( im ) + ekm ( im , j , k ) * dxf ( i )) * dxhi ( i ) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) * dxf ( im ) + ekm ( im , j , k - 1 ) * dxf ( i )) * dxhi ( i )) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) + ( utang2 ( i , j , k ) - utang2 ( im , j , k )) * emom * dxhi ( i ) * dxfi ( i ) - bcmomflux * dxfi ( i ) ! END DO END DO !w east edge top k = block ( n , 6 ) + 1 ! ending k-index DO j = jl , ju utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j + 1 , k ) + utang1 ( i , j + 1 , k - 1 ) + utang1 ( i , j , k - 1 )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j , k - 1 ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang2Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) * 0.5 emom = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) * dxf ( im ) + ekm ( im , j , k ) * dxf ( i )) * dxhi ( i ) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) * dxf ( im ) + ekm ( im , j , k - 1 ) * dxf ( i )) * dxhi ( i )) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) + (( utang2 ( i , j , k ) - utang2 ( im , j , k )) * emom * dxhi ( i ) * dxfi ( i ) - bcmomflux * dxfi ( i )) * 0.5 ! END DO !w east edge bot k = block ( n , 6 ) ! if ( k . gt . 0 ) then DO j = jl , ju utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j + 1 , k ) + utang1 ( i , j + 1 , k - 1 ) + utang1 ( i , j , k - 1 )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j , k - 1 ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang2Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) * 0.5 emom = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) * dxf ( im ) + ekm ( im , j , k ) * dxf ( i )) * dxhi ( i ) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) * dxf ( im ) + ekm ( im , j , k - 1 ) * dxf ( i )) * dxhi ( i )) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) + (( utang2 ( i , j , k ) - utang2 ( im , j , k )) * emom * dxhi ( i ) * dxfi ( i ) - bcmomflux * dxfi ( i )) * 0.5 ! END DO end if !!! case 31 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !wfuno 31 CASE ( 31 ) !wall in xz -> wf in y (=vertical) upper, north wall j = ind jm = j - 1 il = block ( n , 1 ) + 1 iu = block ( n , 2 ) kl = block ( n , 5 ) ku = block ( n , 6 ) delta = 0.5 * dy logdz = LOG ( delta / z0 ) logdzh = LOG ( delta / z0h ) logzh = LOG ( z0 / z0h ) sqdz = SQRT ( delta / z0 ) !u north DO k = kl , ku DO i = il , iu utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i - 1 , j , k ) + utang2 ( i , j , k + 1 ) + utang2 ( i - 1 , j , k + 1 )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = (( Tcell ( i , j , k ) + Tcell ( i - 1 , j , k )) - ( Twall + Twall )) * 0.5 Ribl0 = grav * delta * dT * 2 / (( Twall + Twall ) * utangInt ) !Eq. 6, guess initial Ri ctm = unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field dummy = ( utang1Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi emmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , jm , k )) * dxf ( i - 1 ) + ( ekm ( i - 1 , jm , k ) + ekm ( i - 1 , j , k )) * dxf ( i )) * dxhi ( i ) iout1 ( i , j , k ) = iout1 ( i , j , k ) + ( utang1 ( i , j , k ) - utang1 ( i , jm , k )) * emmo * dy2i - bcmomflux * dyi ! END DO END DO !u north east edge i = block ( n , 2 ) + 1 DO k = kl , ku utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i - 1 , j , k ) + utang2 ( i , j , k + 1 ) + utang2 ( i - 1 , j , k + 1 )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i - 1 , j , k ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang1Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi5 emmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , jm , k )) * dxf ( i - 1 ) + ( ekm ( i - 1 , jm , k ) + ekm ( i - 1 , j , k )) * dxf ( i )) * dxhi ( i ) iout1 ( i , j , k ) = iout1 ( i , j , k ) + (( utang1 ( i , j , k ) - utang1 ( i , jm , k )) * emmo * dy2i - bcmomflux * dyi ) * 0.5 ! END DO !u north west edge i = block ( n , 1 ) DO k = kl , ku utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i - 1 , j , k ) + utang2 ( i , j , k + 1 ) + utang2 ( i - 1 , j , k + 1 )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j , k ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang1Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi5 emmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , jm , k )) * dxf ( i - 1 ) + ( ekm ( i - 1 , jm , k ) + ekm ( i - 1 , j , k )) * dxf ( i )) * dxhi ( i ) iout1 ( i , j , k ) = iout1 ( i , j , k ) + (( utang1 ( i , j , k ) - utang1 ( i , jm , k )) * emmo * dy2i - bcmomflux * dyi ) * 0.5 ! END DO !w north il = block ( n , 1 ) ! kl = block ( n , 5 ) + 1 ! DO k = kl , ku DO i = il , iu utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j , k - 1 ) + utang1 ( i + 1 , j , k ) + utang1 ( i + 1 , j , k - 1 )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = (( Tcell ( i , j , k ) + Tcell ( i , j , k - 1 )) - ( Twall + Twall )) * 0.5 Ribl0 = grav * delta * dT * 2 / (( Twall + Twall ) * utangInt ) !Eq. 6, guess initial Ri ctm = unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field dummy = ( utang2Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi eomm = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , jm , k )) + dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , jm , k - 1 ))) * dzhiq ( k ) ! dz is non-eqidistant iout2 ( i , j , k ) = iout2 ( i , j , k ) + ( utang2 ( i , j , k ) - utang2 ( i , jm , k )) * eomm * dy2i - bcmomflux * dyi ! END DO END DO !w north edge top k = block ( n , 6 ) + 1 DO i = il , iu utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j , k - 1 ) + utang1 ( i + 1 , j , k ) + utang1 ( i + 1 , j , k - 1 )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j , k - 1 ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang2Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi5 eomm = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , jm , k )) + dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , jm , k - 1 ))) * dzhiq ( k ) ! dz is non-eqidistant iout2 ( i , j , k ) = iout2 ( i , j , k ) + (( utang2 ( i , j , k ) - utang2 ( i , jm , k )) * eomm * dy2i - bcmomflux * dyi ) * 0.5 ! END DO !w north edge bot k = block ( n , 6 ) if ( k . gt . 0 ) then DO i = il , iu utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j , k - 1 ) + utang1 ( i + 1 , j , k ) + utang1 ( i + 1 , j , k - 1 )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j , k - 1 ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang2Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi5 eomm = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , jm , k )) + dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , jm , k - 1 ))) * dzhiq ( k ) ! dz is non-eqidistant iout2 ( i , j , k ) = iout2 ( i , j , k ) + (( utang2 ( i , j , k ) - utang2 ( i , jm , k )) * eomm * dy2i - bcmomflux * dyi ) * 0.5 ! END DO end if !!! case 41 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!` !wfuno41 CASE ( 41 ) !wall in xz -> wf in y (=vertical) lower, south wall j = ind jp = j + 1 il = block ( n , 1 ) + 1 iu = block ( n , 2 ) kl = block ( n , 5 ) ku = block ( n , 6 ) delta = 0.5 * dy logdz = LOG ( delta / z0 ) logdzh = LOG ( delta / z0h ) logzh = LOG ( z0 / z0h ) sqdz = SQRT ( delta / z0 ) DO k = kl , ku DO i = il , iu utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i - 1 , j , k ) + utang2 ( i , j , k + 1 ) + utang2 ( i - 1 , j , k + 1 )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = (( Tcell ( i , j , k ) + Tcell ( i - 1 , j , k )) - ( Twall + Twall )) * 0.5 Ribl0 = grav * delta * dT * 2 / (( Twall + Twall ) * utangInt ) !Eq. 6, guess initial Ri ctm = unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field dummy = ( utang1Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi empo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , jp , k )) * dxf ( i - 1 ) + & ( ekm ( i - 1 , j , k ) + ekm ( i - 1 , jp , k )) * dxf ( i )) * dxhi ( i ) ! dx is non-equidistant iout1 ( i , j , k ) = iout1 ( i , j , k ) - ( utang1 ( i , jp , k ) - utang1 ( i , j , k )) * empo * dy2i - bcmomflux * dyi ! END DO END DO !u south edge west i = block ( n , 1 ) DO k = kl , ku utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i - 1 , j , k ) + utang2 ( i , j , k + 1 ) + utang2 ( i - 1 , j , k + 1 )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j , k ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang1Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi5 empo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , jp , k )) * dxf ( i - 1 ) + & ( ekm ( i - 1 , j , k ) + ekm ( i - 1 , jp , k )) * dxf ( i )) * dxhi ( i ) ! dx is non-equidistant iout1 ( i , j , k ) = iout1 ( i , j , k ) - (( utang1 ( i , jp , k ) - utang1 ( i , j , k )) * empo * dy2i - bcmomflux * dyi ) * 0.5 ! END DO !u south edge east i = block ( n , 2 ) + 1 DO k = kl , ku utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i - 1 , j , k ) + utang2 ( i , j , k + 1 ) + utang2 ( i - 1 , j , k + 1 )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i - 1 , j , k ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang1Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi5 empo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , jp , k )) * dxf ( i - 1 ) + & ( ekm ( i - 1 , j , k ) + ekm ( i - 1 , jp , k )) * dxf ( i )) * dxhi ( i ) ! dx is non-equidistant iout1 ( i , j , k ) = iout1 ( i , j , k ) - (( utang1 ( i , jp , k ) - utang1 ( i , j , k )) * empo * dy2i - bcmomflux * dyi ) * 0.5 ! END DO !w south il = block ( n , 1 ) ! kl = block ( n , 5 ) + 1 ! DO k = kl , ku DO i = il , iu utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j , k - 1 ) + utang1 ( i + 1 , j , k ) + utang1 ( i + 1 , j , k - 1 )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = (( Tcell ( i , j , k ) + Tcell ( i , j , k - 1 )) - ( Twall + Twall )) * 0.5 Ribl0 = grav * delta * dT * 2 / (( Twall + Twall ) * utangInt ) !Eq. 6, guess initial Ri ctm = unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field dummy = ( utang2Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi eopm = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , jp , k )) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , jp , k - 1 ))) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) - ( utang2 ( i , jp , k ) - utang2 ( i , j , k )) * eopm * dy2i - bcmomflux * dyi ! END DO END DO !w south edge top k = block ( n , 6 ) + 1 DO i = il , iu utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j , k - 1 ) + utang1 ( i + 1 , j , k ) + utang1 ( i + 1 , j , k - 1 )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j , k - 1 ) - Twall Ribl0 = grav * delta * dT * 2 / ( Twall * utangInt ) !Eq. 6, guess initial Ri !call function repeatedly dummy = ( utang2Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi5 eopm = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , jp , k )) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , jp , k - 1 ))) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) - (( utang2 ( i , jp , k ) - utang2 ( i , j , k )) * eopm * dy2i - bcmomflux * dyi ) * 0.5 ! END DO !w south edge bot k = block ( n , 6 ) if ( k . gt . 0 ) then DO i = il , iu utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j , k - 1 ) + utang1 ( i + 1 , j , k ) + utang1 ( i + 1 , j , k - 1 )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j , k - 1 ) - Twall Ribl0 = grav * delta * dT * 2 / ( Twall * utangInt ) !Eq. 6, guess initial Ri !call function repeatedly dummy = ( utang2Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi5 eopm = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , jp , k )) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , jp , k - 1 ))) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) - (( utang2 ( i , jp , k ) - utang2 ( i , j , k )) * eopm * dy2i - bcmomflux * dyi ) * 0.5 ! END DO end if !!!! case 51 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !wfuno51 CASE ( 51 ) !wall in xy -> wf in z (=horizontal), top wall k = block ( n , 6 ) + 1 !block location if (. not .( k . gt . kmax )) then km = k - 1 !shear velocity location il = block ( n , 1 ) + 1 iu = block ( n , 2 ) jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) delta = 0.5 * dzf ( k ) logdz = LOG ( delta / z0 ) logdzh = LOG ( delta / z0h ) logzh = LOG ( z0 / z0h ) sqdz = SQRT ( delta / z0 ) DO j = jl , ju DO i = il , iu utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i - 1 , j , k ) + utang2 ( i , j + 1 , k ) + utang2 ( i - 1 , j + 1 , k )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = (( Tcell ( i , j , k ) + Tcell ( i - 1 , j , k )) - ( Twall + Twall )) * 0.5 Ribl0 = grav * delta * dT * 2 / (( Twall + Twall ) * utangInt ) !Eq. 6, guess initial Ri ctm = unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field dummy = ( utang1Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) emom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k ) * dxf ( i )) + & dzf ( k ) * ( ekm ( i , j , km ) * dxf ( i - 1 ) + ekm ( i - 1 , j , km ) * dxf ( i ))) * dxhi ( i ) * dzhiq ( k ) iout1 ( i , j , k ) = iout1 ( i , j , k ) + ( utang1 ( i , j , k ) - utang1 ( i , j , km )) * emom * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k ) ! END DO END DO !u top edge west i = block ( n , 1 ) DO j = jl , ju utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i - 1 , j , k ) + utang2 ( i , j + 1 , k ) + utang2 ( i - 1 , j + 1 , k )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j , k ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang1Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) * 0.5 emom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k ) * dxf ( i )) + & dzf ( k ) * ( ekm ( i , j , km ) * dxf ( i - 1 ) + ekm ( i - 1 , j , km ) * dxf ( i ))) * dxhi ( i ) * dzhiq ( k ) iout1 ( i , j , k ) = iout1 ( i , j , k ) + (( utang1 ( i , j , k ) - utang1 ( i , j , km )) * emom * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k )) * 0.5 ! END DO !u top edge east DO j = jl , ju utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i - 1 , j , k ) + utang2 ( i , j + 1 , k ) + utang2 ( i - 1 , j + 1 , k )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i - 1 , j , k ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang1Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) * 0.5 emom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k ) * dxf ( i )) + & dzf ( k ) * ( ekm ( i , j , km ) * dxf ( i - 1 ) + ekm ( i - 1 , j , km ) * dxf ( i ))) * dxhi ( i ) * dzhiq ( k ) iout1 ( i , j , k ) = iout1 ( i , j , k ) + (( utang1 ( i , j , k ) - utang1 ( i , j , km )) * emom * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k )) * 0.5 ! END DO !v il = block ( n , 1 ) jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) + 1 DO j = jl , ju DO i = il , iu utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j - 1 , k ) + utang1 ( i + 1 , j - 1 , k ) + utang1 ( i + 1 , j , k )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = (( Tcell ( i , j , k ) + Tcell ( i , j - 1 , k )) - ( Twall + Twall )) * 0.5 Ribl0 = grav * delta * dT * 2 / (( Twall + Twall ) * utangInt ) !Eq. 6, guess initial Ri ctm = unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field dummy = ( utang2Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) eomm = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) + dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i , j - 1 , km ))) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) + ( utang2 ( i , j , k ) - utang2 ( i , j , km )) * eomm * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k ) ! END DO END DO !v top edge south j = MAX ( block ( n , 3 ) - myid * jmax , 1 ) DO i = il , iu utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j - 1 , k ) + utang1 ( i + 1 , j - 1 , k ) + utang1 ( i + 1 , j , k )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j , k ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang2Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) * 0.5 eomm = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) + dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i , j - 1 , km ))) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) + (( utang2 ( i , j , k ) - utang2 ( i , j , km )) * eomm * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k )) * 0.5 ! END DO !v top edge north j = MIN ( block ( n , 4 ) - myid * jmax , jmax ) + 1 DO i = il , iu utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j - 1 , k ) + utang1 ( i + 1 , j - 1 , k ) + utang1 ( i + 1 , j , k )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j - 1 , k ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang2Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) * 0.5 eomm = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) + dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i , j - 1 , km ))) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) + (( utang2 ( i , j , k ) - utang2 ( i , j , km )) * eomm * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k )) * 0.5 ! END DO end if !!!!!!!!!!!!!!!SPECIAL CASES FOR THE SURFACE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !can actually be made redundant and just be replaced by standard horizontal case (doesn't really matter though) CASE ( 91 ) !surface momentum flux k = kb ! km = k - 1 ! il = ib iu = ie jl = jb ju = je delta = 0.5 * dzf ( k ) !might need attention on streched grids! as well as the dzfi when updating up logdz = LOG ( delta / z0 ) logdzh = LOG ( delta / z0h ) logzh = LOG ( z0 / z0h ) sqdz = SQRT ( delta / z0 ) DO j = jl , ju !u component DO i = il , iu utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i - 1 , j , k ) + utang2 ( i , j + 1 , k ) + utang2 ( i - 1 , j + 1 , k )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = (( Tcell ( i , j , k ) + Tcell ( i - 1 , j , k )) - ( Twall + Twall )) * 0.5 Ribl0 = grav * delta * dT * 2 / (( Twall + Twall ) * utangInt ) !Eq. 6, guess initial Ri ctm = unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field dummy = ( utang1Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang1Int ) !bcmomflux=u_star&#94;2 iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) emom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k ) * dxf ( i )) + & ! dx is non-equidistant dzf ( k ) * ( ekm ( i , j , km ) * dxf ( i - 1 ) + ekm ( i - 1 , j , km ) * dxf ( i ))) * dxhi ( i ) * dzhiq ( k ) iout1 ( i , j , k ) = iout1 ( i , j , k ) + ( utang1 ( i , j , k ) - utang1 ( i , j , km )) * emom * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k ) ! END DO END DO DO j = jl , ju DO i = il , iu utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j - 1 , k ) + utang1 ( i + 1 , j - 1 , k ) + utang1 ( i + 1 , j , k )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = (( Tcell ( i , j , k ) + Tcell ( i , j - 1 , k )) - ( Twall + Twall )) * 0.5 Ribl0 = grav * delta * dT * 2 / (( Twall + Twall ) * utangInt ) !Eq. 6, guess initial Ri ctm = unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field dummy = ( utang2Int ** 2 ) * ctm !save result and update field bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) eomm = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) + dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i , j - 1 , km ))) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) + ( utang2 ( i , j , k ) - utang2 ( i , j , km )) * eomm * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k ) ! END DO END DO !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! CASE ( 92 ) !surface temperature flux k = kb !block location ku = k !shear velocity location il = ib iu = ie jl = jb ju = je delta = dzf ( k ) * 0.5 logdz = LOG ( delta / z0 ) logdzh = LOG ( delta / z0h ) logzh = LOG ( z0 / z0h ) sqdz = SQRT ( delta / z0 ) DO j = jl , ju DO i = il , iu utang1Int = ( utang1 ( i , j , ku ) + utang1 ( i + 1 , j , ku )) * 0.5 utang2Int = ( utang2 ( i , j , ku ) + utang2 ( i , j + 1 , ku )) * 0.5 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = ( Tcell ( i , j , ku ) - Twall ) Ribl0 = grav * delta * dT / ( Twall * utangInt ) ! call unoh ( bcTflux , cth , logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) obcTfluxA = obcTfluxA + bcTflux iotflux ( i , j , k ) = iotflux ( i , j , k ) + bcTflux * dzfi ( k ) iot ( i , j , ku ) = iot ( i , j , ku ) + & 0.5 * ( dzf ( k - 1 ) * ekh ( i , j , k ) + dzf ( k ) * ekh ( i , j , k - 1 )) * & ! zero flux ( Tcell ( i , j , k ) - Tcell ( i , j , k - 1 )) * dzh2i ( ku ) * dzfi ( ku ) & - bcTflux * dzfi ( k ) END DO END DO END SELECT END SUBROUTINE wfuno !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!FUNCTIONS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !for scalar !FUNCTION unoh(logdz, logdzh, logzh, sqdz, utangInt, dT, Ribl0, fkar2) !for heat, the bit that does not change no matter what wall SUBROUTINE unoh ( otf , octh , logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !for heat, the bit that does not change no matter what wall !flux in Km/s IMPLICIT NONE REAL , INTENT ( in ) :: logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 REAL , INTENT ( out ) :: octh , otf REAL :: Ribl1 , Fm , Fh , cm , ch , M , dTrough , cth REAL , PARAMETER :: b1 = 9.4 !parameters from Uno1995 REAL , PARAMETER :: b2 = 4.7 REAL , PARAMETER :: dm = 7.4 REAL , PARAMETER :: dh = 5.3 REAL , PARAMETER :: prandtlmol = 0.71 REAL , PARAMETER :: prandtlmoli = 1 / 0.71 octh = 0. otf = 0. IF ( Ribl0 > 0.21 ) THEN !0.25 approx critical for bulk Richardson number  => stable Fm = 1. / ( 1. + b2 * Ribl0 ) ** 2 !Eq. 4 Fh = Fm !Eq. 4 ELSE ! => unstable cm = ( dm * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 ch = ( dh * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 Fm = 1. - ( b1 * Ribl0 ) / ( 1. + cm * SQRT ( ABS ( Ribl0 ))) !Eq. 3 Fh = 1. - ( b1 * Ribl0 ) / ( 1. + ch * SQRT ( ABS ( Ribl0 ))) !Eq. 3 END IF M = prandtlmol * logdz * SQRT ( Fm ) / Fh !Eq. 14 Ribl1 = Ribl0 - Ribl0 * prandtlmol * logzh / ( prandtlmol * logzh + M ) !Eq. 17 !interate to get new Richardson number IF ( Ribl1 > 0.21 ) THEN !0.25 approx critical for bulk Richardson number  => stable Fm = 1. / ( 1. + b2 * Ribl1 ) ** 2 !Eq. 4 Fh = Fm !Eq. 4 ELSE ! => unstable cm = ( dm * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 ch = ( dh * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 Fm = 1. - ( b1 * Ribl1 ) / ( 1. + cm * SQRT ( ABS ( Ribl1 ))) !Eq. 3 Fh = 1. - ( b1 * Ribl1 ) / ( 1. + ch * SQRT ( ABS ( Ribl1 ))) !Eq. 3 END IF M = prandtlmol * logdz * SQRT ( Fm ) / Fh !Eq. 14 dTrough = dT * 1. / ( prandtlmol * logzh / M + 1. ) !Eq. 13a octh = SQRT ( utangInt ) * fkar2 / ( logdz * logdzh ) * prandtlmoli * Fh !Eq. 8 otf = octh * dTrough !Eq. 2, Eq. 8 END SUBROUTINE unoh !END FUNCTION unoh !!!!!!!!!!!!! !for momentum REAL FUNCTION unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !for momentum, this bit is not depended on orientation etc !momentum flux in m2/s2 !dT,utang and logdzh are unused and could be removed IMPLICIT NONE REAL , INTENT ( in ) :: logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 REAL :: Ribl1 , Fm , Fh , cm , ch , Ctm , M REAL , PARAMETER :: b1 = 9.4 !parameters from Uno1995 REAL , PARAMETER :: b2 = 4.7 REAL , PARAMETER :: dm = 7.4 REAL , PARAMETER :: dh = 5.3 REAL , PARAMETER :: prandtlmol = 0.71 IF ( Ribl0 > 0.21 ) THEN !0.25 approx critical for bulk Richardson number  => stable Fm = 1. / ( 1. + b2 * Ribl0 ) ** 2 !Eq. 4 Fh = Fm !Eq. 4 ELSE ! => unstable cm = ( dm * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 ch = ( dh * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 Fm = 1. - ( b1 * Ribl0 ) / ( 1. + cm * SQRT ( ABS ( Ribl0 ))) !Eq. 3 Fh = 1. - ( b1 * Ribl0 ) / ( 1. + ch * SQRT ( ABS ( Ribl0 ))) !Eq. 3 END IF M = prandtlmol * logdz * SQRT ( Fm ) / Fh !Eq. 14 Ribl1 = Ribl0 - Ribl0 * prandtlmol * logzh / ( prandtlmol * logzh + M ) !Eq. 17 !interate to get new Richardson number IF ( Ribl1 > 0.21 ) THEN !0.25 approx critical for bulk Richardson number  => stable Fm = 1. / ( 1. + b2 * Ribl1 ) ** 2 !Eq. 4 ELSE ! => unstable cm = ( dm * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 Fm = 1. - ( b1 * Ribl1 ) / ( 1. + cm * SQRT ( ABS ( Ribl1 ))) !Eq. 3 END IF Ctm = fkar2 / ( logdz ** 2 ) * Fm !Eq. 7 unom = Ctm !Eq. 2, Eq. 8 END FUNCTION unom","tags":"","loc":"sourcefile/wf_uno.f90.html"},{"title":"domainptr – uDALES ","text":"type, private :: domainptr Contents Variables point Source Code domainptr Components Type Visibility Attributes Name Initial real, public, pointer :: point (:,:,:) Source Code type domainptr real , pointer :: point (:,:,:) end type domainptr","tags":"","loc":"type/domainptr.html"},{"title":"advecc_2nd – uDALES","text":"subroutine advecc_2nd(hi, hj, hk, putin, putout) Uses modglobal modfields modibm modibmdata initfac modmpi proc~~advecc_2nd~~UsesGraph proc~advecc_2nd advecc_2nd module~modibm modibm proc~advecc_2nd->module~modibm module~modibmdata modibmdata proc~advecc_2nd->module~modibmdata module~modmpi modmpi proc~advecc_2nd->module~modmpi module~initfac initfac proc~advecc_2nd->module~initfac module~modfields modfields proc~advecc_2nd->module~modfields module~modglobal modglobal proc~advecc_2nd->module~modglobal module~modibm->module~modibmdata mpi mpi module~modmpi->mpi module~initfac->module~modmpi module~initfac->module~modglobal netcdf netcdf module~initfac->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: hi integer, intent(in) :: hj integer, intent(in) :: hk real, intent(in), dimension(ib - hi:ie + hi, jb - hj:je + hj, kb - hk:ke + hk) :: putin real, intent(inout), dimension(ib - hi:ie + hi, jb - hj:je + hj, kb:ke + hk) :: putout Called by proc~~advecc_2nd~~CalledByGraph proc~advecc_2nd advecc_2nd proc~advection advection proc~advection->proc~advecc_2nd program~dalesurban DALESURBAN program~dalesurban->proc~advection Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code advecc_2nd Source Code subroutine advecc_2nd ( hi , hj , hk , putin , putout ) use modglobal , only : ih , jh , kh , kb , ke , ib , ie , jb , je , dxf , dxhi , dxfi5 , dyi5 , dzf , dzfi5 , dzhi , libm , jmax , dxfi , dzfi , dyi use modfields , only : u0 , v0 , w0 use modibm , only : nxwallsnorm , nzwallsnorm , nywallsm , nywallsp , ywallsm , ywallsp , & xwallsnorm , zwallsnorm , iypluswall , iyminwall , nyminwall , nypluswall use modibmdata , only : nxwall , ixwall use initfac , only : block use modmpi , only : myid implicit none integer , intent ( in ) :: hi !< size of halo in i integer , intent ( in ) :: hj !< size of halo in j integer , intent ( in ) :: hk !< size of halo in k real , dimension ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ), intent ( in ) :: putin !< Input: the cell centered field real , dimension ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ), intent ( inout ) :: putout !< Output: the tendency integer :: i , j , k , ip , im , jp , jm , kp , km , il , iu , jl , ju , kl , ku , n do k = kb , ke km = k - 1 kp = k + 1 do j = jb , je jm = j - 1 jp = j + 1 do i = ib , ie im = i - 1 ip = i + 1 putout ( i , j , k ) = putout ( i , j , k ) - ( & ( & u0 ( ip , j , k ) * ( putin ( ip , j , k ) * dxf ( i ) + putin ( i , j , k ) * dxf ( ip )) * dxhi ( ip ) & - u0 ( i , j , k ) * ( putin ( im , j , k ) * dxf ( i ) + putin ( i , j , k ) * dxf ( im )) * dxhi ( i ) & ! d(uc)/dx ) * dxfi5 ( i ) & + ( & ! v0 ( i , jp , k ) * ( putin ( i , jp , k ) + putin ( i , j , k )) & - v0 ( i , j , k ) * ( putin ( i , jm , k ) + putin ( i , j , k )) & ! d(vc)/dy ) * dyi5 ) end do end do end do do j = jb , je jm = j - 1 jp = j + 1 do i = ib , ie im = i - 1 ip = i + 1 do k = kb , ke km = k - 1 kp = k + 1 putout ( i , j , k ) = putout ( i , j , k ) - ( & w0 ( i , j , kp ) * ( putin ( i , j , kp ) * dzf ( k ) + putin ( i , j , k ) * dzf ( kp )) * dzhi ( kp ) & - w0 ( i , j , k ) * ( putin ( i , j , km ) * dzf ( k ) + putin ( i , j , k ) * dzf ( km )) * dzhi ( k ) & ) * dzfi5 ( k ) end do end do end do end subroutine advecc_2nd","tags":"","loc":"proc/advecc_2nd.html"},{"title":"advecu_2nd – uDALES","text":"subroutine advecu_2nd(putin, putout) Uses modglobal modfields modibm modmpi proc~~advecu_2nd~~UsesGraph proc~advecu_2nd advecu_2nd module~modmpi modmpi proc~advecu_2nd->module~modmpi module~modibm modibm proc~advecu_2nd->module~modibm module~modfields modfields proc~advecu_2nd->module~modfields module~modglobal modglobal proc~advecu_2nd->module~modglobal mpi mpi module~modmpi->mpi module~modibmdata modibmdata module~modibm->module~modibmdata Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(ib - ih:ie + ih, jb - jh:je + jh, kb - kh:ke + kh) :: putin real, intent(inout), dimension(ib - ih:ie + ih, jb - jh:je + jh, kb:ke + kh) :: putout Called by proc~~advecu_2nd~~CalledByGraph proc~advecu_2nd advecu_2nd proc~advection advection proc~advection->proc~advecu_2nd program~dalesurban DALESURBAN program~dalesurban->proc~advection Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code advecu_2nd Source Code subroutine advecu_2nd ( putin , putout ) use modglobal , only : ih , ib , ie , jb , je , jh , kb , ke , kh , dxhiq , dyiq , dzf , dzfi5 , dzhi , dxhi , libm use modfields , only : u0 , v0 , w0 , pres0 use modibm , only : nxwallsnorm , nzwallsnorm , nywallsm , nywallsp , ywallsm , ywallsp , & xwallsnorm , zwallsnorm use modmpi , only : myid implicit none real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ), intent ( in ) :: putin !< Input: the u-field real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ), intent ( inout ) :: putout !< Output: the tendency integer :: i , j , k , ip , im , jp , jm , kp , km , il , iu , jl , ju , kl , ku , n do k = kb , ke km = k - 1 kp = k + 1 do j = jb , je jm = j - 1 jp = j + 1 do i = ib , ie im = i - 1 ip = i + 1 putout ( i , j , k ) = putout ( i , j , k ) - ( & ( & ( putin ( i , j , k ) + putin ( ip , j , k )) * ( u0 ( i , j , k ) + u0 ( ip , j , k )) & - ( putin ( i , j , k ) + putin ( im , j , k )) * ( u0 ( i , j , k ) + u0 ( im , j , k )) & ! d(uu)/dx ) * dxhiq ( i ) & + ( & ( putin ( i , j , k ) + putin ( i , jp , k )) * ( v0 ( i , jp , k ) + v0 ( im , jp , k )) & - ( putin ( i , j , k ) + putin ( i , jm , k )) * ( v0 ( i , j , k ) + v0 ( im , j , k )) & ! d(vu)/dy ) * dyiq ) & - (( pres0 ( i , j , k ) - pres0 ( i - 1 , j , k )) * dxhi ( i )) ! - dp/dx end do end do end do do j = jb , je jm = j - 1 jp = j + 1 do i = ib , ie im = i - 1 ip = i + 1 do k = kb , ke km = k - 1 kp = k + 1 putout ( i , j , k ) = putout ( i , j , k ) - ( & ( putin ( i , j , kp ) * dzf ( k ) + putin ( i , j , k ) * dzf ( kp )) * dzhi ( kp ) & * ( w0 ( i , j , kp ) + w0 ( im , j , kp )) & - ( putin ( i , j , k ) * dzf ( km ) + putin ( i , j , km ) * dzf ( k )) * dzhi ( k ) & * ( w0 ( i , j , k ) + w0 ( im , j , k )) & ) * 0.5 * dzfi5 ( k ) end do end do end do end subroutine advecu_2nd","tags":"","loc":"proc/advecu_2nd.html"},{"title":"advecv_2nd – uDALES","text":"subroutine advecv_2nd(putin, putout) Uses modglobal modfields proc~~advecv_2nd~~UsesGraph proc~advecv_2nd advecv_2nd module~modfields modfields proc~advecv_2nd->module~modfields module~modglobal modglobal proc~advecv_2nd->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(ib - ih:ie + ih, jb - jh:je + jh, kb - kh:ke + kh) :: putin real, intent(inout), dimension(ib - ih:ie + ih, jb - jh:je + jh, kb:ke + kh) :: putout Called by proc~~advecv_2nd~~CalledByGraph proc~advecv_2nd advecv_2nd proc~advection advection proc~advection->proc~advecv_2nd program~dalesurban DALESURBAN program~dalesurban->proc~advection Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code advecv_2nd Source Code subroutine advecv_2nd ( putin , putout ) use modglobal , only : ih , ib , ie , jh , jb , je , kb , ke , kh , dxf , dxhi , dxfiq , dyiq , dzf , dzfi5 , dzhi , dyi use modfields , only : u0 , v0 , w0 , pres0 implicit none real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ), intent ( in ) :: putin !< Input: the v-field real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ), intent ( inout ) :: putout !< Output: the tendency integer :: i , j , k , ip , im , jp , jm , kp , km do k = kb , ke km = k - 1 kp = k + 1 do j = jb , je jm = j - 1 jp = j + 1 do i = ib , ie im = i - 1 ip = i + 1 putout ( i , j , k ) = putout ( i , j , k ) - ( & ( & ( u0 ( ip , j , k ) + u0 ( ip , jm , k )) & * ( putin ( i , j , k ) * dxf ( ip ) + putin ( ip , j , k ) * dxf ( i )) * dxhi ( ip ) & - ( u0 ( i , j , k ) + u0 ( i , jm , k )) & * ( putin ( i , j , k ) * dxf ( im ) + putin ( im , j , k ) * dxf ( i )) * dxhi ( i ) & ! d(uv)/dx ) * dxfiq ( i ) & + ( & ( v0 ( i , jp , k ) + v0 ( i , j , k )) * ( putin ( i , j , k ) + putin ( i , jp , k )) & - ( v0 ( i , jm , k ) + v0 ( i , j , k )) * ( putin ( i , j , k ) + putin ( i , jm , k )) & ! d(vv)/dy ) * dyiq ) & - (( pres0 ( i , j , k ) - pres0 ( i , j - 1 , k )) * dyi ) ! - dp/dy end do end do end do do j = jb , je jm = j - 1 jp = j + 1 do i = ib , ie im = i - 1 ip = i + 1 do k = kb , ke km = k - 1 kp = k + 1 putout ( i , j , k ) = putout ( i , j , k ) - ( & ( w0 ( i , j , kp ) + w0 ( i , jm , kp )) & * ( putin ( i , j , kp ) * dzf ( k ) + putin ( i , j , k ) * dzf ( kp )) * dzhi ( kp ) & - ( w0 ( i , j , k ) + w0 ( i , jm , k )) & * ( putin ( i , j , km ) * dzf ( k ) + putin ( i , j , k ) * dzf ( km )) * dzhi ( k ) & ) * 0.5 * dzfi5 ( k ) end do end do end do end subroutine advecv_2nd","tags":"","loc":"proc/advecv_2nd.html"},{"title":"advecw_2nd – uDALES","text":"subroutine advecw_2nd(putin, putout) Uses modglobal modfields proc~~advecw_2nd~~UsesGraph proc~advecw_2nd advecw_2nd module~modfields modfields proc~advecw_2nd->module~modfields module~modglobal modglobal proc~advecw_2nd->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(ib - ih:ie + ih, jb - jh:je + jh, kb - kh:ke + kh) :: putin real, intent(inout), dimension(ib - ih:ie + ih, jb - jh:je + jh, kb:ke + kh) :: putout Called by proc~~advecw_2nd~~CalledByGraph proc~advecw_2nd advecw_2nd proc~advection advection proc~advection->proc~advecw_2nd program~dalesurban DALESURBAN program~dalesurban->proc~advection Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code advecw_2nd Source Code subroutine advecw_2nd ( putin , putout ) use modglobal , only : ih , ib , ie , jh , jb , je , kb , ke , kh , dxf , dxhi , dxfiq , dyiq , dzf , dzhi , dzhiq use modfields , only : u0 , v0 , w0 , pres0 ! use modmpi, only : myid implicit none real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ), intent ( in ) :: putin !< Input: the w-field real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ), intent ( inout ) :: putout !< Output: the tendency integer :: i , j , k , ip , im , jp , jm , kp , km do k = kb + 1 , ke km = k - 1 kp = k + 1 do j = jb , je jm = j - 1 jp = j + 1 do i = ib , ie im = i - 1 ip = i + 1 putout ( i , j , k ) = - ( & ( & ( putin ( ip , j , k ) * dxf ( i ) + putin ( i , j , k ) * dxf ( ip )) * dxhi ( ip ) & ! d(uw)/dx * ( dzf ( km ) * u0 ( ip , j , k ) + dzf ( k ) * u0 ( ip , j , km )) & - ( putin ( i , j , k ) * dxf ( im ) + putin ( im , j , k ) * dxf ( i )) * dxhi ( i ) & * ( dzf ( km ) * u0 ( i , j , k ) + dzf ( k ) * u0 ( i , j , km )) & ) * dxfiq ( i ) * dzhi ( k ) & + & ( & ( putin ( i , jp , k ) + putin ( i , j , k )) & ! d(vw)/dy * ( dzf ( km ) * v0 ( i , jp , k ) + dzf ( k ) * v0 ( i , jp , km )) & - ( putin ( i , j , k ) + putin ( i , j - 1 , k )) & * ( dzf ( km ) * v0 ( i , j , k ) + dzf ( k ) * v0 ( i , j , km )) & ) * dyiq * dzhi ( k ) & + & ( & ( putin ( i , j , k ) + putin ( i , j , kp )) * ( w0 ( i , j , k ) + w0 ( i , j , kp )) & ! d(ww)/dz - ( putin ( i , j , k ) + putin ( i , j , km )) * ( w0 ( i , j , k ) + w0 ( i , j , km )) & ) * dzhiq ( k ) & ) & - (( pres0 ( i , j , k ) - pres0 ( i , j , k - 1 )) * dzhi ( k )) ! - dp/dz end do end do end do end subroutine advecw_2nd","tags":"","loc":"proc/advecw_2nd.html"},{"title":"createscals – uDALES","text":"subroutine createscals() Uses modglobal modfields modmpi initfac proc~~createscals~~UsesGraph proc~createscals createscals module~modmpi modmpi proc~createscals->module~modmpi module~modfields modfields proc~createscals->module~modfields module~initfac initfac proc~createscals->module~initfac module~modglobal modglobal proc~createscals->module~modglobal mpi mpi module~modmpi->mpi module~initfac->module~modmpi module~initfac->module~modglobal netcdf netcdf module~initfac->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~createscals~~CalledByGraph proc~createscals createscals proc~startup startup proc~startup->proc~createscals program~dalesurban DALESURBAN program~dalesurban->proc~startup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/createscals.html"},{"title":"scalsource – uDALES","text":"subroutine scalsource() Uses modglobal modfields modmpi initfac proc~~scalsource~~UsesGraph proc~scalsource scalsource module~modmpi modmpi proc~scalsource->module~modmpi module~modfields modfields proc~scalsource->module~modfields module~initfac initfac proc~scalsource->module~initfac module~modglobal modglobal proc~scalsource->module~modglobal mpi mpi module~modmpi->mpi module~initfac->module~modmpi module~initfac->module~modglobal netcdf netcdf module~initfac->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~scalsource~~CalledByGraph proc~scalsource scalsource program~dalesurban DALESURBAN program~dalesurban->proc~scalsource Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code scalsource Source Code subroutine scalsource use modglobal , only : nsv , ib , ie , jb , je , kb , ke , ih , jh , kh , ihc , jhc , khc , xf , zf , xh , zh , dy , jmax , lchem ,& xS , yS , zS , SS , sigS , lscasrc , lscasrcl , lscasrcr , libm , dxfi , dzfi , nblocks , xSa , ySa , zSa use modfields , only : svp , svpp , scar , scarl use modmpi , only : myid , mpierr , MY_REAL , comm3d , MPI_SUM use initfac , only : block implicit none integer :: i , j , k , n , il , iu , jl , ju , kl , ku , ncan real :: xL , zL real :: dyi real :: ra2 = 0. real :: scalsum = 0. real :: scalsumt = 0. real :: Pi = 3.1415927 dyi = 1. / dy ! 2-D network of point sources at lowest level if ( lscasrcr . AND . nsv . gt . 0 ) then if ( lchem ) then svp ( ib : ie , jb : je , kb + 1 , 1 ) = svp ( ib : ie , jb : je , kb + 1 , 1 ) + 0.522 * scarl svp ( ib : ie , jb : je , kb + 1 , 2 ) = svp ( ib : ie , jb : je , kb + 1 , 2 ) + 0.2 * scarl svp ( ib : ie , jb : je , kb + 1 , 4 ) = svp ( ib : ie , jb : je , kb + 1 , 4 ) + scarl else svp ( ib : ie , jb : je , kb + 1 , 1 ) = svp ( ib : ie , jb : je , kb + 1 , 1 ) + scarl end if end if !lscasrcr scalsum = 0. !  Input passive scalar point sources if ( lscasrc . AND . nsv . gt . 0 ) then do n = 1 , nsv do k = kb , ke do j = jb , je do i = ib , ie ra2 = ( xf ( i ) - xS ) ** 2 + (( j + myid * jmax - 0.5 ) * dy - yS ) ** 2 + ( zf ( k ) - zS ) ** 2 if ( ra2 . LE . 9 * sigS ** 2 ) then scalsum = scalsum + dxfi ( i ) * dyi * dzfi ( k ) * SS * exp ( - ra2 / ( 2 * sigS ** 2 )) svp ( i , j , k , n ) = svp ( i , j , k , n ) + dxfi ( i ) * dyi * dzfi ( k ) * SS * exp ( - ra2 / ( 2 * sigS ** 2 )) end if end do end do end do end do ! Set svpp to 0 when set inside an obstacle if ( libm ) then do n = 1 , nblocks il = block ( n , 1 ) iu = block ( n , 2 ) kl = block ( n , 5 ) ku = block ( n , 6 ) jl = block ( n , 3 ) - myid * jmax ju = block ( n , 4 ) - myid * jmax if ( ju < jb . or . jl > je ) then cycle else if ( ju > je ) ju = je if ( jl < jb ) jl = jb svp ( il : iu , jl : ju , kl : ku ,:) = 0. end if end do end if ! Normalise scalar field to 1/s !call MPI_ALLREDUCE(scalsum,scalsumt,1,MY_REAL,MPI_SUM,comm3d,mpierr) !svpp(:,:,:,1) = svpp(:,:,:,1) / scalsumt !svp(:,:,:,1) = svp(:,:,:,1) + svpp(:,:,:,1) scalsum = 0. end if !lscasrc ! Input passive scalar line sources if ( lscasrcl . AND . nsv . gt . 0 ) then ncan = count ( block (:, 6 ) > 0 ) !tg3315 update due to block at lowest level zL = zf ( kb + 1 ) if ( nblocks > 0 ) then do n = 1 , ncan - 1 ! not ncan and ncan+1 because we do not want release in first and last canyon for BCxs==2 if ( n == ncan + 1 ) then ! Added to run for pollutant in first canyon !xL = xh(block(1,1) - (block(2,1) - block(1,2)+1)/2) xL = xh ( block ( 1 , 1 )) - 0.5 * ( xh ( block ( 2 , 1 )) - xh ( block ( 1 , 2 ) + 1 )) !          ra2 = (i - (block(1,1) - (block(2,1) - block(1,2))/2.0))**2 + (k)**2 !tg3315 commented for chem validation else !cycle through all other canyons !xL = xh(block(n,2) + (block(2,1) - block(1,2)+1)/2) xL = xh ( block ( n , 2 ) + 1 ) + 0.5 * ( xh ( block ( 2 , 1 )) - xh ( block ( 1 , 2 ) + 1 )) !          ra2 =(xf(i) - xL)**2 + zf(k)**2 end if do i = ib , ie do k = kb , ke !           if (ra2 .LE. 12*sigS**2) then !scalsum = scalsum + dxf(i) * jmax * dy * dzf(k) * (SS/2*Pi*sigS**2) * exp(-ra2/(2*sigS**2)) !tg3315 use this if we want to normalise th scalar conc. !sums values in building too... !              scalsum = scalsum + dy * (je - jb +1) * ( (SS/4.) * & !                        (erf((xh(i+1)-xL)/(sqrt(2.)*sigS)) - erf((xh(i)-xL)/(sqrt(2.)*sigS))) * & !                        (erf((zh(k+1)-zh(kb+1))/(sqrt(2.)*sigS)) - erf((zh(k)-zh(kb+1))/(sqrt(2.)*sigS))) + & !                        (SS/4.) * & !                        (erf((xh(i+1)-xL)/(sqrt(2.)*sigS)) - erf((xh(i)-xL)/(sqrt(2.)*sigS))) * & !                        (erf((zh(k+1)+zh(kb+1))/(sqrt(2.)*sigS)) - erf((zh(k)+zh(kb+1))/(sqrt(2.)*sigS))) ) !                        * dxfi(i) * dzfi(k) svp ( i , jb : je , k , 1 ) = svp ( i , jb : je , k , 1 ) + ( ( SS / 4. ) * & ! SS in g/ms... no normalisation ( erf (( xh ( i + 1 ) - xL ) / ( sqrt ( 2. ) * sigS )) - erf (( xh ( i ) - xL ) / ( sqrt ( 2. ) * sigS ))) * & ( erf (( zh ( k + 1 ) - zL ) / ( sqrt ( 2. ) * sigS )) - erf (( zh ( k ) - zL ) / ( sqrt ( 2. ) * sigS ))) + & ( SS / 4. ) * & ! reflection from ground... ( erf (( xh ( i + 1 ) - xL ) / ( sqrt ( 2. ) * sigS )) - erf (( xh ( i ) - xL ) / ( sqrt ( 2. ) * sigS ))) * & ( erf (( zh ( k ) - 2 * ( zh ( k ) - zh ( kb + 1 )) - zL ) / ( sqrt ( 2. ) * sigS )) - erf (( zh ( k + 1 ) - 2 * ( zh ( k + 1 ) - zh ( kb + 1 )) - zL ) / ( sqrt ( 2. ) * sigS ))) ) & * dxfi ( i ) * dzfi ( k ) !svp(i,jb:je,k,3) = svp(i,jb:je,k,3) + ( (SS/4.) * & ! SS in g/ms... no normalisation !          (erf((xh(i+1)-xL)/(sqrt(2.)*sigS)) - erf((xh(i)-xL)/(sqrt(2.)*sigS))) * & !          (erf((zh(k+1)-zL)/(sqrt(2.)*sigS)) - erf((zh(k)-zL)/(sqrt(2.)*sigS))) + & !          (SS/4.) * & ! reflection from ground... !          (erf((xh(i+1)-xL)/(sqrt(2.)*sigS)) - erf((xh(i)-xL)/(sqrt(2.)*sigS))) * & !          (erf((zh(k)-2*(zh(k)-zh(kb+1))-zL)/(sqrt(2.)*sigS)) - erf((zh(k+1)-2*(zh(k+1)-zh(kb+1))-zL)/(sqrt(2.)*sigS))) ) & !          * dxfi(i) * dzfi(k) !            end if end do end do end do end if !nblocks ! Set svpp to 0 when set inside an obstacle if ( libm ) then do n = 1 , nblocks il = block ( n , 1 ) iu = block ( n , 2 ) kl = kb ku = block ( n , 6 ) jl = block ( n , 3 ) - myid * jmax ju = block ( n , 4 ) - myid * jmax if ( ju < jb . or . jl > je ) then cycle else if ( ju > je ) ju = je if ( jl < jb ) jl = jb svp ( il : iu , jl : ju , kl : ku ,:) = 0. end if end do end if !libm ! Normalise scalar field to 1/s !    call MPI_ALLREDUCE(scalsum,scalsumt,1,MY_REAL,MPI_SUM,comm3d,mpierr) !    write(*,*), 'scalsum', scalsum !    if (lchem) then !svpp(:,:,:,1) = svpp(:,:,:,1) !      svp(:,:,:,1) = svp(:,:,:,1) + svpp(:,:,:,1) !svp(:,:,:,2) = svp(:,:,:,2) + 0.1518 * svpp(:,:,:,1) !    else !      svpp(:,:,:,1) = svpp(:,:,:,1)/ scalsumt !tg3315 not normalised 07/11/2017 !      svp(:,:,:,1) = svp(:,:,:,1) + svpp(:,:,:,1) !svp(:,:,:,2) = svp(:,:,:,2) + 0.1518 * svpp(:,:,:,1) !    end if svpp = 0. scalsum = 0. end if !lscasrcl end subroutine scalsource","tags":"","loc":"proc/scalsource.html"},{"title":"advection – uDALES","text":"subroutine advection() Uses modglobal modfields modsubgriddata proc~~advection~~UsesGraph proc~advection advection module~modfields modfields proc~advection->module~modfields module~modsubgriddata modsubgriddata proc~advection->module~modsubgriddata module~modglobal modglobal proc~advection->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~advection~~CallsGraph proc~advection advection proc~advecu_2nd advecu_2nd proc~advection->proc~advecu_2nd proc~advecc_kappa advecc_kappa proc~advection->proc~advecc_kappa proc~advecc_2nd advecc_2nd proc~advection->proc~advecc_2nd proc~advecw_2nd advecw_2nd proc~advection->proc~advecw_2nd proc~advecv_2nd advecv_2nd proc~advection->proc~advecv_2nd proc~rlim rlim proc~advecc_kappa->proc~rlim Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~advection~~CalledByGraph proc~advection advection program~dalesurban DALESURBAN program~dalesurban->proc~advection Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code advection Source Code subroutine advection use modglobal , only : lmoist , nsv , iadv_mom , iadv_tke , iadv_thl , iadv_qt , iadv_sv , & iadv_cd2 , iadv_kappa , iadv_upw , & ltempeq , ih , jh , kh , ihc , jhc , khc use modfields , only : u0 , up , v0 , vp , w0 , wp , e120 , e12p , thl0 , thlp , qt0 , qtp , sv0 , svp use modsubgriddata , only : loneeqn implicit none integer :: n select case ( iadv_mom ) case ( iadv_cd2 ) call advecu_2nd ( u0 , up ) call advecv_2nd ( v0 , vp ) call advecw_2nd ( w0 , wp ) case default write ( 0 , * ) \"ERROR: Unknown advection scheme\" stop 1 end select if ( loneeqn ) then select case ( iadv_tke ) case ( iadv_cd2 ) call advecc_2nd ( ih , jh , kh , e120 , e12p ) case default write ( 0 , * ) \"ERROR: Unknown advection scheme\" stop 1 end select end if select case ( iadv_thl ) case ( iadv_cd2 ) if ( ltempeq ) call advecc_2nd ( ih , jh , kh , thl0 , thlp ) case ( iadv_kappa ) call advecc_kappa ( ihc , jhc , khc , thl0 , thlp ) case default write ( 0 , * ) \"ERROR: Unknown advection scheme\" stop 1 end select if ( lmoist ) then select case ( iadv_qt ) case ( iadv_cd2 ) call advecc_2nd ( ih , jh , kh , qt0 , qtp ) case default write ( 0 , * ) \"ERROR: Unknown advection scheme\" stop 1 end select end if do n = 1 , nsv select case ( iadv_sv ( n )) case ( iadv_cd2 ) call advecc_2nd ( ihc , jhc , khc , sv0 (:, :, :, n ), svp (:, :, :, n )) case ( iadv_kappa ) call advecc_kappa ( ihc , jhc , khc , sv0 (:, :, :, n ), svp (:, :, :, n )) case ( iadv_upw ) call advecc_upw ( ihc , jhc , khc , sv0 (:, :, :, n ), svp (:, :, :, n )) case default write ( 0 , * ) \"ERROR: Unknown advection scheme\" stop 1 end select end do end subroutine advection","tags":"","loc":"proc/advection.html"},{"title":"rlim – uDALES","text":"function rlim(d1, d2) Uses modglobal proc~~rlim~~UsesGraph proc~rlim rlim module~modglobal modglobal proc~rlim->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(in) :: d1 real, intent(in) :: d2 Return Value real Called by proc~~rlim~~CalledByGraph proc~rlim rlim proc~advecc_kappa advecc_kappa proc~advecc_kappa->proc~rlim proc~advection advection proc~advection->proc~advecc_kappa program~dalesurban DALESURBAN program~dalesurban->proc~advection Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code rlim Source Code real function rlim ( d1 , d2 ) use modglobal , only : eps1 implicit none real , intent ( in ) :: d1 !< Scalar flux at 1.5 cells upwind real , intent ( in ) :: d2 !< Scalar flux at 0.5 cells upwind real ri , phir ri = ( d2 + eps1 ) / ( d1 + eps1 ) phir = max ( 0. , min ( 2. * ri , min ( 1. / 3. + 2. / 3. * ri , 2. ))) rlim = 0.5 * phir * d1 end function rlim","tags":"","loc":"proc/rlim.html"},{"title":"advecc_kappa – uDALES","text":"subroutine advecc_kappa(hi, hj, hk, var, varp) Uses modglobal modibmdata modfields proc~~advecc_kappa~~UsesGraph proc~advecc_kappa advecc_kappa module~modfields modfields proc~advecc_kappa->module~modfields module~modibmdata modibmdata proc~advecc_kappa->module~modibmdata module~modglobal modglobal proc~advecc_kappa->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: hi integer, intent(in) :: hj integer, intent(in) :: hk real, intent(in), dimension(ib - hi:ie + hi, jb - hj:je + hj, kb - hk:ke + hk) :: var real, intent(inout), dimension(ib - hi:ie + hi, jb - hj:je + hj, kb:ke + hk) :: varp Calls proc~~advecc_kappa~~CallsGraph proc~advecc_kappa advecc_kappa proc~rlim rlim proc~advecc_kappa->proc~rlim Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~advecc_kappa~~CalledByGraph proc~advecc_kappa advecc_kappa proc~advection advection proc~advection->proc~advecc_kappa program~dalesurban DALESURBAN program~dalesurban->proc~advection Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code advecc_kappa Source Code subroutine advecc_kappa ( hi , hj , hk , var , varp ) !  use modglobal, only : i1,i2,ih,j1,j2,jh,k1,kmax,dxi,dyi,dzi use modglobal , only : ib , ie , ihc , jb , je , jhc , kb , ke , khc , dxhci , dyi , dzhci , dxfc , dzfc , dxfci , dzfci , libm use modibmdata , only : nxwallsnorm , nywallsnorm , nzwallsnorm , xwallsnorm , & ywallsnorm , zwallsnorm , nywallsp , nywallsm , ywallsp , ywallsm use modfields , only : u0 , v0 , w0 implicit none real , external :: rlim integer , intent ( in ) :: hi !< size of halo in i integer , intent ( in ) :: hj !< size of halo in j integer , intent ( in ) :: hk !< size of halo in k real , dimension ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ), intent ( in ) :: var !< Input: the cell centered field real , dimension ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ), intent ( inout ) :: varp !< Output: the tendency real , dimension ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) :: duml ! 3d dummy variable: lower cell side real , dimension ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) :: dumu ! 3d dummy variable: upper cell side integer i , j , k , il , iu , jl , ju , kl , ku , n real :: cf , d1 , d2 dumu (:, :, :) = 0. duml (:, :, :) = 0. ! -d(uc)/dx (stretched grid) do k = kb , ke do j = jb , je do i = ib , ie + 1 if ( u0 ( i , j , k ) > 0 ) then d1 = ( var ( i - 1 , j , k ) - var ( i - 2 , j , k )) * dxhci ( i - 1 ) d2 = ( var ( i , j , k ) - var ( i - 1 , j , k )) * dxhci ( i ) cf = var ( i - 1 , j , k ) else d1 = ( var ( i , j , k ) - var ( i + 1 , j , k )) * dxhci ( i + 1 ) d2 = ( var ( i - 1 , j , k ) - var ( i , j , k )) * dxhci ( i ) cf = var ( i , j , k ) end if cf = cf + dxfc ( i ) * rlim ( d1 , d2 ) dumu ( i - 1 , j , k ) = - cf * u0 ( i , j , k ) * dxfci ( i - 1 ) !swapped the -1s here !tg3315 !now also swapped the signs... duml ( i , j , k ) = cf * u0 ( i , j , k ) * dxfci ( i ) end do end do end do varp (:,:,:) = varp (:,:,:) + dumu (:,:,:) + duml (:,:,:) dumu (:,:,:) = 0. duml (:,:,:) = 0. ! -d(vc)/dy (no stretched grid) do k = kb , ke do j = jb , je + 1 do i = ib , ie if ( v0 ( i , j , k ) > 0 ) then d1 = var ( i , j - 1 , k ) - var ( i , j - 2 , k ) d2 = var ( i , j , k ) - var ( i , j - 1 , k ) cf = var ( i , j - 1 , k ) else d1 = var ( i , j , k ) - var ( i , j + 1 , k ) d2 = var ( i , j - 1 , k ) - var ( i , j , k ) cf = var ( i , j , k ) end if cf = cf + rlim ( d1 , d2 ) duml ( i , j , k ) = cf * v0 ( i , j , k ) * dyi !tg3315 dumu ( i , j - 1 , k ) = - cf * v0 ( i , j , k ) * dyi end do end do end do varp (:,:,:) = varp (:,:,:) + dumu (:,:,:) + duml (:,:,:) dumu (:,:,:) = 0. duml (:,:,:) = 0. ! -d(wc)/dz (stretched grid) !  do k=kb,ke+1 do k = kb + 1 , ke + 1 do j = jb , je do i = ib , ie if ( w0 ( i , j , k ) > 0 ) then d1 = ( var ( i , j , k - 1 ) - var ( i , j , k - 2 )) * dzhci ( k - 1 ) d2 = ( var ( i , j , k ) - var ( i , j , k - 1 )) * dzhci ( k ) cf = var ( i , j , k - 1 ) else d1 = ( var ( i , j , k ) - var ( i , j , k + 1 )) * dzhci ( k + 1 ) d2 = ( var ( i , j , k - 1 ) - var ( i , j , k )) * dzhci ( k ) cf = var ( i , j , k ) end if cf = cf + dzfc ( k ) * rlim ( d1 , d2 ) duml ( i , j , k ) = cf * w0 ( i , j , k ) * dzfci ( k ) !tg3315 swapped dumu ( i , j , k - 1 ) = - cf * w0 ( i , j , k ) * dzfci ( k - 1 ) end do end do end do varp (:,:,:) = varp (:,:,:) + dumu (:,:,:) + duml (:,:,:) return end subroutine advecc_kappa","tags":"","loc":"proc/advecc_kappa.html"},{"title":"advecc_upw – uDALES","text":"subroutine advecc_upw(hi, hj, hk, putin, putout) Uses modglobal modfields proc~~advecc_upw~~UsesGraph proc~advecc_upw advecc_upw module~modfields modfields proc~advecc_upw->module~modfields module~modglobal modglobal proc~advecc_upw->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: hi integer, intent(in) :: hj integer, intent(in) :: hk real, intent(in), dimension(ib - hi:ie + hi, jb - hj:je + hj, kb - hk:ke + hk) :: putin real, intent(inout), dimension(ib - hi:ie + hi, jb - hj:je + hj, kb:ke + hk) :: putout Contents Source Code advecc_upw Source Code subroutine advecc_upw ( hi , hj , hk , putin , putout ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , dyi , dxfci , dzfci use modfields , only : u0 , v0 , w0 implicit none integer , intent ( in ) :: hi !< size of halo in i integer , intent ( in ) :: hj !< size of halo in j integer , intent ( in ) :: hk !< size of halo in k real , dimension ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ), intent ( in ) :: putin !< Input: the cell centered field real , dimension ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ), intent ( inout ) :: putout !< Output: the tendency real , allocatable , dimension (:, :, :) :: put integer :: i , j , k allocate ( put ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk )) do k = kb , ke do j = jb , je do i = ib , ie + 1 if ( u0 ( i , j , k ) > 0 ) then put ( i , j , k ) = putin ( i - 1 , j , k ) else put ( i , j , k ) = putin ( i , j , k ) endif enddo enddo enddo do k = kb , ke do j = jb , je do i = ib , ie putout ( i , j , k ) = putout ( i , j , k ) - & ( u0 ( i + 1 , j , k ) * put ( i + 1 , j , k ) - u0 ( i , j , k ) * put ( i , j , k )) * dxfci ( i ) enddo enddo enddo do k = kb , ke do j = jb , je + 1 do i = ib , ie if ( v0 ( i , j , k ) > 0 ) then put ( i , j , k ) = putin ( i , j - 1 , k ) else put ( i , j , k ) = putin ( i , j , k ) endif enddo enddo enddo do k = kb , ke do j = jb , je do i = ib , ie putout ( i , j , k ) = putout ( i , j , k ) - & ( v0 ( i , j + 1 , k ) * put ( i , j + 1 , k ) - v0 ( i , j , k ) * put ( i , j , k )) * dyi enddo enddo enddo do k = kb , ke + 1 do j = jb , je do i = ib , ie if ( w0 ( i , j , k ) > 0 ) then put ( i , j , k ) = putin ( i , j , k - 1 ) else put ( i , j , k ) = putin ( i , j , k ) endif enddo enddo enddo do k = kb , ke do j = jb , je do i = ib , ie putout ( i , j , k ) = putout ( i , j , k ) - & ( w0 ( i , j , k + 1 ) * put ( i , j , k + 1 ) - w0 ( i , j , k ) * put ( i , j , k )) * dzfci ( k ) enddo enddo enddo deallocate ( put ) end subroutine advecc_upw","tags":"","loc":"proc/advecc_upw.html"},{"title":"wfmneutral – uDALES","text":"subroutine wfmneutral(hi, hj, hk, iout1, iout2, iomomflux, utang1, utang2, z0, n, ind, wforient) Uses modglobal modsubgriddata modmpi initfac modibmdata proc~~wfmneutral~~UsesGraph proc~wfmneutral wfmneutral module~modibmdata modibmdata proc~wfmneutral->module~modibmdata module~modmpi modmpi proc~wfmneutral->module~modmpi module~modsubgriddata modsubgriddata proc~wfmneutral->module~modsubgriddata module~initfac initfac proc~wfmneutral->module~initfac module~modglobal modglobal proc~wfmneutral->module~modglobal mpi mpi module~modmpi->mpi module~initfac->module~modmpi module~initfac->module~modglobal netcdf netcdf module~initfac->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: hi integer, intent(in) :: hj integer, intent(in) :: hk real, intent(inout) :: iout1 (ib-hi:ie+hi,jb-hj:je+hj,kb:ke+hk) real, intent(inout) :: iout2 (ib-hi:ie+hi,jb-hj:je+hj,kb:ke+hk) real, intent(inout) :: iomomflux (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(in) :: utang1 (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(in) :: utang2 (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(in) :: z0 integer, intent(in) :: n integer, intent(in) :: ind integer, intent(in) :: wforient Called by proc~~wfmneutral~~CalledByGraph proc~wfmneutral wfmneutral proc~bottom bottom proc~bottom->proc~wfmneutral program~dalesurban DALESURBAN program~dalesurban->proc~bottom Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code wfmneutral Source Code SUBROUTINE wfmneutral ( hi , hj , hk , iout1 , iout2 , iomomflux , utang1 , utang2 , z0 , n , ind , wforient ) !wfmneutral !wf for momentum under neutral conditions !calculating wall function for momentum assuming neutral conditions !follow approach in wfuno !fluxes in m2/s2 USE modglobal , ONLY : dzf , dzfi , dzh2i , dzhi , dzhiq , dy , dyi , dy2i , dyi5 , dxf , dxh , dxfi , dxhi , dxh2i , ib , ie , jb , je , kb , ke , fkar , jmax , rk3step , kmax , jge , jgb USE modsubgriddata , ONLY : ekh , ekm USE modmpi , ONLY : myid USE initfac , ONLY : block USE modibmdata INTEGER i , j , k , jl , ju , kl , ku , il , iu , km , im , jm , ip , jp , kp REAL :: bcmomflux = 0. !temp storage for momentum flux REAL :: ctm = 0. !momentum transfer coefficient REAL :: dummy = 0. !for debugging REAL :: delta = 0. !distance from wall REAL :: logdz2 = 0. !log(delta/z0)**2 REAL :: utang1Int !Interpolated 1st tangential velocity component needed for stability calculation (to T location) REAL :: utang2Int !Interpolated 2nd tangential velocity component needed for stability calculation (to T location) REAL :: fkar2 = fkar ** 2 !fkar&#94;2, von Karman constant squared REAL :: emmo = 0. , epmo = 0. , epom = 0. , emom = 0. , eopm = 0. , eomm = 0. , empo = 0. INTEGER , INTENT ( in ) :: hi !<size of halo in i INTEGER , INTENT ( in ) :: hj !<size of halo in j INTEGER , INTENT ( in ) :: hk !<size of halo in k REAL , INTENT ( inout ) :: iout1 ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) !updated prognostic tangential velocity (component1) REAL , INTENT ( inout ) :: iout2 ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) !updated prognostic tangential velocity (component2) REAL , INTENT ( inout ) :: iomomflux ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !a field to save the momentum flux REAL , INTENT ( in ) :: z0 REAL , INTENT ( in ) :: utang1 ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !tangential velocity field REAL , INTENT ( in ) :: utang2 ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !second tangential velocity field INTEGER , INTENT ( in ) :: n ! number of the block, used to get i,j,k-indeces INTEGER , INTENT ( in ) :: ind ! in case of y-wall (case 3x & 4x) \"ind\" is used for j-index, otherwise this is irrelevant INTEGER , INTENT ( in ) :: wforient !orientation of the facet see below: !frist digit, orientation of wall, determines iteration indices !second digit, if for momentum or for scalar (necessary because of staggered grid -> which variable to interpolate) !xlow=1,xup=2,yup=3,ylow=4,z=5 !momentum=1 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CASES!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CASES FOR MOMENTUM!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SELECT CASE ( wforient ) CASE ( 11 ) !wfmneutral11, case 11 , west wall i = block ( n , 1 ) - 1 !fluid location (also where wall variables are stored) ip = i + 1 !inside wall, used for subtracting original diffusion term jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) + 1 ! starting j-index      !might cause problem when jl=1 ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) ! ending j-index     !might cause problem when ju=jmax kl = block ( n , 5 ) ! starting k-index ku = block ( n , 6 ) ! ending k-index delta = dxf ( i ) * 0.5 logdz2 = LOG ( delta / z0 ) ** 2 !v west DO k = kl , ku DO j = jl , ju utang1Int = utang1 ( i , j , k ) ctm = fkar2 / ( logdz2 ) dummy = ( utang1Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) epmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) * dxf ( ip ) + & ( ekm ( ip , j , k ) + ekm ( ip , j - 1 , k )) * dxf ( i )) * dxhi ( ip ) iout1 ( i , j , k ) = iout1 ( i , j , k ) - ( utang1 ( ip , j , k ) - utang1 ( i , j , k )) * epmo * dxhi ( ip ) * dxfi ( i ) - bcmomflux * dxfi ( i ) ! END DO END DO !v west edge south j = MAX ( block ( n , 3 ) - myid * jmax , 1 ) DO k = kl , ku utang1Int = utang1 ( i , j , k ) dummy = ( utang1Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) * 0.5 !only half since on edge of block (another half might come from another processor?) !   epmo = 0.5 * (ekm(ip,j,k)*dxf(i) + ekm(i,j,k)*dxf(ip)) * dxhi(ip) epmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) * dxf ( ip ) + & ( ekm ( ip , j , k ) + ekm ( ip , j - 1 , k )) * dxf ( i )) * dxhi ( ip ) iout1 ( i , j , k ) = iout1 ( i , j , k ) - (( utang1 ( ip , j , k ) - utang1 ( i , j , k )) * epmo * dxhi ( ip ) * dxfi ( i ) - bcmomflux * dxfi ( i )) * 0.5 ! remove standard diffusion apply only half of wall-flux since it's an edge !only half of the flux, since only half of the control-volume around v is touching this facet (other half is either in free air or touching another facet) END DO !v west edge north j = MIN ( block ( n , 4 ) - myid * jmax , jmax ) + 1 DO k = kl , ku utang1Int = utang1 ( i , j , k ) dummy = ( utang1Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) * 0.5 epmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) * dxf ( ip ) + & ( ekm ( ip , j , k ) + ekm ( ip , j - 1 , k )) * dxf ( i )) * dxhi ( ip ) iout1 ( i , j , k ) = iout1 ( i , j , k ) - (( utang1 ( ip , j , k ) - utang1 ( i , j , k )) * epmo * dxhi ( ip ) * dxfi ( i ) - bcmomflux * dxfi ( i )) * 0.5 ! %remove standard diffusion apply only half of wall-flux since it's an edge END DO !w west jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ! kl = block ( n , 5 ) + 1 ! DO k = kl , ku DO j = jl , ju utang2Int = utang2 ( i , j , k ) ctm = fkar2 / ( logdz2 ) dummy = ( utang2Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) epom = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) * dxf ( ip ) + ekm ( ip , j , k ) * dxf ( i )) * dxhi ( ip ) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) * dxf ( ip ) + ekm ( ip , j , k - 1 ) * dxf ( i )) * dxhi ( ip )) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) - ( utang2 ( ip , j , k ) - utang2 ( i , j , k )) * epom * dxhi ( ip ) * dxfi ( i ) - bcmomflux * dxfi ( i ) ! END DO END DO !w west top edge k = block ( n , 6 ) + 1 ! ending k-index km = k - 1 DO j = jl , ju utang2Int = utang2 ( i , j , k ) dummy = ( utang2Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) * 0.5 epom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( ip ) + ekm ( ip , j , k ) * dxf ( i )) * dxhi ( ip ) + & dzf ( k ) * ( ekm ( i , j , km ) * dxf ( ip ) + ekm ( ip , j , km ) * dxf ( i )) * dxhi ( ip )) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) - (( utang2 ( ip , j , k ) - utang2 ( i , j , k )) * epom * dxhi ( ip ) * dxfi ( i ) - bcmomflux * dxfi ( i )) * 0.5 ! END DO !w west bottom edge k = block ( n , 6 ) ! ending k-index if ( k . gt . 0 ) then km = k - 1 DO j = jl , ju utang2Int = utang2 ( i , j , k ) dummy = ( utang2Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) * 0.5 epom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( ip ) + ekm ( ip , j , k ) * dxf ( i )) * dxhi ( ip ) + & dzf ( k ) * ( ekm ( i , j , km ) * dxf ( ip ) + ekm ( ip , j , km ) * dxf ( i )) * dxhi ( ip )) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) - (( utang2 ( ip , j , k ) - utang2 ( i , j , k )) * epom * dxhi ( ip ) * dxfi ( i ) - bcmomflux * dxfi ( i )) * 0.5 ! END DO end if !!! case 21 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !wfmneutral 21 !wall in yz -> wf in x (=vertical), upper wall, east wall CASE ( 21 ) !v east i = block ( n , 2 ) + 1 !fluid im = i - 1 !inside block jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) + 1 ! starting j-index      !might cause problem when jl=1 ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) ! ending j-index     !might cause problem when ju=jmax kl = block ( n , 5 ) ! starting k-index ku = block ( n , 6 ) ! ending k-index delta = dxh ( i ) * 0.5 logdz2 = LOG ( delta / z0 ) ** 2 DO k = kl , ku DO j = jl , ju utang1Int = utang1 ( i , j , k ) ctm = fkar2 / ( logdz2 ) dummy = ( utang1Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) emmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) * dxf ( im ) + ( ekm ( im , j - 1 , k ) + ekm ( im , j , k )) * dxf ( i )) * dxhi ( i ) ! dx is non-equidistant iout1 ( i , j , k ) = iout1 ( i , j , k ) + ( utang1 ( i , j , k ) - utang1 ( im , j , k )) * emmo * dxhi ( i ) * dxfi ( i ) - bcmomflux * dxfi ( i ) ! END DO END DO !v east edge south j = MAX ( block ( n , 3 ) - myid * jmax , 1 ) DO k = kl , ku utang1Int = utang1 ( i , j , k ) dummy = ( utang1Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) * 0.5 emmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) * dxf ( im ) + ( ekm ( im , j - 1 , k ) + ekm ( im , j , k )) * dxf ( i )) * dxhi ( i ) ! dx is non-equidistant iout1 ( i , j , k ) = iout1 ( i , j , k ) + (( utang1 ( i , j , k ) - utang1 ( im , j , k )) * emmo * dxhi ( i ) * dxfi ( i ) - bcmomflux * dxfi ( i )) * 0.5 ! END DO !v east edge north j = MIN ( block ( n , 4 ) - myid * jmax , jmax ) + 1 ! DO k = kl , ku utang1Int = utang1 ( i , j , k ) dummy = ( utang1Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) * 0.5 emmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) * dxf ( im ) + ( ekm ( im , j - 1 , k ) + ekm ( im , j , k )) * dxf ( i )) * dxhi ( i ) ! dx is non-equidistant iout1 ( i , j , k ) = iout1 ( i , j , k ) + (( utang1 ( i , j , k ) - utang1 ( im , j , k )) * emmo * dxhi ( i ) * dxfi ( i ) - bcmomflux * dxfi ( i )) * 0.5 ! END DO !w east jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ! kl = block ( n , 5 ) + 1 ! DO k = kl , ku DO j = jl , ju utang2Int = utang2 ( i , j , k ) ctm = fkar2 / ( logdz2 ) dummy = ( utang2Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) emom = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) * dxf ( im ) + ekm ( im , j , k ) * dxf ( i )) * dxhi ( i ) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) * dxf ( im ) + ekm ( im , j , k - 1 ) * dxf ( i )) * dxhi ( i )) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) + ( utang2 ( i , j , k ) - utang2 ( im , j , k )) * emom * dxhi ( i ) * dxfi ( i ) - bcmomflux * dxfi ( i ) ! END DO END DO !w east edge top k = block ( n , 6 ) + 1 ! ending k-index DO j = jl , ju utang2Int = utang2 ( i , j , k ) dummy = ( utang2Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) * 0.5 emom = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) * dxf ( im ) + ekm ( im , j , k ) * dxf ( i )) * dxhi ( i ) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) * dxf ( im ) + ekm ( im , j , k - 1 ) * dxf ( i )) * dxhi ( i )) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) + (( utang2 ( i , j , k ) - utang2 ( im , j , k )) * emom * dxhi ( i ) * dxfi ( i ) - bcmomflux * dxfi ( i )) * 0.5 ! END DO !w east edge bot k = block ( n , 6 ) ! if ( k . gt . 0 ) then DO j = jl , ju utang2Int = utang2 ( i , j , k ) dummy = ( utang2Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) * 0.5 emom = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) * dxf ( im ) + ekm ( im , j , k ) * dxf ( i )) * dxhi ( i ) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) * dxf ( im ) + ekm ( im , j , k - 1 ) * dxf ( i )) * dxhi ( i )) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) + (( utang2 ( i , j , k ) - utang2 ( im , j , k )) * emom * dxhi ( i ) * dxfi ( i ) - bcmomflux * dxfi ( i )) * 0.5 ! END DO end if !!! case 31 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !wfuno 31 CASE ( 31 ) !wall in xz -> wf in y (=vertical) upper, north wall j = ind jm = j - 1 il = block ( n , 1 ) + 1 iu = block ( n , 2 ) kl = block ( n , 5 ) ku = block ( n , 6 ) delta = 0.5 * dy logdz2 = LOG ( delta / z0 ) ** 2 !u north DO k = kl , ku DO i = il , iu utang1Int = utang1 ( i , j , k ) ctm = fkar2 / ( logdz2 ) dummy = ( utang1Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi emmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , jm , k )) * dxf ( i - 1 ) + ( ekm ( i - 1 , jm , k ) + ekm ( i - 1 , j , k )) * dxf ( i )) * dxhi ( i ) iout1 ( i , j , k ) = iout1 ( i , j , k ) + ( utang1 ( i , j , k ) - utang1 ( i , jm , k )) * emmo * dy2i - bcmomflux * dyi ! END DO END DO !u north east edge i = block ( n , 2 ) + 1 DO k = kl , ku utang1Int = utang1 ( i , j , k ) dummy = ( utang1Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi5 emmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , jm , k )) * dxf ( i - 1 ) + ( ekm ( i - 1 , jm , k ) + ekm ( i - 1 , j , k )) * dxf ( i )) * dxhi ( i ) iout1 ( i , j , k ) = iout1 ( i , j , k ) + (( utang1 ( i , j , k ) - utang1 ( i , jm , k )) * emmo * dy2i - bcmomflux * dyi ) * 0.5 ! END DO !u north west edge i = block ( n , 1 ) DO k = kl , ku utang1Int = utang1 ( i , j , k ) dummy = ( utang1Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi5 emmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , jm , k )) * dxf ( i - 1 ) + ( ekm ( i - 1 , jm , k ) + ekm ( i - 1 , j , k )) * dxf ( i )) * dxhi ( i ) iout1 ( i , j , k ) = iout1 ( i , j , k ) + (( utang1 ( i , j , k ) - utang1 ( i , jm , k )) * emmo * dy2i - bcmomflux * dyi ) * 0.5 ! END DO !w north il = block ( n , 1 ) ! kl = block ( n , 5 ) + 1 ! DO k = kl , ku DO i = il , iu utang2Int = utang2 ( i , j , k ) ctm = fkar2 / ( logdz2 ) dummy = ( utang2Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi eomm = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , jm , k )) + dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , jm , k - 1 ))) * dzhiq ( k ) ! dz is non-eqidistant iout2 ( i , j , k ) = iout2 ( i , j , k ) + ( utang2 ( i , j , k ) - utang2 ( i , jm , k )) * eomm * dy2i - bcmomflux * dyi ! END DO END DO !w north edge top k = block ( n , 6 ) + 1 DO i = il , iu utang2Int = utang2 ( i , j , k ) dummy = ( utang2Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi5 eomm = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , jm , k )) + dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , jm , k - 1 ))) * dzhiq ( k ) ! dz is non-eqidistant iout2 ( i , j , k ) = iout2 ( i , j , k ) + (( utang2 ( i , j , k ) - utang2 ( i , jm , k )) * eomm * dy2i - bcmomflux * dyi ) * 0.5 ! END DO !w north edge bot k = block ( n , 6 ) if ( k . gt . 0 ) then DO i = il , iu utang2Int = utang2 ( i , j , k ) dummy = ( utang2Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi5 eomm = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , jm , k )) + dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , jm , k - 1 ))) * dzhiq ( k ) ! dz is non-eqidistant iout2 ( i , j , k ) = iout2 ( i , j , k ) + (( utang2 ( i , j , k ) - utang2 ( i , jm , k )) * eomm * dy2i - bcmomflux * dyi ) * 0.5 ! END DO end if !!! case 41 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!` !wfuno41 CASE ( 41 ) !wall in xz -> wf in y (=vertical) lower, south wall j = ind jp = j + 1 il = block ( n , 1 ) + 1 iu = block ( n , 2 ) kl = block ( n , 5 ) ku = block ( n , 6 ) delta = 0.5 * dy logdz2 = LOG ( delta / z0 ) ** 2 DO k = kl , ku DO i = il , iu utang1Int = utang1 ( i , j , k ) ctm = fkar2 / ( logdz2 ) dummy = ( utang1Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi empo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , jp , k )) * dxf ( i - 1 ) + & ( ekm ( i - 1 , j , k ) + ekm ( i - 1 , jp , k )) * dxf ( i )) * dxhi ( i ) ! dx is non-equidistant iout1 ( i , j , k ) = iout1 ( i , j , k ) - ( utang1 ( i , jp , k ) - utang1 ( i , j , k )) * empo * dy2i - bcmomflux * dyi ! END DO END DO !u south edge west i = block ( n , 1 ) DO k = kl , ku utang1Int = utang1 ( i , j , k ) dummy = ( utang1Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi5 empo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , jp , k )) * dxf ( i - 1 ) + & ( ekm ( i - 1 , j , k ) + ekm ( i - 1 , jp , k )) * dxf ( i )) * dxhi ( i ) ! dx is non-equidistant iout1 ( i , j , k ) = iout1 ( i , j , k ) - (( utang1 ( i , jp , k ) - utang1 ( i , j , k )) * empo * dy2i - bcmomflux * dyi ) * 0.5 ! END DO !u south edge east i = block ( n , 2 ) + 1 DO k = kl , ku utang1Int = utang1 ( i , j , k ) dummy = ( utang1Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi5 empo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , jp , k )) * dxf ( i - 1 ) + & ( ekm ( i - 1 , j , k ) + ekm ( i - 1 , jp , k )) * dxf ( i )) * dxhi ( i ) ! dx is non-equidistant iout1 ( i , j , k ) = iout1 ( i , j , k ) - (( utang1 ( i , jp , k ) - utang1 ( i , j , k )) * empo * dy2i - bcmomflux * dyi ) * 0.5 ! END DO !w south il = block ( n , 1 ) ! kl = block ( n , 5 ) + 1 ! DO k = kl , ku DO i = il , iu utang2Int = utang2 ( i , j , k ) ctm = fkar2 / ( logdz2 ) dummy = ( utang2Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi eopm = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , jp , k )) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , jp , k - 1 ))) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) - ( utang2 ( i , jp , k ) - utang2 ( i , j , k )) * eopm * dy2i - bcmomflux * dyi ! END DO END DO !w south edge top k = block ( n , 6 ) + 1 DO i = il , iu utang2Int = utang2 ( i , j , k ) dummy = ( utang2Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi5 eopm = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , jp , k )) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , jp , k - 1 ))) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) - (( utang2 ( i , jp , k ) - utang2 ( i , j , k )) * eopm * dy2i - bcmomflux * dyi ) * 0.5 ! END DO !w south edge bot k = block ( n , 6 ) if ( k . gt . 0 ) then DO i = il , iu utang2Int = utang2 ( i , j , k ) !call function repeatedly dummy = ( utang2Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi5 eopm = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , jp , k )) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , jp , k - 1 ))) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) - (( utang2 ( i , jp , k ) - utang2 ( i , j , k )) * eopm * dy2i - bcmomflux * dyi ) * 0.5 ! END DO end if !!!! case 51 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !wfuno51 CASE ( 51 ) !wall in xy -> wf in z (=horizontal), top wall k = block ( n , 6 ) + 1 !block location if (. not .( k . gt . kmax )) then km = k - 1 !shear velocity location il = block ( n , 1 ) + 1 iu = block ( n , 2 ) jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) delta = 0.5 * dzf ( k ) logdz2 = LOG ( delta / z0 ) ** 2 DO j = jl , ju DO i = il , iu utang1Int = utang1 ( i , j , k ) ctm = fkar2 / ( logdz2 ) dummy = ( utang1Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) emom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k ) * dxf ( i )) + & dzf ( k ) * ( ekm ( i , j , km ) * dxf ( i - 1 ) + ekm ( i - 1 , j , km ) * dxf ( i ))) * dxhi ( i ) * dzhiq ( k ) iout1 ( i , j , k ) = iout1 ( i , j , k ) + ( utang1 ( i , j , k ) - utang1 ( i , j , km )) * emom * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k ) ! END DO END DO !u top edge west i = block ( n , 1 ) DO j = jl , ju utang1Int = utang1 ( i , j , k ) dummy = ( utang1Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) * 0.5 emom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k ) * dxf ( i )) + & dzf ( k ) * ( ekm ( i , j , km ) * dxf ( i - 1 ) + ekm ( i - 1 , j , km ) * dxf ( i ))) * dxhi ( i ) * dzhiq ( k ) iout1 ( i , j , k ) = iout1 ( i , j , k ) + (( utang1 ( i , j , k ) - utang1 ( i , j , km )) * emom * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k )) * 0.5 ! END DO !u top edge east DO j = jl , ju utang1Int = utang1 ( i , j , k ) dummy = ( utang1Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) * 0.5 emom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k ) * dxf ( i )) + & dzf ( k ) * ( ekm ( i , j , km ) * dxf ( i - 1 ) + ekm ( i - 1 , j , km ) * dxf ( i ))) * dxhi ( i ) * dzhiq ( k ) iout1 ( i , j , k ) = iout1 ( i , j , k ) + (( utang1 ( i , j , k ) - utang1 ( i , j , km )) * emom * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k )) * 0.5 ! END DO !v il = block ( n , 1 ) jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) + 1 DO j = jl , ju DO i = il , iu utang2Int = utang2 ( i , j , k ) ctm = fkar2 / ( logdz2 ) dummy = ( utang2Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) eomm = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) + dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i , j - 1 , km ))) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) + ( utang2 ( i , j , k ) - utang2 ( i , j , km )) * eomm * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k ) ! END DO END DO !v top edge south j = MAX ( block ( n , 3 ) - myid * jmax , 1 ) DO i = il , iu utang2Int = utang2 ( i , j , k ) dummy = ( utang2Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) * 0.5 eomm = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) + dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i , j - 1 , km ))) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) + (( utang2 ( i , j , k ) - utang2 ( i , j , km )) * eomm * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k )) * 0.5 ! END DO !v top edge north j = MIN ( block ( n , 4 ) - myid * jmax , jmax ) + 1 DO i = il , iu utang2Int = utang2 ( i , j , k ) dummy = ( utang2Int ** 2 ) * fkar2 / ( logdz2 ) bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) * 0.5 eomm = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) + dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i , j - 1 , km ))) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) + (( utang2 ( i , j , k ) - utang2 ( i , j , km )) * eomm * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k )) * 0.5 ! END DO end if !!!!!!!!!!!!!!!SPECIAL CASES FOR THE SURFACE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !can actually be made redundant and just be replaced by standard horizontal case (doesn't really matter though) CASE ( 91 ) !surface momentum flux k = kb ! km = k - 1 ! il = ib iu = ie jl = jb ju = je delta = 0.5 * dzf ( k ) !might need attention on streched grids! as well as the dzfi when updating up logdz2 = LOG ( delta / z0 ) ** 2 DO j = jl , ju !u component DO i = il , iu utang1Int = utang1 ( i , j , k ) ctm = fkar2 / ( logdz2 ) dummy = ( utang1Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) emom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k ) * dxf ( i )) + & ! dx is non-equidistant dzf ( k ) * ( ekm ( i , j , km ) * dxf ( i - 1 ) + ekm ( i - 1 , j , km ) * dxf ( i ))) * dxhi ( i ) * dzhiq ( k ) iout1 ( i , j , k ) = iout1 ( i , j , k ) + ( utang1 ( i , j , k ) - utang1 ( i , j , km )) * emom * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k ) ! END DO END DO DO j = jl , ju !v component DO i = il , iu utang2Int = utang2 ( i , j , k ) ctm = fkar2 / ( logdz2 ) dummy = ( utang2Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) eomm = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) + dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i , j - 1 , km ))) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) + ( utang2 ( i , j , k ) - utang2 ( i , j , km )) * eomm * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k ) ! END DO END DO END SELECT END SUBROUTINE wfmneutral","tags":"","loc":"proc/wfmneutral.html"},{"title":"wfGR – uDALES","text":"subroutine wfGR(hi, hj, hk, ioq, ioqflux, icth, obcqfluxA, qcell, qwall, hurel, resc, ress, n, ind, wforient) Uses modglobal modsubgriddata modmpi initfac modibmdata proc~~wfgr~~UsesGraph proc~wfgr wfGR module~modibmdata modibmdata proc~wfgr->module~modibmdata module~modmpi modmpi proc~wfgr->module~modmpi module~modsubgriddata modsubgriddata proc~wfgr->module~modsubgriddata module~initfac initfac proc~wfgr->module~initfac module~modglobal modglobal proc~wfgr->module~modglobal mpi mpi module~modmpi->mpi module~initfac->module~modmpi module~initfac->module~modglobal netcdf netcdf module~initfac->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: hi integer, intent(in) :: hj integer, intent(in) :: hk real, intent(inout) :: ioq (ib-hi:ie+hi,jb-hj:je+hj,kb:ke+hk) real, intent(inout) :: ioqflux (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(in) :: icth (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(out) :: obcqfluxA real, intent(in) :: qcell (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(in) :: qwall real, intent(in) :: hurel real, intent(in) :: resc real, intent(in) :: ress integer, intent(in) :: n integer, intent(in) :: ind integer, intent(in) :: wforient Contents Source Code wfGR Source Code SUBROUTINE wfGR ( hi , hj , hk , ioq , ioqflux , icth , obcqfluxA , qcell , qwall , hurel , resc , ress , n , ind , wforient ) !wfGR USE modglobal , ONLY : dzf , dzfi , dzh2i , dzhi , dzhiq , dy , dyi , dy2i , dyi5 , dxf , dxh , dxfi , dxhi , dxh2i , ib , ie , jb , je , kb , ke , fkar , grav , jmax , rk3step USE modsubgriddata , ONLY : ekh USE modmpi , ONLY : myid USE initfac , ONLY : block USE modibmdata INTEGER i , j , k , jl , ju , kl , ku , il , iu , km , im , jm , ip , jp , kp REAL :: bcqflux = 0. !temp storage for temperature flux REAL :: bcmomflux = 0. !temp storage for momentum flux REAL :: dummy = 0. !for debugging REAL :: delta = 0. !distance from wall REAL :: fkar2 = fkar ** 2 !fkar&#94;2, von Karman constant squared REAL :: emmo = 0. , epmo = 0. , epom = 0. , emom = 0. , eopm = 0. , eomm = 0. , empo = 0. REAL :: umin = 0.0001 !m&#94;2/s&#94;2 REAL :: cveg = 0.8 !hardcoded for now, !fraction of GR covered in vegetation, should be made into a proper model parameter (-> modglobal) INTEGER , INTENT ( in ) :: hi !<size of halo in i INTEGER , INTENT ( in ) :: hj !<size of halo in j INTEGER , INTENT ( in ) :: hk !<size of halo in k REAL , INTENT ( out ) :: obcqfluxA ; !temperature flux of entire wall facet (double sum over indeces) [Km/s] REAL , INTENT ( inout ) :: ioq ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) !updated prognostic temperature REAL , INTENT ( inout ) :: ioqflux ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !a field to save the momentum flux REAL , INTENT ( in ) :: icth ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) ; !heat transfer coefficient, used to calculate moisture flux REAL , INTENT ( in ) :: qcell ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !Temperature of fluid cell !       real, intent(in)    :: Troof(ib:ie,jb:je,kb:ke)  !Temperature of horizontal surfaces (also includes roads) REAL , INTENT ( in ) :: qwall REAL , INTENT ( in ) :: hurel REAL , INTENT ( in ) :: resc REAL , INTENT ( in ) :: ress INTEGER , INTENT ( in ) :: n ! number of the block, used to get i,j,k-indeces INTEGER , INTENT ( in ) :: ind ! in case of y-wall (case 3x & 4x) \"ind\" is used for j-index, otherwise this is irrelevant INTEGER , INTENT ( in ) :: wforient !frist digit, orientation of wall, determines iteration idices and if Twall or Troof is used obcqfluxA = 0. !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CASES!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CASES FOR SCALARS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SELECT CASE ( wforient ) CASE ( 12 ) !wall in yz -> wf in x (=vertical), lower wall, west wall i = block ( n , 1 ) - 1 !wall property and fluid index ip = i + 1 !index to remove subgrid flux jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ! starting j-index ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) ! ending j-index kl = block ( n , 5 ) ! starting k-index ku = block ( n , 6 ) ! ending k-index delta = dxf ( i ) * 0.5 ! DO k = kl , ku DO j = jl , ju bcqflux = min ( 0. , cveg * ( qcell ( i , j , k ) - qwall ) * 1 / ( 1 / icth ( i , j , k ) + resc ) + ( 1 - cveg ) * ( qcell ( i , j , k ) - qwall * hurel ) * 1 / ( 1 / icth ( i , j , k ) + ress )) obcqfluxA = obcqfluxA + bcqflux ioqflux ( i , j , k ) = ioqflux ( i , j , k ) + bcqflux * dxfi ( i ) ioq ( i , j , k ) = ioq ( i , j , k ) - 0.5 * ( ekh ( ip , j , k ) * dxf ( i ) + ekh ( i , j , k ) * dxf ( ip )) * ( qcell ( ip , j , k ) - qcell ( i , j , k )) * dxh2i ( ip ) * dxfi ( i ) - bcqflux * dxfi ( i ) ! END DO END DO !!! case 22 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! CASE ( 22 ) i = block ( n , 2 ) + 1 ! im = i - 1 ! jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ! starting j-index ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) ! ending j-index kl = block ( n , 5 ) ! starting k-index ku = block ( n , 6 ) ! ending k-index delta = dxh ( i ) * 0.5 DO k = kl , ku DO j = jl , ju !dq * 1/res, where res is in [s/m] bcqflux = min ( 0. , cveg * ( qcell ( i , j , k ) - qwall ) * 1 / ( 1 / icth ( i , j , k ) + resc ) + ( 1 - cveg ) * ( qcell ( i , j , k ) - qwall * hurel ) * 1 / ( 1 / icth ( i , j , k ) + ress )) obcqfluxA = obcqfluxA + bcqflux ioqflux ( i , j , k ) = ioqflux ( i , j , k ) + bcqflux * dxfi ( i ) ioq ( i , j , k ) = ioq ( i , j , k ) + 0.5 * ( ekh ( i , j , k ) * dxf ( im ) + ekh ( im , j , k ) * dxf ( i )) * ( qcell ( i , j , k ) - qcell ( im , j , k )) * dxh2i ( i ) * dxfi ( i ) - bcqflux * dxfi ( i ) END DO END DO !!! case 32 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! CASE ( 32 ) !wall in xz -> wf in y (=vertical) upper, north wall j = ind jm = j - 1 il = block ( n , 1 ) iu = block ( n , 2 ) kl = block ( n , 5 ) ku = block ( n , 6 ) DO k = kl , ku DO i = il , iu bcqflux = min ( 0. , cveg * ( qcell ( i , j , k ) - qwall ) * 1 / ( 1 / icth ( i , j , k ) + resc ) + ( 1 - cveg ) * ( qcell ( i , j , k ) - qwall * hurel ) * 1 / ( 1 / icth ( i , j , k ) + ress )) obcqfluxA = obcqfluxA + bcqflux ioqflux ( i , j , k ) = ioqflux ( i , j , k ) + bcqflux * dyi ioq ( i , j , k ) = ioq ( i , j , k ) + ( & 0.5 * ( ekh ( i , j , k ) + ekh ( i , jm , k )) * ( qcell ( i , j , k ) - qcell ( i , jm , k ))) * dy2i & - bcqflux * dyi END DO END DO !!! case 42 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! CASE ( 42 ) !wall in xz -> wf in y (=vertical) lower, south wall j = ind jp = j + 1 il = block ( n , 1 ) iu = block ( n , 2 ) kl = block ( n , 5 ) ku = block ( n , 6 ) DO k = kl , ku DO i = il , iu bcqflux = min ( 0. , cveg * ( qcell ( i , j , k ) - qwall ) * 1 / ( 1 / icth ( i , j , k ) + resc ) + ( 1 - cveg ) * ( qcell ( i , j , k ) - qwall * hurel ) * 1 / ( 1 / icth ( i , j , k ) + ress )) obcqfluxA = obcqfluxA + bcqflux ioqflux ( i , j , k ) = ioqflux ( i , j , k ) + bcqflux * dyi ioq ( i , j , k ) = ioq ( i , j , k ) - & 0.5 * ( ekh ( i , jp , k ) + ekh ( i , j , k )) * ( qcell ( i , jp , k ) - qcell ( i , j , k )) * dy2i & - bcqflux * dyi END DO END DO !!! case 52 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! CASE ( 52 ) !wall in xy -> wf in z (=horizontal), top wall k = block ( n , 6 ) + 1 !block location km = k - 1 ! il = block ( n , 1 ) iu = block ( n , 2 ) jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) delta = dzf ( k ) * 0.5 DO j = jl , ju DO i = il , iu bcqflux = min ( 0. , cveg * ( qcell ( i , j , k ) - qwall ) * 1 / ( 1 / icth ( i , j , k ) + resc ) + ( 1 - cveg ) * ( qcell ( i , j , k ) - qwall * hurel ) * 1 / ( 1 / icth ( i , j , k ) + ress )) obcqfluxA = obcqfluxA + bcqflux ioqflux ( i , j , k ) = ioqflux ( i , j , k ) + bcqflux * dzfi ( k ) ioq ( i , j , k ) = ioq ( i , j , k ) & + 0.5 * ( dzf ( km ) * ekh ( i , j , k ) + dzf ( k ) * ekh ( i , j , km )) * ( qcell ( i , j , k ) - qcell ( i , j , km )) * dzh2i ( k ) * dzfi ( k ) & - bcqflux * dzfi ( k ) END DO END DO END SELECT END SUBROUTINE wfGR","tags":"","loc":"proc/wfgr.html"},{"title":"tstep_update – uDALES","text":"subroutine tstep_update() Uses modglobal modfields modsubgriddata modmpi proc~~tstep_update~~UsesGraph proc~tstep_update tstep_update module~modmpi modmpi proc~tstep_update->module~modmpi module~modfields modfields proc~tstep_update->module~modfields module~modsubgriddata modsubgriddata proc~tstep_update->module~modsubgriddata module~modglobal modglobal proc~tstep_update->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~tstep_update~~CallsGraph proc~tstep_update tstep_update mpi_allreduce mpi_allreduce proc~tstep_update->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~tstep_update~~CalledByGraph proc~tstep_update tstep_update program~dalesurban DALESURBAN program~dalesurban->proc~tstep_update Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code tstep_update Source Code subroutine tstep_update use modglobal , only : ib , ie , jb , je , rk3step , timee , runtime , dtmax , dt , ntimee , ntrun , courant , diffnr ,& kb , ke , dxh , dxhi , dxh2i , dyi , dy2i , dzh , dt_lim , ladaptive , timeleft , dt , lwarmstart ,& dzh2i , tEB , tnextEB , dtEB use modfields , only : um , vm , wm use modsubgriddata , only : ekm , ekh use modmpi , only : myid , comm3d , mpierr , mpi_max , my_real implicit none integer :: i , j , k , imin , kmin real , save :: courtot =- 1. , diffnrtot =- 1. real :: courtotl , courold , diffnrtotl , diffnrold !  logical,save  :: spinup=.true. logical , save :: spinup = . false . if ( lwarmstart ) spinup = . false . rk3step = mod ( rk3step , 3 ) + 1 if ( rk3step == 1 ) then ! Initialization if ( spinup ) then write ( 6 , * ) '!spinup!' if ( ladaptive ) then courold = courtot diffnrold = diffnrtot courtotl = 0. diffnrtotl = 0. do k = kb , ke do j = jb , je do i = ib , ie courtotl = max ( courtotl ,( abs ( um ( i , j , k )) * dxhi ( i ) + abs ( vm ( i , j , k )) * dyi + abs ( wm ( i , j , k )) / dzh ( k )) * dt ) !          diffnrtotl = max(diffnrtotl,  ekm(i,j,k)*(1/dzh(k)**2 + dxh2i(i) + dy2i)*dt ) diffnrtotl = max ( diffnrtotl , ekm ( i , j , k ) * ( dzh2i ( k ) + dxh2i ( i ) + dy2i ) * dt , & ekh ( i , j , k ) * ( dzh2i ( k ) + dxh2i ( i ) + dy2i ) * dt ) end do end do end do call MPI_ALLREDUCE ( courtotl , courtot , 1 , MY_REAL , MPI_MAX , comm3d , mpierr ) call MPI_ALLREDUCE ( diffnrtotl , diffnrtot , 1 , MY_REAL , MPI_MAX , comm3d , mpierr ) if ( diffnrold > 0 ) then dt = min ( dtmax , dt * courant / courtot , dt * diffnr / diffnrtot ) if (( abs ( courtot - courold ) / courold < 0.1 ) . and . ( abs ( diffnrtot - diffnrold ) / diffnrold < 0.1 )) then spinup = . false . end if end if dt = dt dt_lim = timeleft timee = timee + dt timeleft = timeleft - dt ntimee = ntimee + 1 ntrun = ntrun + 1 else dt = 2 * dt if ( dt >= dtmax ) then dt = dtmax spinup = . false . end if end if ! Normal time loop else !spinup = .false. if ( ladaptive ) then courtotl = 0. diffnrtotl = 1e-5 do k = kb , ke do j = jb , je do i = ib , ie courtotl = max ( courtotl ,( abs ( um ( i , j , k )) * dxhi ( i ) + abs ( vm ( i , j , k )) * dyi + abs ( wm ( i , j , k )) / dzh ( k )) * dt ) diffnrtotl = max ( diffnrtotl , ekm ( i , j , k ) * ( dzh2i ( k ) + dxh2i ( i ) + dy2i ) * dt ,& ekh ( i , j , k ) * ( dzh2i ( k ) + dxh2i ( i ) + dy2i ) * dt ) !          if (diffnrtotl ==  ekh(i,j,k)*(dzh2i(k) + dxh2i(i) + dy2i)*dt) then !           imin = i !           kmin = k !          end if end do end do end do !     write(6,*) 'Peclet criterion at proc,i,k = ', myid,imin,kmin call MPI_ALLREDUCE ( courtotl , courtot , 1 , MY_REAL , MPI_MAX , comm3d , mpierr ) call MPI_ALLREDUCE ( diffnrtotl , diffnrtot , 1 , MY_REAL , MPI_MAX , comm3d , mpierr ) if ( courtot <= 0 ) then write ( 6 , * ) 'courtot=0!' end if if ( diffnrtot <= 0 ) then write ( 6 , * ) 'diffnrtot=0!' end if dt = min ( dtmax , dt * courant / courtot , dt * diffnr / diffnrtot ) timeleft = timeleft - dt dt_lim = timeleft timee = timee + dt ntimee = ntimee + 1 ntrun = ntrun + 1 else dt = dtmax ntimee = ntimee + 1 ntrun = ntrun + 1 timee = timee + dt timeleft = timeleft - dt end if end if end if end subroutine tstep_update","tags":"","loc":"proc/tstep_update.html"},{"title":"tstep_integrate – uDALES","text":"subroutine tstep_integrate() Uses modglobal modmpi modfields modinletdata modsubgriddata modchem proc~~tstep_integrate~~UsesGraph proc~tstep_integrate tstep_integrate module~modmpi modmpi proc~tstep_integrate->module~modmpi module~modsubgriddata modsubgriddata proc~tstep_integrate->module~modsubgriddata module~modchem modchem proc~tstep_integrate->module~modchem module~modinletdata modinletdata proc~tstep_integrate->module~modinletdata module~modfields modfields proc~tstep_integrate->module~modfields module~modglobal modglobal proc~tstep_integrate->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~tstep_integrate~~CallsGraph proc~tstep_integrate tstep_integrate 13 13 proc~tstep_integrate->13 proc~chem chem proc~tstep_integrate->proc~chem Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~tstep_integrate~~CalledByGraph proc~tstep_integrate tstep_integrate program~dalesurban DALESURBAN program~dalesurban->proc~tstep_integrate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code tstep_integrate Source Code subroutine tstep_integrate use modglobal , only : ib , ie , jb , jgb , je , kb , ke , nsv , dt , rk3step , e12min , lmoist , timee , ntrun ,& linoutflow , iinletgen , ltempeq , idriver ,& dzf , dzhi , dzf , dxhi , dxf , ifixuinf , thlsrc , lchem use modmpi , only : cmyid , myid , nprocs use modfields , only : u0 , um , up , v0 , vm , vp , w0 , wm , wp ,& thl0 , thlm , thlp , qt0 , qtm , qtp , e120 , e12m , e12p , sv0 , svm , svp , uouttot ,& wouttot , dpdxl , dgdt , momfluxb , tfluxb , qfluxb use modinletdata , only : totalu , di_test , dr , thetar , thetai , displ , irecy , & dti_test , dtr , thetati , thetatr , q0 , lmoi , lmor , utaui , utaur ,& storetdriver , nstepread , nstepreaddriver , irecydriver use modsubgriddata , only : loneeqn , ekm , ekh use modchem , only : chem implicit none integer i , j , k , n , m real rk3coef , rk3coefi rk3coef = dt / ( 4. - dble ( rk3step )) rk3coefi = 1. / rk3coef if ( ifixuinf == 2 ) then dpdxl (:) = dpdxl (:) + dgdt * rk3coef !    if(ltempeq) then !      thlsrc = thlsrc + thlsrcdt*rk3coef !    end if !    write(6,*) 'dpdx = ', dpdxl(kb) end if if ( loneeqn ) then do k = kb , ke do j = jb , je do i = ib , ie u0 ( i , j , k ) = um ( i , j , k ) + rk3coef * up ( i , j , k ) v0 ( i , j , k ) = vm ( i , j , k ) + rk3coef * vp ( i , j , k ) w0 ( i , j , k ) = wm ( i , j , k ) + rk3coef * wp ( i , j , k ) e120 ( i , j , k ) = e12m ( i , j , k ) + rk3coef * e12p ( i , j , k ) e120 ( i , j , k ) = max ( e12min , e120 ( i , j , k )) e12m ( i , j , k ) = max ( e12min , e12m ( i , j , k )) do n = 1 , nsv sv0 ( i , j , k , n ) = svm ( i , j , k , n ) + rk3coef * svp ( i , j , k , n ) enddo enddo enddo end do else do k = kb , ke do j = jb , je do i = ib , ie u0 ( i , j , k ) = um ( i , j , k ) + rk3coef * up ( i , j , k ) v0 ( i , j , k ) = vm ( i , j , k ) + rk3coef * vp ( i , j , k ) w0 ( i , j , k ) = wm ( i , j , k ) + rk3coef * wp ( i , j , k ) do n = 1 , nsv sv0 ( i , j , k , n ) = svm ( i , j , k , n ) + rk3coef * svp ( i , j , k , n ) enddo enddo enddo enddo end if if ( lchem . and . rk3coef == dt ) then call chem end if if ( ltempeq ) then ! if (myid==0) then ! write(*,*) \"thlp(20,1,46)\",thlp(20,1,46) ! end if do k = kb , ke do j = jb , je do i = ib , ie thl0 ( i , j , k ) = thlm ( i , j , k ) + rk3coef * thlp ( i , j , k ) enddo enddo enddo end if if ( lmoist ) then do k = kb , ke do j = jb , je do i = ib , ie qt0 ( i , j , k ) = qtm ( i , j , k ) + rk3coef * qtp ( i , j , k ) enddo enddo enddo end if if ( linoutflow ) then if (( iinletgen == 0 ) . and . ( idriver /= 2 )) then u0 ( ie + 1 , jb : je , kb : ke ) = um ( ie + 1 , jb : je , kb : ke ) + rk3coef * up ( ie + 1 , jb : je , kb : ke ) else u0 ( ib - 1 , jb : je , kb : ke ) = um ( ib - 1 , jb : je , kb : ke ) + rk3coef * up ( ib - 1 , jb : je , kb : ke ) u0 ( ie + 1 , jb : je , kb : ke ) = um ( ie + 1 , jb : je , kb : ke ) + rk3coef * up ( ie + 1 , jb : je , kb : ke ) end if end if !up to here !  Write some statistics to monitoring file if (( myid == 0 ) . and . ( rk3step == 3 )) then open ( unit = 11 , file = 'monitor' // cmyid // '.txt' , position = 'append' ) if ( iinletgen == 1 ) then write ( 11 , 3001 ) timee elseif ( idriver == 1 ) then write ( 11 , '(I4)' ) nstepreaddriver write ( 11 , 3001 ) timee , u0 ( irecydriver , 1 , 32 ) ! elseif (idriver == 2) then ! write(11, '(I4)') nstepreaddriver ! write(11, 3001) timee, storetdriver(nstepreaddriver), u0(irecydriver, 1, 32) else write ( 11 , 3001 ) timee end if 3001 format ( 13 ( 6e14 . 6 )) close ( 11 ) if ( ifixuinf == 2 ) then open ( unit = 11 , file = 'dpdx___.txt' , position = 'append' ) write ( 11 , 3002 ) timee , dpdxl ( kb ) 3002 format ( 13 ( 6e20 . 12 )) close ( 11 ) if ( ltempeq ) then open ( unit = 11 , file = 'thlsrc.txt' , position = 'append' ) write ( 11 , 3002 ) timee , thlsrc 3003 format ( 13 ( 6e20 . 12 )) close ( 11 ) end if end if endif up = 0. vp = 0. wp = 0. thlp = 0. svp = 0. e12p = 0. qtp = 0. if ( rk3step == 3 ) then um = u0 vm = v0 wm = w0 thlm = thl0 e12m = e120 svm = sv0 qtm = qt0 end if end subroutine tstep_integrate","tags":"","loc":"proc/tstep_integrate.html"},{"title":"unom – uDALES","text":"function unom(logdz, logdzh, logzh, sqdz, utangInt, dT, Ribl0, fkar2) Arguments Type Intent Optional Attributes Name real, intent(in) :: logdz real, intent(in) :: logdzh real, intent(in) :: logzh real, intent(in) :: sqdz real, intent(in) :: utangInt real, intent(in) :: dT real, intent(in) :: Ribl0 real, intent(in) :: fkar2 Return Value real Contents Source Code unom Source Code REAL FUNCTION unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !for momentum, this bit is not depended on orientation etc !momentum flux in m2/s2 !dT,utang and logdzh are unused and could be removed IMPLICIT NONE REAL , INTENT ( in ) :: logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 REAL :: Ribl1 , Fm , Fh , cm , ch , Ctm , M REAL , PARAMETER :: b1 = 9.4 !parameters from Uno1995 REAL , PARAMETER :: b2 = 4.7 REAL , PARAMETER :: dm = 7.4 REAL , PARAMETER :: dh = 5.3 REAL , PARAMETER :: prandtlmol = 0.71 IF ( Ribl0 > 0.21 ) THEN !0.25 approx critical for bulk Richardson number  => stable Fm = 1. / ( 1. + b2 * Ribl0 ) ** 2 !Eq. 4 Fh = Fm !Eq. 4 ELSE ! => unstable cm = ( dm * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 ch = ( dh * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 Fm = 1. - ( b1 * Ribl0 ) / ( 1. + cm * SQRT ( ABS ( Ribl0 ))) !Eq. 3 Fh = 1. - ( b1 * Ribl0 ) / ( 1. + ch * SQRT ( ABS ( Ribl0 ))) !Eq. 3 END IF M = prandtlmol * logdz * SQRT ( Fm ) / Fh !Eq. 14 Ribl1 = Ribl0 - Ribl0 * prandtlmol * logzh / ( prandtlmol * logzh + M ) !Eq. 17 !interate to get new Richardson number IF ( Ribl1 > 0.21 ) THEN !0.25 approx critical for bulk Richardson number  => stable Fm = 1. / ( 1. + b2 * Ribl1 ) ** 2 !Eq. 4 ELSE ! => unstable cm = ( dm * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 Fm = 1. - ( b1 * Ribl1 ) / ( 1. + cm * SQRT ( ABS ( Ribl1 ))) !Eq. 3 END IF Ctm = fkar2 / ( logdz ** 2 ) * Fm !Eq. 7 unom = Ctm !Eq. 2, Eq. 8 END FUNCTION unom","tags":"","loc":"proc/unom.html"},{"title":"wfuno – uDALES","text":"subroutine wfuno(hi, hj, hk, iout1, iout2, iot, iomomflux, iotflux, iocth, obcTfluxA, utang1, utang2, Tcell, Twall, z0, z0h, n, ind, wforient) Uses modglobal modsubgriddata modmpi initfac modibmdata proc~~wfuno~~UsesGraph proc~wfuno wfuno module~modibmdata modibmdata proc~wfuno->module~modibmdata module~modmpi modmpi proc~wfuno->module~modmpi module~modsubgriddata modsubgriddata proc~wfuno->module~modsubgriddata module~initfac initfac proc~wfuno->module~initfac module~modglobal modglobal proc~wfuno->module~modglobal mpi mpi module~modmpi->mpi module~initfac->module~modmpi module~initfac->module~modglobal netcdf netcdf module~initfac->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: hi integer, intent(in) :: hj integer, intent(in) :: hk real, intent(inout) :: iout1 (ib-hi:ie+hi,jb-hj:je+hj,kb:ke+hk) real, intent(inout) :: iout2 (ib-hi:ie+hi,jb-hj:je+hj,kb:ke+hk) real, intent(inout) :: iot (ib-hi:ie+hi,jb-hj:je+hj,kb:ke+hk) real, intent(inout) :: iomomflux (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(inout) :: iotflux (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(inout) :: iocth (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(out) :: obcTfluxA real, intent(in) :: utang1 (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(in) :: utang2 (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(in) :: Tcell (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(in) :: Twall real, intent(in) :: z0 real, intent(in) :: z0h integer, intent(in) :: n integer, intent(in) :: ind integer, intent(in) :: wforient Calls proc~~wfuno~~CallsGraph proc~wfuno wfuno proc~unoh unoh proc~wfuno->proc~unoh Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~wfuno~~CalledByGraph proc~wfuno wfuno proc~bottom bottom proc~bottom->proc~wfuno program~dalesurban DALESURBAN program~dalesurban->proc~bottom Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code wfuno Source Code SUBROUTINE wfuno ( hi , hj , hk , iout1 , iout2 , iot , iomomflux , iotflux , iocth , obcTfluxA , utang1 , utang2 , Tcell , Twall , z0 , z0h , n , ind , wforient ) !wfuno !calculating wall function for momentum and scalars following Cai2012&Uno1995, extension of Louis 1979 method to rough walls !fluxes in m2/s2 and Km/s USE modglobal , ONLY : dzf , dzfi , dzh2i , dzhi , dzhiq , dy , dyi , dy2i , dyi5 , dxf , dxh , dxfi , dxhi , dxh2i , ib , ie , jb , je , kb , ke , fkar , grav , jmax , rk3step , kmax , jge , jgb USE modsubgriddata , ONLY : ekh , ekm USE modmpi , ONLY : myid USE initfac , ONLY : block USE modibmdata REAL , EXTERNAL :: unom INTEGER i , j , k , jl , ju , kl , ku , il , iu , km , im , jm , ip , jp , kp REAL :: Ribl0 = 0. !initial guess of Ribl based on Ts REAL :: bcTflux = 0. !temp storage for temperature flux REAL :: bcmomflux = 0. !temp storage for momentum flux REAL :: ctm = 0. !momentum transfer coefficient REAL :: cth = 0. !heat transfer coefficient REAL :: dummy = 0. !for debugging REAL :: delta = 0. !distance from wall REAL :: logdz = 0. !log(delta/z0) REAL :: logdzh = 0. !log(delta/z0h) REAL :: logzh = 0. !log(z0/z0h) REAL :: sqdz = 0. !sqrt(delta/z0) REAL :: utang1Int !Interpolated 1st tangential velocity component needed for stability calculation (to T location) REAL :: utang2Int !Interpolated 2nd tangential velocity component needed for stability calculation (to T location) REAL :: utangInt !Interpolated absolute tangential velocity REAL :: dT !Temperature difference between wall and cell REAL :: fkar2 = fkar ** 2 !fkar&#94;2, von Karman constant squared REAL :: emmo = 0. , epmo = 0. , epom = 0. , emom = 0. , eopm = 0. , eomm = 0. , empo = 0. REAL :: umin = 0.0001 !m&#94;2/s&#94;2 INTEGER , INTENT ( in ) :: hi !<size of halo in i INTEGER , INTENT ( in ) :: hj !<size of halo in j INTEGER , INTENT ( in ) :: hk !<size of halo in k REAL , INTENT ( out ) :: obcTfluxA !temperature flux of entire wall facet (double sum over indeces) [Km/s] REAL , INTENT ( inout ) :: iout1 ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) !updated prognostic tangential velocity (component1) REAL , INTENT ( inout ) :: iout2 ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) !updated prognostic tangential velocity (component2) REAL , INTENT ( inout ) :: iot ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) !updated prognostic temperature REAL , INTENT ( inout ) :: iomomflux ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !a field to save the momentum flux REAL , INTENT ( inout ) :: iotflux ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !a field to save the heat flux REAL , INTENT ( inout ) :: iocth ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !heat transfer coefficient, used to calculate moisture flux REAL , INTENT ( in ) :: Tcell ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !Temperature of fluid cell REAL , INTENT ( in ) :: Twall !Temperature of surfaces !SINCE EVERY WALL HAS PRECISELY ONE TEMPERATURE (at the outside). CAREFUL IF THIS EVER CHANGES (i.e. multiple EB facets per wall) REAL , INTENT ( in ) :: z0 REAL , INTENT ( in ) :: z0h REAL , INTENT ( in ) :: utang1 ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !tangential velocity field REAL , INTENT ( in ) :: utang2 ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !second tangential velocity field INTEGER , INTENT ( in ) :: n ! number of the block, used to get i,j,k-indeces INTEGER , INTENT ( in ) :: ind ! in case of y-wall (case 3x & 4x) \"ind\" is used for j-index, otherwise this is irrelevant INTEGER , INTENT ( in ) :: wforient !orientation of the facet see below: !frist digit, orientation of wall, determines iteration indices !second digit, if for momentum or for scalar (necessary because of staggered grid -> which variable to interpolate) !xlow=1,xup=2,yup=3,ylow=4,z=5 !momentum=1,scalar=2 obcTfluxA = 0. !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CASES!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CASES FOR SCALARS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SELECT CASE ( wforient ) CASE ( 12 ) !wall in yz -> wf in x (=vertical), lower wall, west wall !wfuno12, case 12 i = block ( n , 1 ) - 1 !wall property and fluid index ip = i + 1 !index to remove subgrid flux jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ! starting j-index ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) ! ending j-index kl = block ( n , 5 ) ! starting k-index ku = block ( n , 6 ) ! ending k-index delta = dxf ( i ) * 0.5 ! logdz = LOG ( delta / z0 ) logdzh = LOG ( delta / z0h ) logzh = LOG ( z0 / z0h ) sqdz = SQRT ( delta / z0 ) DO k = kl , ku DO j = jl , ju utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j + 1 , k )) * 0.5 utang2Int = ( utang2 ( i , j , k ) + utang2 ( i , j , k + 1 )) * 0.5 utangInt = max (( utang1Int ** 2 + utang2Int ** 2 ), umin ) dT = ( Tcell ( i , j , k ) - Twall ) Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri call unoh ( bcTflux , cth , logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field obcTfluxA = obcTfluxA + bcTflux iocth ( i , j , k ) = cth iotflux ( i , j , k ) = iotflux ( i , j , k ) + bcTflux * dxfi ( i ) iot ( i , j , k ) = iot ( i , j , k ) - 0.5 * ( ekh ( ip , j , k ) * dxf ( i ) + ekh ( i , j , k ) * dxf ( ip )) * ( Tcell ( ip , j , k ) - Tcell ( i , j , k )) * dxh2i ( ip ) * dxfi ( i ) - bcTflux * dxfi ( i ) ! END DO END DO !!! case 22 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !wfuno22 !wall in yz -> wf in x (=vertical), upper wall, east wall CASE ( 22 ) i = block ( n , 2 ) + 1 ! im = i - 1 ! jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ! starting j-index ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) ! ending j-index kl = block ( n , 5 ) ! starting k-index ku = block ( n , 6 ) ! ending k-index delta = dxh ( i ) * 0.5 logdz = LOG ( delta / z0 ) logdzh = LOG ( delta / z0h ) logzh = LOG ( z0 / z0h ) sqdz = SQRT ( delta / z0 ) DO k = kl , ku DO j = jl , ju utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j + 1 , k )) * 0.5 utang2Int = ( utang2 ( i , j , k ) + utang2 ( i , j , k + 1 )) * 0.5 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = ( Tcell ( i , j , k ) - Twall ) Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri call unoh ( bcTflux , cth , logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field obcTfluxA = obcTfluxA + bcTflux iotflux ( i , j , k ) = iotflux ( i , j , k ) + bcTflux * dxfi ( i ) iocth ( i , j , k ) = cth iot ( i , j , k ) = iot ( i , j , k ) + 0.5 * ( ekh ( i , j , k ) * dxf ( im ) + ekh ( im , j , k ) * dxf ( i )) * ( Tcell ( i , j , k ) - Tcell ( im , j , k )) * dxh2i ( i ) * dxfi ( i ) - bcTflux * dxfi ( i ) END DO END DO !!! case 32 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !wfuno32 CASE ( 32 ) !wall in xz -> wf in y (=vertical) upper, north wall j = ind jm = j - 1 il = block ( n , 1 ) iu = block ( n , 2 ) kl = block ( n , 5 ) ku = block ( n , 6 ) delta = 0.5 * dy logdz = LOG ( delta / z0 ) logdzh = LOG ( delta / z0h ) logzh = LOG ( z0 / z0h ) sqdz = SQRT ( delta / z0 ) DO k = kl , ku DO i = il , iu utang1Int = ( utang1 ( i , j , k ) + utang1 ( i + 1 , j , k )) * 0.5 utang2Int = ( utang2 ( i , j , k ) + utang2 ( i , j , k + 1 )) * 0.5 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = ( Tcell ( i , j , k ) - Twall ) Ribl0 = grav * delta * dT / ( Twall * utangInt ) ! call unoh ( bcTflux , cth , logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) obcTfluxA = obcTfluxA + bcTflux iotflux ( i , j , k ) = iotflux ( i , j , k ) + bcTflux * dyi iocth ( i , j , k ) = cth iot ( i , j , k ) = iot ( i , j , k ) + ( & 0.5 * ( ekh ( i , j , k ) + ekh ( i , jm , k )) * ( Tcell ( i , j , k ) - Tcell ( i , jm , k ))) * dy2i & - bcTflux * dyi END DO END DO !!! case 42 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !wfuno42 CASE ( 42 ) !wall in xz -> wf in y (=vertical) lower, south wall j = ind jp = j + 1 il = block ( n , 1 ) iu = block ( n , 2 ) kl = block ( n , 5 ) ku = block ( n , 6 ) delta = 0.5 * dy logdz = LOG ( delta / z0 ) logdzh = LOG ( delta / z0h ) logzh = LOG ( z0 / z0h ) sqdz = SQRT ( delta / z0 ) DO k = kl , ku DO i = il , iu utang1Int = ( utang1 ( i , j , k ) + utang1 ( i + 1 , j , k )) * 0.5 utang2Int = ( utang2 ( i , j , k ) + utang2 ( i , j , k + 1 )) * 0.5 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = ( Tcell ( i , j , k ) - Twall ) Ribl0 = grav * delta * dT / ( Twall * utangInt ) ! call unoh ( bcTflux , cth , logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) obcTfluxA = obcTfluxA + bcTflux iotflux ( i , j , k ) = iotflux ( i , j , k ) + bcTflux * dyi iocth ( i , j , k ) = cth iot ( i , j , k ) = iot ( i , j , k ) - & 0.5 * ( ekh ( i , jp , k ) + ekh ( i , j , k )) * ( Tcell ( i , jp , k ) - Tcell ( i , j , k )) * dy2i & - bcTflux * dyi END DO END DO !!! case 52 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !wfuno52 CASE ( 52 ) !wall in xy -> wf in z (=horizontal), top wall k = block ( n , 6 ) + 1 !block location if (. not .( k . gt . kmax )) then km = k - 1 ! il = block ( n , 1 ) iu = block ( n , 2 ) jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) delta = dzf ( k ) * 0.5 logdz = LOG ( delta / z0 ) logdzh = LOG ( delta / z0h ) logzh = LOG ( z0 / z0h ) sqdz = SQRT ( delta / z0 ) DO j = jl , ju DO i = il , iu utang1Int = ( utang1 ( i , j , k ) + utang1 ( i + 1 , j , k )) * 0.5 utang2Int = ( utang2 ( i , j , k ) + utang2 ( i , j + 1 , k )) * 0.5 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = ( Tcell ( i , j , k ) - Twall ) Ribl0 = grav * delta * dT / ( Twall * utangInt ) ! call unoh ( bcTflux , cth , logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) obcTfluxA = obcTfluxA + bcTflux iotflux ( i , j , k ) = iotflux ( i , j , k ) + bcTflux * dzfi ( k ) iocth ( i , j , k ) = cth iot ( i , j , k ) = iot ( i , j , k ) & + 0.5 * ( dzf ( km ) * ekh ( i , j , k ) + dzf ( k ) * ekh ( i , j , km )) * ( Tcell ( i , j , k ) - Tcell ( i , j , km )) * dzh2i ( k ) * dzfi ( k ) & - bcTflux * dzfi ( k ) END DO END DO end if !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CASES FOR MOMENTUM!!!!!!!!!!!!!!!!!!!!!!!!!!!!! CASE ( 11 ) !wfuno11, case 11 , west wall i = block ( n , 1 ) - 1 !fluid location (also where wall variables are stored) ip = i + 1 !inside wall, used for subtracting original diffusion term jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) + 1 ! starting j-index      !might cause problem when jl=1 ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) ! ending j-index     !might cause problem when ju=jmax kl = block ( n , 5 ) ! starting k-index ku = block ( n , 6 ) ! ending k-index delta = dxf ( i ) * 0.5 logdz = LOG ( delta / z0 ) logdzh = LOG ( delta / z0h ) logzh = LOG ( z0 / z0h ) sqdz = SQRT ( delta / z0 ) !v west DO k = kl , ku DO j = jl , ju utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i , j , k + 1 ) + utang2 ( i , j - 1 , k ) + utang2 ( i , j - 1 , k + 1 )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = (( Tcell ( i , j , k ) + Tcell ( i , j - 1 , k )) - ( Twall + Twall )) * 0.5 Ribl0 = grav * delta * dT * 2 / (( Twall + Twall ) * utangInt ) !Eq. 6, guess initial Ri ctm = unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field dummy = ( utang1Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) epmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) * dxf ( ip ) + & ( ekm ( ip , j , k ) + ekm ( ip , j - 1 , k )) * dxf ( i )) * dxhi ( ip ) iout1 ( i , j , k ) = iout1 ( i , j , k ) - ( utang1 ( ip , j , k ) - utang1 ( i , j , k )) * epmo * dxhi ( ip ) * dxfi ( i ) - bcmomflux * dxfi ( i ) ! END DO END DO !v west edge south j = MAX ( block ( n , 3 ) - myid * jmax , 1 ) DO k = kl , ku utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i , j , k + 1 ) + utang2 ( i , j - 1 , k ) + utang2 ( i , j - 1 , k + 1 )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j , k ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang1Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) * 0.5 !only half since on edge of block (another half might come from another processor?) !   epmo = 0.5 * (ekm(ip,j,k)*dxf(i) + ekm(i,j,k)*dxf(ip)) * dxhi(ip) epmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) * dxf ( ip ) + & ( ekm ( ip , j , k ) + ekm ( ip , j - 1 , k )) * dxf ( i )) * dxhi ( ip ) iout1 ( i , j , k ) = iout1 ( i , j , k ) - (( utang1 ( ip , j , k ) - utang1 ( i , j , k )) * epmo * dxhi ( ip ) * dxfi ( i ) - bcmomflux * dxfi ( i )) * 0.5 ! remove standard diffusion apply only half of wall-flux since it's an edge !only half of the flux, since only half of the control-volume around v is touching this facet (other half is either in free air or touching another facet) END DO !v west edge north j = MIN ( block ( n , 4 ) - myid * jmax , jmax ) + 1 DO k = kl , ku utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i , j , k + 1 ) + utang2 ( i , j - 1 , k ) + utang2 ( i , j - 1 , k + 1 )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j - 1 , k ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang1Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) * 0.5 epmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) * dxf ( ip ) + & ( ekm ( ip , j , k ) + ekm ( ip , j - 1 , k )) * dxf ( i )) * dxhi ( ip ) iout1 ( i , j , k ) = iout1 ( i , j , k ) - (( utang1 ( ip , j , k ) - utang1 ( i , j , k )) * epmo * dxhi ( ip ) * dxfi ( i ) - bcmomflux * dxfi ( i )) * 0.5 ! %remove standard diffusion apply only half of wall-flux since it's an edge END DO !w west jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ! kl = block ( n , 5 ) + 1 ! DO k = kl , ku DO j = jl , ju utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j + 1 , k ) + utang1 ( i , j + 1 , k - 1 ) + utang1 ( i , j , k - 1 )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = (( Tcell ( i , j , k ) + Tcell ( i , j , k - 1 )) - ( Twall + Twall )) * 0.5 Ribl0 = grav * delta * dT * 2 / (( Twall + Twall ) * utangInt ) !Eq. 6, guess initial Ri ctm = unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field dummy = ( utang2Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) epom = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) * dxf ( ip ) + ekm ( ip , j , k ) * dxf ( i )) * dxhi ( ip ) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) * dxf ( ip ) + ekm ( ip , j , k - 1 ) * dxf ( i )) * dxhi ( ip )) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) - ( utang2 ( ip , j , k ) - utang2 ( i , j , k )) * epom * dxhi ( ip ) * dxfi ( i ) - bcmomflux * dxfi ( i ) ! END DO END DO !w west top edge k = block ( n , 6 ) + 1 ! ending k-index km = k - 1 DO j = jl , ju utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j + 1 , k ) + utang1 ( i , j + 1 , k - 1 ) + utang1 ( i , j , k - 1 )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j , k - 1 ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang2Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) * 0.5 epom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( ip ) + ekm ( ip , j , k ) * dxf ( i )) * dxhi ( ip ) + & dzf ( k ) * ( ekm ( i , j , km ) * dxf ( ip ) + ekm ( ip , j , km ) * dxf ( i )) * dxhi ( ip )) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) - (( utang2 ( ip , j , k ) - utang2 ( i , j , k )) * epom * dxhi ( ip ) * dxfi ( i ) - bcmomflux * dxfi ( i )) * 0.5 ! END DO !w west bottom edge k = block ( n , 6 ) ! ending k-index if ( k . gt . 0 ) then km = k - 1 DO j = jl , ju utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j + 1 , k ) + utang1 ( i , j + 1 , k - 1 ) + utang1 ( i , j , k - 1 )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j , k - 1 ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang2Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) * 0.5 epom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( ip ) + ekm ( ip , j , k ) * dxf ( i )) * dxhi ( ip ) + & dzf ( k ) * ( ekm ( i , j , km ) * dxf ( ip ) + ekm ( ip , j , km ) * dxf ( i )) * dxhi ( ip )) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) - (( utang2 ( ip , j , k ) - utang2 ( i , j , k )) * epom * dxhi ( ip ) * dxfi ( i ) - bcmomflux * dxfi ( i )) * 0.5 ! END DO end if !!! case 21 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !wfuno 21 !wall in yz -> wf in x (=vertical), upper wall, east wall CASE ( 21 ) !v east i = block ( n , 2 ) + 1 !fluid im = i - 1 !inside block jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) + 1 ! starting j-index      !might cause problem when jl=1 ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) ! ending j-index     !might cause problem when ju=jmax kl = block ( n , 5 ) ! starting k-index ku = block ( n , 6 ) ! ending k-index delta = dxh ( i ) * 0.5 logdz = LOG ( delta / z0 ) logdzh = LOG ( delta / z0h ) logzh = LOG ( z0 / z0h ) sqdz = SQRT ( delta / z0 ) DO k = kl , ku DO j = jl , ju utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i , j , k + 1 ) + utang2 ( i , j - 1 , k ) + utang2 ( i , j - 1 , k + 1 )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = (( Tcell ( i , j , k ) + Tcell ( i , j - 1 , k )) - ( Twall + Twall )) * 0.5 Ribl0 = grav * delta * dT * 2 / (( Twall + Twall ) * utangInt ) !Eq. 6, guess initial Ri !call function repeatedly ctm = unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field dummy = ( utang1Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) emmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) * dxf ( im ) + ( ekm ( im , j - 1 , k ) + ekm ( im , j , k )) * dxf ( i )) * dxhi ( i ) ! dx is non-equidistant iout1 ( i , j , k ) = iout1 ( i , j , k ) + ( utang1 ( i , j , k ) - utang1 ( im , j , k )) * emmo * dxhi ( i ) * dxfi ( i ) - bcmomflux * dxfi ( i ) ! END DO END DO !v east edge south j = MAX ( block ( n , 3 ) - myid * jmax , 1 ) DO k = kl , ku utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i , j , k + 1 ) + utang2 ( i , j - 1 , k ) + utang2 ( i , j - 1 , k + 1 )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j , k ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang1Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) * 0.5 emmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) * dxf ( im ) + ( ekm ( im , j - 1 , k ) + ekm ( im , j , k )) * dxf ( i )) * dxhi ( i ) ! dx is non-equidistant iout1 ( i , j , k ) = iout1 ( i , j , k ) + (( utang1 ( i , j , k ) - utang1 ( im , j , k )) * emmo * dxhi ( i ) * dxfi ( i ) - bcmomflux * dxfi ( i )) * 0.5 ! END DO !v east edge north j = MIN ( block ( n , 4 ) - myid * jmax , jmax ) + 1 ! DO k = kl , ku utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i , j , k + 1 ) + utang2 ( i , j - 1 , k ) + utang2 ( i , j - 1 , k + 1 )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j - 1 , k ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang1Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) * 0.5 emmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) * dxf ( im ) + ( ekm ( im , j - 1 , k ) + ekm ( im , j , k )) * dxf ( i )) * dxhi ( i ) ! dx is non-equidistant iout1 ( i , j , k ) = iout1 ( i , j , k ) + (( utang1 ( i , j , k ) - utang1 ( im , j , k )) * emmo * dxhi ( i ) * dxfi ( i ) - bcmomflux * dxfi ( i )) * 0.5 ! END DO !w east jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ! kl = block ( n , 5 ) + 1 ! DO k = kl , ku DO j = jl , ju utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j + 1 , k ) + utang1 ( i , j + 1 , k - 1 ) + utang1 ( i , j , k - 1 )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = (( Tcell ( i , j , k ) + Tcell ( i , j , k - 1 )) - ( Twall + Twall )) * 0.5 Ribl0 = grav * delta * dT * 2 / (( Twall + Twall ) * utangInt ) !Eq. 6, guess initial Ri ctm = unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field dummy = ( utang2Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) emom = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) * dxf ( im ) + ekm ( im , j , k ) * dxf ( i )) * dxhi ( i ) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) * dxf ( im ) + ekm ( im , j , k - 1 ) * dxf ( i )) * dxhi ( i )) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) + ( utang2 ( i , j , k ) - utang2 ( im , j , k )) * emom * dxhi ( i ) * dxfi ( i ) - bcmomflux * dxfi ( i ) ! END DO END DO !w east edge top k = block ( n , 6 ) + 1 ! ending k-index DO j = jl , ju utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j + 1 , k ) + utang1 ( i , j + 1 , k - 1 ) + utang1 ( i , j , k - 1 )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j , k - 1 ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang2Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) * 0.5 emom = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) * dxf ( im ) + ekm ( im , j , k ) * dxf ( i )) * dxhi ( i ) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) * dxf ( im ) + ekm ( im , j , k - 1 ) * dxf ( i )) * dxhi ( i )) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) + (( utang2 ( i , j , k ) - utang2 ( im , j , k )) * emom * dxhi ( i ) * dxfi ( i ) - bcmomflux * dxfi ( i )) * 0.5 ! END DO !w east edge bot k = block ( n , 6 ) ! if ( k . gt . 0 ) then DO j = jl , ju utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j + 1 , k ) + utang1 ( i , j + 1 , k - 1 ) + utang1 ( i , j , k - 1 )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j , k - 1 ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang2Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dxfi ( i ) * 0.5 emom = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) * dxf ( im ) + ekm ( im , j , k ) * dxf ( i )) * dxhi ( i ) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) * dxf ( im ) + ekm ( im , j , k - 1 ) * dxf ( i )) * dxhi ( i )) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) + (( utang2 ( i , j , k ) - utang2 ( im , j , k )) * emom * dxhi ( i ) * dxfi ( i ) - bcmomflux * dxfi ( i )) * 0.5 ! END DO end if !!! case 31 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !wfuno 31 CASE ( 31 ) !wall in xz -> wf in y (=vertical) upper, north wall j = ind jm = j - 1 il = block ( n , 1 ) + 1 iu = block ( n , 2 ) kl = block ( n , 5 ) ku = block ( n , 6 ) delta = 0.5 * dy logdz = LOG ( delta / z0 ) logdzh = LOG ( delta / z0h ) logzh = LOG ( z0 / z0h ) sqdz = SQRT ( delta / z0 ) !u north DO k = kl , ku DO i = il , iu utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i - 1 , j , k ) + utang2 ( i , j , k + 1 ) + utang2 ( i - 1 , j , k + 1 )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = (( Tcell ( i , j , k ) + Tcell ( i - 1 , j , k )) - ( Twall + Twall )) * 0.5 Ribl0 = grav * delta * dT * 2 / (( Twall + Twall ) * utangInt ) !Eq. 6, guess initial Ri ctm = unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field dummy = ( utang1Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi emmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , jm , k )) * dxf ( i - 1 ) + ( ekm ( i - 1 , jm , k ) + ekm ( i - 1 , j , k )) * dxf ( i )) * dxhi ( i ) iout1 ( i , j , k ) = iout1 ( i , j , k ) + ( utang1 ( i , j , k ) - utang1 ( i , jm , k )) * emmo * dy2i - bcmomflux * dyi ! END DO END DO !u north east edge i = block ( n , 2 ) + 1 DO k = kl , ku utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i - 1 , j , k ) + utang2 ( i , j , k + 1 ) + utang2 ( i - 1 , j , k + 1 )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i - 1 , j , k ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang1Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi5 emmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , jm , k )) * dxf ( i - 1 ) + ( ekm ( i - 1 , jm , k ) + ekm ( i - 1 , j , k )) * dxf ( i )) * dxhi ( i ) iout1 ( i , j , k ) = iout1 ( i , j , k ) + (( utang1 ( i , j , k ) - utang1 ( i , jm , k )) * emmo * dy2i - bcmomflux * dyi ) * 0.5 ! END DO !u north west edge i = block ( n , 1 ) DO k = kl , ku utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i - 1 , j , k ) + utang2 ( i , j , k + 1 ) + utang2 ( i - 1 , j , k + 1 )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j , k ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang1Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi5 emmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , jm , k )) * dxf ( i - 1 ) + ( ekm ( i - 1 , jm , k ) + ekm ( i - 1 , j , k )) * dxf ( i )) * dxhi ( i ) iout1 ( i , j , k ) = iout1 ( i , j , k ) + (( utang1 ( i , j , k ) - utang1 ( i , jm , k )) * emmo * dy2i - bcmomflux * dyi ) * 0.5 ! END DO !w north il = block ( n , 1 ) ! kl = block ( n , 5 ) + 1 ! DO k = kl , ku DO i = il , iu utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j , k - 1 ) + utang1 ( i + 1 , j , k ) + utang1 ( i + 1 , j , k - 1 )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = (( Tcell ( i , j , k ) + Tcell ( i , j , k - 1 )) - ( Twall + Twall )) * 0.5 Ribl0 = grav * delta * dT * 2 / (( Twall + Twall ) * utangInt ) !Eq. 6, guess initial Ri ctm = unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field dummy = ( utang2Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi eomm = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , jm , k )) + dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , jm , k - 1 ))) * dzhiq ( k ) ! dz is non-eqidistant iout2 ( i , j , k ) = iout2 ( i , j , k ) + ( utang2 ( i , j , k ) - utang2 ( i , jm , k )) * eomm * dy2i - bcmomflux * dyi ! END DO END DO !w north edge top k = block ( n , 6 ) + 1 DO i = il , iu utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j , k - 1 ) + utang1 ( i + 1 , j , k ) + utang1 ( i + 1 , j , k - 1 )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j , k - 1 ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang2Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi5 eomm = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , jm , k )) + dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , jm , k - 1 ))) * dzhiq ( k ) ! dz is non-eqidistant iout2 ( i , j , k ) = iout2 ( i , j , k ) + (( utang2 ( i , j , k ) - utang2 ( i , jm , k )) * eomm * dy2i - bcmomflux * dyi ) * 0.5 ! END DO !w north edge bot k = block ( n , 6 ) if ( k . gt . 0 ) then DO i = il , iu utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j , k - 1 ) + utang1 ( i + 1 , j , k ) + utang1 ( i + 1 , j , k - 1 )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j , k - 1 ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang2Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi5 eomm = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , jm , k )) + dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , jm , k - 1 ))) * dzhiq ( k ) ! dz is non-eqidistant iout2 ( i , j , k ) = iout2 ( i , j , k ) + (( utang2 ( i , j , k ) - utang2 ( i , jm , k )) * eomm * dy2i - bcmomflux * dyi ) * 0.5 ! END DO end if !!! case 41 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!` !wfuno41 CASE ( 41 ) !wall in xz -> wf in y (=vertical) lower, south wall j = ind jp = j + 1 il = block ( n , 1 ) + 1 iu = block ( n , 2 ) kl = block ( n , 5 ) ku = block ( n , 6 ) delta = 0.5 * dy logdz = LOG ( delta / z0 ) logdzh = LOG ( delta / z0h ) logzh = LOG ( z0 / z0h ) sqdz = SQRT ( delta / z0 ) DO k = kl , ku DO i = il , iu utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i - 1 , j , k ) + utang2 ( i , j , k + 1 ) + utang2 ( i - 1 , j , k + 1 )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = (( Tcell ( i , j , k ) + Tcell ( i - 1 , j , k )) - ( Twall + Twall )) * 0.5 Ribl0 = grav * delta * dT * 2 / (( Twall + Twall ) * utangInt ) !Eq. 6, guess initial Ri ctm = unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field dummy = ( utang1Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi empo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , jp , k )) * dxf ( i - 1 ) + & ( ekm ( i - 1 , j , k ) + ekm ( i - 1 , jp , k )) * dxf ( i )) * dxhi ( i ) ! dx is non-equidistant iout1 ( i , j , k ) = iout1 ( i , j , k ) - ( utang1 ( i , jp , k ) - utang1 ( i , j , k )) * empo * dy2i - bcmomflux * dyi ! END DO END DO !u south edge west i = block ( n , 1 ) DO k = kl , ku utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i - 1 , j , k ) + utang2 ( i , j , k + 1 ) + utang2 ( i - 1 , j , k + 1 )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j , k ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang1Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi5 empo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , jp , k )) * dxf ( i - 1 ) + & ( ekm ( i - 1 , j , k ) + ekm ( i - 1 , jp , k )) * dxf ( i )) * dxhi ( i ) ! dx is non-equidistant iout1 ( i , j , k ) = iout1 ( i , j , k ) - (( utang1 ( i , jp , k ) - utang1 ( i , j , k )) * empo * dy2i - bcmomflux * dyi ) * 0.5 ! END DO !u south edge east i = block ( n , 2 ) + 1 DO k = kl , ku utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i - 1 , j , k ) + utang2 ( i , j , k + 1 ) + utang2 ( i - 1 , j , k + 1 )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i - 1 , j , k ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang1Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi5 empo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , jp , k )) * dxf ( i - 1 ) + & ( ekm ( i - 1 , j , k ) + ekm ( i - 1 , jp , k )) * dxf ( i )) * dxhi ( i ) ! dx is non-equidistant iout1 ( i , j , k ) = iout1 ( i , j , k ) - (( utang1 ( i , jp , k ) - utang1 ( i , j , k )) * empo * dy2i - bcmomflux * dyi ) * 0.5 ! END DO !w south il = block ( n , 1 ) ! kl = block ( n , 5 ) + 1 ! DO k = kl , ku DO i = il , iu utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j , k - 1 ) + utang1 ( i + 1 , j , k ) + utang1 ( i + 1 , j , k - 1 )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = (( Tcell ( i , j , k ) + Tcell ( i , j , k - 1 )) - ( Twall + Twall )) * 0.5 Ribl0 = grav * delta * dT * 2 / (( Twall + Twall ) * utangInt ) !Eq. 6, guess initial Ri ctm = unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field dummy = ( utang2Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi eopm = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , jp , k )) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , jp , k - 1 ))) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) - ( utang2 ( i , jp , k ) - utang2 ( i , j , k )) * eopm * dy2i - bcmomflux * dyi ! END DO END DO !w south edge top k = block ( n , 6 ) + 1 DO i = il , iu utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j , k - 1 ) + utang1 ( i + 1 , j , k ) + utang1 ( i + 1 , j , k - 1 )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j , k - 1 ) - Twall Ribl0 = grav * delta * dT * 2 / ( Twall * utangInt ) !Eq. 6, guess initial Ri !call function repeatedly dummy = ( utang2Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi5 eopm = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , jp , k )) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , jp , k - 1 ))) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) - (( utang2 ( i , jp , k ) - utang2 ( i , j , k )) * eopm * dy2i - bcmomflux * dyi ) * 0.5 ! END DO !w south edge bot k = block ( n , 6 ) if ( k . gt . 0 ) then DO i = il , iu utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j , k - 1 ) + utang1 ( i + 1 , j , k ) + utang1 ( i + 1 , j , k - 1 )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j , k - 1 ) - Twall Ribl0 = grav * delta * dT * 2 / ( Twall * utangInt ) !Eq. 6, guess initial Ri !call function repeatedly dummy = ( utang2Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dyi5 eopm = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , jp , k )) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , jp , k - 1 ))) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) - (( utang2 ( i , jp , k ) - utang2 ( i , j , k )) * eopm * dy2i - bcmomflux * dyi ) * 0.5 ! END DO end if !!!! case 51 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !wfuno51 CASE ( 51 ) !wall in xy -> wf in z (=horizontal), top wall k = block ( n , 6 ) + 1 !block location if (. not .( k . gt . kmax )) then km = k - 1 !shear velocity location il = block ( n , 1 ) + 1 iu = block ( n , 2 ) jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) delta = 0.5 * dzf ( k ) logdz = LOG ( delta / z0 ) logdzh = LOG ( delta / z0h ) logzh = LOG ( z0 / z0h ) sqdz = SQRT ( delta / z0 ) DO j = jl , ju DO i = il , iu utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i - 1 , j , k ) + utang2 ( i , j + 1 , k ) + utang2 ( i - 1 , j + 1 , k )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = (( Tcell ( i , j , k ) + Tcell ( i - 1 , j , k )) - ( Twall + Twall )) * 0.5 Ribl0 = grav * delta * dT * 2 / (( Twall + Twall ) * utangInt ) !Eq. 6, guess initial Ri ctm = unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field dummy = ( utang1Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) emom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k ) * dxf ( i )) + & dzf ( k ) * ( ekm ( i , j , km ) * dxf ( i - 1 ) + ekm ( i - 1 , j , km ) * dxf ( i ))) * dxhi ( i ) * dzhiq ( k ) iout1 ( i , j , k ) = iout1 ( i , j , k ) + ( utang1 ( i , j , k ) - utang1 ( i , j , km )) * emom * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k ) ! END DO END DO !u top edge west i = block ( n , 1 ) DO j = jl , ju utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i - 1 , j , k ) + utang2 ( i , j + 1 , k ) + utang2 ( i - 1 , j + 1 , k )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j , k ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang1Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) * 0.5 emom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k ) * dxf ( i )) + & dzf ( k ) * ( ekm ( i , j , km ) * dxf ( i - 1 ) + ekm ( i - 1 , j , km ) * dxf ( i ))) * dxhi ( i ) * dzhiq ( k ) iout1 ( i , j , k ) = iout1 ( i , j , k ) + (( utang1 ( i , j , k ) - utang1 ( i , j , km )) * emom * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k )) * 0.5 ! END DO !u top edge east DO j = jl , ju utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i - 1 , j , k ) + utang2 ( i , j + 1 , k ) + utang2 ( i - 1 , j + 1 , k )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i - 1 , j , k ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang1Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) * 0.5 emom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k ) * dxf ( i )) + & dzf ( k ) * ( ekm ( i , j , km ) * dxf ( i - 1 ) + ekm ( i - 1 , j , km ) * dxf ( i ))) * dxhi ( i ) * dzhiq ( k ) iout1 ( i , j , k ) = iout1 ( i , j , k ) + (( utang1 ( i , j , k ) - utang1 ( i , j , km )) * emom * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k )) * 0.5 ! END DO !v il = block ( n , 1 ) jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) + 1 DO j = jl , ju DO i = il , iu utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j - 1 , k ) + utang1 ( i + 1 , j - 1 , k ) + utang1 ( i + 1 , j , k )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = (( Tcell ( i , j , k ) + Tcell ( i , j - 1 , k )) - ( Twall + Twall )) * 0.5 Ribl0 = grav * delta * dT * 2 / (( Twall + Twall ) * utangInt ) !Eq. 6, guess initial Ri ctm = unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field dummy = ( utang2Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) eomm = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) + dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i , j - 1 , km ))) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) + ( utang2 ( i , j , k ) - utang2 ( i , j , km )) * eomm * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k ) ! END DO END DO !v top edge south j = MAX ( block ( n , 3 ) - myid * jmax , 1 ) DO i = il , iu utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j - 1 , k ) + utang1 ( i + 1 , j - 1 , k ) + utang1 ( i + 1 , j , k )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j , k ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang2Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) * 0.5 eomm = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) + dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i , j - 1 , km ))) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) + (( utang2 ( i , j , k ) - utang2 ( i , j , km )) * eomm * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k )) * 0.5 ! END DO !v top edge north j = MIN ( block ( n , 4 ) - myid * jmax , jmax ) + 1 DO i = il , iu utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j - 1 , k ) + utang1 ( i + 1 , j - 1 , k ) + utang1 ( i + 1 , j , k )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = Tcell ( i , j - 1 , k ) - Twall Ribl0 = grav * delta * dT / ( Twall * utangInt ) !Eq. 6, guess initial Ri dummy = ( utang2Int ** 2 ) * unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) * 0.5 eomm = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) + dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i , j - 1 , km ))) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) + (( utang2 ( i , j , k ) - utang2 ( i , j , km )) * eomm * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k )) * 0.5 ! END DO end if !!!!!!!!!!!!!!!SPECIAL CASES FOR THE SURFACE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !can actually be made redundant and just be replaced by standard horizontal case (doesn't really matter though) CASE ( 91 ) !surface momentum flux k = kb ! km = k - 1 ! il = ib iu = ie jl = jb ju = je delta = 0.5 * dzf ( k ) !might need attention on streched grids! as well as the dzfi when updating up logdz = LOG ( delta / z0 ) logdzh = LOG ( delta / z0h ) logzh = LOG ( z0 / z0h ) sqdz = SQRT ( delta / z0 ) DO j = jl , ju !u component DO i = il , iu utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i - 1 , j , k ) + utang2 ( i , j + 1 , k ) + utang2 ( i - 1 , j + 1 , k )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = (( Tcell ( i , j , k ) + Tcell ( i - 1 , j , k )) - ( Twall + Twall )) * 0.5 Ribl0 = grav * delta * dT * 2 / (( Twall + Twall ) * utangInt ) !Eq. 6, guess initial Ri ctm = unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field dummy = ( utang1Int ** 2 ) * ctm bcmomflux = SIGN ( dummy , utang1Int ) !bcmomflux=u_star&#94;2 iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) emom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k ) * dxf ( i )) + & ! dx is non-equidistant dzf ( k ) * ( ekm ( i , j , km ) * dxf ( i - 1 ) + ekm ( i - 1 , j , km ) * dxf ( i ))) * dxhi ( i ) * dzhiq ( k ) iout1 ( i , j , k ) = iout1 ( i , j , k ) + ( utang1 ( i , j , k ) - utang1 ( i , j , km )) * emom * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k ) ! END DO END DO DO j = jl , ju DO i = il , iu utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j - 1 , k ) + utang1 ( i + 1 , j - 1 , k ) + utang1 ( i + 1 , j , k )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = (( Tcell ( i , j , k ) + Tcell ( i , j - 1 , k )) - ( Twall + Twall )) * 0.5 Ribl0 = grav * delta * dT * 2 / (( Twall + Twall ) * utangInt ) !Eq. 6, guess initial Ri ctm = unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field dummy = ( utang2Int ** 2 ) * ctm !save result and update field bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) eomm = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) + dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i , j - 1 , km ))) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) + ( utang2 ( i , j , k ) - utang2 ( i , j , km )) * eomm * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k ) ! END DO END DO !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! CASE ( 92 ) !surface temperature flux k = kb !block location ku = k !shear velocity location il = ib iu = ie jl = jb ju = je delta = dzf ( k ) * 0.5 logdz = LOG ( delta / z0 ) logdzh = LOG ( delta / z0h ) logzh = LOG ( z0 / z0h ) sqdz = SQRT ( delta / z0 ) DO j = jl , ju DO i = il , iu utang1Int = ( utang1 ( i , j , ku ) + utang1 ( i + 1 , j , ku )) * 0.5 utang2Int = ( utang2 ( i , j , ku ) + utang2 ( i , j + 1 , ku )) * 0.5 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = ( Tcell ( i , j , ku ) - Twall ) Ribl0 = grav * delta * dT / ( Twall * utangInt ) ! call unoh ( bcTflux , cth , logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) obcTfluxA = obcTfluxA + bcTflux iotflux ( i , j , k ) = iotflux ( i , j , k ) + bcTflux * dzfi ( k ) iot ( i , j , ku ) = iot ( i , j , ku ) + & 0.5 * ( dzf ( k - 1 ) * ekh ( i , j , k ) + dzf ( k ) * ekh ( i , j , k - 1 )) * & ! zero flux ( Tcell ( i , j , k ) - Tcell ( i , j , k - 1 )) * dzh2i ( ku ) * dzfi ( ku ) & - bcTflux * dzfi ( k ) END DO END DO END SELECT END SUBROUTINE wfuno","tags":"","loc":"proc/wfuno.html"},{"title":"unoh – uDALES","text":"subroutine unoh(otf, octh, logdz, logdzh, logzh, sqdz, utangInt, dT, Ribl0, fkar2) Arguments Type Intent Optional Attributes Name real, intent(out) :: otf real, intent(out) :: octh real, intent(in) :: logdz real, intent(in) :: logdzh real, intent(in) :: logzh real, intent(in) :: sqdz real, intent(in) :: utangInt real, intent(in) :: dT real, intent(in) :: Ribl0 real, intent(in) :: fkar2 Called by proc~~unoh~~CalledByGraph proc~unoh unoh proc~wfuno wfuno proc~wfuno->proc~unoh proc~bottom bottom proc~bottom->proc~wfuno program~dalesurban DALESURBAN program~dalesurban->proc~bottom Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code unoh Source Code SUBROUTINE unoh ( otf , octh , logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !for heat, the bit that does not change no matter what wall !flux in Km/s IMPLICIT NONE REAL , INTENT ( in ) :: logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 REAL , INTENT ( out ) :: octh , otf REAL :: Ribl1 , Fm , Fh , cm , ch , M , dTrough , cth REAL , PARAMETER :: b1 = 9.4 !parameters from Uno1995 REAL , PARAMETER :: b2 = 4.7 REAL , PARAMETER :: dm = 7.4 REAL , PARAMETER :: dh = 5.3 REAL , PARAMETER :: prandtlmol = 0.71 REAL , PARAMETER :: prandtlmoli = 1 / 0.71 octh = 0. otf = 0. IF ( Ribl0 > 0.21 ) THEN !0.25 approx critical for bulk Richardson number  => stable Fm = 1. / ( 1. + b2 * Ribl0 ) ** 2 !Eq. 4 Fh = Fm !Eq. 4 ELSE ! => unstable cm = ( dm * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 ch = ( dh * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 Fm = 1. - ( b1 * Ribl0 ) / ( 1. + cm * SQRT ( ABS ( Ribl0 ))) !Eq. 3 Fh = 1. - ( b1 * Ribl0 ) / ( 1. + ch * SQRT ( ABS ( Ribl0 ))) !Eq. 3 END IF M = prandtlmol * logdz * SQRT ( Fm ) / Fh !Eq. 14 Ribl1 = Ribl0 - Ribl0 * prandtlmol * logzh / ( prandtlmol * logzh + M ) !Eq. 17 !interate to get new Richardson number IF ( Ribl1 > 0.21 ) THEN !0.25 approx critical for bulk Richardson number  => stable Fm = 1. / ( 1. + b2 * Ribl1 ) ** 2 !Eq. 4 Fh = Fm !Eq. 4 ELSE ! => unstable cm = ( dm * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 ch = ( dh * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 Fm = 1. - ( b1 * Ribl1 ) / ( 1. + cm * SQRT ( ABS ( Ribl1 ))) !Eq. 3 Fh = 1. - ( b1 * Ribl1 ) / ( 1. + ch * SQRT ( ABS ( Ribl1 ))) !Eq. 3 END IF M = prandtlmol * logdz * SQRT ( Fm ) / Fh !Eq. 14 dTrough = dT * 1. / ( prandtlmol * logzh / M + 1. ) !Eq. 13a octh = SQRT ( utangInt ) * fkar2 / ( logdz * logdzh ) * prandtlmoli * Fh !Eq. 8 otf = octh * dTrough !Eq. 2, Eq. 8 END SUBROUTINE unoh","tags":"","loc":"proc/unoh.html"},{"title":"initstatsdump – uDALES","text":"public subroutine initstatsdump() Uses modmpi modglobal modstat_nc modfields proc~~initstatsdump~~UsesGraph proc~initstatsdump initstatsdump module~modmpi modmpi proc~initstatsdump->module~modmpi module~modfields modfields proc~initstatsdump->module~modfields module~modstat_nc modstat_nc proc~initstatsdump->module~modstat_nc module~modglobal modglobal proc~initstatsdump->module~modglobal mpi mpi module~modmpi->mpi module~modstat_nc->module~modmpi netcdf netcdf module~modstat_nc->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~initstatsdump~~CallsGraph proc~initstatsdump initstatsdump proc~writestat_dims_nc writestat_dims_nc proc~initstatsdump->proc~writestat_dims_nc mpi_bcast mpi_bcast proc~initstatsdump->mpi_bcast proc~define_nc define_nc proc~initstatsdump->proc~define_nc proc~open_nc open_nc proc~initstatsdump->proc~open_nc nf90_put_var nf90_put_var proc~writestat_dims_nc->nf90_put_var nf90_inquire_dimension nf90_inquire_dimension proc~writestat_dims_nc->nf90_inquire_dimension nf90_inq_varid nf90_inq_varid proc~writestat_dims_nc->nf90_inq_varid nf90_put_att nf90_put_att proc~define_nc->nf90_put_att nf90_redef nf90_redef proc~define_nc->nf90_redef nf90_def_var nf90_def_var proc~define_nc->nf90_def_var proc~define_nc->nf90_inq_varid nf90_inq_dimid nf90_inq_dimid proc~define_nc->nf90_inq_dimid nf90_enddef nf90_enddef proc~define_nc->nf90_enddef proc~nchandle_error nchandle_error proc~define_nc->proc~nchandle_error proc~open_nc->nf90_put_att nf90_def_dim nf90_def_dim proc~open_nc->nf90_def_dim proc~open_nc->nf90_inquire_dimension proc~open_nc->nf90_def_var proc~open_nc->nf90_inq_varid nf90_inquire nf90_inquire proc~open_nc->nf90_inquire nf90_open nf90_open proc~open_nc->nf90_open proc~open_nc->nf90_inq_dimid nf90_create nf90_create proc~open_nc->nf90_create nf90_get_var nf90_get_var proc~open_nc->nf90_get_var proc~open_nc->nf90_enddef nf90_sync nf90_sync proc~open_nc->nf90_sync nf90_strerror nf90_strerror proc~nchandle_error->nf90_strerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~initstatsdump~~CalledByGraph proc~initstatsdump initstatsdump program~dalesurban DALESURBAN program~dalesurban->proc~initstatsdump Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code initstatsdump Source Code subroutine initstatsdump use modmpi , only : my_real , mpierr , comm3d , mpi_logical , mpi_integer , mpi_character , cmyid use modglobal , only : imax , jmax , kmax , cexpnr , ifnamopt , fname_options , kb , ke , ladaptive , btime ,& nsv , lslicedump , lxytdump use modstat_nc , only : open_nc , define_nc , ncinfo , writestat_dims_nc use modfields , only : ncstaty , ncstatyt , ncstattke , ncstatxy , ncstatslice , ncstatxyt , ncstatt implicit none integer :: ierr namelist / NAMSTATSDUMP / & lydump , tsample , klow , khigh , tstatsdump , lytdump , ltkedump , lxydump , lxytdump , ltdump allocate ( ncstaty ( nstaty , 4 )) allocate ( ncstatyt ( nstatyt , 4 )) allocate ( ncstattke ( nstattke , 4 )) allocate ( ncstatxy ( nstatxy , 4 )) allocate ( ncstatslice ( nstatslice , 4 )) allocate ( ncstatxyt ( nstatxyt , 4 )) allocate ( ncstatt ( nstatt , 4 )) klow = kb khigh = ke if ( myid == 0 ) then open ( ifnamopt , file = fname_options , status = 'old' , iostat = ierr ) read ( ifnamopt , NAMSTATSDUMP , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions NAMSTATSDUMP' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif write ( 6 , NAMSTATSDUMP ) close ( ifnamopt ) end if call MPI_BCAST ( klow , 1 , MPI_INTEGER , 0 , comm3d , ierr ) !have to do this? just want nc for first CPU call MPI_BCAST ( khigh , 1 , MPI_INTEGER , 0 , comm3d , ierr ) call MPI_BCAST ( nstatt , 1 , MPI_INTEGER , 0 , comm3d , ierr ) ! call MPI_BCAST(nstaty      ,1,MPI_INTEGER,0,comm3d,ierr) call MPI_BCAST ( ncstatyt , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( ncstaty , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( ncstattke , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( ncstatxy , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( ncstatxyt , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( ncstatt , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( ltdump , 1 , MPI_LOGICAL , 0 , comm3d , ierr ) !> Generate y-averaged NetCDF: ydump.xxx.nc if ( lydump ) then yname ( 7 : 9 ) = cexpnr call ncinfo ( tncstaty ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) call ncinfo ( ncstaty ( 1 ,:), 'uy' , 'Streamwise velocity' , 'm/s' , 'm0tt' ) call ncinfo ( ncstaty ( 2 ,:), 'vy' , 'Spanwise velocity' , 'm/s' , 't0tt' ) call ncinfo ( ncstaty ( 3 ,:), 'wy' , 'Vertical velocity' , 'm/s' , 't0mt' ) call ncinfo ( ncstaty ( 4 ,:), 'thly' , 'Temperature' , 'K' , 't0tt' ) call ncinfo ( ncstaty ( 5 ,:), 'qty' , 'Moisture' , 'kg/kg' , 't0tt' ) call ncinfo ( ncstaty ( 6 ,:), 'sca1y' , 'Scalar field 1' , 'kg/m&#94;3' , 't0tt' ) call ncinfo ( ncstaty ( 7 ,:), 'sca2y' , 'Scalar field 2' , 'kg/m&#94;3' , 't0tt' ) call ncinfo ( ncstaty ( 8 ,:), 'sca3y' , 'Scalar field 3' , 'kg/m&#94;3' , 't0tt' ) call ncinfo ( ncstaty ( 9 ,:), 'upwpy' , 'Turbulent mom. flux' , 'm&#94;2/s&#94;2' , 'm0mt' ) call ncinfo ( ncstaty ( 10 ,:), 'wpthlpy' , 'Turbulent heat flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstaty ( 11 ,:), 'usgsy' , 'SGS mom. flux' , 'm&#94;2/s&#94;2' , 'm0mt' ) call ncinfo ( ncstaty ( 12 ,:), 'thlsgsy' , 'SGS heat flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstaty ( 13 ,:), 'uwyik' , 'Advective mom. flux' , 'm&#94;2/s&#94;2' , 'm0mt' ) call ncinfo ( ncstaty ( 14 ,:), 'wthlyk' , 'Advective heat flux' , 'K m/s' , 't0mt' ) if ( myid == 0 ) then call open_nc ( yname , ncidy , nrecy , n1 = imax , n3 = khigh - klow + 1 ) if ( nrecy == 0 ) then call define_nc ( ncidy , 1 , tncstaty ) call writestat_dims_nc ( ncidy ) end if call define_nc ( ncidy , nstaty , ncstaty ) endif !myid==0 endif !> Generate time and y averaged NetCDF: ytdump.xxx.nc if ( lytdump ) then ytname ( 8 : 10 ) = cexpnr call ncinfo ( tncstatyt ( 1 ,:), 'time' , 'Sampling time' , 's' , 'time' ) call ncinfo ( ncstatyt ( 1 ,:), 'uyt' , 'Streamwise velocity' , 'm/s' , 'm0tt' ) call ncinfo ( ncstatyt ( 2 ,:), 'vyt' , 'Spanwise velocity' , 'm/s' , 't0tt' ) call ncinfo ( ncstatyt ( 3 ,:), 'wyt' , 'Vertical velocity' , 'm/s' , 't0mt' ) call ncinfo ( ncstatyt ( 4 ,:), 'thlyt' , 'Temperature' , 'K' , 't0tt' ) call ncinfo ( ncstatyt ( 5 ,:), 'qtyt' , 'Moisture' , 'kg/kg' , 't0tt' ) call ncinfo ( ncstatyt ( 6 ,:), 'sca1yt' , 'Scalar field 1' , 'kg/m&#94;3' , 't0tt' ) call ncinfo ( ncstatyt ( 7 ,:), 'sca2yt' , 'Scalar field 2' , 'kg/m&#94;3' , 't0tt' ) call ncinfo ( ncstatyt ( 8 ,:), 'sca3yt' , 'Scalar field 3' , 'kg/m&#94;3' , 't0tt' ) call ncinfo ( ncstatyt ( 9 ,:), 'upwpyt' , 'Turbulent mom. flux' , 'm&#94;2/s&#94;2' , 'm0mt' ) call ncinfo ( ncstatyt ( 10 ,:), 'wpthlpyt' , 'Turbulent heat flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 11 ,:), 'wpqtpyt' , 'Turbulent moisture flux' , 'kg/kg m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 12 ,:), 'wpsca1tpyt' , 'Turbulent scalar flux' , 'M m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 13 ,:), 'wpsca2tpyt' , 'Turbulent scalar flux' , 'M m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 14 ,:), 'wpsca3tpyt' , 'Turbulent scalar flux' , 'M m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 15 ,:), 'uwyt' , 'Kinematic mom. flux' , 'm&#94;2/s&#94;2' , 'm0mt' ) call ncinfo ( ncstatyt ( 16 ,:), 'wthlyt' , 'Kinematic heat flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 17 ,:), 'wqtyt' , 'Kinematic moisture flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 18 ,:), 'wsca1yt' , 'Kinematic scalar flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 19 ,:), 'wsca2yt' , 'Kinematic scalar flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 20 ,:), 'wsca3yt' , 'Kinematic scalar flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 21 ,:), 'upupyt' , 'mom. variance' , 'm&#94;2/s&#94;2' , 'm0tt' ) call ncinfo ( ncstatyt ( 22 ,:), 'wpwpyt' , 'mom. variance' , 'm&#94;2/s&#94;2' , 't0mt' ) call ncinfo ( ncstatyt ( 23 ,:), 'thlpthlpyt' , 'temp. variance' , 'K&#94;2' , 't0tt' ) call ncinfo ( ncstatyt ( 24 ,:), 'qtpqtpyt' , 'moisture. variance' , 'kg&#94;2/kg&#94;2' , 't0tt' ) call ncinfo ( ncstatyt ( 25 ,:), 'sca1tpsca1pyt' , 'scalar. variance' , 'M&#94;2' , 't0tt' ) call ncinfo ( ncstatyt ( 26 ,:), 'sca2tpsca2pyt' , 'scalar. variance' , 'M&#94;2' , 't0tt' ) call ncinfo ( ncstatyt ( 27 ,:), 'sca3tpsca3pyt' , 'scalar. variance' , 'M&#94;2' , 't0tt' ) call ncinfo ( ncstatyt ( 28 ,:), 'usgsyt' , 'SGS mom. flux' , 'm&#94;2/s&#94;2' , 'm0mt' ) call ncinfo ( ncstatyt ( 29 ,:), 'wsgsyt' , 'SGS mom. flux' , 'm&#94;2/s&#94;2' , 't0mt' ) call ncinfo ( ncstatyt ( 30 ,:), 'thlsgsyt' , 'SGS heat flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 31 ,:), 'qtsgsyt' , 'SGS moisture flux' , 'kg/kg m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 32 ,:), 'sca1sgsyt' , 'SGS scalar flux' , 'M m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 33 ,:), 'sca2sgsyt' , 'SGS scalar flux' , 'M m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 34 ,:), 'sca3sgsyt' , 'SGS scalar flux' , 'M m/s' , 't0mt' ) if ( myid == 0 ) then call open_nc ( ytname , ncidyt , nrecyt , n1 = imax , n3 = khigh - klow + 1 ) if ( nrecyt == 0 ) then call define_nc ( ncidyt , 1 , tncstatyt ) call writestat_dims_nc ( ncidyt ) end if call define_nc ( ncidyt , nstatyt , ncstatyt ) endif !myid==0 endif !> Generate y and x averaged NetCDF: xydump.xxx.nc if ( lxydump ) then xyname ( 8 : 10 ) = cexpnr call ncinfo ( tncstatxy ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) call ncinfo ( ncstatxy ( 1 ,:), 'uxy' , 'Streamwise velocity' , 'm/s' , 'tt' ) call ncinfo ( ncstatxy ( 2 ,:), 'vxy' , 'Spanwise velocity' , 'm/s' , 'tt' ) call ncinfo ( ncstatxy ( 3 ,:), 'wxy' , 'Vertical velocity' , 'm/s' , 'mt' ) call ncinfo ( ncstatxy ( 4 ,:), 'thlxy' , 'Temperature' , 'K' , 'tt' ) call ncinfo ( ncstatxy ( 5 ,:), 'qtxy' , 'Moisture' , 'kg/kg' , 'tt' ) call ncinfo ( ncstatxy ( 6 ,:), 'pxy' , 'Pressure' , 'kgm/s&#94;2' , 'tt' ) call ncinfo ( ncstatxy ( 7 ,:), 'upwpxy' , 'Mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxy ( 8 ,:), 'wpthlpxy' , 'Heat flux' , 'Km/s' , 'mt' ) call ncinfo ( ncstatxy ( 9 ,:), 'vpwpxy' , 'Mom. flux' , 'Km/s' , 'mt' ) call ncinfo ( ncstatxy ( 10 ,:), 'usgsxy' , 'SGS mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxy ( 11 ,:), 'thlsgsxy' , 'SGS heat flux' , 'Km/s' , 'mt' ) call ncinfo ( ncstatxy ( 12 ,:), 'vsgsxy' , 'SGS mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxy ( 13 ,:), 'uwxyik' , 'Advective mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxy ( 14 ,:), 'wthlxy' , 'Advective heat flux' , 'K m/s' , 'mt' ) call ncinfo ( ncstatxy ( 15 ,:), 'vwxy' , 'Advective mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) if ( myid == 0 ) then call open_nc ( xyname , ncidxy , nrecxy , n3 = khigh - klow + 1 ) if ( nrecxy == 0 ) then call define_nc ( ncidxy , 1 , tncstatxy ) call writestat_dims_nc ( ncidxy ) end if call define_nc ( ncidxy , nstatxy , ncstatxy ) end if end if !> Generate time, y and x averaged NetCDF: xytdump.xxx.nc if ( lxytdump ) then xytname ( 9 : 11 ) = cexpnr call ncinfo ( tncstatxyt ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) call ncinfo ( ncstatxyt ( 1 ,:), 'uxyt' , 'Streamwise velocity' , 'm/s' , 'tt' ) call ncinfo ( ncstatxyt ( 2 ,:), 'vxyt' , 'Spanwise velocity' , 'm/s' , 'tt' ) call ncinfo ( ncstatxyt ( 3 ,:), 'wxyt' , 'Vertical velocity' , 'm/s' , 'mt' ) call ncinfo ( ncstatxyt ( 4 ,:), 'thlxyt' , 'Temperature' , 'K' , 'tt' ) call ncinfo ( ncstatxyt ( 5 ,:), 'qtxyt' , 'Moisture' , 'kg/kg' , 'tt' ) call ncinfo ( ncstatxyt ( 6 ,:), 'pxyt' , 'Pressure' , 'kgm/s&#94;2' , 'tt' ) call ncinfo ( ncstatxyt ( 7 ,:), 'upwpxyt' , 'Turbulent mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxyt ( 8 ,:), 'wpthlpxyt' , 'Turbulent heat flux' , 'K m/s' , 'mt' ) call ncinfo ( ncstatxyt ( 9 ,:), 'vpwpxyt' , 'Turbulent mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxyt ( 10 ,:), 'upvpxyt' , 'Turbulent mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxyt ( 11 ,:), 'uwxyt' , 'Kinematic mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxyt ( 12 ,:), 'wthlxyt' , 'Kinematic heat flux' , 'K m/s' , 'mt' ) call ncinfo ( ncstatxyt ( 13 ,:), 'uvxyt' , 'Kinematic mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxyt ( 14 ,:), 'vwxyt' , 'Kinematic mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxyt ( 15 ,:), 'wwxyt' , 'Kinematic mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxyt ( 16 ,:), 'usgsxyt' , 'SGS mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxyt ( 17 ,:), 'thlsgsxyt' , 'SGS heat flux' , 'K m/s' , 'mt' ) call ncinfo ( ncstatxyt ( 18 ,:), 'vsgsxyt' , 'SGS mom. flux' , 'K m/s' , 'mt' ) call ncinfo ( ncstatxyt ( 19 ,:), 'thlpthlptxy' , 'Temp. variance' , 'K&#94;2' , 'tt' ) call ncinfo ( ncstatxyt ( 20 ,:), 'upuptxyc' , 'u variance' , 'm&#94;2/s&#94;2' , 'tt' ) call ncinfo ( ncstatxyt ( 21 ,:), 'vpvptxyc' , 'v variance' , 'm&#94;2/s&#94;2' , 'tt' ) call ncinfo ( ncstatxyt ( 22 ,:), 'wpwptxyc' , 'w variance' , 'm&#94;2/s&#94;2' , 'tt' ) call ncinfo ( ncstatxyt ( 23 ,:), 'tketxyc' , 'tke' , 'm&#94;2/s&#94;2' , 'tt' ) if ( myid == 0 ) then call open_nc ( xytname , ncidxyt , nrecxyt , n3 = khigh - klow + 1 ) if ( nrecxyt == 0 ) then call define_nc ( ncidxyt , 1 , tncstatxyt ) call writestat_dims_nc ( ncidxyt ) end if call define_nc ( ncidxyt , nstatxyt , ncstatxyt ) end if end if !> Generate time averaged NetCDF: tdump.xxx.nc if ( ltdump ) then tname ( 7 : 9 ) = cmyid tname ( 11 : 13 ) = cexpnr call ncinfo ( tncstatt ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) call ncinfo ( ncstatt ( 1 ,:), 'ut' , 'Streamwise velocity' , 'm/s' , 'mttt' ) call ncinfo ( ncstatt ( 2 ,:), 'vt' , 'Spanwise velocity' , 'm/s' , 'tmtt' ) call ncinfo ( ncstatt ( 3 ,:), 'wt' , 'Vertical velocity' , 'm/s' , 'ttmt' ) call ncinfo ( ncstatt ( 4 ,:), 'thlt' , 'Temperature' , 'K' , 'tttt' ) call ncinfo ( ncstatt ( 5 ,:), 'qtt' , 'Moisture' , 'kg/kg' , 'tttt' ) call ncinfo ( ncstatt ( 6 ,:), 'pt' , 'Pressure' , 'kgm/s&#94;2' , 'tttt' ) call ncinfo ( ncstatt ( 7 ,:), 'sca1t' , 'Concentration field 1' , 'g/m&#94;3' , 'tttt' ) call ncinfo ( ncstatt ( 8 ,:), 'sca2t' , 'Concentration field 2' , 'g/m&#94;3' , 'tttt' ) call ncinfo ( ncstatt ( 9 ,:), 'sca3t' , 'Concentration field 3' , 'g/m&#94;3' , 'tttt' ) call ncinfo ( ncstatt ( 10 ,:), 'sca4t' , 'Concentration field 4' , 'g/m&#94;3' , 'tttt' ) call ncinfo ( ncstatt ( 11 ,:), 'PSS' , 'PSS defect' , 'gm/s' , 'tttt' ) call ncinfo ( ncstatt ( 12 ,:), 'upwpt' , 'Turbulent momentum flux' , 'm&#94;2/s&#94;2' , 'mtmt' ) call ncinfo ( ncstatt ( 13 ,:), 'vpwpt' , 'Turbulent momentum flux' , 'm&#94;2/s&#94;2' , 'tmmt' ) call ncinfo ( ncstatt ( 14 ,:), 'upvpt' , 'Turbulent momentum flux' , 'm&#94;2/s&#94;2' , 'mmtt' ) call ncinfo ( ncstatt ( 15 ,:), 'wpthlpt' , 'Turbulent heat flux' , 'K m/s' , 'ttmt' ) call ncinfo ( ncstatt ( 16 ,:), 'wpsca1pt' , 'Turbulent flux 1' , 'gm/s' , 'ttmt' ) call ncinfo ( ncstatt ( 17 ,:), 'wpsca2pt' , 'Turbulent flux 2' , 'gm/s' , 'ttmt' ) call ncinfo ( ncstatt ( 18 ,:), 'wpsca3pt' , 'Turbulent flux 3' , 'gm/s' , 'ttmt' ) call ncinfo ( ncstatt ( 19 ,:), 'wpsca4pt' , 'Turbulent flux 4' , 'gm/s' , 'ttmt' ) call ncinfo ( ncstatt ( 20 ,:), 'thlpthlpt' , 'Temperature variance' , 'K&#94;2' , 'tttt' ) call ncinfo ( ncstatt ( 21 ,:), 'upuptc' , 'u variance' , 'm&#94;2/s&#94;2' , 'tttt' ) call ncinfo ( ncstatt ( 22 ,:), 'vpvptc' , 'v variance' , 'm&#94;2/s&#94;2' , 'tttt' ) call ncinfo ( ncstatt ( 23 ,:), 'wpwptc' , 'w variance' , 'm&#94;2/s&#94;2' , 'tttt' ) call ncinfo ( ncstatt ( 24 ,:), 'tketc' , 'TKE' , 'm&#94;2/s&#94;2' , 'tttt' ) call ncinfo ( ncstatt ( 25 ,:), 'sca1psca1pt' , 'Concentration variance 1' , 'g&#94;2/m&#94;6' , 'tttt' ) call ncinfo ( ncstatt ( 26 ,:), 'sca2psca2pt' , 'Concentration variance 2' , 'g&#94;2/m&#94;6' , 'tttt' ) call ncinfo ( ncstatt ( 27 ,:), 'sca3psca3pt' , 'Concentration variance 3' , 'g&#94;2/m&#94;6' , 'tttt' ) call ncinfo ( ncstatt ( 28 ,:), 'sca4psca4pt' , 'Concentration variance 4' , 'g&#94;2/m&#94;6' , 'tttt' ) call ncinfo ( ncstatt ( 29 ,:), 'sv1sgs' , 'SGS flux 1' , 'gm/s' , 'ttmt' ) call ncinfo ( ncstatt ( 30 ,:), 'sv2sgs' , 'SGS flux 2' , 'gm/s' , 'ttmt' ) call ncinfo ( ncstatt ( 31 ,:), 'sv3sgs' , 'SGS flux 3' , 'gm/s' , 'ttmt' ) call ncinfo ( ncstatt ( 32 ,:), 'sv4sgs' , 'SGS flux 4' , 'gm/s' , 'ttmt' ) ! call ncinfo(ncstatt(33,:),'sca1t_max','Max concentration field 1'   ,'g/m&#94;3'  ,'tttt'  ) ! call ncinfo(ncstatt(34,:),'sca2t_max','Max concentration field 2'   ,'g/m&#94;3'  ,'tttt'  ) ! call ncinfo(ncstatt(35,:),'sca3t_max','Max concentration field 3'   ,'g/m&#94;3'  ,'tttt'  ) ! call ncinfo(ncstatt(36,:),'sca4t_max','Max concentration field 4'   ,'g/m&#94;3'  ,'tttt'  ) !      if (myid==0) then call open_nc ( tname , ncidt , nrect , n1 = imax , n2 = jmax , n3 = khigh - klow + 1 ) if ( nrect == 0 ) then call define_nc ( ncidt , 1 , tncstatt ) call writestat_dims_nc ( ncidt ) end if call define_nc ( ncidt , nstatt , ncstatt ) !      end if end if !> Generate time, y and x averaged NetCDF for tke budget: tkedump.xxx.nc if ( ltkedump ) then tkename ( 9 : 11 ) = cexpnr call ncinfo ( tncstattke ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) call ncinfo ( ncstattke ( 1 ,:), 'p_b' , 'p_bant production or consumption term' , 'm&#94;2/s&#94;3' , 'tt' ) call ncinfo ( ncstattke ( 2 ,:), 't_p' , 'total viscous transport (?)' , 'm&#94;2/s&#94;3' , 'tt' ) call ncinfo ( ncstattke ( 3 ,:), 'adv' , 'Advection by mean wind' , 'm&#94;2/s&#94;3' , 'tt' ) call ncinfo ( ncstattke ( 4 ,:), 't_t' , 'Total turb???' , 'm&#94;2/s&#94;3' , 'tt' ) call ncinfo ( ncstattke ( 5 ,:), 't_sgs' , 'total SGS  term' , 'm&#94;2/s&#94;3' , 'tt' ) call ncinfo ( ncstattke ( 6 ,:), 'p_t' , 'Shear production term' , 'm&#94;2/s&#94;3' , 'tt' ) call ncinfo ( ncstattke ( 7 ,:), 't_v' , 'Resolved viscous dissipation term' , 'm&#94;2/s&#94;3' , 'tt' ) call ncinfo ( ncstattke ( 8 ,:), 'd_sgs' , 'SGS dissipation term' , 'm&#94;2/s&#94;3' , 'tt' ) if ( myid == 0 ) then call open_nc ( tkename , ncidtke , nrectke , n3 = khigh - klow + 1 ) if ( nrectke == 0 ) then call define_nc ( ncidtke , 1 , tncstattke ) call writestat_dims_nc ( ncidtke ) end if call define_nc ( ncidtke , nstattke , ncstattke ) endif !myid==0 endif !> Generate sliced NetCDF: slicedump.xxx.xxx.nc if ( lslicedump ) then slicename ( 11 : 13 ) = cmyid slicename ( 15 : 17 ) = cexpnr call ncinfo ( tncstatslice ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) call ncinfo ( ncstatslice ( 1 ,:), 'sca_kb1' , 'Scalar field at kb' , '-' , 'tt0t' ) call ncinfo ( ncstatslice ( 2 ,:), 'sca_ave1' , 'Averaged scalar field over canyon' , '-' , 'tt0t' ) call ncinfo ( ncstatslice ( 3 ,:), 'sca_kb2' , 'Scalar field at kb+1' , '-' , 'tt0t' ) call ncinfo ( ncstatslice ( 4 ,:), 'sca_ave2' , 'Averaged scalar field over canyon' , '-' , 'tt0t' ) call ncinfo ( ncstatslice ( 5 ,:), 'sca_kb3' , 'Scalar field at kb+1' , '-' , 'tt0t' ) call ncinfo ( ncstatslice ( 6 ,:), 'sca_ave3' , 'Averaged scalar field over canyon' , '-' , 'tt0t' ) call ncinfo ( ncstatslice ( 7 ,:), 'u_kb' , 'Streamwise velocity at kb' , '-' , 'mt0t' ) call ncinfo ( ncstatslice ( 8 ,:), 'v_kb' , 'Spanwise velocity at kb' , '-' , 'tm0t' ) call open_nc ( slicename , ncidslice , nrecslice , n1 = imax , n2 = jmax ) if ( nrecslice == 0 ) then call define_nc ( ncidslice , 1 , tncstatslice ) call writestat_dims_nc ( ncidslice ) end if call define_nc ( ncidslice , nstatslice , ncstatslice ) end if !> Set times to zero so works for warm starts... could have issues with warmstarts here... tsamplep = 0. tstatsdumpp = 0. end subroutine initstatsdump","tags":"","loc":"proc/initstatsdump.html"},{"title":"statsdump – uDALES","text":"public subroutine statsdump() Uses modfields modglobal modstat_nc modmpi modsurfdata modsubgrid modstatistics proc~~statsdump~~UsesGraph proc~statsdump statsdump module~modsurfdata modsurfdata proc~statsdump->module~modsurfdata module~modmpi modmpi proc~statsdump->module~modmpi module~modsubgrid modsubgrid proc~statsdump->module~modsubgrid module~modstatistics modstatistics proc~statsdump->module~modstatistics module~modstat_nc modstat_nc proc~statsdump->module~modstat_nc module~modfields modfields proc~statsdump->module~modfields module~modglobal modglobal proc~statsdump->module~modglobal mpi mpi module~modmpi->mpi module~modsubgriddata modsubgriddata module~modsubgrid->module~modsubgriddata module~modstatistics->module~modmpi module~modstatistics->module~modglobal module~modstat_nc->module~modmpi netcdf netcdf module~modstat_nc->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~statsdump~~CallsGraph proc~statsdump statsdump proc~writestat_1d_nc writestat_1D_nc proc~statsdump->proc~writestat_1d_nc proc~tkestatsdump tkestatsdump proc~statsdump->proc~tkestatsdump interface~writestat_nc writestat_nc proc~statsdump->interface~writestat_nc ekm ekm proc~statsdump->ekm ekh ekh proc~statsdump->ekh nf90_put_var nf90_put_var proc~writestat_1d_nc->nf90_put_var nf90_inq_varid nf90_inq_varid proc~writestat_1d_nc->nf90_inq_varid nf90_sync nf90_sync proc~writestat_1d_nc->nf90_sync proc~excjs excjs proc~tkestatsdump->proc~excjs interface~writestat_nc->proc~writestat_1d_nc proc~writestat_2d_nc writestat_2D_nc interface~writestat_nc->proc~writestat_2d_nc proc~writestat_time_nc writestat_time_nc interface~writestat_nc->proc~writestat_time_nc proc~writestat_3d_nc writestat_3D_nc interface~writestat_nc->proc~writestat_3d_nc proc~writestat_3d_short_nc writestat_3D_short_nc interface~writestat_nc->proc~writestat_3d_short_nc proc~writestat_2d_nc->nf90_put_var proc~writestat_2d_nc->nf90_inq_varid proc~writestat_2d_nc->nf90_sync proc~writestat_time_nc->nf90_put_var proc~writestat_time_nc->nf90_inq_varid proc~writestat_time_nc->nf90_sync proc~writestat_3d_nc->nf90_put_var proc~writestat_3d_nc->nf90_inq_varid proc~writestat_3d_nc->nf90_sync mpi_sendrecv mpi_sendrecv proc~excjs->mpi_sendrecv proc~writestat_3d_short_nc->nf90_put_var proc~writestat_3d_short_nc->nf90_inq_varid proc~writestat_3d_short_nc->nf90_sync Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~statsdump~~CalledByGraph proc~statsdump statsdump program~dalesurban DALESURBAN program~dalesurban->proc~statsdump Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code statsdump Source Code subroutine statsdump use modfields , only : um , up , vm , wm , svm , qtm , thlm , pres0 , ncstaty , ncstatxy , ncstatyt , ncstattke ,& ncstatslice , t_t , t_v , t_p , t_sgs , d_sgs , p_b , p_t , adv ,& IIc , IIu , IIv , IIw , IIuw , IIvw , IIct , IIwt , IIut , IIvt , IIuwt , IIuv ,& IIcs , IIws , IIus , IIvs , IIuws , IIvws , IIuvs ,& slice , slice2 , slice3 , slice4 , slice5 , slice6 , slice7 , slice8 ,& vyt , uyt , wyt , thlyt , qtyt ,& sca1yt , sca2yt , sca3yt , thlsgsyt , qtsgsyt , sv1sgsyt , sv2sgsyt , sv3sgsyt , usgsyt , wsgsyt ,& usgsxyt , thlsgsxyt , vsgsxyt , uwtik , vwtjk , uvtij , utik , wtik , wtjk , vtjk , utij , vtij ,& wthltk , wqttk , thlthlt , qtqtt , sv1sv1t , sv2sv2t , sv3sv3t , sv4sv4t , wmt , thltk , qttk , thlt , uxyt , vxyt , wxyt , thlxyt ,& ncstatxyt , qtxyt , pxyt , ncstatt , uutc , vvtc , wwtc , utc , vtc , wtc ,& umt , vmt , sv1t , sv2t , sv3t , sv4t , sv1tk , sv2tk , sv3tk , sv4tk , wsv1tk , wsv2tk , wsv3tk , wsv4tk ,& sv1sgst , sv2sgst , sv3sgst , sv4sgst , qtt , pt , PSSt !,sv1max,sv2max,sv3max,sv4max use modglobal , only : ib , ie , ih , ihc , xf , xh , jb , je , jhc , jgb , jge , dy , dyi , jh , ke , kb , kh , khc , rk3step ,& timee , cexpnr , tsample , tstatsdump , jtot , imax , jmax , dzf ,& ltempeq , zh , dxf , dzf , dzh2i , lprofforc , lscasrcl ,& lslicedump , lchem , dzhi , dzfi , dzhiq , dxhi , lmoist , nsv ,& k1 , JNO2 , lchem !  use modsubgriddata,   only : ekm,sbshr use modstat_nc , only : writestat_nc , writestat_1D_nc use modmpi , only : myid , cmyid , my_real , mpi_sum , avey_ibm , mpierr ,& comm3d , avexy_ibm , nprocs use modsurfdata , only : thls use modsubgrid , only : ekh , ekm use modstatistics , only : genstats , tkestats implicit none !> Create fields to be used in statistics ! interpolated fields !  real, dimension(ib:ie,jb:je,kb:ke)     :: umc !  real, dimension(ib:ie,jb:je,kb:ke)     :: vmc !  real, dimension(ib:ie,jb:je,kb:ke)     :: wmc ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: thlk ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: qtk ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: uik ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: wik ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: vjk ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: wjk ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: uij ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: vij ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: uc ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: vc ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: wc real , allocatable :: thlk (:,:,:) real , allocatable :: qtk (:,:,:) real , allocatable :: uik (:,:,:) real , allocatable :: wik (:,:,:) real , allocatable :: vjk (:,:,:) real , allocatable :: wjk (:,:,:) real , allocatable :: uij (:,:,:) real , allocatable :: vij (:,:,:) real , allocatable :: uc (:,:,:) real , allocatable :: vc (:,:,:) real , allocatable :: wc (:,:,:) ! SGS fluxes ! real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh)     :: thlsgs ! real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh)     :: qtsgs ! real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh)     :: usgs ! real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh)     :: vsgs ! real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh)     :: wsgs real , allocatable :: thlsgs (:,:,:) real , allocatable :: qtsgs (:,:,:) real , allocatable :: usgs (:,:,:) real , allocatable :: vsgs (:,:,:) real , allocatable :: wsgs (:,:,:) ! t-averaged fields ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: sv1k ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: sv2k ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: sv3k ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: sv4k ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: wpsv1p ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: wpsv2p ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: wpsv3p ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: wpsv4p ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: sv1sgs ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: sv2sgs ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: sv3sgs ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: sv4sgs real , allocatable :: sv1k (:,:,:) real , allocatable :: sv2k (:,:,:) real , allocatable :: sv3k (:,:,:) real , allocatable :: sv4k (:,:,:) real , allocatable :: sv1sgs (:,:,:) real , allocatable :: sv2sgs (:,:,:) real , allocatable :: sv3sgs (:,:,:) real , allocatable :: sv4sgs (:,:,:) real , allocatable :: wpsv1p (:,:,:) real , allocatable :: wpsv2p (:,:,:) real , allocatable :: wpsv3p (:,:,:) real , allocatable :: wpsv4p (:,:,:) real , allocatable :: sv1psv1pt (:,:,:) real , allocatable :: sv2psv2pt (:,:,:) real , allocatable :: sv3psv3pt (:,:,:) real , allocatable :: sv4psv4pt (:,:,:) real , allocatable :: PSS (:,:,:) ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: upwptik ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: vpwptjk ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: upvptij ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: wpthlptk ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: thlpthlpt ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: upuptc ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: vpvptc ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: wpwptc ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: tketc real , allocatable :: upwptik (:,:,:) real , allocatable :: vpwptjk (:,:,:) real , allocatable :: upvptij (:,:,:) real , allocatable :: wpthlptk (:,:,:) real , allocatable :: thlpthlpt (:,:,:) real , allocatable :: upuptc (:,:,:) real , allocatable :: vpvptc (:,:,:) real , allocatable :: wpwptc (:,:,:) real , allocatable :: tketc (:,:,:) ! y-averaged fields real , dimension ( ib : ie , kb : ke ) :: uy real , dimension ( ib : ie , kb : ke ) :: vy real , dimension ( ib : ie , kb : ke ) :: wy real , dimension ( ib : ie , kb : ke ) :: thly real , dimension ( ib : ie , kb : ke ) :: qty real , dimension ( ib : ie , kb : ke ) :: sca1y real , dimension ( ib : ie , kb : ke ) :: sca2y real , dimension ( ib : ie , kb : ke ) :: sca3y real , dimension ( ib : ie , kb : ke ) :: usgsy real , dimension ( ib : ie , kb : ke ) :: wsgsy real , dimension ( ib : ie , kb : ke ) :: thlsgsy real , dimension ( ib : ie , kb : ke ) :: qtsgsy real , dimension ( ib : ie , kb : ke ) :: sv1sgsy real , dimension ( ib : ie , kb : ke ) :: sv2sgsy real , dimension ( ib : ie , kb : ke ) :: sv3sgsy real , dimension ( ib : ie , kb : ke ) :: uwyik real , dimension ( ib : ie , kb : ke ) :: wthlyk real , dimension ( ib : ie , kb : ke ) :: wqtyk ! real, dimension(ib:ie,kb:ke)                 :: wsv1yk ! real, dimension(ib:ie,kb:ke)                 :: wsv2yk real , dimension ( ib : ie , kb : ke ) :: wyik real , dimension ( ib : ie , kb : ke ) :: uyik real , dimension ( ib : ie , kb : ke ) :: thlyk real , dimension ( ib : ie , kb : ke ) :: upwpyik real , dimension ( ib : ie , kb : ke ) :: wpthlpyk ! ty-averaged fluxes real , dimension ( ib : ie , kb : ke ) :: upwptyik real , dimension ( ib : ie , kb : ke ) :: wpthlptyk real , dimension ( ib : ie , kb : ke ) :: wpqtptyk real , dimension ( ib : ie , kb : ke ) :: wpsv1ptyk real , dimension ( ib : ie , kb : ke ) :: wpsv2ptyk real , dimension ( ib : ie , kb : ke ) :: wpsv3ptyk real , dimension ( ib : ie , kb : ke ) :: upuptyc real , dimension ( ib : ie , kb : ke ) :: vpvptyc real , dimension ( ib : ie , kb : ke ) :: wpwptyc real , dimension ( ib : ie , kb : ke ) :: qtpqtpty real , dimension ( ib : ie , kb : ke ) :: thlpthlpty real , dimension ( ib : ie , kb : ke ) :: sv1psv1pty real , dimension ( ib : ie , kb : ke ) :: sv2psv2pty real , dimension ( ib : ie , kb : ke ) :: sv3psv3pty real , dimension ( ib : ie , kb : ke ) :: uwtyik real , dimension ( ib : ie , kb : ke ) :: wthltyk real , dimension ( ib : ie , kb : ke ) :: wqttyk real , dimension ( ib : ie , kb : ke ) :: wsv1tyk real , dimension ( ib : ie , kb : ke ) :: wsv2tyk real , dimension ( ib : ie , kb : ke ) :: wsv3tyk ! xy-averaged fields real , dimension ( kb : ke + kh ) :: uxy real , dimension ( kb : ke + kh ) :: vxy real , dimension ( kb : ke + kh ) :: wxy real , dimension ( kb : ke + kh ) :: thlxy real , dimension ( kb : ke + kh ) :: qtxy real , dimension ( kb : ke + kh ) :: pxy real , dimension ( kb : ke + kh ) :: usgsxy real , dimension ( kb : ke + kh ) :: thlsgsxy real , dimension ( kb : ke + kh ) :: vsgsxy real , dimension ( kb : ke + kh ) :: sca1xy real , dimension ( kb : ke + kh ) :: uwxyik real , dimension ( kb : ke + kh ) :: vwxyjk real , dimension ( kb : ke + kh ) :: wthlxyk real , dimension ( kb : ke + kh ) :: thlxyk real , dimension ( kb : ke + kh ) :: wxyik real , dimension ( kb : ke + kh ) :: uxyik real , dimension ( kb : ke + kh ) :: vxyjk real , dimension ( kb : ke + kh ) :: wxyjk real , dimension ( kb : ke + kh ) :: upwpxyik real , dimension ( kb : ke + kh ) :: wpthlpxyk real , dimension ( kb : ke + kh ) :: vpwpxyjk ! txy-averaged fields real , dimension ( kb : ke + kh ) :: upwptxyik real , dimension ( kb : ke + kh ) :: wpthlptxyk real , dimension ( kb : ke + kh ) :: thlpthlptxy real , dimension ( kb : ke + kh ) :: upuptxyc real , dimension ( kb : ke + kh ) :: vpvptxyc real , dimension ( kb : ke + kh ) :: wpwptxyc real , dimension ( kb : ke + kh ) :: tketxyc real , dimension ( kb : ke + kh ) :: vpwptxyjk real , dimension ( kb : ke + kh ) :: upvptxyij real , dimension ( kb : ke + kh ) :: uwtxyik real , dimension ( kb : ke + kh ) :: wthltxyk real , dimension ( kb : ke + kh ) :: vwtxyjk real , dimension ( kb : ke + kh ) :: wwtxyk real , dimension ( kb : ke + kh ) :: uvtxyij real , allocatable :: field (:,:), varsy (:,:,:), varsyt (:,:,:), varstke (:,:), varsxy (:,:),& varslice (:,:,:), varsxyt (:,:), varst (:,:,:,:) real :: tstatsdumppi , emom integer :: i , j , k , ip , im , jp , jm , kp , km integer :: writecounter = 1 integer :: reclength allocate ( thlk ( ib : ie , jb : je , kb : ke + kh )) allocate ( qtk ( ib : ie , jb : je , kb : ke + kh )) allocate ( uik ( ib : ie , jb : je , kb : ke + kh )) allocate ( wik ( ib : ie , jb : je , kb : ke + kh )) allocate ( vjk ( ib : ie , jb : je , kb : ke + kh )) allocate ( wjk ( ib : ie , jb : je , kb : ke + kh )) allocate ( uij ( ib : ie , jb : je , kb : ke + kh )) allocate ( vij ( ib : ie , jb : je , kb : ke + kh )) allocate ( uc ( ib : ie , jb : je , kb : ke + kh )) allocate ( vc ( ib : ie , jb : je , kb : ke + kh )) allocate ( wc ( ib : ie , jb : je , kb : ke + kh )) allocate ( thlsgs ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( qtsgs ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( usgs ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( vsgs ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( wsgs ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( sv1k ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv2k ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv3k ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv4k ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv1sgs ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv2sgs ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv3sgs ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv4sgs ( ib : ie , jb : je , kb : ke + kh )) allocate ( wpsv1p ( ib : ie , jb : je , kb : ke + kh )) allocate ( wpsv2p ( ib : ie , jb : je , kb : ke + kh )) allocate ( wpsv3p ( ib : ie , jb : je , kb : ke + kh )) allocate ( wpsv4p ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv1psv1pt ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv2psv2pt ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv3psv3pt ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv4psv4pt ( ib : ie , jb : je , kb : ke + kh )) allocate ( PSS ( ib : ie , jb : je , kb : ke + kh )) allocate ( upwptik ( ib : ie , jb : je , kb : ke + kh )) allocate ( vpwptjk ( ib : ie , jb : je , kb : ke + kh )) allocate ( upvptij ( ib : ie , jb : je , kb : ke + kh )) allocate ( wpthlptk ( ib : ie , jb : je , kb : ke + kh )) allocate ( thlpthlpt ( ib : ie , jb : je , kb : ke + kh )) allocate ( upuptc ( ib : ie , jb : je , kb : ke + kh )) allocate ( vpvptc ( ib : ie , jb : je , kb : ke + kh )) allocate ( wpwptc ( ib : ie , jb : je , kb : ke + kh )) allocate ( tketc ( ib : ie , jb : je , kb : ke + kh )) thlk = 0. ; qtk = 0. ; uik = 0. ; wik = 0. ; vjk = 0. ; wjk = 0. ; uij = 0. ; vij = 0. ; uc = 0. ; vc = 0. ; wc = 0. ; thlsgs = 0. ; qtsgs = 0. ; usgs = 0. ; vsgs = 0. ; wsgs = 0. ; sv1k = 0. ; sv2k = 0. ; sv3k = 0. ; sv4k = 0. ; sv1sgs = 0. ; sv2sgs = 0. ; sv3sgs = 0. ; sv4sgs = 0. ; wpsv1p = 0. ; wpsv2p = 0. wpsv3p = 0. ; wpsv4p = 0. ; sv1psv1pt = 0. ; sv2psv2pt = 0. ; sv3psv3pt = 0. ; sv4psv4pt = 0. ; PSS = 0. ; upwptik = 0. ; vpwptjk = 0. ; upvptij = 0. ; wpthlptk = 0. ; thlpthlpt = 0. ; upuptc = 0. ; vpvptc = 0. ; wpwptc = 0. ; tketc = 0. upwptyik = 0. ; wpthlptyk = 0. ; wpqtptyk = 0. ; wpsv1ptyk = 0. ; wpsv2ptyk = 0. ; wpsv3ptyk = 0. ; uwtyik = 0. ; wthltyk = 0. ; wqttyk = 0. ; wsv1tyk = 0. ; wsv2tyk = 0. ; wsv3tyk = 0. ; upuptyc = 0. ; wpwptyc = 0. ; thlpthlpty = 0. qtpqtpty = 0. ; sv1psv1pty = 0. ; sv2psv2pty = 0. ; sv3psv3pty = 0. if (. not . rk3step == 3 ) return if ( tsamplep > tsample ) then if ( lytdump . or . lydump . or . lxydump . or . lxytdump . or . ltdump ) then ! wpthlptyk=0.;wpqtptyk=0.;wpsv1ptyk=0.;wpsv2ptyk=0. tstatsdumppi = 1. / tstatsdumpp !> Perform required interpolations for flux calculations !  tg3315 for non-equidistant x and z-grids this needs to change do k = kb , ke + kh do j = jb , je do i = ib , ie uik ( i , j , k ) = 0.5 * dzhi ( k ) * ( um ( i , j , k ) * dzf ( k - 1 ) + um ( i , j , k - 1 ) * dzf ( k )) wik ( i , j , k ) = 0.5 * dxhi ( i ) * ( wm ( i , j , k ) * dxf ( i - 1 ) + wm ( i - 1 , j , k ) * dxf ( i )) vjk ( i , j , k ) = 0.5 * dzhi ( k ) * ( vm ( i , j , k ) * dzf ( k - 1 ) + vm ( i , j , k - 1 ) * dzf ( k )) wjk ( i , j , k ) = 0.5 * ( wm ( i , j , k ) + wm ( i , j - 1 , k )) uij ( i , j , k ) = 0.5 * ( um ( i , j , k ) + um ( i , j - 1 , k )) vij ( i , j , k ) = 0.5 * dxhi ( i ) * ( vm ( i , j , k ) * dxf ( i - 1 ) + vm ( i - 1 , j , k ) * dxf ( i )) uc ( i , j , k ) = 0.5 * dxhi ( i ) * ( um ( i , j , k ) * dxf ( i - 1 ) + um ( i - 1 , j , k ) * dxf ( i )) vc ( i , j , k ) = 0.5 * ( vm ( i , j , k ) + vm ( i , j - 1 , k )) wc ( i , j , k ) = 0.5 * dzhi ( k ) * ( wm ( i , j , k ) * dzf ( k - 1 ) + wm ( i , j , k - 1 ) * dzf ( k )) ! SGS fluxes ! interps ekm to cell corner (uw) emom = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k ) * dxf ( i ) ) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k - 1 ) * dxf ( i ) ) ) * dxhi ( i ) * dzhiq ( k ) usgs ( i , j , k ) = emom * ( ( um ( i , j , k ) - um ( i , j , k - 1 )) * dzhi ( k ) & + ( wm ( i , j , k ) - wm ( i - 1 , j , k )) * dxhi ( i )) ! interps ekm to cell corner (vw) emom = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k ) ) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , j - 1 , k - 1 ) ) ) * dzhiq ( k ) vsgs ( i , j , k ) = emom * ( ( vm ( i , j , k ) - vm ( i , j , k - 1 )) * dzhi ( k ) & + ( wm ( i , j , k ) - wm ( i , j - 1 , k )) * dyi ) end do end do end do do k = kb , ke do j = jb , je do i = ib , ie wsgs ( i , j , k ) = ( ekm ( i , j , k ) * ( wm ( i , j , k + 1 ) - wm ( i , j , k )) * dzfi ( k ) & - ekm ( i , j , k - 1 ) * ( wm ( i , j , k ) - wm ( i , j , k - 1 )) * dzfi ( k - 1 ) ) * 2. & * dzhi ( k ) ! tg3315 check this end do end do end do if ( ltempeq ) then do k = kb , ke + kh do j = jb , je do i = ib , ie thlk ( i , j , k ) = 0.5 * dzhi ( k ) * ( thlm ( i , j , k ) * dzf ( k - 1 ) + thlm ( i , j , k - 1 ) * dzf ( k )) end do end do end do do k = kb , ke !> SGS fluxes thlsgs (:,:, k ) = 0.5 * ( dzf ( k - 1 ) * ekh (:,:, k ) + dzf ( k ) * ekh (:,:, k - 1 )) & * ( thlm (:,:, k ) - thlm (:,:, k - 1 )) * dzh2i ( k ) end do end if if ( lmoist ) then do k = kb , ke + kh do j = jb , je do i = ib , ie qtk ( i , j , k ) = 0.5 * dzhi ( k ) * ( qtm ( i , j , k ) * dzf ( k - 1 ) + qtm ( i , j , k - 1 ) * dzf ( k )) end do end do end do do k = kb , ke !> SGS fluxes qtsgs (:,:, k ) = 0.5 * ( dzf ( k - 1 ) * ekh (:,:, k ) + dzf ( k ) * ekh (:,:, k - 1 )) & * ( qtm (:,:, k ) - qtm (:,:, k - 1 )) * dzh2i ( k ) end do end if if ( nsv > 0 ) then do k = kb , ke do j = jb , je do i = ib , ie sv1k ( i , j , k ) = 0.5 * dzhi ( k ) * ( svm ( i , j , k , 1 ) * dzf ( k - 1 ) + svm ( i , j , k - 1 , 1 ) * dzf ( k )) end do end do end do do k = kb , ke sv1sgs ( ib : ie , jb : je , k ) = 0.5 * ( dzf ( k - 1 ) * ekh ( ib : ie , jb : je , k ) + dzf ( k ) * ekh ( ib : ie , jb : je , k - 1 )) & * ( svm ( ib : ie , jb : je , k , 1 ) - svm ( ib : ie , jb : je , k - 1 , 1 )) * dzh2i ( k ) end do end if if ( nsv > 1 ) then do k = kb , ke + kh do j = jb , je do i = ib , ie sv2k ( i , j , k ) = 0.5 * dzhi ( k ) * ( svm ( i , j , k , 2 ) * dzf ( k - 1 ) + svm ( i , j , k - 1 , 2 ) * dzf ( k )) end do end do end do do k = kb , ke sv2sgs ( ib : ie , jb : je , k ) = 0.5 * ( dzf ( k - 1 ) * ekh ( ib : ie , jb : je , k ) + dzf ( k ) * ekh ( ib : ie , jb : je , k - 1 )) & * ( svm ( ib : ie , jb : je , k , 2 ) - svm ( ib : ie , jb : je , k - 1 , 2 )) * dzh2i ( k ) end do end if if ( nsv > 2 ) then do k = kb , ke + kh do j = jb , je do i = ib , ie sv3k ( i , j , k ) = 0.5 * dzhi ( k ) * ( svm ( i , j , k , 3 ) * dzf ( k - 1 ) + svm ( i , j , k - 1 , 3 ) * dzf ( k )) end do end do end do do k = kb , ke sv3sgs ( ib : ie , jb : je , k ) = 0.5 * ( dzf ( k - 1 ) * ekh ( ib : ie , jb : je , k ) + dzf ( k ) * ekh ( ib : ie , jb : je , k - 1 )) & * ( svm ( ib : ie , jb : je , k , 3 ) - svm ( ib : ie , jb : je , k - 1 , 3 )) * dzh2i ( k ) end do end if if ( nsv > 3 ) then do k = kb , ke + kh do j = jb , je do i = ib , ie sv4k ( i , j , k ) = 0.5 * dzhi ( k ) * ( svm ( i , j , k , 4 ) * dzf ( k - 1 ) + svm ( i , j , k - 1 , 4 ) * dzf ( k )) end do end do end do do k = kb , ke sv4sgs ( ib : ie , jb : je , k ) = 0.5 * ( dzf ( k - 1 ) * ekh ( ib : ie , jb : je , k ) + dzf ( k ) * ekh ( ib : ie , jb : je , k - 1 )) & * ( svm ( ib : ie , jb : je , k , 4 ) - svm ( ib : ie , jb : je , k - 1 , 4 )) * dzh2i ( k ) end do end if if (( nsv > 2 ) . and . ( lchem . eqv . . true .)) then do k = kb , ke do j = jb , je do i = ib , ie if (( ABS ( svm ( i , j , k , 2 )) . gt . 1.e-40 ) . and . ( IIc ( i , j , k ) == 1 )) then PSS ( i , j , k ) = ( ( ( k1 * ( svm ( i , j , k , 1 ) / 3 0. ) * ( svm ( i , j , k , 3 ) / 4 8. )) / ( JNO2 * ( svm ( i , j , k , 2 ) / 4 6. )) ) - 1 ) * 100 end if end do end do end do end if !!>> CALCS FOR INST. STATS !> Note: More computationally efficient to spatially average mean quantities first & !        for time dependant stats, hence the .or.s. Assuming homogeneity in y. !> Average in y-direction if ( lydump . or . lytdump ) then uy = 0. ; vy = 0. ; wy = 0. ; uwyik = 0. ; usgsy = 0. ; wsgsy = 0. ; thly = 0. ; wthlyk = 0. ; thlsgsy = 0. qty = 0. ; wqtyk = 0. ; qtsgsy = 0. ; sca1y = 0. ; sv1sgsy = 0. ; sv2sgsy = 0. ; sca2y = 0. ; sca3y = 0. ; sv3sgsy = 0. call avey_ibm ( uy , um ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIu ( ib : ie , jb : je , kb : ke ), IIut ( ib : ie , kb : ke )) call avey_ibm ( vy , vm ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIv ( ib : ie , jb : je , kb : ke ), IIvt ( ib : ie , kb : ke )) call avey_ibm ( wy , wm ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( uwyik , uik ( ib : ie , jb : je , kb : ke ) * wik ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIuw ( ib : ie , jb : je , kb : ke ), IIuwt ( ib : ie , kb : ke )) call avey_ibm ( usgsy , usgs ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIuw ( ib : ie , jb : je , kb : ke ), IIuwt ( ib : ie , kb : ke )) call avey_ibm ( wsgsy , wsgs ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) if ( ltempeq ) then call avey_ibm ( thly , thlm ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) call avey_ibm ( wthlyk , wm ( ib : ie , jb : je , kb : ke ) * thlk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( thlsgsy , thlsgs ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) end if if ( lmoist ) then call avey_ibm ( qty , qtm ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) call avey_ibm ( wqtyk , wm ( ib : ie , jb : je , kb : ke ) * qtk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( qtsgsy , qtsgs ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) end if if ( nsv > 0 ) then call avey_ibm ( sca1y , svm ( ib : ie , jb : je , kb : ke , 1 ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) ! call avey_ibm(wsv1yk,wm(ib:ie,jb:je,kb:ke)*sv1k(ib:ie,jb:je,kb:ke),ib,ie,jb,je,kb,ke,IIw(ib:ie,jb:je,kb:ke),IIwt(ib:ie,kb:ke)) call avey_ibm ( sv1sgsy , sv1sgs ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) end if if ( nsv > 1 ) then call avey_ibm ( sca2y , svm ( ib : ie , jb : je , kb : ke , 2 ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) ! call avey_ibm(wsv2yk,wm(ib:ie,jb:je,kb:ke)*sv2k(ib:ie,jb:je,kb:ke),ib,ie,jb,je,kb,ke,IIw(ib:ie,jb:je,kb:ke),IIwt(ib:ie,kb:ke)) call avey_ibm ( sv2sgsy , sv2sgs ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) end if if ( nsv > 2 ) then call avey_ibm ( sca3y , svm ( ib : ie , jb : je , kb : ke , 3 ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) call avey_ibm ( sv3sgsy , sv3sgs ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) end if end if ! lydump .or. lytdump if ( lydump ) then uwyik = 0. ; wthlyk = 0. ; uyik = 0. ; wyik = 0. ; thlyk = 0. ; wpthlpyk = 0. call avey_ibm ( uwyik , uik ( ib : ie , jb : je , kb : ke ) * wik ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIuw ( ib : ie , jb : je , kb : ke ), IIuwt ( ib : ie , kb : ke )) call avey_ibm ( uyik , uik ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIuw ( ib : ie , jb : je , kb : ke ), IIuwt ( ib : ie , kb : ke )) call avey_ibm ( wyik , wik ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIuw ( ib : ie , jb : je , kb : ke ), IIuwt ( ib : ie , kb : ke )) if ( ltempeq ) then call avey_ibm ( wthlyk , wm ( ib : ie , jb : je , kb : ke ) * thlk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( thlyk , thlk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) end if upwpyik = uwyik - uyik * wyik if ( ltempeq ) then wpthlpyk = wthlyk - wy * thlyk where ( IIwt == 0 ) wpthlpyk = - 99 9.0 endwhere end if where ( IIuwt == 0 ) upwpyik = - 99 9.0 endwhere end if ! lydump !> tg3315 10.07.18 - in any case where averaging spatially can assume homogeneity and therefore average !  spatially first? Perhaps not due to UCL...? Would save space but goes against triple decomposition !  definition !> Average in x and y-direction if ( lxydump . or . lxytdump ) then uxy = 0. ; vxy = 0. ; wxy = 0. ; thlxy = 0. ; qtxy = 0. ; pxy = 0. ; usgsxy = 0. ; thlsgsxy = 0. ; sca1xy = 0. ; vsgsxy = 0. !> Spatial averages of mean quantities call avexy_ibm ( uxy ( kb : ke + kh ), um ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIu ( ib : ie , jb : je , kb : ke + kh ), IIus ( kb : ke + kh ),. true .) call avexy_ibm ( vxy ( kb : ke + kh ), vm ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIv ( ib : ie , jb : je , kb : ke + kh ), IIvs ( kb : ke + kh ),. true .) call avexy_ibm ( wxy ( kb : ke + kh ), wm ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. true .) if ( ltempeq ) then call avexy_ibm ( thlxy ( kb : ke + kh ), thlm ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. true .) call avexy_ibm ( thlsgsxy ( kb : ke + kh ), thlsgs ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. true .) end if if ( lmoist ) then call avexy_ibm ( qtxy ( kb : ke + kh ), qtm ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. true .) end if call avexy_ibm ( pxy ( kb : ke + kh ), pres0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. true .) call avexy_ibm ( usgsxy ( kb : ke + kh ), usgs ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIuw ( ib : ie , jb : je , kb : ke + kh ), IIuws ( kb : ke + kh ),. true .) call avexy_ibm ( vsgsxy ( kb : ke + kh ), vsgs ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIvw ( ib : ie , jb : je , kb : ke + kh ), IIvws ( kb : ke + kh ),. true .) end if ! lxydump .or. lxytdump if ( lxydump ) then uwxyik = 0. ; vwxyjk = 0. ; uxyik = 0. ; wxyik = 0. ; vxyjk = 0. ; wxyjk = 0. ; wthlxyk = 0. ; thlxyk = 0. ; wpthlpxyk = 0. call avexy_ibm ( uwxyik ( kb : ke + kh ), uik ( ib : ie , jb : je , kb : ke + kh ) * wik ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIuw ( ib : ie , jb : je , kb : ke + kh ), IIuws ( kb : ke + kh ),. true .) call avexy_ibm ( vwxyjk ( kb : ke + kh ), vjk ( ib : ie , jb : je , kb : ke + kh ) * wjk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIvw ( ib : ie , jb : je , kb : ke + kh ), IIvws ( kb : ke + kh ),. true .) call avexy_ibm ( uxyik ( kb : ke + kh ), uik ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIuw ( ib : ie , jb : je , kb : ke + kh ), IIuws ( kb : ke + kh ),. true .) call avexy_ibm ( wxyik ( kb : ke + kh ), wik ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIuw ( ib : ie , jb : je , kb : ke + kh ), IIuws ( kb : ke + kh ),. true .) call avexy_ibm ( wxyjk ( kb : ke + kh ), wjk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIvw ( ib : ie , jb : je , kb : ke + kh ), IIvws ( kb : ke + kh ),. true .) call avexy_ibm ( vxyjk ( kb : ke + kh ), vjk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIvw ( ib : ie , jb : je , kb : ke + kh ), IIvws ( kb : ke + kh ),. true .) if ( ltempeq ) then call avexy_ibm ( wthlxyk ( kb : ke + kh ), wm ( ib : ie , jb : je , kb : ke + kh ) * thlk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. true .) call avexy_ibm ( thlxyk ( kb : ke + kh ), thlk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. true .) end if upwpxyik = uwxyik - uxyik * wxyik vpwpxyjk = vwxyjk - vxyjk * wxyjk if ( ltempeq ) then wpthlpxyk = wthlxyk - wxy * thlxyk end if end if ! lxydump !!>> CALCS FOR TIME DEPENDANT (AVERAGED) STATS !> Average 1-D fields in time if ( lxytdump ) then uxyt ( kb : ke + kh ) = ( uxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + uxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi vxyt ( kb : ke + kh ) = ( vxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + vxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi wxyt ( kb : ke + kh ) = ( wxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi qtxyt ( kb : ke + kh ) = ( qtxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + qtxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi pxyt ( kb : ke + kh ) = ( pxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + pxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi usgsxyt ( kb : ke + kh ) = ( usgsxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + usgsxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi vsgsxyt ( kb : ke + kh ) = ( vsgsxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + vsgsxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi if ( ltempeq ) then thlsgsxyt ( kb : ke + kh ) = ( thlsgsxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + thlsgsxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi thlxyt ( kb : ke + kh ) = ( thlxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + thlxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi end if end if ! lxytdump !> Average 2-D fields in time if ( lytdump ) then if ( myid == 0 ) then vyt ( ib : ie , kb : ke ) = ( vyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + vy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi uyt ( ib : ie , kb : ke ) = ( uyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + uy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi wyt ( ib : ie , kb : ke ) = ( wyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + wy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi usgsyt ( ib : ie , kb : ke ) = ( usgsyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + usgsy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi wsgsyt ( ib : ie , kb : ke ) = ( wsgsyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + wsgsy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi if ( ltempeq ) then thlyt ( ib : ie , kb : ke ) = ( thlyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + thly ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi thlsgsyt ( ib : ie , kb : ke ) = ( thlsgsyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + thlsgsy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi end if if ( lmoist ) then qtyt ( ib : ie , kb : ke ) = ( qtyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + qty ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi qtsgsyt ( ib : ie , kb : ke ) = ( qtsgsyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + qtsgsy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi end if if ( nsv > 0 ) then sca1yt ( ib : ie , kb : ke ) = ( sca1yt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + sca1y ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi sv1sgsyt ( ib : ie , kb : ke ) = ( sv1sgsyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + sv1sgsy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi end if if ( nsv > 1 ) then sca2yt ( ib : ie , kb : ke ) = ( sca2yt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + sca2y ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi sv2sgsyt ( ib : ie , kb : ke ) = ( sv2sgsyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + sv2sgsy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi end if if ( nsv > 2 ) then sca3yt ( ib : ie , kb : ke ) = ( sca3yt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + sca3y ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi sv3sgsyt ( ib : ie , kb : ke ) = ( sv3sgsyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + sv3sgsy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi end if end if ! myid end if !lytdump ! Average 3-D fields in time ! tg3315 may be possible to do less calculations by splitting up ! some calcs not necessary for xyt or yt... if ( lxytdump . or . lytdump . or . ltdump ) then uwtik (:,:, kb : ke + kh ) = ( uwtik (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wik (:,:, kb : ke + kh ) * uik (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi vwtjk (:,:, kb : ke + kh ) = ( vwtjk (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wjk (:,:, kb : ke + kh ) * vjk (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi uvtij (:,:, kb : ke + kh ) = ( uvtij (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + uij (:,:, kb : ke + kh ) * vij (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi uutc ( ib : ie , jb : je , kb : ke + kh ) = ( uutc ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + uc ( ib : ie , jb : je , kb : ke + kh ) * uc ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi vvtc ( ib : ie , jb : je , kb : ke + kh ) = ( vvtc ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + vc ( ib : ie , jb : je , kb : ke + kh ) * vc ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi wwtc ( ib : ie , jb : je , kb : ke + kh ) = ( wwtc ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wc ( ib : ie , jb : je , kb : ke + kh ) * wc ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi utik (:,:, kb : ke + kh ) = ( utik (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + uik (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi wtik (:,:, kb : ke + kh ) = ( wtik (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wik (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi vtjk (:,:, kb : ke + kh ) = ( vtjk (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + vjk (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi wtjk (:,:, kb : ke + kh ) = ( wtjk (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wjk (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi utij (:,:, kb : ke + kh ) = ( utij (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + uij (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi vtij (:,:, kb : ke + kh ) = ( vtij (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + vij (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi umt ( ib : ie , jb : je , kb : ke + kh ) = ( umt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + um ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi vmt ( ib : ie , jb : je , kb : ke + kh ) = ( vmt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + vm ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi wmt ( ib : ie , jb : je , kb : ke + kh ) = ( wmt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wm ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi utc ( ib : ie , jb : je , kb : ke + kh ) = ( utc ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + uc ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi vtc ( ib : ie , jb : je , kb : ke + kh ) = ( vtc ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + vc ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi wtc ( ib : ie , jb : je , kb : ke + kh ) = ( wtc ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wc ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi pt ( ib : ie , jb : je , kb : ke + kh ) = ( pt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + pres0 ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi if ( ltempeq ) then wthltk ( ib : ie , jb : je , kb : ke + kh ) = ( wthltk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + thlk ( ib : ie , jb : je , kb : ke + kh ) * wm ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi thlthlt ( ib : ie , jb : je , kb : ke + kh ) = ( thlthlt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + thlm ( ib : ie , jb : je , kb : ke + kh ) * thlm ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi thltk ( ib : ie , jb : je , kb : ke + kh ) = ( thltk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + thlk ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi thlt ( ib : ie , jb : je , kb : ke + kh ) = ( thlt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + thlm ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi end if if ( lmoist ) then wqttk ( ib : ie , jb : je , kb : ke + kh ) = ( wqttk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + qtk ( ib : ie , jb : je , kb : ke + kh ) * wm ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi qtqtt ( ib : ie , jb : je , kb : ke + kh ) = ( qtqtt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + qtm ( ib : ie , jb : je , kb : ke + kh ) * qtm ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi qttk ( ib : ie , jb : je , kb : ke + kh ) = ( qttk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + qtk ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi qtt ( ib : ie , jb : je , kb : ke + kh ) = ( qtt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + qtm ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi end if if ( nsv > 0 ) then sv1t ( ib : ie , jb : je , kb : ke + kh ) = ( sv1t ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + svm ( ib : ie , jb : je , kb : ke + kh , 1 ) * tsamplep ) * tstatsdumppi sv1tk ( ib : ie , jb : je , kb : ke + kh ) = ( sv1tk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + sv1k ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi wsv1tk ( ib : ie , jb : je , kb : ke + kh ) = ( wsv1tk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wm ( ib : ie , jb : je , kb : ke + kh ) * sv1k ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi sv1sgst ( ib : ie , jb : je , kb : ke + kh ) = ( sv1sgst ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + sv1sgs ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi sv1sv1t ( ib : ie , jb : je , kb : ke + kh ) = ( sv1sv1t ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + svm ( ib : ie , jb : je , kb : ke + kh , 1 ) * svm ( ib : ie , jb : je , kb : ke + kh , 1 ) * tsamplep ) * tstatsdumppi ! sv1max(ib:ie,jb:je,kb:ke) = max(sv1max(ib:ie,jb:je,kb:ke),svm(ib:ie,jb:je,kb:ke,1)) end if if (( lchem . eqv . . true .) . and . ( nsv > 2 )) then PSSt ( ib : ie , jb : je , kb : ke + kh ) = ( PSSt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + PSS ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi end if if ( nsv > 1 ) then sv2t ( ib : ie , jb : je , kb : ke + kh ) = ( sv2t ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + svm ( ib : ie , jb : je , kb : ke + kh , 2 ) * tsamplep ) * tstatsdumppi sv2tk ( ib : ie , jb : je , kb : ke + kh ) = ( sv2tk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + sv2k ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi wsv2tk ( ib : ie , jb : je , kb : ke + kh ) = ( wsv2tk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wm ( ib : ie , jb : je , kb : ke + kh ) * sv2k ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi sv2sgst ( ib : ie , jb : je , kb : ke + kh ) = ( sv2sgst ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + sv2sgs ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi sv2sv2t ( ib : ie , jb : je , kb : ke + kh ) = ( sv2sv2t ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + svm ( ib : ie , jb : je , kb : ke + kh , 2 ) * svm ( ib : ie , jb : je , kb : ke + kh , 2 ) * tsamplep ) * tstatsdumppi ! sv2max(ib:ie,jb:je,kb:ke) = max(sv2max(ib:ie,jb:je,kb:ke),svm(ib:ie,jb:je,kb:ke,2)) end if if ( nsv > 2 ) then sv3t ( ib : ie , jb : je , kb : ke + kh ) = ( sv3t ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + svm ( ib : ie , jb : je , kb : ke + kh , 3 ) * tsamplep ) * tstatsdumppi sv3tk ( ib : ie , jb : je , kb : ke + kh ) = ( sv3tk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + sv3k ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi wsv3tk ( ib : ie , jb : je , kb : ke + kh ) = ( wsv3tk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wm ( ib : ie , jb : je , kb : ke + kh ) * sv3k ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi sv3sgst ( ib : ie , jb : je , kb : ke + kh ) = ( sv3sgst ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + sv3sgs ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi sv3sv3t ( ib : ie , jb : je , kb : ke + kh ) = ( sv3sv3t ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + svm ( ib : ie , jb : je , kb : ke + kh , 3 ) * svm ( ib : ie , jb : je , kb : ke + kh , 3 ) * tsamplep ) * tstatsdumppi ! sv3max(ib:ie,jb:je,kb:ke) = max(sv3max(ib:ie,jb:je,kb:ke),svm(ib:ie,jb:je,kb:ke,3)) end if if ( nsv > 3 ) then sv4t ( ib : ie , jb : je , kb : ke + kh ) = ( sv4t ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + svm ( ib : ie , jb : je , kb : ke + kh , 4 ) * tsamplep ) * tstatsdumppi sv4tk ( ib : ie , jb : je , kb : ke + kh ) = ( sv4tk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + sv4k ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi wsv4tk ( ib : ie , jb : je , kb : ke + kh ) = ( wsv4tk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wm ( ib : ie , jb : je , kb : ke + kh ) * sv4k ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi sv4sgst ( ib : ie , jb : je , kb : ke + kh ) = ( sv4sgst ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + sv4sgs ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi sv4sv4t ( ib : ie , jb : je , kb : ke + kh ) = ( sv4sv4t ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + svm ( ib : ie , jb : je , kb : ke + kh , 4 ) * svm ( ib : ie , jb : je , kb : ke + kh , 4 ) * tsamplep ) * tstatsdumppi ! sv4max(ib:ie,jb:je,kb:ke) = max(sv4max(ib:ie,jb:je,kb:ke),svm(ib:ie,jb:je,kb:ke,4)) end if end if !lxytdump .or. lytdump .or. ltdump ! Other 3-D fields specifically for tdump !if (ltdump) then ! bss116 already calculated above ! wmt(ib:ie,jb:je,kb:ke+kh) = (wmt(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + wm(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! sv1t(ib:ie,jb:je,kb:ke+kh) = (sv1t(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + svm(ib:ie,jb:je,kb:ke+kh,1)*tsamplep)*tstatsdumppi ! sv2t(ib:ie,jb:je,kb:ke+kh) = (sv2t(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + svm(ib:ie,jb:je,kb:ke+kh,2)*tsamplep)*tstatsdumppi ! sv3t(ib:ie,jb:je,kb:ke+kh) = (sv3t(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + svm(ib:ie,jb:je,kb:ke+kh,3)*tsamplep)*tstatsdumppi ! ! sv4t(ib:ie,jb:je,kb:ke+kh) = (sv4t(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + svm(ib:ie,jb:je,kb:ke+kh,4)*tsamplep)*tstatsdumppi ! sv1tk(ib:ie,jb:je,kb:ke+kh) = (sv1tk(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + sv1k(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! sv2tk(ib:ie,jb:je,kb:ke+kh) = (sv2tk(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + sv2k(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! sv3tk(ib:ie,jb:je,kb:ke+kh) = (sv3tk(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + sv3k(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! sv4tk(ib:ie,jb:je,kb:ke+kh) = (sv4tk(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + sv4k(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! wsv1tk(ib:ie,jb:je,kb:ke+kh) = (wsv1tk(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + wm(ib:ie,jb:je,kb:ke+kh)*sv1k(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! wsv2tk(ib:ie,jb:je,kb:ke+kh) = (wsv2tk(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + wm(ib:ie,jb:je,kb:ke+kh)*sv2k(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! wsv3tk(ib:ie,jb:je,kb:ke+kh) = (wsv3tk(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + wm(ib:ie,jb:je,kb:ke+kh)*sv3k(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! wsv4tk(ib:ie,jb:je,kb:ke+kh) = (wsv4tk(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + wm(ib:ie,jb:je,kb:ke+kh)*sv4k(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! sv1sgst(ib:ie,jb:je,kb:ke+kh) = (sv1sgst(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + sv1sgs(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! sv2sgst(ib:ie,jb:je,kb:ke+kh) = (sv2sgst(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + sv2sgs(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! sv3sgst(ib:ie,jb:je,kb:ke+kh) = (sv3sgst(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + sv3sgs(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! sv4sgst(ib:ie,jb:je,kb:ke+kh) = (sv4sgst(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + sv4sgs(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi !end if ! ltdump !      where (IIuwt==0) !        upwpyik    = -999 !        upwpytik   = -999 !      endwhere ! EXAMPLE FOR OTHER SLICE PLANES !> slice over purifier !      if (nprocs>7) then !      if (myid==7) then !        sca1y(ib:ie,kb:ke) = (sca1y(ib:ie,kb:ke)*(tstatsdumpp-tsamplep) + svm(ib:ie,2,kb:ke,1)*tsamplep)*tstatsdumppi !      end if !      end if end if ! lytdump .or. lydump .or. lxydump .or. lxytdump ! slicedump fields are generalised so can define what is required here if ( lslicedump ) then slice = ( slice * ( tstatsdumpp - tsamplep ) + ( 0.5 * ( svm ( ib : ie , jb : je , kb , 1 ) + svm ( ib : ie , jb : je , kb + 1 , 1 ))) * tsamplep ) * tstatsdumppi slice2 = ( slice2 * ( tstatsdumpp - tsamplep ) + ( sum ( svm ( ib : ie , jb : je , kb : kb + 8 , 1 ), 3 ) / 9. ) * tsamplep ) * tstatsdumppi slice3 = ( slice3 * ( tstatsdumpp - tsamplep ) + ( 0.5 * ( svm ( ib : ie , jb : je , kb , 2 ) + svm ( ib : ie , jb : je , kb + 1 , 2 ))) * tsamplep ) * tstatsdumppi slice4 = ( slice4 * ( tstatsdumpp - tsamplep ) + ( sum ( svm ( ib : ie , jb : je , kb : kb + 8 , 2 ), 3 ) / 9. ) * tsamplep ) * tstatsdumppi slice5 = ( slice5 * ( tstatsdumpp - tsamplep ) + ( 0.5 * ( svm ( ib : ie , jb : je , kb , 3 ) + svm ( ib : ie , jb : je , kb + 1 , 3 ))) * tsamplep ) * tstatsdumppi slice6 = ( slice6 * ( tstatsdumpp - tsamplep ) + ( sum ( svm ( ib : ie , jb : je , kb : kb + 8 , 3 ), 3 ) / 9. ) * tsamplep ) * tstatsdumppi slice7 = ( slice7 * ( tstatsdumpp - tsamplep ) + ( um ( ib : ie , jb : je , kb ) + um ( ib : ie , jb : je , kb + 1 )) * tsamplep ) * tstatsdumppi slice8 = ( slice8 * ( tstatsdumpp - tsamplep ) + ( vm ( ib : ie , jb : je , kb ) + vm ( ib : ie , jb : je , kb + 1 )) * tsamplep ) * tstatsdumppi endif !lslicedump ! Write y-averaged statistics every tsample if ( lydump ) then if ( myid == 0 ) then allocate ( field ( ib : ie , kb : ke )) allocate ( varsy ( imax , khigh - klow + 1 , nstaty )) varsy = 0. varsy (:,:, 1 ) = uy ( ib : ie , kb : ke ) varsy (:,:, 2 ) = vy ( ib : ie , kb : ke ) varsy (:,:, 3 ) = wy ( ib : ie , kb : ke ) varsy (:,:, 4 ) = thly ( ib : ie , kb : ke ) varsy (:,:, 5 ) = qty ( ib : ie , kb : ke ) varsy (:,:, 6 ) = sca1y ( ib : ie , kb : ke ) varsy (:,:, 7 ) = sca2y ( ib : ie , kb : ke ) varsy (:,:, 8 ) = sca3y ( ib : ie , kb : ke ) varsy (:,:, 9 ) = upwpyik ( ib : ie , kb : ke ) varsy (:,:, 10 ) = wpthlpyk ( ib : ie , kb : ke ) varsy (:,:, 11 ) = usgsy ( ib : ie , kb : ke ) varsy (:,:, 12 ) = thlsgsy ( ib : ie , kb : ke ) varsy (:,:, 13 ) = uwyik ( ib : ie , kb : ke ) varsy (:,:, 14 ) = wthlyk ( ib : ie , kb : ke ) call writestat_nc ( ncidy , 1 , tncstaty ,( / timee / ), nrecy ,. true .) call writestat_nc ( ncidy , nstaty , ncstaty , varsy , nrecy , imax , khigh - klow + 1 ) deallocate ( field , varsy ) endif !myid endif !lydump ! Write xy-averaged statistics every tsample if ( lxydump ) then if ( myid == 0 ) then call writestat_nc ( ncidxy , 1 , tncstatxy ,( / timee / ), nrecxy ,. true .) allocate ( varsxy ( khigh - klow + 1 , nstatxy )) varsxy (:, 1 ) = uxy ( kb : ke ) varsxy (:, 2 ) = vxy ( kb : ke ) varsxy (:, 3 ) = wxy ( kb : ke ) varsxy (:, 4 ) = thlxy ( kb : ke ) varsxy (:, 5 ) = qtxy ( kb : ke ) varsxy (:, 6 ) = pxy ( kb : ke ) varsxy (:, 7 ) = upwpxyik ( kb : ke ) varsxy (:, 8 ) = wpthlpxyk ( kb : ke ) varsxy (:, 9 ) = vpwpxyjk ( kb : ke ) varsxy (:, 10 ) = usgsxy ( kb : ke ) varsxy (:, 11 ) = thlsgsxy ( kb : ke ) !wdthldtc(kb:ke) varsxy (:, 12 ) = vsgsxy ( kb : ke ) varsxy (:, 13 ) = uwxyik ( kb : ke ) varsxy (:, 14 ) = wthlxyk ( kb : ke ) varsxy (:, 15 ) = vwxyjk ( kb : ke ) call writestat_1D_nc ( ncidxy , nstatxy , ncstatxy , varsxy , nrecxy , khigh - klow + 1 ) end if !myid end if !lxydump if ( ltkedump ) then !call genstats(tsamplep,tstatsdumpp,umc,vmc,wmc) endif tsamplep = dt else !timestatsdumpp < tsample tsamplep = tsamplep + dt endif if ( tstatsdumpp > tstatsdump ) then ! Final calculations and write xyt-averaged statistics every tsample if ( lxytdump ) then wthltxyk = 0. ; uwtxyik = 0. ; vwtxyjk = 0. ; wwtxyk = 0. ; uvtxyij = 0. ; wpthlptxyk = 0. ; upwptxyik = 0. ; vpwptxyjk = 0. ; upvptxyij = 0. ; thlpthlptxy = 0. ; upuptxyc = 0. ; vpvptxyc = 0. ; wpwptxyc = 0. ; tketxyc = 0. !> Advective flux if ( ltempeq ) then call avexy_ibm ( wthltxyk ( kb : ke + kh ), wmt ( ib : ie , jb : je , kb : ke + kh ) * thltk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. true .) end if call avexy_ibm ( uwtxyik ( kb : ke + kh ), utik ( ib : ie , jb : je , kb : ke + kh ) * wtik ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIuw ( ib : ie , jb : je , kb : ke + kh ), IIuws ( kb : ke + kh ),. true .) call avexy_ibm ( vwtxyjk ( kb : ke + kh ), vtjk ( ib : ie , jb : je , kb : ke + kh ) * wtjk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIvw ( ib : ie , jb : je , kb : ke + kh ), IIvws ( kb : ke + kh ),. true .) call avexy_ibm ( wwtxyk ( kb : ke + kh ), wmt ( ib : ie , jb : je , kb : ke + kh ) * wmt ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. true .) call avexy_ibm ( uvtxyij ( kb : ke + kh ), utij ( ib : ie , jb : je , kb : ke + kh ) * vtij ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIuv ( ib : ie , jb : je , kb : ke + kh ), IIuvs ( kb : ke + kh ),. true .) !> Turbulent fluxes if ( ltempeq ) then call avexy_ibm ( wpthlptxyk ( kb : ke + kh ), wthltk ( ib : ie , jb : je , kb : ke + kh ) - wmt ( ib : ie , jb : je , kb : ke + kh ) * thltk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. true .) end if call avexy_ibm ( upwptxyik ( kb : ke + kh ), uwtik ( ib : ie , jb : je , kb : ke + kh ) - utik ( ib : ie , jb : je , kb : ke + kh ) * wtik ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIuw ( ib : ie , jb : je , kb : ke + kh ), IIuws ( kb : ke + kh ),. true .) call avexy_ibm ( vpwptxyjk ( kb : ke + kh ), vwtjk ( ib : ie , jb : je , kb : ke + kh ) - vtjk ( ib : ie , jb : je , kb : ke + kh ) * wtjk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIvw ( ib : ie , jb : je , kb : ke + kh ), IIvws ( kb : ke + kh ),. true .) call avexy_ibm ( upvptxyij ( kb : ke + kh ), uvtij ( ib : ie , jb : je , kb : ke + kh ) - utij ( ib : ie , jb : je , kb : ke + kh ) * vtij ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIuv ( ib : ie , jb : je , kb : ke + kh ), IIuvs ( kb : ke + kh ),. true .) !> Variances and TKE if ( ltempeq ) then call avexy_ibm ( thlpthlptxy ( kb : ke + kh ), thlthlt ( ib : ie , jb : je , kb : ke + kh ) - thlt ( ib : ie , jb : je , kb : ke + kh ) * thlt ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. true .) end if call avexy_ibm ( upuptxyc ( kb : ke + kh ), uutc ( ib : ie , jb : je , kb : ke + kh ) - utc ( ib : ie , jb : je , kb : ke + kh ) * utc ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. true .) call avexy_ibm ( vpvptxyc ( kb : ke + kh ), vvtc ( ib : ie , jb : je , kb : ke + kh ) - vtc ( ib : ie , jb : je , kb : ke + kh ) * vtc ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. true .) call avexy_ibm ( wpwptxyc ( kb : ke + kh ), wwtc ( ib : ie , jb : je , kb : ke + kh ) - wtc ( ib : ie , jb : je , kb : ke + kh ) * wtc ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. true .) call avexy_ibm ( tketxyc ( kb : ke + kh ), 0.5 * (( wwtc ( ib : ie , jb : je , kb : ke + kh ) - wtc ( ib : ie , jb : je , kb : ke + kh ) * wtc ( ib : ie , jb : je , kb : ke + kh )) + ( vvtc ( ib : ie , jb : je , kb : ke + kh ) - vtc ( ib : ie , jb : je , kb : ke + kh ) * vtc ( ib : ie , jb : je , kb : ke + kh )) + ( uutc ( ib : ie , jb : je , kb : ke + kh ) - utc ( ib : ie , jb : je , kb : ke + kh ) * utc ( ib : ie , jb : je , kb : ke + kh ))), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. true .) if ( myid == 0 ) then call writestat_nc ( ncidxyt , 1 , tncstatxyt ,( / timee / ), nrecxyt ,. true .) allocate ( varsxyt ( khigh - klow + 1 , nstatxyt )) varsxyt (:, 1 ) = uxyt ( kb : ke ) varsxyt (:, 2 ) = vxyt ( kb : ke ) varsxyt (:, 3 ) = wxyt ( kb : ke ) varsxyt (:, 4 ) = thlxyt ( kb : ke ) varsxyt (:, 5 ) = qtxyt ( kb : ke ) varsxyt (:, 6 ) = pxyt ( kb : ke ) varsxyt (:, 7 ) = upwptxyik ( kb : ke ) varsxyt (:, 8 ) = wpthlptxyk ( kb : ke ) varsxyt (:, 9 ) = vpwptxyjk ( kb : ke ) varsxyt (:, 10 ) = upvptxyij ( kb : ke ) varsxyt (:, 11 ) = uwtxyik ( kb : ke ) varsxyt (:, 12 ) = wthltxyk ( kb : ke ) !wdthldtc(kb:ke) varsxyt (:, 13 ) = uvtxyij ( kb : ke ) varsxyt (:, 14 ) = vwtxyjk ( kb : ke ) varsxyt (:, 15 ) = wwtxyk ( kb : ke ) varsxyt (:, 16 ) = usgsxyt ( kb : ke ) !wdthldtw(kb:ke) varsxyt (:, 17 ) = thlsgsxyt ( kb : ke ) varsxyt (:, 18 ) = vsgsxyt ( kb : ke ) varsxyt (:, 19 ) = thlpthlptxy ( kb : ke ) varsxyt (:, 20 ) = upuptxyc ( kb : ke ) varsxyt (:, 21 ) = vpvptxyc ( kb : ke ) varsxyt (:, 22 ) = wpwptxyc ( kb : ke ) varsxyt (:, 23 ) = tketxyc ( kb : ke ) call writestat_1D_nc ( ncidxyt , nstatxyt , ncstatxyt , varsxyt , nrecxyt , khigh - klow + 1 ) end if !myid end if !lxytdump ! Final calculations and write yt-averaged statistics every tsample if ( lytdump ) then !    call MPI_BCAST(sca1yt ,(ke+kh-(kb-kh))*(ie+ih-(ib-ih)),MY_REAL   ,7,comm3d,mpierr) ! Turbulent flux call avey_ibm ( upwptyik , uwtik ( ib : ie , jb : je , kb : ke ) - utik ( ib : ie , jb : je , kb : ke ) * wtik ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIuw ( ib : ie , jb : je , kb : ke ), IIuwt ( ib : ie , kb : ke )) call avey_ibm ( uwtyik , utik ( ib : ie , jb : je , kb : ke ) * wtik ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIuw ( ib : ie , jb : je , kb : ke ), IIuwt ( ib : ie , kb : ke )) call avey_ibm ( upuptyc , uutc ( ib : ie , jb : je , kb : ke ) - utc ( ib : ie , jb : je , kb : ke ) * utc ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) call avey_ibm ( vpvptyc , vvtc ( ib : ie , jb : je , kb : ke ) - vtc ( ib : ie , jb : je , kb : ke ) * vtc ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) call avey_ibm ( wpwptyc , wwtc ( ib : ie , jb : je , kb : ke ) - wtc ( ib : ie , jb : je , kb : ke ) * wtc ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) if ( ltempeq ) then call avey_ibm ( wpthlptyk , wthltk ( ib : ie , jb : je , kb : ke ) - wmt ( ib : ie , jb : je , kb : ke ) * thltk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( wthltyk , wmt ( ib : ie , jb : je , kb : ke ) * thltk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( thlpthlpty , thlthlt ( ib : ie , jb : je , kb : ke ) - thlt ( ib : ie , jb : je , kb : ke ) * thlt ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) end if if ( lmoist ) then call avey_ibm ( wpqtptyk , wqttk ( ib : ie , jb : je , kb : ke ) - wmt ( ib : ie , jb : je , kb : ke ) * qttk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( wqttyk , wmt ( ib : ie , jb : je , kb : ke ) * qttk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( qtpqtpty , qtqtt ( ib : ie , jb : je , kb : ke ) - qtt ( ib : ie , jb : je , kb : ke ) * qtt ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) end if if ( nsv > 0 ) then call avey_ibm ( wpsv1ptyk , wsv1tk ( ib : ie , jb : je , kb : ke ) - wmt ( ib : ie , jb : je , kb : ke ) * sv1tk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( wsv1tyk , wmt ( ib : ie , jb : je , kb : ke ) * sv1tk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( sv1psv1pty , sv1sv1t ( ib : ie , jb : je , kb : ke ) - sv1t ( ib : ie , jb : je , kb : ke ) * sv1t ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) end if if ( nsv > 1 ) then call avey_ibm ( wpsv2ptyk , wsv2tk ( ib : ie , jb : je , kb : ke ) - wmt ( ib : ie , jb : je , kb : ke ) * sv2tk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( wsv2tyk , wmt ( ib : ie , jb : je , kb : ke ) * sv2tk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( sv2psv2pty , sv2sv2t ( ib : ie , jb : je , kb : ke ) - sv2t ( ib : ie , jb : je , kb : ke ) * sv2t ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) end if if ( nsv > 2 ) then call avey_ibm ( wpsv3ptyk , wsv3tk ( ib : ie , jb : je , kb : ke ) - wmt ( ib : ie , jb : je , kb : ke ) * sv3tk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( wsv3tyk , wmt ( ib : ie , jb : je , kb : ke ) * sv3tk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( sv3psv3pty , sv3sv3t ( ib : ie , jb : je , kb : ke ) - sv3t ( ib : ie , jb : je , kb : ke ) * sv3t ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) end if if ( myid == 0 ) then allocate ( varsyt ( imax , khigh - klow + 1 , nstatyt )) varsyt = 0. call writestat_nc ( ncidyt , 1 , tncstatyt ,( / timee / ), nrecyt ,. true .) varsyt (:,:, 1 ) = uyt ( ib : ie , kb : ke ) varsyt (:,:, 2 ) = vyt ( ib : ie , kb : ke ) varsyt (:,:, 3 ) = wyt ( ib : ie , kb : ke ) varsyt (:,:, 4 ) = thlyt ( ib : ie , kb : ke ) varsyt (:,:, 5 ) = qtyt ( ib : ie , kb : ke ) varsyt (:,:, 6 ) = sca1yt ( ib : ie , kb : ke ) varsyt (:,:, 7 ) = sca2yt ( ib : ie , kb : ke ) varsyt (:,:, 8 ) = sca3yt ( ib : ie , kb : ke ) varsyt (:,:, 9 ) = upwptyik ( ib : ie , kb : ke ) varsyt (:,:, 10 ) = wpthlptyk ( ib : ie , kb : ke ) varsyt (:,:, 11 ) = wpqtptyk ( ib : ie , kb : ke ) varsyt (:,:, 12 ) = wpsv1ptyk ( ib : ie , kb : ke ) varsyt (:,:, 13 ) = wpsv2ptyk ( ib : ie , kb : ke ) varsyt (:,:, 14 ) = wpsv3ptyk ( ib : ie , kb : ke ) varsyt (:,:, 15 ) = uwtyik ( ib : ie , kb : ke ) varsyt (:,:, 16 ) = wthltyk ( ib : ie , kb : ke ) varsyt (:,:, 17 ) = wqttyk ( ib : ie , kb : ke ) varsyt (:,:, 18 ) = wsv1tyk ( ib : ie , kb : ke ) varsyt (:,:, 19 ) = wsv2tyk ( ib : ie , kb : ke ) varsyt (:,:, 20 ) = wsv3tyk ( ib : ie , kb : ke ) varsyt (:,:, 21 ) = upuptyc ( ib : ie , kb : ke ) varsyt (:,:, 22 ) = wpwptyc ( ib : ie , kb : ke ) varsyt (:,:, 23 ) = thlpthlpty ( ib : ie , kb : ke ) varsyt (:,:, 24 ) = qtpqtpty ( ib : ie , kb : ke ) varsyt (:,:, 25 ) = sv1psv1pty ( ib : ie , kb : ke ) varsyt (:,:, 26 ) = sv2psv2pty ( ib : ie , kb : ke ) varsyt (:,:, 27 ) = sv3psv3pty ( ib : ie , kb : ke ) varsyt (:,:, 28 ) = usgsyt ( ib : ie , kb : ke ) varsyt (:,:, 29 ) = wsgsyt ( ib : ie , kb : ke ) varsyt (:,:, 30 ) = thlsgsyt ( ib : ie , kb : ke ) varsyt (:,:, 31 ) = qtsgsyt ( ib : ie , kb : ke ) varsyt (:,:, 32 ) = sv1sgsyt ( ib : ie , kb : ke ) varsyt (:,:, 33 ) = sv2sgsyt ( ib : ie , kb : ke ) varsyt (:,:, 34 ) = sv3sgsyt ( ib : ie , kb : ke ) call writestat_nc ( ncidyt , nstatyt , ncstatyt , varsyt , nrecyt , imax , khigh - klow + 1 ) end if !myid end if !lytdump ! Final calculations and write t-averaged statistics every tsample if ( ltdump ) then ! wpsv1p = wsv1tk - wmt*sv1tk ! wpsv2p = wsv2tk - wmt*sv2tk ! wpsv3p = wsv3tk - wmt*sv3tk ! wpsv4p = wsv4tk - wmt*sv4tk wpthlptk = 0. ; thlpthlpt = 0. !> Turbulent fluxes upwptik = uwtik - utik * wtik vpwptjk = vwtjk - vtjk * wtjk upvptij = uvtij - utij * vtij if ( ltempeq ) then wpthlptk = wthltk - wmt * thlk end if if ( nsv > 0 ) then wpsv1p = wsv1tk - wmt * sv1tk end if if ( nsv > 1 ) then wpsv2p = wsv2tk - wmt * sv2tk end if if ( nsv > 2 ) then wpsv3p = wsv3tk - wmt * sv3tk end if if ( nsv > 3 ) then wpsv4p = wsv4tk - wmt * sv4tk end if !> Variances and TKE if ( ltempeq ) then thlpthlpt = thlthlt - thlt * thlt end if upuptc = uutc - utc * utc vpvptc = vvtc - vtc * vtc wpwptc = wwtc - wtc * wtc tketc = 0.5 * ( upuptc + vpvptc + wpwptc ) if ( nsv > 0 ) then sv1psv1pt = sv1sv1t - sv1t * sv1t end if if ( nsv > 1 ) then sv2psv2pt = sv2sv2t - sv2t * sv2t end if if ( nsv > 2 ) then sv3psv3pt = sv3sv3t - sv3t * sv3t end if if ( nsv > 3 ) then sv4psv4pt = sv4sv4t - sv4t * sv4t end if !      if (myid == 0) then allocate ( varst ( imax , jmax , khigh - klow + 1 , nstatt )) call writestat_nc ( ncidt , 1 , tncstatt ,( / timee / ), nrect ,. true .) varst (:,:,:, 1 ) = umt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 2 ) = vmt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 3 ) = wmt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 4 ) = thlt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 5 ) = qtt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 6 ) = pt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 7 ) = sv1t ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 8 ) = sv2t ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 9 ) = sv3t ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 10 ) = sv4t ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 11 ) = PSSt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 12 ) = upwptik ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 13 ) = vpwptjk ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 14 ) = upvptij ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 15 ) = wpthlptk ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 16 ) = wpsv1p ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 17 ) = wpsv2p ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 18 ) = wpsv3p ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 19 ) = wpsv4p ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 20 ) = thlpthlpt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 21 ) = upuptc ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 22 ) = vpvptc ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 23 ) = wpwptc ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 24 ) = tketc ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 25 ) = sv1psv1pt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 26 ) = sv2psv2pt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 27 ) = sv3psv3pt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 28 ) = sv4psv4pt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 29 ) = sv1sgst ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 30 ) = sv2sgst ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 31 ) = sv3sgst ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 32 ) = sv4sgst ( ib : ie , jb : je , kb : ke ) ! varst(:,:,:,33) = sv1max(ib:ie,jb:je,kb:ke) ! varst(:,:,:,34) = sv2max(ib:ie,jb:je,kb:ke) ! varst(:,:,:,35) = sv3max(ib:ie,jb:je,kb:ke) ! varst(:,:,:,36) = sv4max(ib:ie,jb:je,kb:ke) call writestat_nc ( ncidt , nstatt , ncstatt , varst , nrect , imax , jmax , khigh - klow + 1 ) !        end if !myid deallocate ( varst ) end if !ltdump if ( ltkedump ) then call tkestatsdump if ( myid == 0 ) then call writestat_nc ( ncidtke , 1 , tncstattke ,( / timee / ), nrectke ,. true .) allocate ( varstke ( khigh - klow + 1 , nstattke )) varstke (:, 1 ) = p_b ( kb : ke + kh ) varstke (:, 2 ) = t_p ( kb : ke + kh ) varstke (:, 3 ) = adv ( kb : ke + kh ) varstke (:, 4 ) = t_t ( kb : ke + kh ) varstke (:, 5 ) = t_sgs ( kb : ke + kh ) varstke (:, 6 ) = p_t ( kb : ke + kh ) varstke (:, 7 ) = t_v ( kb : ke + kh ) varstke (:, 8 ) = d_sgs ( kb : ke + kh ) call writestat_1D_nc ( ncidtke , nstattke , ncstattke , varstke , nrectke , khigh - klow + 1 ) end if !myid endif !ltkedump if ( lslicedump ) then allocate ( varslice ( imax , jmax , nstatslice )) call writestat_nc ( ncidslice , 1 , tncstatslice ,( / timee / ), nrecslice ,. true .) varslice (:,:, 1 ) = slice varslice (:,:, 2 ) = slice2 varslice (:,:, 3 ) = slice3 varslice (:,:, 4 ) = slice4 varslice (:,:, 5 ) = slice5 varslice (:,:, 6 ) = slice6 varslice (:,:, 7 ) = slice7 varslice (:,:, 8 ) = slice8 ! write(*,*) myid ! write(*,*) 'ncidslice,1,tncstatslice,(/timee/),nrecslice,.true.', ncidslice,1,tncstatslice,(/timee/),nrecslice call writestat_nc ( ncidslice , nstatslice , ncstatslice , varslice , nrecslice , imax , jmax ) ! deallocate(varslice) endif tstatsdumpp = dt else !tstatsdumpp < tstatsdump tstatsdumpp = tstatsdumpp + dt endif deallocate ( thlk , qtk , uik , wik , vjk , wjk , uij , vij , uc , vc , wc ) deallocate ( thlsgs , qtsgs , usgs , vsgs , wsgs ) deallocate ( sv1k , sv2k , sv3k , sv4k , sv1sgs , sv2sgs , sv3sgs , sv4sgs , PSS , wpsv1p , wpsv2p , wpsv3p , wpsv4p , sv1psv1pt , sv2psv2pt , sv3psv3pt , sv4psv4pt ) deallocate ( upwptik , vpwptjk , upvptij , wpthlptk , thlpthlpt , upuptc , vpvptc , wpwptc , tketc ) end subroutine statsdump","tags":"","loc":"proc/statsdump.html"},{"title":"tkestatsdump – uDALES","text":"private subroutine tkestatsdump() Uses modfields modglobal modmpi modsurfdata modsubgrid proc~~tkestatsdump~~UsesGraph proc~tkestatsdump tkestatsdump module~modsurfdata modsurfdata proc~tkestatsdump->module~modsurfdata module~modmpi modmpi proc~tkestatsdump->module~modmpi module~modsubgrid modsubgrid proc~tkestatsdump->module~modsubgrid module~modfields modfields proc~tkestatsdump->module~modfields module~modglobal modglobal proc~tkestatsdump->module~modglobal mpi mpi module~modmpi->mpi module~modsubgriddata modsubgriddata module~modsubgrid->module~modsubgriddata Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~tkestatsdump~~CallsGraph proc~tkestatsdump tkestatsdump proc~excjs excjs proc~tkestatsdump->proc~excjs mpi_sendrecv mpi_sendrecv proc~excjs->mpi_sendrecv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~tkestatsdump~~CalledByGraph proc~tkestatsdump tkestatsdump proc~statsdump statsdump proc~statsdump->proc~tkestatsdump program~dalesurban DALESURBAN program~dalesurban->proc~statsdump Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code tkestatsdump Source Code subroutine tkestatsdump use modfields , only : u0 , v0 , w0 , thl0 , uav , vav , wav , uuav , vvav , wwav , uvav , uwav , vwav , thlav , thlthlav , pres0 , thluav , thlvav , thlwav ,& upupav , vpvpav , wpwpav , thlpthlpav , upvpav , upwpav , vpwpav , thlpupav , thlpvpav , thlpwpav , presav ,& strain2av , disssgsav , t_vav , tvmx , tvmy , tvmz , tsgsmx1 , tsgsmx2 , tsgsmy1 , tsgsmy2 , tsgsmz1 , t_sgsav , nusgsav ,& tpm , t_pav , ttmx , ttmy , ttmz , t_tav , p_bav , d_sgsav , p_tav , tkeadv , tsgsmz1 , tsgsmz2 , t_t , t_v , t_p , t_sgs , d_sgs ,& p_b , p_t , adv , IIc , IIcs use modglobal , only : ib , ie , ih , jb , je , jgb , jge , dy , jh , ke , kb , kh , rk3step , timee , cexpnr , tsample , tstatsdump , jtot , imax , dzf ,& dzf , dzfi , dzhi , dxf , dxfi , dyi , dxhi , dy2i , grav , numol use modmpi , only : myid , cmyid , my_real , mpi_sum , avey_ibm , mpierr , comm3d , excjs , avexy_ibm use modsurfdata , only : thls use modsubgrid , only : ekh implicit none real , dimension ( ib : ie , jb : je , kb : ke ) :: disssgsfl ! average subgrid visc. * average rate of strain squared : 2*<nu_t>*<Sij>*<Sij> real , dimension ( ib : ie , jb : je , kb : ke ) :: dissresav ! average resolved dissipation: 2*nu*<Sij'*Sij'> = 2*nu*( <Sij*Sij> - <Sij>*<Sij> ) real , dimension ( ib : ie , jb : je , kb : ke ) :: tke ! tke = 0.5*<ui'ui'> real , dimension ( ib : ie , jb : je , kb : ke ) :: mke ! = <ui>d/dxj(<ui><uj>) + <ui>d/dxj(<ui'uj'>) = <ui>d/dxj(<ui*uj>) real , dimension ( ib : ie + 1 , jb : je , kb : ke ) :: dummyx real , dimension ( ib : ie , jb - 1 : je + 1 , kb : ke ) :: dummyy real , dimension ( ib : ie , jb : je , kb : ke + 1 ) :: dummyz integer i , j , k , ip , im , jp , jm , kp , km real strainav2 real dummy ! Tvav = (Tvm - <ui>*d/dxj(<Sij>)  ) + 2*nu*<Sij'Sij'> ! Tvm = Tvmx + Tvmy + Tvmz -> therefore: subtraction, then interpolation, ! then addition of 2*nu*<Sij'Sij'> do k = kb , ke km = k - 1 kp = k + 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie im = i - 1 ip = i + 1 !            t_vav(i,j,k) =  0.5*( (tvmx(i,j,k) - (                      & dummyx ( i , j , k ) = ( & ( numol * ( uav ( i + 1 , j , k ) - uav ( i , j , k )) * dxfi ( i ) & - numol * ( uav ( i , j , k ) - uav ( i - 1 , j , k )) * dxfi ( i - 1 ) ) * 2. * dxhi ( i ) & + & ( numol * ( ( uav ( i , jp , k ) - uav ( i , j , k )) * dyi & + ( vav ( i , jp , k ) - vav ( i - 1 , jp , k )) * dxhi ( i )) & - numol * ( ( uav ( i , j , k ) - uav ( i , jm , k )) * dyi & + ( vav ( i , j , k ) - vav ( i - 1 , j , k )) * dxhi ( i )) & ) * dyi & + & ( numol * ( ( uav ( i , j , kp ) - uav ( i , j , k )) * dzhi ( kp ) & + ( wav ( i , j , kp ) - wav ( i - 1 , j , kp )) * dxhi ( i )) & - numol * ( ( uav ( i , j , k ) - uav ( i , j , km )) * dzhi ( k ) & + ( wav ( i , j , k ) - wav ( i - 1 , j , k )) * dxhi ( i )) & ) * dzfi ( k ) ) ! y-direction dummyy ( i , j , k ) = ( & ( numol * ( ( vav ( i + 1 , j , k ) - vav ( i , j , k )) * dxhi ( i + 1 ) & + ( uav ( i + 1 , j , k ) - uav ( i + 1 , jm , k )) * dyi ) & - numol * ( ( vav ( i , j , k ) - vav ( i - 1 , j , k )) * dxhi ( i ) & + ( uav ( i , j , k ) - uav ( i , jm , k )) * dyi ) & ) * dxfi ( i ) & ! = d/dx( Km*(dv/dx + du/dy) ) + & ( numol * ( vav ( i , jp , k ) - vav ( i , j , k )) & - numol * ( vav ( i , j , k ) - vav ( i , jm , k )) ) * 2. * dy2i & ! =d/dy( 2*Km*(dv/dy) ) + & ( numol * ( ( vav ( i , j , kp ) - vav ( i , j , k )) * dzhi ( kp ) & + ( wav ( i , j , kp ) - wav ( i , jm , kp )) * dyi ) & - numol * ( ( vav ( i , j , k ) - vav ( i , j , km )) * dzhi ( k ) & + ( wav ( i , j , k ) - wav ( i , jm , k )) * dyi ) & ) * dzfi ( k ) ) ! = d/dz( Km*(dv/dz + dw/dy) ) ! z-direction dummyz ( i , j , k ) = ( & ( numol * ( ( wav ( i + 1 , j , k ) - wav ( i , j , k )) * dxhi ( i + 1 ) & + ( uav ( i + 1 , j , k ) - uav ( i + 1 , j , km )) * dzhi ( k ) ) & - numol * ( ( wav ( i , j , k ) - wav ( i - 1 , j , k )) * dxhi ( i ) & + ( uav ( i , j , k ) - uav ( i , j , km )) * dzhi ( k ) ) & ) * dxfi ( i ) & + & ( numol * ( ( wav ( i , jp , k ) - wav ( i , j , k )) * dyi & + ( vav ( i , jp , k ) - vav ( i , jp , km )) * dzhi ( k ) ) & - numol * ( ( wav ( i , j , k ) - wav ( i , jm , k )) * dyi & + ( vav ( i , j , k ) - vav ( i , j , km )) * dzhi ( k ) ) & ) * dyi & + & ( numol * ( wav ( i , j , kp ) - wav ( i , j , k )) * dzfi ( k ) & - numol * ( wav ( i , j , k ) - wav ( i , j , km )) * dzfi ( km ) ) * 2. & * dzhi ( k )) strainav2 = ( & (( uav ( ip , j , k ) - uav ( i , j , k )) * dxfi ( i ) ) ** 2 + & (( vav ( i , jp , k ) - vav ( i , j , k )) * dyi ) ** 2 + & (( wav ( i , j , kp ) - wav ( i , j , k )) * dzfi ( k ) ) ** 2 ) strainav2 = strainav2 + 0.125 * ( & (( wav ( i , j , kp ) - wav ( im , j , kp )) * dxhi ( i ) + & ( uav ( i , j , kp ) - uav ( i , j , k )) * dzhi ( kp ) ) ** 2 + & (( wav ( i , j , k ) - wav ( im , j , k )) * dxhi ( i ) + & ( uav ( i , j , k ) - uav ( i , j , km )) * dzhi ( k ) ) ** 2 + & (( wav ( ip , j , k ) - wav ( i , j , k )) * dxhi ( ip ) + & ( uav ( ip , j , k ) - uav ( ip , j , km )) * dzhi ( k ) ) ** 2 + & (( wav ( ip , j , kp ) - wav ( i , j , kp )) * dxhi ( ip ) + & ( uav ( ip , j , kp ) - uav ( ip , j , k )) * dzhi ( kp ) ) ** 2 ) strainav2 = strainav2 + 0.125 * ( & (( uav ( i , jp , k ) - uav ( i , j , k )) * dyi + & ( vav ( i , jp , k ) - vav ( im , jp , k )) * dxhi ( i ) ) ** 2 + & (( uav ( i , j , k ) - uav ( i , jm , k )) * dyi + & ( vav ( i , j , k ) - vav ( im , j , k )) * dxhi ( i ) ) ** 2 + & (( uav ( ip , j , k ) - uav ( ip , jm , k )) * dyi + & ( vav ( ip , j , k ) - vav ( i , j , k )) * dxhi ( ip ) ) ** 2 + & (( uav ( ip , jp , k ) - uav ( ip , j , k )) * dyi + & ( vav ( ip , jp , k ) - vav ( i , jp , k )) * dxhi ( ip ) ) ** 2 ) strainav2 = strainav2 + 0.125 * ( & (( vav ( i , j , kp ) - vav ( i , j , k )) * dzhi ( kp ) + & ( wav ( i , j , kp ) - wav ( i , jm , kp )) * dyi ) ** 2 + & (( vav ( i , j , k ) - vav ( i , j , km )) * dzhi ( k ) + & ( wav ( i , j , k ) - wav ( i , jm , k )) * dyi ) ** 2 + & (( vav ( i , jp , k ) - vav ( i , jp , km )) * dzhi ( k ) + & ( wav ( i , jp , k ) - wav ( i , j , k )) * dyi ) ** 2 + & (( vav ( i , jp , kp ) - vav ( i , jp , k )) * dzhi ( kp ) + & ( wav ( i , jp , kp ) - wav ( i , j , kp )) * dyi ) ** 2 ) dissresav ( i , j , k ) = 2. * numol * ( strain2av ( i , j , k ) - strainav2 ) !resolved dissipation end do end do end do ! BC's tvmx ( ie + 1 ,:,:) = tvmx ( ie ,:,:) tsgsmx1 ( ie + 1 ,:,:) = tsgsmx1 ( ie ,:,:) tsgsmx2 ( ie + 1 ,:,:) = tsgsmx2 ( ie ,:,:) dummyx ( ie + 1 ,:,:) = dummyx ( ie ,:,:) ttmx ( ie + 1 ,:,:) = ttmx ( ie ,:,:) call excjs ( tvmy , ib , ie , jb , je , kb , ke , 0 , 1 ) ! jb-1 is not used call excjs ( tsgsmy1 , ib , ie , jb , je , kb , ke , 0 , 1 ) ! jb-1 is not used call excjs ( tsgsmy2 , ib , ie , jb , je , kb , ke , 0 , 1 ) ! jb-1 is not used call excjs ( dummyy , ib , ie , jb , je , kb , ke , 0 , 1 ) ! jb-1 is not used call excjs ( ttmy , ib , ie , jb , je , kb , ke , 0 , 1 ) ! jb-1 is not used tvmz (:,:, ke + 1 ) = tvmz (:,:, ke ) tsgsmz1 (:,:, ke + 1 ) = tsgsmz1 (:,:, ke ) tsgsmz2 (:,:, ke + 1 ) = tsgsmz2 (:,:, ke ) dummyz (:,:, ke + 1 ) = dummyz (:,:, ke ) ttmz (:,:, ke + 1 ) = ttmz (:,:, ke ) do k = kb , ke km = k - 1 kp = k + 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie im = i - 1 ip = i + 1 ! Total viscous dissipation t_vav ( i , j , k ) = 0.5 * ( ( tvmx ( i , j , k ) - dummyx ( i , j , k ) * uav ( i , j , k )) + & ( tvmx ( ip , j , k ) - dummyx ( ip , j , k ) * uav ( ip , j , k ))) & + 0.5 * ( ( tvmy ( i , j , k ) - dummyy ( i , j , k ) * vav ( i , j , k )) + & ( tvmy ( i , jp , k ) - dummyy ( i , jp , k ) * vav ( i , jp , k ))) & + 0.5 * ( ( tvmz ( i , j , k ) - dummyz ( i , j , k ) * wav ( i , j , k )) + & ( tvmz ( i , j , kp ) - dummyz ( i , j , kp ) * wav ( i , j , kp ))) & + dissresav ( i , j , k ) ! d/dxj(2*nu*<ui'Sij'>) = <u_i*d/dxj(2*nu*Sij')> +2*nu*<Sij'Sij'> !      Now the same for subgrid stress !      <d/dxj(2*u_i'*nu_t*Sij)'> = <u_i'*d/dxj(2*nu_t*Sij)'> + <(2*nu_t*Sij)'*Sij'> !                                = <u_i*d/dxj(2*nu_t*Sij)> - !                                  <u_i>*<d/dxj(2*nu_t*Sij)>   + <2*nu_t*Sij*Sij> - !                                  <(2*nu_t*Sij)>*<Sij> !                                = <u_i*d/dxj(2*nu_t*Sij)> - !                                  <u_i>*<d/dxj(2*nu_t*Sij)>   + <2*nu_t*Sij*Sij> - !                                  2*<nu_t>*<Sij>*<Sij> - 2*<nu_t'*Sij'>*<Sij> !--------------------------------------- !Total subgrid TKE !--------------------------------------- ! Mean SGS dissipation disssgsfl ( i , j , k ) = 2. * nusgsav ( i , j , k ) * strainav2 ! = 2*<nu_sgs>*<sij>*<sij> ! TKE tke ( i , j , k ) = 0.5 * ( 0.5 * ( upupav ( ip , j , k ) + upupav ( i , j , k )) + & 0.5 * ( vpvpav ( i , jp , k ) + vpvpav ( i , j , k )) + & 0.5 * ( wpwpav ( i , j , kp ) + wpwpav ( i , j , k ))) ! total SGS t_sgsav ( i , j , k ) = 0.5 * ( ( tsgsmx1 ( i , j , k ) - uav ( i , j , k ) * tsgsmx2 ( i , j , k )) + & ( tsgsmx1 ( ip , j , k ) - uav ( ip , j , k ) * tsgsmx2 ( ip , j , k ))) & + & ! = <2*nu_t*SijSij> - <2*nu_t*Sij>*<Sij> 0.5 * ( ( tsgsmy1 ( i , j , k ) - vav ( i , j , k ) * tsgsmy2 ( i , j , k )) + & ( tsgsmy1 ( i , jp , k ) - vav ( i , jp , k ) * tsgsmy2 ( i , jp , k ))) & + & ! = <2*nu_t*SijSij> - <2*nu_t*Sij>*<Sij> 0.5 * ( ( tsgsmz1 ( i , j , k ) - vav ( i , j , k ) * tsgsmz2 ( i , j , k )) + & ( tsgsmz1 ( i , j , kp ) - vav ( i , j , kp ) * tsgsmz2 ( i , j , kp ))) & + disssgsav ( i , j , k ) - disssgsfl ( i , j , k ) ! -2*<nu_t'Sij'>*<Sij>  should still be added! ! SGS dissipation d_sgsav ( i , j , k ) = - disssgsav ( i , j , k ) + disssgsfl ( i , j , k ) ! +2*<nu_t'Sij'>*<Sij>  should still be added! (is compensated with above) !--------------------------------------- !Total pressure TKE !--------------------------------------- ! Pressure correlation term ! - <uj'*dp'/dxj> = - <uj*dp/dxj> + <uj>*d<p>/dxj t_pav ( i , j , k ) = tpm ( i , j , k ) + & 0.5 * ( uav ( i , j , k ) * ( presav ( i , j , k ) - presav ( i - 1 , j , k )) * dxhi ( i ) + & uav ( i + 1 , j , k ) * ( presav ( i + 1 , j , k ) - presav ( i , j , k )) * dxhi ( i + 1 )) & + & 0.5 * ( vav ( i , j , k ) * ( presav ( i , j , k ) - presav ( i , j - 1 , k )) * dyi + & vav ( i , j + 1 , k ) * ( presav ( i , j + 1 , k ) - presav ( i , j , k )) * dyi ) & + & 0.5 * ( wav ( i , j , k ) * ( presav ( i , j , k ) - presav ( i , j , k - 1 )) * dzhi ( k ) + & wav ( i , j , k + 1 ) * ( presav ( i , j , k + 1 ) - presav ( i , j , k )) * dzhi ( k + 1 )) ! - d/dxj(<0.5*ui'ui'uj'>) = -<uj'd/dxj(<0.5*ui'ui'>) + <ui'uj'><Sij> !                             = -<uj*d/dxj(0.5*ui'ui')> + <uj>*d/dxj(<0.5*ui'ui'> + !                             <ui'uj'><Sij>) !            ttav(i,j,k)   = ttm(i,j,k) - !--------------------------------------- !Total advection TKE !--------------------------------------- !            <advection term N.S. times ui> = MKE + A - Pshear - Tt !            Tt = -<ui'd/dxj(ui'uj')> = -<d/dxj(0.5*ui'ui'uj')> = A + MKE - Pshear - Total !Pshear =Ptav = -<ui'uj'>d/dxj(<Sij>) = -<ui'uj'>d<ui>/dxj ! mechanical or shear production p_tav ( i , j , k ) = - ( & 0.5 * ( upupav ( i , j , k ) + upupav ( ip , j , k )) * ( uav ( ip , j , k ) - uav ( i , j , k )) * dxfi ( i ) + & ! <u'u'>*d<u>/dx 0.25 * ( upvpav ( i , j , k ) * ( uav ( i , j , k ) - uav ( i , jm , k ) ) * dyi + & upvpav ( i , jp , k ) * ( uav ( i , jp , k ) - uav ( i , j , k ) ) * dyi + & upvpav ( ip , j , k ) * ( uav ( ip , j , k ) - uav ( ip , jm , k ) ) * dyi + & upvpav ( ip , jp , k ) * ( uav ( ip , jp , k ) - uav ( ip , j , k ) ) * dyi ) + & ! <u'v'>*d<u>/dy 0.25 * ( upwpav ( i , j , k ) * ( uav ( i , j , k ) - uav ( i , j , km )) * dzhi ( k ) + & upwpav ( i , j , kp ) * ( uav ( i , j , kp ) - uav ( i , j , k )) * dzhi ( kp ) + & upwpav ( ip , j , k ) * ( uav ( ip , j , k ) - uav ( ip , j , km )) * dzhi ( k ) + & upwpav ( ip , j , kp ) * ( uav ( ip , j , kp ) - uav ( ip , j , k )) * dzhi ( kp )) + & ! <u'w'>*d<u>/dz 0.25 * ( upvpav ( i , j , k ) * ( vav ( i , j , k ) - vav ( im , j , k )) * dxhi ( i ) + & upvpav ( ip , j , k ) * ( vav ( ip , j , k ) - vav ( i , j , k )) * dxhi ( ip ) + & upvpav ( i , jp , k ) * ( vav ( i , jp , k ) - vav ( im , jp , k )) * dxhi ( i ) + & upvpav ( ip , jp , k ) * ( vav ( ip , jp , k ) - vav ( i , jp , k )) * dxhi ( ip )) + & ! <u'v'>*d<v>/dx 0.5 * ( vpvpav ( i , j , k ) + vpvpav ( i , jp , k )) * ( vav ( i , jp , k ) - vav ( i , j , k )) * dyi + & ! <v'v'>*d<v>/dy 0.5 * ( vpvpav ( i , j , k ) + vpvpav ( i , jp , k )) * ( vav ( i , jp , k ) - vav ( i , j , k )) * dyi + & ! <v'v'>*d<v>/dy 0.25 * ( vpwpav ( i , j , k ) * ( vav ( i , j , k ) - vav ( i , j , km )) * dzhi ( k ) + & vpwpav ( i , j , kp ) * ( vav ( i , j , kp ) - vav ( i , j , k )) * dzhi ( kp ) + & vpwpav ( i , jp , k ) * ( vav ( i , jp , k ) - vav ( i , jp , km )) * dzhi ( k ) + & vpwpav ( i , jp , kp ) * ( vav ( i , jp , kp ) - vav ( i , jp , k )) * dzhi ( kp )) + & ! <v'w'>*d<v>/dz 0.25 * ( upwpav ( i , j , k ) * ( wav ( i , j , k ) - wav ( im , j , k )) * dxhi ( i ) + & upwpav ( ip , j , k ) * ( wav ( ip , j , k ) - wav ( i , j , k )) * dxhi ( ip ) + & upwpav ( i , j , kp ) * ( wav ( i , j , kp ) - wav ( im , j , kp )) * dxhi ( i ) + & upwpav ( ip , j , kp ) * ( wav ( ip , j , kp ) - wav ( i , j , kp )) * dxhi ( ip )) + & ! <u'w'>*d<w>/dx 0.25 * ( vpwpav ( i , j , k ) * ( wav ( i , j , k ) - wav ( i , jm , k ) ) * dyi + & vpwpav ( i , jp , k ) * ( wav ( i , jp , k ) - wav ( i , j , k ) ) * dyi + & vpwpav ( ip , j , k ) * ( wav ( i , j , kp ) - wav ( i , jm , kp ) ) * dyi + & vpwpav ( ip , jp , k ) * ( wav ( i , jp , kp ) - wav ( i , j , kp ) ) * dyi ) + & ! <v'w'>*d<w>/dy 0.5 * ( wpwpav ( i , j , k ) + wpwpav ( i , j , kp )) * ( wav ( i , j , kp ) - wav ( i , j , k )) * dzfi ( k ) ) ! <w'w'>*d<w>/dz ! Mean kinetic energy term (expected to be small). mke ( i , j , k ) = 0.5 * ( uav ( ip , j , k ) + uav ( i , j , k )) * ( uuav ( ip , j , k ) - uuav ( i , j , k )) * dxfi ( i ) + & !<u>*d<uu>/dx 0.5 * ( uav ( i , j , k ) * ( uvav ( i , jp , k ) - uvav ( i , j , k )) * dyi + & ! <u>*d<uv>/dy uav ( ip , j , k ) * ( uvav ( ip , jp , k ) - uvav ( ip , j , k )) * dyi ) + & 0.5 * ( uav ( i , j , k ) * ( uwav ( i , j , kp ) - uwav ( i , j , k )) * dzfi ( k ) + & ! <u>*d<uw>/dz uav ( ip , j , k ) * ( uwav ( ip , j , kp ) - uwav ( ip , j , k )) * dzfi ( k )) + & 0.5 * ( vav ( i , j , k ) * ( uvav ( ip , j , k ) - uvav ( i , j , k )) * dxfi ( i ) + & ! <v>*d<uv>/dx vav ( i , jp , k ) * ( uvav ( ip , jp , k ) - uvav ( i , jp , k )) * dxfi ( i )) + & 0.5 * ( vav ( i , jp , k ) + vav ( i , j , k )) * ( vvav ( i , jp , k ) - vvav ( i , j , k )) * dyi + & ! <v>*d<vv>/dy 0.5 * ( vav ( i , j , k ) * ( vwav ( i , j , kp ) - vwav ( i , j , k )) * dzfi ( k ) + & ! <v>*d<vw>/dz vav ( i , jp , k ) * ( vwav ( i , jp , kp ) - vwav ( i , jp , k )) * dzfi ( k )) + & 0.5 * ( wav ( i , j , k ) * ( uwav ( ip , j , k ) - uwav ( i , j , k )) * dxfi ( i ) + & ! <w>*d<uw>/dx wav ( i , j , kp ) * ( uwav ( ip , j , kp ) - uwav ( i , j , kp )) * dxfi ( i )) + & 0.5 * ( wav ( i , j , k ) * ( vwav ( i , jp , k ) - vwav ( i , j , k )) * dyi + & ! <w>*d<vw>/dy wav ( i , j , kp ) * ( vwav ( i , jp , kp ) - vwav ( i , j , kp )) * dyi ) + & 0.5 * ( wav ( i , j , kp ) + wav ( i , j , k )) * ( wwav ( i , j , kp ) - wwav ( i , j , k )) * dzfi ( k ) ! <w>*d<ww>/dz ! Advection of TKE tkeadv ( i , j , k ) = 0.5 * ( uav ( i , j , k ) * ( tke ( i , j , k ) - tke ( im , j , k )) * dxhi ( i ) + & ! <u>*de/dx uav ( ip , j , k ) * ( tke ( ip , j , k ) - tke ( i , j , k )) * dxhi ( ip )) + & ! 0.5 * ( vav ( i , j , k ) * ( tke ( i , j , k ) - tke ( i , jm , k )) * dyi + & ! <v>*de/dy vav ( i , jp , k ) * ( tke ( i , jp , k ) - tke ( i , j , k )) * dyi ) + & 0.5 * ( wav ( i , j , k ) * ( tke ( i , j , k ) - tke ( i , j , km )) * dzhi ( k ) + & ! <w>*de/dz wav ( i , j , kp ) * ( tke ( i , j , kp ) - tke ( i , j , k )) * dzhi ( kp )) ! <advection term N.S. times ui> = MKE + A - Pshear - Tt ! Tt = -<ui'd/dxj(ui'uj')> = -<d/dxj(0.5*ui'ui'uj')> = A      +    MKE   - ! Pshear  -   Total !                                                    = tkeadv +    mke   - !                                                    p_tav   -   ttm !        t_tav(i,j,k)   = tkeadv(i,j,k) + mke(i,j,k) - p_tav(i,j,k) - ttm(i,j,k) t_tav ( i , j , k ) = tkeadv ( i , j , k ) + mke ( i , j , k ) - p_tav ( i , j , k ) & - 0.5 * ( ttmx ( i , j , k ) + ttmx ( ip , j , k )) & - 0.5 * ( ttmy ( i , j , k ) + ttmy ( i , jp , k )) & - 0.5 * ( ttmz ( i , j , k ) + ttmz ( i , j , kp )) p_bav ( i , j , k ) = ( grav / thls ) * 0.5 * ( thlpwpav ( i , j , k ) + thlpwpav ( i , j , kp )) !use of thls here...???? end do end do end do ! need updating tg3315 call avexy_ibm ( p_b ( kb : ke + kh ), p_bav (:,:, kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc , IIcs ,. true .) call avexy_ibm ( t_p ( kb : ke + kh ), t_pav (:,:, kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc , IIcs ,. true .) call avexy_ibm ( adv ( kb : ke + kh ), tkeadv (:,:, kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc , IIcs ,. true .) call avexy_ibm ( t_t ( kb : ke + kh ), t_tav (:,:, kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc , IIcs ,. true .) call avexy_ibm ( t_sgs ( kb : ke + kh ), t_sgsav (:,:, kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc , IIcs ,. true .) call avexy_ibm ( p_t ( kb : ke + kh ), p_tav (:,:, kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc , IIcs ,. true .) call avexy_ibm ( d_sgs ( kb : ke + kh ), d_sgsav (:,:, kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc , IIcs ,. true .) call avexy_ibm ( t_v ( kb : ke + kh ), t_vav (:,:, kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc , IIcs ,. true .) end subroutine tkestatsdump","tags":"","loc":"proc/tkestatsdump.html"},{"title":"exitstatsdump – uDALES","text":"public subroutine exitstatsdump() Uses modstat_nc modglobal proc~~exitstatsdump~~UsesGraph proc~exitstatsdump exitstatsdump module~modstat_nc modstat_nc proc~exitstatsdump->module~modstat_nc module~modglobal modglobal proc~exitstatsdump->module~modglobal module~modmpi modmpi module~modstat_nc->module~modmpi netcdf netcdf module~modstat_nc->netcdf mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~exitstatsdump~~CalledByGraph proc~exitstatsdump exitstatsdump program~dalesurban DALESURBAN program~dalesurban->proc~exitstatsdump Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code exitstatsdump Source Code subroutine exitstatsdump use modstat_nc , only : exitstat_nc use modglobal , only : lslicedump , ltdump implicit none !       if (lydump) then !         call exitstat_nc(ncid) !       endif ! will doing this ruin the averaging? ... try tg3315 !       if (lytdump) then !         call exitstat_nc(ncidt) !       endif !      if (ltkedump) then !        call exitstat_nc(ncidtke) !      endif !      if (lslicedump) then !        call exitstat_nc(ncidslice) !      endif !       if (ltdump) then !         call exitstat_nc(ncidt) !       endif end subroutine exitstatsdump","tags":"","loc":"proc/exitstatsdump.html"},{"title":"initglobal – uDALES","text":"public subroutine initglobal() Uses modmpi proc~~initglobal~~UsesGraph proc~initglobal initglobal module~modmpi modmpi proc~initglobal->module~modmpi mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~initglobal~~CallsGraph proc~initglobal initglobal float float proc~initglobal->float mpi_bcast mpi_bcast proc~initglobal->mpi_bcast Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~initglobal~~CalledByGraph proc~initglobal initglobal proc~startup startup proc~startup->proc~initglobal program~dalesurban DALESURBAN program~dalesurban->proc~startup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code initglobal Source Code subroutine initglobal use modmpi , only : nprocs , myid , comm3d , my_real , mpierr implicit none integer :: advarr ( 4 ) real phi , colat , silat , omega , omega_gs integer :: i , k , n character ( 80 ) chmess !timestepping if ( courant < 0 ) then select case ( iadv_mom ) case ( iadv_cd2 ) courant = 1.5 case default courant = 1.4 end select if ( any ( iadv_sv ( 1 : nsv ) == iadv_kappa ) . or . any (( / iadv_thl , iadv_qt , iadv_tke / ) == iadv_kappa )) then courant = min ( courant , 1.1 ) elseif ( any ( iadv_sv ( 1 : nsv ) == iadv_upw ) . or . any (( / iadv_thl , iadv_qt , iadv_tke / ) == iadv_upw )) then courant = min ( courant , 1.1 ) elseif ( any ( iadv_sv ( 1 : nsv ) == iadv_cd2 ) . or . any (( / iadv_thl , iadv_qt , iadv_tke / ) == iadv_cd2 )) then courant = min ( courant , 1.5 ) end if end if ! phsgrid jmax = jtot / nprocs isen = imax / nprocs jsen = jmax !set the number of ghost cells. NB: This switch has to run in order of required ghost cells advarr = ( / iadv_mom , iadv_tke , iadv_thl , iadv_qt / ) if ( any ( advarr == iadv_kappa )) then ih = 2 jh = 2 ! ih = 1 ! jh = 1 kh = 1 elseif ( any ( advarr == iadv_cd2 ) . or . any ( iadv_sv ( 1 : nsv ) == iadv_cd2 )) then ih = 1 jh = 1 kh = 1 ihc = 1 jhc = 1 khc = 1 end if ! J. Tomas added this for using only kappa scheme for sv(:) if ( any ( iadv_sv ( 1 : nsv ) == iadv_kappa )) then ihc = 2 jhc = 2 khc = 2 end if offset = 1 ib = 2 - offset ie = imax + 1 - offset jb = 2 - offset je = jmax + 1 - offset jgb = jb ! global j range (starting at the same as j as the processor j range) jge = jtot + 1 - offset ! global j range kb = 1 - offset ke = kmax - offset ! Global constants ! Select advection scheme for scalars. If not set in the options file, the momentum scheme is used if ( iadv_tke < 0 ) iadv_tke = iadv_mom if ( iadv_thl < 0 ) iadv_thl = iadv_mom if ( iadv_qt < 0 ) iadv_qt = iadv_mom !CvH remove where !where (iadv_sv<0)  iadv_sv  = iadv_mom !tg3315 added - only uses kappa advection scheme... do n = 1 , nsv iadv_sv ( n ) = iadv_kappa end do !ends here phi = xlat * pi / 18 0. colat = cos ( phi ) silat = sin ( phi ) omega = 7.292e-5 omega_gs = 7.292e-5 om22 = 2. * omega * colat om23 = 2. * omega * silat om22_gs = 2. * omega_gs * colat om23_gs = 2. * omega_gs * silat ! Variables allocate ( dsv ( nsv )) write ( cexpnr , '(i3.3)' ) iexpnr ! Create the physical grid variables allocate ( dzf ( kb - kh : ke + kh )) allocate ( dzf2 ( kb - kh : ke + kh )) allocate ( dzfi ( kb - kh : ke + kh )) allocate ( dzfiq ( kb - kh : ke + kh )) allocate ( dzfi5 ( kb - kh : ke + kh )) allocate ( dzh ( kb : ke + kh )) allocate ( dzhi ( kb : ke + kh )) allocate ( dzhiq ( kb : ke + kh )) allocate ( dzh2i ( kb : ke + kh )) allocate ( zh ( kb : ke + kh )) allocate ( zf ( kb : ke + kh )) allocate ( dxf ( ib - ih : ie + ih )) allocate ( dxf2 ( ib - ih : ie + ih )) allocate ( dxfi ( ib - ih : ie + ih )) allocate ( dxfiq ( ib - ih : ie + ih )) allocate ( dxfi5 ( ib - ih : ie + ih )) allocate ( dxh ( ib : ie + ih )) allocate ( dxhi ( ib : ie + ih )) allocate ( dxhiq ( ib : ie + ih )) allocate ( dxh2i ( ib : ie + ih )) allocate ( xh ( ib : ie + ih )) allocate ( xf ( ib : ie + ih )) allocate ( delta ( ib - ih : ie + ih , kb : ke + kh )) rslabs = real ( imax * jtot ) dy = ysize / float ( jtot ) ! MPI ! Note, that the loop for reading zf and calculating zh ! has been split so that reading is only done on PE 1 if ( myid == 0 ) then open ( ifinput , file = 'prof.inp.' // cexpnr ) read ( ifinput , '(a72)' ) chmess read ( ifinput , '(a72)' ) chmess do k = kb , ke read ( ifinput , * ) zf ( k ) end do close ( ifinput ) ! J. Tomas: Read the x-coordinates of the cell centers from xgrid.inp.XXX open ( ifinput , file = 'xgrid.inp.' // cexpnr ) read ( ifinput , '(a72)' ) chmess read ( ifinput , '(a72)' ) chmess do i = ib , ie read ( ifinput , * ) xf ( i ) end do close ( ifinput ) end if ! end if myid==0 ! MPI broadcast kmax elements from zf call MPI_BCAST ( zf , kmax , MY_REAL , 0 , comm3d , mpierr ) ! MPI broadcast imax elements from xf call MPI_BCAST ( xf , imax , MY_REAL , 0 , comm3d , mpierr ) zh ( kb ) = 0.0 do k = kb , ke zh ( k + 1 ) = zh ( k ) + 2.0 * ( zf ( k ) - zh ( k )) end do zf ( ke + kh ) = zf ( ke ) + 2.0 * ( zh ( ke + kh ) - zf ( ke )) do k = kb , ke dzf ( k ) = zh ( k + 1 ) - zh ( k ) end do dzf ( ke + 1 ) = dzf ( ke ) dzf ( kb - 1 ) = dzf ( kb ) dzh ( kb ) = 2 * zf ( kb ) do k = kb + 1 , ke + kh dzh ( k ) = zf ( k ) - zf ( k - 1 ) end do ! j. tomas: same trick for x-direction... xh ( ib ) = 0.0 do i = ib , ie xh ( i + 1 ) = xh ( i ) + 2.0 * ( xf ( i ) - xh ( i )) end do xf ( ie + ih ) = xf ( ie ) + 2.0 * ( xh ( ie + ih ) - xf ( ie )) do i = ib , ie dxf ( i ) = xh ( i + 1 ) - xh ( i ) end do dxf ( ie + 1 ) = dxf ( ie ) dxf ( ib - 1 ) = dxf ( ib ) dxh ( ib ) = 2 * xf ( ib ) do i = ib + 1 , ie + ih dxh ( i ) = xf ( i ) - xf ( i - 1 ) end do do k = kb , ke + kh do i = ib - ih , ie + ih delta ( i , k ) = ( dxf ( i ) * dy * dzf ( k )) ** ( 1. / 3. ) end do end do !-------------------------------------------------- ! *** Check whether the grid is equidistant ***** !-------------------------------------------------- !if (myid == 0) then !do k=kb,ke+kh !if (.not.(dzf(k).eq.dzf(1))) !      write (6, *) & !      'WARNING, You are working with a non-equidistant grid!!!!' !end if !end do !end if ! end if myid==0 dzhi = 1. / dzh dzfi = 1. / dzf dzf2 = dzf * dzf dxhi = 1. / dxh dxfi = 1. / dxf dxf2 = dxf * dxf dyi = 1. / dy dy2 = dy * dy dzhiq = 0.25 * dzhi dzfiq = 0.25 * dzfi dxhiq = 0.25 * dxhi dxfiq = 0.25 * dxfi dyiq = 0.25 * dyi dzh2i = dzhi * dzhi dxh2i = dxhi * dxhi dy2i = dyi * dyi dzfi5 = 0.5 * dzfi dxfi5 = 0.5 * dxfi dyi5 = 0.5 * dyi ! Grid used in kappa scheme advection (extra ghost nodes) if ( any ( iadv_sv ( 1 : nsv ) == iadv_kappa )) then allocate ( dzfc ( kb - khc : ke + khc )) allocate ( dxfc ( ib - ihc : ie + ihc )) allocate ( dzfci ( kb - khc : ke + khc )) allocate ( dxfci ( ib - ihc : ie + ihc )) allocate ( dzhci ( kb - 1 : ke + khc )) allocate ( dxhci ( ib - 1 : ie + ihc )) dzfc ( kb - kh : ke + kh ) = dzf ( kb - kh : ke + kh ) dzfc ( kb - khc ) = dzfc ( kb - kh ) dzfc ( ke + khc ) = dzfc ( ke + kh ) dxfc ( ib - ih : ie + ih ) = dxf ( ib - ih : ie + ih ) dxfc ( ib - ihc ) = dxfc ( ib - ih ) dxfc ( ie + ihc ) = dxfc ( ie + ih ) dzhci ( kb : ke + kh ) = dzhi ( kb : ke + kh ) dzhci ( kb - 1 ) = dzhci ( kb ) dzhci ( ke + khc ) = dzhci ( ke + kh ) dxhci ( ib : ie + ih ) = dxhi ( ib : ie + ih ) dxhci ( ib - 1 ) = dxhci ( ib ) dxhci ( ie + ihc ) = dxhci ( ie + ih ) dzfci = 1. / dzfc dxfci = 1. / dxfc end if if ( myid == 0 ) then write ( 6 , * ) 'lev    dz     zf      zh       dzh    delta(ib,k)' do k = ke + 1 , kb , - 1 write ( 6 , '(i4,5f8.5)' ) k , dzf ( k ), zf ( k ), zh ( k ), dzh ( k ), delta ( ib , k ) end do ! same for x: write ( 6 , * ) 'lev    dxf     xf      xh       dxh    delta(i,kb)' do i = ie + 1 , ib , - 1 write ( 6 , '(i4,5f9.5)' ) i , dxf ( i ), xf ( i ), xh ( i ), dxh ( i ), delta ( i , kb ) end do end if tnextrestart = trestart tnextfielddump = tfielddump !    tnextstatsdump = tstatsdump timeleft = runtime ! tg3315 previously btime + runtime end subroutine initglobal","tags":"","loc":"proc/initglobal.html"},{"title":"exitglobal – uDALES","text":"public subroutine exitglobal() Arguments None Called by proc~~exitglobal~~CalledByGraph proc~exitglobal exitglobal proc~exitmodules exitmodules proc~exitmodules->proc~exitglobal program~dalesurban DALESURBAN program~dalesurban->proc~exitmodules Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code exitglobal Source Code subroutine exitglobal deallocate ( dsv , dzf , dzh , zh , zf , delta ) end subroutine exitglobal","tags":"","loc":"proc/exitglobal.html"},{"title":"createwalls – uDALES","text":"public subroutine createwalls() Uses modglobal modsurfdata modfields modmpi initfac proc~~createwalls~~UsesGraph proc~createwalls createwalls module~modsurfdata modsurfdata proc~createwalls->module~modsurfdata module~modmpi modmpi proc~createwalls->module~modmpi module~initfac initfac proc~createwalls->module~initfac module~modfields modfields proc~createwalls->module~modfields module~modglobal modglobal proc~createwalls->module~modglobal mpi mpi module~modmpi->mpi module~initfac->module~modmpi module~initfac->module~modglobal netcdf netcdf module~initfac->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~createwalls~~CalledByGraph proc~createwalls createwalls program~dalesurban DALESURBAN program~dalesurban->proc~createwalls Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code createwalls Source Code subroutine createwalls use modglobal , only : ib , ie , jb , je , jgb , jge , kb , ke , jmax , nblocks , & nsv , cexpnr , ifinput , libm , ih , kh , iwallmom , iwalltemp , iwallmoist , rslabs , bldT use modsurfdata , only : thls , z0h , z0 , thvs use modfields , only : sv0 , svm , thl0 , thlm , qtp , qt0 , IIc , IIu , IIv , IIw , IIct , IIwt , IIcs , IIus , IIvs , IIws use modmpi , only : myid , comm3d , mpierr , MPI_INTEGER , MPI_DOUBLE_PRECISION , MY_REAL , nprocs , cmyid , & MPI_REAL8 , MPI_REAL4 , MPI_SUM use initfac , only : block integer n , nn , pn , mn , jbeg , jend , nxn , nxs , nyn , nzn , nzs , iu , il , ju , jl , ku , kl , sc , & i , k , dbi , dbj , dbk integer :: IIcl ( kb : ke + kh ), IIul ( kb : ke + kh ), IIvl ( kb : ke + kh ), IIwl ( kb : ke + kh ) integer :: IIcd ( ib - ih : ie + ih , kb : ke + kh ) integer :: IIwd ( ib - ih : ie + ih , kb : ke + kh ) character ( 80 ) chmess , name2 if (. not . libm ) return ! check if walls are at least 2 cells in each dimension do n = 1 , nblocks dbi = block ( n , 2 ) - block ( n , 1 ) dbj = block ( n , 4 ) - block ( n , 3 ) dbk = block ( n , 6 ) - block ( n , 5 ) if ( any (( / dbi , dbj , dbk / ) < 1 )) then write ( 6 , * ) \"blocks not at least 2 cells in each dimension, or upper limit < lower limit\" !stop  !ils13 19.07.17, don't stop for now end if end do ! For all blocks set the internal concentrations to zero and internal ! temperature to building temperature do n = 1 , nblocks il = block ( n , 1 ) iu = block ( n , 2 ) kl = block ( n , 5 ) ku = block ( n , 6 ) jl = block ( n , 3 ) - myid * jmax ju = block ( n , 4 ) - myid * jmax if (( ju < jb - 1 ) . or . ( jl > je + 1 )) then ! The block is entirely out of this partition cycle end if if ( ju > je ) ju = je !tg3315 and bss116 added 23.10.18 as bad allocation otherwise. if ( jl < jb ) jl = jb do sc = 1 , nsv !sv0(il:iu, jl:ju, kl:ku, sc) = svprof(kl:ku)  !internal ! tg3315 commented to avoid flux at startup !svm(il:iu, jl:ju, kl:ku, sc) = svprof(kl:ku)  !internal end do thl0 ( il : iu , jl : ju , kl : ku ) = bldT !internal ! make sure bldT is equal to init thl prof thlm ( il : iu , jl : ju , kl : ku ) = bldT !internal end do nxwall = 0 do n = 1 , nblocks ! first x and z walls if ( block ( n , 4 ) < jb + myid * jmax ) then ! no x-wall/z-wall in the range of this proc cycle elseif ( block ( n , 3 ) > je + myid * jmax ) then ! no x-wall/z-wall in the range of this proc cycle else ! x-wall/z-wall found on this proc nxwall = nxwall + 1 end if end do allocate ( ixwall ( nxwall )) !allocate the list that stores the indeces of the blocks on this cpu k = 1 do n = 1 , nblocks ! save indeces of the found x/z-walls by re-iterating if ( block ( n , 4 ) < jb + myid * jmax ) then ! no x-wall/z-wall in the range of this proc cycle elseif ( block ( n , 3 ) > je + myid * jmax ) then ! no x-wall/z-wall in the range of this proc cycle else ixwall ( k ) = n ! save index of block which is on this processor k = k + 1 end if end do !!new approach both y walls################################################# !!store index of block and index of the wall (since block might not be on this cpu, but is needed for x and z coords) !!check if wall is on next cpu but not on this !!check if wall is on last cpu but not on first (periodicity in y) !check if wall is on first cpu but not on last (periodicity in y) !!check if wall is on this cpu and another one on the next (i.e. both blocks end at cpu boundary, but touch each other) nyminwall = 0 nypluswall = 0 do n = 1 , nblocks jl = block ( n , 3 ) - myid * jmax ju = block ( n , 4 ) - myid * jmax !IMPORTANT: THESE LINES OF CODE SHOULD BE HERE BUT CAUSE TROUBLE! MAKE SURE BLOCK DOES NOT TOUCH BOUNDARY (EXCECPT ALL FLOORS) !SEE ALSO BELOW! (Like 40 lines or so) if (( myid == 0 ) . and . ( block ( n , 4 ) == jge )) then ! periodicity! nypluswall = nypluswall + 1 else if (( block ( n , 3 ) == jgb ) . and . ( myid == ( nprocs - 1 ))) then ! periodicity! nyminwall = nyminwall + 1 end if if (( ju < ( jb - 1 )) . or . ( jl > ( je + 1 ))) then cycle end if if ( ju == ( jb - 1 )) then !block on previous cpu, north wall on this nypluswall = nypluswall + 1 ! cycle end if if ( jl == ( je + 1 )) then nyminwall = nyminwall + 1 !block on next cpu, southwall on this cycle end if if (( ju < je ) . and . ( ju >= jb )) then !block & northwall on this cpu nypluswall = nypluswall + 1 end if if (( jl > jb ) . and . ( jl <= je )) then !block & southwall on this cpu nyminwall = nyminwall + 1 end if end do allocate ( iyminwall ( 1 : nyminwall , 1 : 2 )) !two indeces to store wall index and block index allocate ( iypluswall ( 1 : nypluswall , 1 : 2 )) iyminwall (:, 1 ) = 0 iyminwall (:, 2 ) = 0 iypluswall (:, 1 ) = 0 iypluswall (:, 2 ) = 0 pn = 1 mn = 1 do n = 1 , nblocks jl = block ( n , 3 ) - myid * jmax ju = block ( n , 4 ) - myid * jmax !IMPORTANT: THESE LINES OF CODE SHOULD BE HERE BUT CAUSE TROUBLE! MAKE SURE BLOCK DOES NOT TOUCH BOUNDARY (EXCECPT ALL FLOORS) if (( myid == 0 ) . and . ( block ( n , 4 ) == jge )) then ! periodicity! iypluswall ( pn , 1 ) = n iypluswall ( pn , 2 ) = jb pn = pn + 1 else if (( block ( n , 3 ) == jgb ) . and . ( myid == ( nprocs - 1 ))) then ! periodicity! iyminwall ( mn , 1 ) = n iyminwall ( mn , 2 ) = je mn = mn + 1 end if if (( ju < ( jb - 1 )) . or . ( jl > ( je + 1 ))) then cycle end if if ( ju == ( jb - 1 )) then !block on previous cpu, north wall on this iypluswall ( pn , 1 ) = n iypluswall ( pn , 2 ) = jb pn = pn + 1 cycle end if if ( jl == ( je + 1 )) then !block on next cpu, south wall on this iyminwall ( mn , 1 ) = n iyminwall ( mn , 2 ) = je mn = mn + 1 cycle end if if (( ju < je ) . and . ( ju >= jb )) then !block & northwall on this cpu   !ILS13, 5.12.17 following Tom iypluswall ( pn , 1 ) = n iypluswall ( pn , 2 ) = ju + 1 pn = pn + 1 end if if (( jl > jb ) . and . ( jl <= je )) then !block & southwall on this cpu iyminwall ( mn , 1 ) = n iyminwall ( mn , 2 ) = jl - 1 mn = mn + 1 end if end do end subroutine createwalls","tags":"","loc":"proc/createwalls.html"},{"title":"ibmwallfun – uDALES","text":"public subroutine ibmwallfun() Uses modglobal modfields proc~~ibmwallfun~~UsesGraph proc~ibmwallfun ibmwallfun module~modfields modfields proc~ibmwallfun->module~modfields module~modglobal modglobal proc~ibmwallfun->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~ibmwallfun~~CallsGraph proc~ibmwallfun ibmwallfun proc~xwallfun xwallfun proc~ibmwallfun->proc~xwallfun proc~ywallfunmin ywallfunmin proc~ibmwallfun->proc~ywallfunmin proc~zwallfun zwallfun proc~ibmwallfun->proc~zwallfun proc~ywallfunplus ywallfunplus proc~ibmwallfun->proc~ywallfunplus proc~ywallscalarmin ywallscalarmin proc~ywallfunmin->proc~ywallscalarmin proc~ywallscalarplus ywallscalarplus proc~ywallfunplus->proc~ywallscalarplus Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ibmwallfun~~CalledByGraph proc~ibmwallfun ibmwallfun program~dalesurban DALESURBAN program~dalesurban->proc~ibmwallfun Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ibmwallfun Source Code subroutine ibmwallfun use modglobal , only : libm use modfields , only : momfluxb , tfluxb , qfluxb if ( libm ) then ! compute fluxes at IBM momfluxb = 0. tfluxb = 0. qfluxb = 0. call xwallfun call ywallfunplus ! due to parallellisation differentiation between + and - side call ywallfunmin ! due to parallellisation differentiation between + and - side call zwallfun end if end subroutine ibmwallfun","tags":"","loc":"proc/ibmwallfun.html"},{"title":"xwallfun – uDALES","text":"public subroutine xwallfun() Uses modglobal modfields initfac proc~~xwallfun~~UsesGraph proc~xwallfun xwallfun module~modfields modfields proc~xwallfun->module~modfields module~initfac initfac proc~xwallfun->module~initfac module~modglobal modglobal proc~xwallfun->module~modglobal module~initfac->module~modglobal module~modmpi modmpi module~initfac->module~modmpi netcdf netcdf module~initfac->netcdf mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~xwallfun~~CalledByGraph proc~xwallfun xwallfun proc~ibmwallfun ibmwallfun proc~ibmwallfun->proc~xwallfun program~dalesurban DALESURBAN program~dalesurban->proc~ibmwallfun Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code xwallfun Source Code subroutine xwallfun use modglobal , only : dzf , dzhiq , dzhi , dxf , dxfi , dxhi , dyi , lles , nsv , numol , ltempeq , lmoist , & ih , jh , kh , ihc , jhc , khc , dxh , dy , dt , totavtime , rk3step , ib , ie , kb , ke , iwallmom , iwalltemp , iwallmoist , iwallscal , nblocks use modfields , only : um , up , v0 , w0 , vp , wp , shear , thl0 , thlp , qt0 , qtp , sv0 , svp , momfluxb , tfluxb , exnf , cth , qfluxb use initfac , only : fachf , block , faclGR , facef , facqsat , fachurel , facf , facT , facz0 , facz0h integer i , j , k , n , nc , jl , ju , kl , ku , im , jm , jp , km , m if ( iwallmom == 1 ) then !fixed flux !not implemented else if ( iwallmom == 2 ) then !wall function do n = 1 , nxwall k = block ( ixwall ( n ), 8 ) !west side call wfuno ( ih , jh , kh , vp , wp , thlp , momfluxb , tfluxb , cth , bcTfluxA , v0 , w0 , thl0 , facT ( k , 1 ), facz0 ( k ), facz0h ( k ), ixwall ( n ), 1 , 11 ) k = block ( ixwall ( n ), 9 ) !east side call wfuno ( ih , jh , kh , vp , wp , thlp , momfluxb , tfluxb , cth , bcTfluxA , v0 , w0 , thl0 , facT ( k , 1 ), facz0 ( k ), facz0h ( k ), ixwall ( n ), 1 , 21 ) end do else if ( iwallmom == 3 ) then do n = 1 , nxwall k = block ( ixwall ( n ), 8 ) !west side call wfmneutral ( ih , jh , kh , vp , wp , momfluxb , v0 , w0 , facz0 ( k ), ixwall ( n ), 1 , 11 ) k = block ( ixwall ( n ), 9 ) !east side call wfmneutral ( ih , jh , kh , vp , wp , momfluxb , v0 , w0 , facz0 ( k ), ixwall ( n ), 1 , 21 ) end do end if if ( ltempeq ) then if ( iwalltemp == 1 ) then !fixed flux do n = 1 , nxwall call xwallscalar ( ih , jh , kh , thl0 , thlp , bctfxm , bctfxp , ixwall ( n )) end do else if ( iwalltemp == 2 ) then do n = 1 , nxwall k = block ( ixwall ( n ), 8 ) !west side call wfuno ( ih , jh , kh , vp , wp , thlp , momfluxb , tfluxb , cth , bcTfluxA , v0 , w0 , thl0 , facT ( k , 1 ), facz0 ( k ), facz0h ( k ), ixwall ( n ), 1 , 12 ) !left wall fachf ( k ) = fachf ( k ) + bcTfluxA !accumulate flux from that facet (can be on multiple processors, will be MPI_ALLREDUCEd in modEB) k = block ( ixwall ( n ), 9 ) !east side call wfuno ( ih , jh , kh , vp , wp , thlp , momfluxb , tfluxb , cth , bcTfluxA , v0 , w0 , thl0 , facT ( k , 1 ), facz0 ( k ), facz0h ( k ), ixwall ( n ), 1 , 22 ) !right wall fachf ( k ) = fachf ( k ) + bcTfluxA end do end if end if if ( lmoist ) then if ( iwallmoist == 1 ) then !fixed flux do n = 1 , nxwall call xwallscalar ( ih , jh , kh , qt0 , qtp , bcqfxm , bcqfxp , ixwall ( n )) end do end if if (( ltempeq ) . and . ( iwallmoist == 2 )) then do n = 1 , nxwall k = block ( ixwall ( n ), 8 ) if ( faclGR ( k )) then !only if it is a vegetated surface call wfGR ( ih , jh , kh , qtp , qfluxb , cth , bcqfluxA , qt0 (:, :, :), facqsat ( k ), fachurel ( k ), facf ( k , 4 ), facf ( k , 5 ), ixwall ( n ), 1 , 12 ) !left wall facef ( k ) = facef ( k ) + bcqfluxA end if k = block ( ixwall ( n ), 9 ) if ( faclGR ( k )) then call wfGR ( ih , jh , kh , qtp , qfluxb , cth , bcqfluxA , qt0 (:, :, :), facqsat ( k ), fachurel ( k ), facf ( k , 4 ), facf ( k , 5 ), ixwall ( n ), 1 , 22 ) !right wall facef ( k ) = facef ( k ) + bcqfluxA end if end do end if end if if ( nsv > 0 ) then if ( iwallscal == 1 ) then !fixed flux do n = 1 , nxwall do m = 1 , nsv call xwallscalar ( ihc , jhc , khc , sv0 (:,:,:, m ), svp (:,:,:, m ), 0. , 0. , ixwall ( n )) end do end do end if end if end subroutine xwallfun","tags":"","loc":"proc/xwallfun.html"},{"title":"xwallscalar – uDALES","text":"public subroutine xwallscalar(hi, hj, hk, putin, putout, bcvaluem, bcvaluep, n) Uses modglobal modfields modmpi modsubgriddata initfac proc~~xwallscalar~~UsesGraph proc~xwallscalar xwallscalar module~modmpi modmpi proc~xwallscalar->module~modmpi module~modsubgriddata modsubgriddata proc~xwallscalar->module~modsubgriddata module~initfac initfac proc~xwallscalar->module~initfac module~modfields modfields proc~xwallscalar->module~modfields module~modglobal modglobal proc~xwallscalar->module~modglobal mpi mpi module~modmpi->mpi module~initfac->module~modmpi module~initfac->module~modglobal netcdf netcdf module~initfac->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: hi integer, intent(in) :: hj integer, intent(in) :: hk real, intent(in) :: putin (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(inout) :: putout (ib-hi:ie+hi,jb-hj:je+hj,kb:ke+hk) real, intent(in) :: bcvaluem real, intent(in) :: bcvaluep integer, intent(in) :: n Contents Source Code xwallscalar Source Code subroutine xwallscalar ( hi , hj , hk , putin , putout , bcvaluem , bcvaluep , n ) use modglobal , only : jmax , dxf , dxfi , dxfi5 , dxhi , dxh2i , nsv , ib , ie , jb , je , kb , ke , prandtlmoli , numol use modfields , only : u0 use modmpi , only : myid use modsubgriddata , only : ekh use initfac , only : block integer i , j , k , jl , ju , kl , ku , iww , iee integer , intent ( in ) :: hi !<size of halo in i integer , intent ( in ) :: hj !<size of halo in j integer , intent ( in ) :: hk !<size of halo in k real , intent ( in ) :: putin ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) real , intent ( inout ) :: putout ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) real , intent ( in ) :: bcvaluem , bcvaluep integer , intent ( in ) :: n iww = block ( n , 1 ) - 1 iee = block ( n , 2 ) + 1 jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ! starting j-index ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) ! ending j-index kl = block ( n , 5 ) ! starting k-index ku = block ( n , 6 ) ! ending k-index !fixed flux !remove standard diffusion term, add flux=bcvalue do k = kl , ku do j = jl , ju putout ( iee , j , k ) = putout ( iee , j , k ) + ( & 0.5 * ( ekh ( iee , j , k ) * dxf ( iee - 1 ) + ekh ( iee - 1 , j , k ) * dxf ( iee )) * & ( putin ( iee , j , k ) - putin ( iee - 1 , j , k )) * dxh2i ( iee ) - & bcvaluep ) * dxfi ( iee ) ! putout ( iww , j , k ) = putout ( iww , j , k ) + ( & - 0.5 * ( ekh ( iww + 1 , j , k ) * dxf ( iww ) + ekh ( iww , j , k ) * dxf ( iww + 1 )) * & ( putin ( iww + 1 , j , k ) - putin ( iww , j , k )) * dxh2i ( iww + 1 ) - & bcvaluem ) * dxfi ( iww ) ! end do end do end subroutine xwallscalar","tags":"","loc":"proc/xwallscalar.html"},{"title":"ywallfunplus – uDALES","text":"public subroutine ywallfunplus() Uses modglobal modfields modsubgriddata modmpi initfac proc~~ywallfunplus~~UsesGraph proc~ywallfunplus ywallfunplus module~modmpi modmpi proc~ywallfunplus->module~modmpi module~modsubgriddata modsubgriddata proc~ywallfunplus->module~modsubgriddata module~initfac initfac proc~ywallfunplus->module~initfac module~modfields modfields proc~ywallfunplus->module~modfields module~modglobal modglobal proc~ywallfunplus->module~modglobal mpi mpi module~modmpi->mpi module~initfac->module~modmpi module~initfac->module~modglobal netcdf netcdf module~initfac->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~ywallfunplus~~CallsGraph proc~ywallfunplus ywallfunplus proc~ywallscalarplus ywallscalarplus proc~ywallfunplus->proc~ywallscalarplus Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ywallfunplus~~CalledByGraph proc~ywallfunplus ywallfunplus proc~ibmwallfun ibmwallfun proc~ibmwallfun->proc~ywallfunplus program~dalesurban DALESURBAN program~dalesurban->proc~ibmwallfun Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ywallfunplus Source Code subroutine ywallfunplus use modglobal , only : dzf , dzhiq , dzhi , dxf , dxhi , dy , dyi , nsv , lles , numol , ltempeq , lmoist , & je , jb , ih , jh , kh , ihc , jhc , khc , iwallmom , iwallmoist , iwalltemp , iwallscal , nblocks use modfields , only : u0 , w0 , up , wp , shear , thlp , thl0 , qtp , qt0 , sv0 , svp , tfluxb , momfluxb , exnf , cth , qfluxb use modsubgriddata , only : ekm use modmpi , only : myid use initfac , only : fachf , block , faclGR , facqsat , facef , fachurel , facf , facT , facz0 , facz0h integer i , j , k , n , nc , il , iu , kl , ku , im , jm , km , m if ( iwallmom == 1 ) then !fixed flux !not implemented else if ( iwallmom == 2 ) then do n = 1 , nypluswall k = block ( iypluswall ( n , 1 ), 10 ) !upper y wall = north wall call wfuno ( ih , jh , kh , up , wp , thlp , momfluxb , tfluxb , cth , bcTfluxA , u0 , w0 , thl0 , facT ( k , 1 ), facz0 ( k ), facz0h ( k ), iypluswall ( n , 1 ), iypluswall ( n , 2 ), 31 ) end do else if ( iwallmom == 3 ) then do n = 1 , nypluswall k = block ( iypluswall ( n , 1 ), 10 ) !upper y wall = north wall call wfmneutral ( ih , jh , kh , up , wp , momfluxb , u0 , w0 , facz0 ( k ), iypluswall ( n , 1 ), iypluswall ( n , 2 ), 31 ) end do end if if ( ltempeq ) then if ( iwalltemp == 1 ) then do n = 1 , nypluswall ! loop over all shear x-walls !write(*,*) 'shape(iypluswall), nypluswall', shape(iypluswall), nypluswall call ywallscalarplus ( ih , jh , kh , thl0 , thlp , bctfyp , n ) end do else if ( iwalltemp == 2 ) then do n = 1 , nypluswall k = block ( iypluswall ( n , 1 ), 10 ) call wfuno ( ih , jh , kh , up , wp , thlp , momfluxb , tfluxb , cth , bcTfluxA , u0 , w0 , thl0 , facT ( k , 1 ), facz0 ( k ), facz0h ( k ), iypluswall ( n , 1 ), iypluswall ( n , 2 ), 32 ) fachf ( k ) = fachf ( k ) + bcTfluxA end do end if end if if ( lmoist ) then if ( iwallmoist == 1 ) then do n = 1 , nypluswall ! loop over all shear x-walls call ywallscalarplus ( ih , jh , kh , qt0 , qtp , bcqfyp , n ) end do end if if (( ltempeq ) . and . ( iwallmoist == 2 )) then do n = 1 , nypluswall k = block ( iypluswall ( n , 1 ), 10 ) if ( faclGR ( k )) then call wfGR ( ih , jh , kh , qtp , qfluxb , cth , bcqfluxA , qt0 , facqsat ( k ), fachurel ( k ), facf ( k , 4 ), facf ( k , 5 ), iypluswall ( n , 1 ), iypluswall ( n , 2 ), 32 ) facef ( k ) = facef ( k ) + bcqfluxA end if end do end if end if if ( nsv > 0 ) then if ( iwallscal == 1 ) then do n = 1 , nypluswall ! loop over all shear x-walls do m = 1 , nsv call ywallscalarplus ( ihc , jhc , khc , sv0 (:,:,:, m ), svp (:,:,:, m ), 0. , n ) end do end do end if end if end subroutine ywallfunplus","tags":"","loc":"proc/ywallfunplus.html"},{"title":"ywallscalarplus – uDALES","text":"public subroutine ywallscalarplus(hi, hj, hk, putin, putout, bcvaluep, n) Uses modglobal modsubgriddata modmpi initfac proc~~ywallscalarplus~~UsesGraph proc~ywallscalarplus ywallscalarplus module~modmpi modmpi proc~ywallscalarplus->module~modmpi module~initfac initfac proc~ywallscalarplus->module~initfac module~modsubgriddata modsubgriddata proc~ywallscalarplus->module~modsubgriddata module~modglobal modglobal proc~ywallscalarplus->module~modglobal mpi mpi module~modmpi->mpi module~initfac->module~modmpi module~initfac->module~modglobal netcdf netcdf module~initfac->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: hi integer, intent(in) :: hj integer, intent(in) :: hk real, intent(in) :: putin (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(inout) :: putout (ib-hi:ie+hi,jb-hj:je+hj,kb:ke+hk) real, intent(in) :: bcvaluep integer, intent(in) :: n Called by proc~~ywallscalarplus~~CalledByGraph proc~ywallscalarplus ywallscalarplus proc~ywallfunplus ywallfunplus proc~ywallfunplus->proc~ywallscalarplus proc~ibmwallfun ibmwallfun proc~ibmwallfun->proc~ywallfunplus program~dalesurban DALESURBAN program~dalesurban->proc~ibmwallfun Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ywallscalarplus Source Code subroutine ywallscalarplus ( hi , hj , hk , putin , putout , bcvaluep , n ) use modglobal , only : dyi , ib , ie , jb , je , kb , ke , numol , prandtlmoli use modsubgriddata , only : ekh use modmpi , only : myid use initfac , only : block integer i , j , k , il , iu , kl , ku , m integer , intent ( in ) :: hi !<size of halo in i integer , intent ( in ) :: hj !<size of halo in j integer , intent ( in ) :: hk !<size of halo in k real , intent ( in ) :: putin ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) real , intent ( inout ) :: putout ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) real , intent ( in ) :: bcvaluep integer , intent ( in ) :: n m = iypluswall ( n , 1 ) j = iypluswall ( n , 2 ) il = block ( m , 1 ) iu = block ( m , 2 ) kl = block ( m , 5 ) ku = block ( m , 6 ) !fixed flux do k = kl , ku do i = il , iu putout ( i , j , k ) = putout ( i , j , k ) + ( 0.5 * ( ekh ( i , j , k ) + ekh ( i , j - 1 , k )) * ( putin ( i , j , k ) - putin ( i , j - 1 , k )) * dyi - bcvaluep ) * dyi end do end do end subroutine ywallscalarplus","tags":"","loc":"proc/ywallscalarplus.html"},{"title":"ywallfunmin – uDALES","text":"public subroutine ywallfunmin() Uses modglobal modfields initfac proc~~ywallfunmin~~UsesGraph proc~ywallfunmin ywallfunmin module~modfields modfields proc~ywallfunmin->module~modfields module~initfac initfac proc~ywallfunmin->module~initfac module~modglobal modglobal proc~ywallfunmin->module~modglobal module~initfac->module~modglobal module~modmpi modmpi module~initfac->module~modmpi netcdf netcdf module~initfac->netcdf mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~ywallfunmin~~CallsGraph proc~ywallfunmin ywallfunmin proc~ywallscalarmin ywallscalarmin proc~ywallfunmin->proc~ywallscalarmin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ywallfunmin~~CalledByGraph proc~ywallfunmin ywallfunmin proc~ibmwallfun ibmwallfun proc~ibmwallfun->proc~ywallfunmin program~dalesurban DALESURBAN program~dalesurban->proc~ibmwallfun Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ywallfunmin Source Code subroutine ywallfunmin use modglobal , only : dxf , dxhi , dy , dyi , dzhiq , dzf , dzhi , lles , nsv , numol , ltempeq , lmoist , & ih , jh , kh , ihc , jhc , khc , iwallmom , iwalltemp , iwallmoist , iwallscal , nblocks use modfields , only : u0 , w0 , up , wp , shear , thl0 , thlp , qt0 , qtp , sv0 , svp , tfluxb , momfluxb , exnf , cth , qfluxb use initfac , only : fachf , block , faclGR , facqsat , facef , fachurel , facf , facT , facz0 , facz0h !      use modsurfdata,     only : wtsurf integer i , j , k , n , nc , il , iu , kl , ku , im , jp , km , m if ( iwallmom == 1 ) then !fixed flux, not implemented else if ( iwallmom == 2 ) then do n = 1 , nyminwall k = block ( iyminwall ( n , 1 ), 11 ) call wfuno ( ih , jh , kh , up , wp , thlp , momfluxb , tfluxb , cth , bcTfluxA , u0 , w0 , thl0 , facT ( k , 1 ), facz0 ( k ), facz0h ( k ), iyminwall ( n , 1 ), iyminwall ( n , 2 ), 41 ) end do else if ( iwallmom == 3 ) then do n = 1 , nyminwall k = block ( iyminwall ( n , 1 ), 11 ) call wfmneutral ( ih , jh , kh , up , wp , momfluxb , u0 , w0 , facz0 ( k ), iyminwall ( n , 1 ), iyminwall ( n , 2 ), 41 ) end do end if ! if ( ltempeq ) then if ( iwalltemp == 1 ) then do n = 1 , nyminwall ! call ywallscalarmin ( ih , jh , kh , thl0 , thlp , bctfym , n ) end do else if ( iwalltemp == 2 ) then do n = 1 , nyminwall k = block ( iyminwall ( n , 1 ), 11 ) call wfuno ( ih , jh , kh , up , wp , thlp , momfluxb , tfluxb , cth , bcTfluxA , u0 , w0 , thl0 , facT ( k , 1 ), facz0 ( k ), facz0h ( k ), iyminwall ( n , 1 ), iyminwall ( n , 2 ), 42 ) fachf ( k ) = fachf ( k ) + bcTfluxA end do end if end if if ( lmoist ) then if ( iwallmoist == 1 ) then do n = 1 , nyminwall ! call ywallscalarmin ( ih , jh , kh , qt0 , qtp , bcqfym , n ) end do end if if (( ltempeq ) . and . ( iwallmoist == 2 )) then do n = 1 , nyminwall k = block ( iyminwall ( n , 1 ), 11 ) if ( faclGR ( k )) then call wfGR ( ih , jh , kh , qtp , qfluxb , cth , bcqfluxA , qt0 , facqsat ( k ), fachurel ( k ), facf ( k , 4 ), facf ( k , 5 ), iyminwall ( n , 1 ), iyminwall ( n , 2 ), 42 ) facef ( k ) = facef ( k ) + bcqfluxA end if end do end if end if if ( nsv > 0 ) then if ( iwallscal == 1 ) then do n = 1 , nyminwall ! do m = 1 , nsv call ywallscalarmin ( ihc , jhc , khc , sv0 (:,:,:, m ), svp (:,:,:, m ), 0. , n ) end do end do end if end if end subroutine ywallfunmin","tags":"","loc":"proc/ywallfunmin.html"},{"title":"ywallscalarmin – uDALES","text":"public subroutine ywallscalarmin(hi, hj, hk, putin, putout, bcvaluem, n) Uses modglobal modsubgriddata modmpi initfac proc~~ywallscalarmin~~UsesGraph proc~ywallscalarmin ywallscalarmin module~modmpi modmpi proc~ywallscalarmin->module~modmpi module~initfac initfac proc~ywallscalarmin->module~initfac module~modsubgriddata modsubgriddata proc~ywallscalarmin->module~modsubgriddata module~modglobal modglobal proc~ywallscalarmin->module~modglobal mpi mpi module~modmpi->mpi module~initfac->module~modmpi module~initfac->module~modglobal netcdf netcdf module~initfac->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: hi integer, intent(in) :: hj integer, intent(in) :: hk real, intent(in) :: putin (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(inout) :: putout (ib-hi:ie+hi,jb-hj:je+hj,kb:ke+hk) real, intent(in) :: bcvaluem integer, intent(in) :: n Called by proc~~ywallscalarmin~~CalledByGraph proc~ywallscalarmin ywallscalarmin proc~ywallfunmin ywallfunmin proc~ywallfunmin->proc~ywallscalarmin proc~ibmwallfun ibmwallfun proc~ibmwallfun->proc~ywallfunmin program~dalesurban DALESURBAN program~dalesurban->proc~ibmwallfun Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ywallscalarmin Source Code subroutine ywallscalarmin ( hi , hj , hk , putin , putout , bcvaluem , n ) use modglobal , only : dyi , ib , ie , jb , je , kb , ke , prandtlmoli , numol use modsubgriddata , only : ekh use modmpi , only : myid use initfac , only : block integer i , j , k , il , iu , kl , ku , m integer , intent ( in ) :: hi !<size of halo in i integer , intent ( in ) :: hj !<size of halo in j integer , intent ( in ) :: hk !<size of halo in k real , intent ( in ) :: putin ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) real , intent ( inout ) :: putout ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) real , intent ( in ) :: bcvaluem integer , intent ( in ) :: n j = iyminwall ( n , 2 ) m = iyminwall ( n , 1 ) il = block ( m , 1 ) iu = block ( m , 2 ) kl = block ( m , 5 ) ku = block ( m , 6 ) do k = kl , ku do i = il , iu putout ( i , j , k ) = putout ( i , j , k ) + ( & - 0.5 * ( ekh ( i , j , k ) + ekh ( i , j + 1 , k )) * ( putin ( i , j + 1 , k ) - putin ( i , j , k )) * dyi & - bcvaluem ) * dyi end do end do end subroutine ywallscalarmin","tags":"","loc":"proc/ywallscalarmin.html"},{"title":"zwallfun – uDALES","text":"public subroutine zwallfun() Uses modglobal modfields modmpi initfac proc~~zwallfun~~UsesGraph proc~zwallfun zwallfun module~modmpi modmpi proc~zwallfun->module~modmpi module~modfields modfields proc~zwallfun->module~modfields module~initfac initfac proc~zwallfun->module~initfac module~modglobal modglobal proc~zwallfun->module~modglobal mpi mpi module~modmpi->mpi module~initfac->module~modmpi module~initfac->module~modglobal netcdf netcdf module~initfac->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~zwallfun~~CalledByGraph proc~zwallfun zwallfun proc~ibmwallfun ibmwallfun proc~ibmwallfun->proc~zwallfun program~dalesurban DALESURBAN program~dalesurban->proc~ibmwallfun Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code zwallfun Source Code subroutine zwallfun use modglobal , only : dzf , dzfi , dzhi , dzhiq , dxf , dxfi , dxhi , dyi , nsv , lles , numol , ltempeq , lmoist , & ih , jh , kh , ihc , jhc , khc , iwallmom , iwalltemp , iwallmoist , iwallscal use modfields , only : u0 , v0 , up , vp , shear , thl0 , thlp , qt0 , qtp , sv0 , svp , tfluxb , momfluxb , exnf , cth , qfluxb use modmpi , only : myid use initfac , only : fachf , block , faclGR , facef , facqsat , fachurel , facf , facT , facz0 , facz0h integer i , j , k , n , nc , il , iu , jl , ju , im , jm , km , m if ( iwallmom == 1 ) then !fixed flux else if ( iwallmom == 2 ) then do n = 1 , nxwall k = block ( ixwall ( n ), 7 ) call wfuno ( ih , jh , kh , up , vp , thlp , momfluxb , tfluxb , cth , bcTfluxA , u0 , v0 , thl0 , facT ( k , 1 ), facz0 ( k ), facz0h ( k ), ixwall ( n ), 1 , 51 ) end do else if ( iwallmom == 3 ) then do n = 1 , nxwall k = block ( ixwall ( n ), 7 ) call wfmneutral ( ih , jh , kh , up , vp , momfluxb , u0 , v0 , facz0 ( k ), ixwall ( n ), 1 , 51 ) end do end if if ( ltempeq ) then if ( iwalltemp == 1 ) then do n = 1 , nxwall ! loop over all shear x-walls call zwallscalar ( ih , jh , kh , thl0 , thlp , bctfz , ixwall ( n )) end do else if ( iwalltemp == 2 ) then do n = 1 , nxwall k = block ( ixwall ( n ), 7 ) call wfuno ( ih , jh , kh , up , vp , thlp , momfluxb , tfluxb , cth , bcTfluxA , u0 , v0 , thl0 , facT ( k , 1 ), facz0 ( k ), facz0h ( k ), ixwall ( n ), 1 , 52 ) fachf ( k ) = fachf ( k ) + bcTfluxA end do end if end if if ( lmoist ) then if ( iwallmoist == 1 ) then do n = 1 , nxwall ! loop over all shear x-walls call zwallscalar ( ih , jh , kh , qt0 , qtp , bcqfz , ixwall ( n )) end do end if if (( ltempeq ) . and . ( iwallmoist == 2 )) then do n = 1 , nxwall k = block ( ixwall ( n ), 7 ) if ( faclGR ( k )) then call wfGR ( ih , jh , kh , qtp , qfluxb , cth , bcqfluxA , qt0 , facqsat ( k ), fachurel ( k ), facf ( k , 4 ), facf ( k , 5 ), ixwall ( n ), 1 , 52 ) facef ( k ) = facef ( k ) + bcqfluxA end if end do end if end if if ( nsv > 0 ) then if ( iwallscal == 1 ) then do n = 1 , nxwall ! loop over all shear x-walls do m = 1 , nsv call zwallscalar ( ihc , jhc , khc , sv0 (:,:,:, m ), svp (:,:,:, m ), 0. , ixwall ( n )) end do end do end if end if end subroutine zwallfun","tags":"","loc":"proc/zwallfun.html"},{"title":"zwallscalar – uDALES","text":"public subroutine zwallscalar(hi, hj, hk, putin, putout, bcvalue, n) Uses modglobal modsubgriddata modmpi initfac proc~~zwallscalar~~UsesGraph proc~zwallscalar zwallscalar module~modmpi modmpi proc~zwallscalar->module~modmpi module~initfac initfac proc~zwallscalar->module~initfac module~modsubgriddata modsubgriddata proc~zwallscalar->module~modsubgriddata module~modglobal modglobal proc~zwallscalar->module~modglobal mpi mpi module~modmpi->mpi module~initfac->module~modmpi module~initfac->module~modglobal netcdf netcdf module~initfac->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: hi integer, intent(in) :: hj integer, intent(in) :: hk real, intent(in) :: putin (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(inout) :: putout (ib-hi:ie+hi,jb-hj:je+hj,kb:ke+hk) real, intent(in) :: bcvalue integer, intent(in) :: n Contents Source Code zwallscalar Source Code subroutine zwallscalar ( hi , hj , hk , putin , putout , bcvalue , n ) use modglobal , only : jmax , dzf , dzfi , dzhi , dzh2i , ib , ie , jb , je , kb , ke , prandtlmoli , numol use modsubgriddata , only : ekh use modmpi , only : myid use initfac , only : block integer i , j , k , il , iu , jl , ju , km integer , intent ( in ) :: hi !<size of halo in i integer , intent ( in ) :: hj !<size of halo in j integer , intent ( in ) :: hk !<size of halo in k real , intent ( in ) :: putin ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) real , intent ( inout ) :: putout ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) real , intent ( in ) :: bcvalue integer , intent ( in ) :: n k = block ( n , 6 ) + 1 !block location km = k - 1 ! il = block ( n , 1 ) iu = block ( n , 2 ) jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) !  delta=putout(3,1,2) do j = jl , ju do i = il , iu putout ( i , j , k ) = putout ( i , j , k ) + ( & 0.5 * ( dzf ( km ) * ekh ( i , j , k ) + dzf ( k ) * ekh ( i , j , km )) * & ! zero flux ( putin ( i , j , k ) - putin ( i , j , km )) * dzh2i ( k ) - & bcvalue ) * dzfi ( k ) end do end do end subroutine zwallscalar","tags":"","loc":"proc/zwallscalar.html"},{"title":"ibmnorm – uDALES","text":"public subroutine ibmnorm() Uses modglobal modfields modmpi initfac proc~~ibmnorm~~UsesGraph proc~ibmnorm ibmnorm module~modmpi modmpi proc~ibmnorm->module~modmpi module~modfields modfields proc~ibmnorm->module~modfields module~initfac initfac proc~ibmnorm->module~initfac module~modglobal modglobal proc~ibmnorm->module~modglobal mpi mpi module~modmpi->mpi module~initfac->module~modmpi module~initfac->module~modglobal netcdf netcdf module~initfac->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~ibmnorm~~CalledByGraph proc~ibmnorm ibmnorm program~dalesurban DALESURBAN program~dalesurban->proc~ibmnorm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ibmnorm Source Code subroutine ibmnorm use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , rk3step , dt , libm , jmax , & nblocks , nsv , ltempeq , lmoist , rk3step , ih , kh , dt , totavtime , & dxh , dzf , dy , ih , kh , jh , jge use modfields , only : up , vp , wp , um , vm , wm , u0 , v0 , w0 , thl0 , thlm , svp , svm , thlp , qtp , qt0 , qtm use modmpi , only : myid , nprocs use initfac , only : block real , dimension ( ib - ih : ie + ih , kb - kh : ke + kh ) :: dummy real rk3coef , rk3coefi , timecomplibm , timecomplibmplusdti integer n , i , j , k , il , iu , jl , ju , kl , ku , sc if ( libm ) then rk3coef = dt / ( 4. - dble ( rk3step )) rk3coefi = 1. / rk3coef do n = 1 , nxwall il = block ( ixwall ( n ), 1 ) iu = block ( ixwall ( n ), 2 ) + 1 jl = max ( block ( ixwall ( n ), 3 ) - myid * jmax , 1 ) ! ju = min ( block ( ixwall ( n ), 4 ) - myid * jmax , jmax ) ! !kl = block(ixwall(n), 5) kl = kb ! tg3315 18.03.19 - use kb because for lEB buildings block starts at kb+1 but this leaves area underneath the buildings and horizontally between the roads where we have no block. Only leads to small velocities in these areas but this negates this issue. WARNING - for modelling overhangs this should be changed but this would also require another facade type etc. Similarly applied to y and z directions below. ku = block ( ixwall ( n ), 6 ) !up(il:iu, jl:ju, kl:ku) = -um(il:iu, jl:ju, kl:ku)*rk3coefi up ( iu , jl : ju , kl : ku ) = - um ( iu , jl : ju , kl : ku ) * rk3coefi up ( il , jl : ju , kl : ku ) = - um ( il , jl : ju , kl : ku ) * rk3coefi up ( il + 1 : iu - 1 , jl : ju , kl : ku ) = 0. !internal velocity don't change or um ( il + 1 : iu - 1 , jl : ju , kl : ku ) = 0. !internal velocity = 0    or both? end do ! 1,nxwallsnorm do n = 1 , nyminwall if (( myid == nprocs - 1 . and . block ( iyminwall ( n , 1 ), 3 ) == 1 )) then jl = jmax + 1 ju = jmax + 1 else jl = max ( block ( iyminwall ( n , 1 ), 3 ) - myid * jmax , 1 ) ju = min ( block ( iyminwall ( n , 1 ), 4 ) - myid * jmax , jmax ) + 1 end if il = block ( iyminwall ( n , 1 ), 1 ) iu = block ( iyminwall ( n , 1 ), 2 ) !kl = block(iyminwall(n, 1), 5) kl = kb ! tg3315 see comment for x-direction above ku = block ( iyminwall ( n , 1 ), 6 ) ! write(*,*) 'jl, ju, jmax, iyminwall(n,1)', jl, ju, jmax, iyminwall(n,1) ! vp(il:iu, jl:ju, kl:ku) = -vm(il:iu, jl:ju, kl:ku)*rk3coefi vp ( il : iu , jl , kl : ku ) = - vm ( il : iu , jl , kl : ku ) * rk3coefi vp ( il : iu , ju , kl : ku ) = - vm ( il : iu , ju , kl : ku ) * rk3coefi vp ( il : iu , jl + 1 : ju - 1 , kl : ku ) = 0.0 vm ( il : iu , jl + 1 : ju - 1 , kl : ku ) = 0.0 end do !1,nyminwall do n = 1 , nypluswall if ( myid == 0 . and . block ( iypluswall ( n , 1 ), 4 ) == jge ) then jl = 1 ju = 1 else jl = max ( block ( iypluswall ( n , 1 ), 3 ) - myid * jmax , 1 ) ! should this not be able to be zero? ju = min ( block ( iypluswall ( n , 1 ), 4 ) - myid * jmax , jmax ) + 1 end if il = block ( iypluswall ( n , 1 ), 1 ) iu = block ( iypluswall ( n , 1 ), 2 ) !kl = block(iypluswall(n, 1), 5) kl = kb ! tg3315 see comment for x-direction above ku = block ( iypluswall ( n , 1 ), 6 ) !write(*,*) 'jl, ju, jmax, iypluswall(n,1)', jl, ju, jmax, iypluswall(n,1) !vp(il:iu, jl:ju, kl:ku) = -vm(il:iu, jl:ju, kl:ku)*rk3coefi vp ( il : iu , jl , kl : ku ) = - vm ( il : iu , jl , kl : ku ) * rk3coefi vp ( il : iu , ju , kl : ku ) = - vm ( il : iu , ju , kl : ku ) * rk3coefi vp ( il : iu , jl + 1 : ju - 1 , kl : ku ) = 0.0 vm ( il : iu , jl + 1 : ju - 1 , kl : ku ) = 0.0 end do !1,nypluswall do n = 1 , nxwall !kl = block(ixwall(n), 5) kl = kb ! tg3315 see comment for x-direction above ku = block ( ixwall ( n ), 6 ) + 1 il = block ( ixwall ( n ), 1 ) iu = block ( ixwall ( n ), 2 ) jl = max ( block ( ixwall ( n ), 3 ) - myid * jmax , 1 ) ju = min ( block ( ixwall ( n ), 4 ) - myid * jmax , jmax ) !wp(il:iu, jl:ju, kl:ku) = -wm(il:iu, jl:ju, kl:ku)*rk3coefi wp ( il : iu , jl : ju , kl ) = - wm ( il : iu , jl : ju , kl ) * rk3coefi wp ( il : iu , jl : ju , ku ) = - wm ( il : iu , jl : ju , ku ) * rk3coefi wp ( il : iu , jl : ju , kl + 1 : ku - 1 ) = 0. wm ( il : iu , jl : ju , kl + 1 : ku - 1 ) = 0. end do !1,nxwall if ( ltempeq ) then do n = 1 , nblocks il = block ( n , 1 ) iu = block ( n , 2 ) !kl = block(n, 5) kl = kb ! tg3315 see comment for x-direction above ku = block ( n , 6 ) jl = block ( n , 3 ) - myid * jmax ju = block ( n , 4 ) - myid * jmax if (( ju < jb ) . or . ( jl > je )) then cycle else if ( ju > je ) ju = je if ( jl < jb ) jl = jb thlp ( il : iu , jl : ju , kl : ku ) = 0. !try setting internal T to fluid T thlm ( il , jl : ju , kl : ku ) = thlm ( il - 1 , jl : ju , kl : ku ) thlm ( iu , jl : ju , kl : ku ) = thlm ( iu + 1 , jl : ju , kl : ku ) thlm ( il : iu , jl , kl : ku ) = thlm ( il : iu , jl - 1 , kl : ku ) thlm ( il : iu , ju , kl : ku ) = thlm ( il : iu , ju + 1 , kl : ku ) thlm ( il : iu , jl : ju , ku ) = thlm ( il : iu , jl : ju , ku + 1 ) end if end do end if if ( lmoist ) then do n = 1 , nblocks il = block ( n , 1 ) iu = block ( n , 2 ) !kl = block(n, 5) kl = kb ! tg3315 see comment for x-direction above ku = block ( n , 6 ) jl = block ( n , 3 ) - myid * jmax ju = block ( n , 4 ) - myid * jmax if (( ju < jb ) . or . ( jl > je )) then cycle else if ( ju > je ) ju = je if ( jl < jb ) jl = jb qtp ( il : iu , jl : ju , kl : ku ) = 0. qtm ( il , jl : ju , kl : ku ) = qtm ( il - 1 , jl : ju , kl : ku ) qtm ( iu , jl : ju , kl : ku ) = qtm ( iu + 1 , jl : ju , kl : ku ) qtm ( il : iu , jl , kl : ku ) = qtm ( il : iu , jl - 1 , kl : ku ) qtm ( il : iu , ju , kl : ku ) = qtm ( il : iu , ju + 1 , kl : ku ) qtm ( il : iu , jl : ju , ku ) = qtm ( il : iu , jl : ju , ku + 1 ) end if end do end if if ( nsv > 0 ) then do n = 1 , nblocks il = block ( n , 1 ) iu = block ( n , 2 ) !kl = block(n, 5) kl = kb ! tg3315 see comment for x-direction above ku = block ( n , 6 ) jl = block ( n , 3 ) - myid * jmax ju = block ( n , 4 ) - myid * jmax if (( ju < jb ) . or . ( jl > je )) then cycle else if ( ju > je ) ju = je if ( jl < jb ) jl = jb svp ( il : iu , jl : ju , kl : ku , :) = 0. svp ( il : iu , jl : ju , kl : ku ,:) = 0. svm ( il , jl : ju , kl : ku , :) = svm ( il - 1 , jl : ju , kl : ku ,:) ! tg3315 swapped these around with jl, ju as was getting values in buildings as blovks are split along x in real topology svm ( iu , jl : ju , kl : ku , :) = svm ( iu + 1 , jl : ju , kl : ku ,:) svm ( il : iu , jl , kl : ku , :) = svm ( il : iu , jl - 1 , kl : ku ,:) svm ( il : iu , ju , kl : ku , :) = svm ( il : iu , ju + 1 , kl : ku ,:) svm ( il : iu , jl : ju , ku , :) = svm ( il : iu , jl : ju , ku + 1 ,:) end if end do end if end if ! libm end subroutine ibmnorm","tags":"","loc":"proc/ibmnorm.html"},{"title":"nearwall – uDALES","text":"public subroutine nearwall() Uses modglobal modsubgriddata modfields modibmdata modmpi initfac proc~~nearwall~~UsesGraph proc~nearwall nearwall module~modibmdata modibmdata proc~nearwall->module~modibmdata module~modmpi modmpi proc~nearwall->module~modmpi module~modsubgriddata modsubgriddata proc~nearwall->module~modsubgriddata module~initfac initfac proc~nearwall->module~initfac module~modfields modfields proc~nearwall->module~modfields module~modglobal modglobal proc~nearwall->module~modglobal mpi mpi module~modmpi->mpi module~initfac->module~modmpi module~initfac->module~modglobal netcdf netcdf module~initfac->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Contents Source Code nearwall Source Code subroutine nearwall use modglobal , only : ib , ie , jb , je , jgb , jge , jmax , kb , ke , xh , xf , dy , zh , zf , lwarmstart , nblocks , libm , lzerogradtop , lwalldist use modsubgriddata , only : lsmagorinsky , loneeqn use modfields , only : mindist , wall use modibmdata , only : xwallsglobal , ywallsglobal , zwallsglobal use modmpi , only : myid use initfac , only : block implicit none integer , allocatable :: ux0all (:, :, :), vy0all (:, :, :), wz0all (:, :, :) real , allocatable :: distxf (:, :), distxh (:, :), distyf (:, :), distyh (:, :), distzf (:, :), distzh (:, :), & distxf2 (:, :), distxh2 (:, :), distyf2 (:, :), distyh2 (:, :), distzf2 (:, :), distzh2 (:, :), distance (:) real distx , disty , distz ! distx is the distance to nearest x-wall, etc. ! integer, allocatable :: optie(:) integer ic , jc , kc , i , j , k , optie , il , iu , jl , ju , kl , ku , n ! if (lwarmstart .or. lles.eqv..false. .or. lvreman) then if ((( lsmagorinsky ) . or . ( loneeqn )) . and . ( lwalldist )) then if ( myid == 0 ) then write ( 6 , * ) 'Computing wall distances' end if ! if (lles.eqv..false. .or. lvreman) then mindist = 1.0e10 allocate ( ux0all ( ib - 1 : ie + 1 , jgb - 1 : jge + 1 , kb - 1 : ke + 1 )) ! This contains ux0 + the lower and (possibly) the upper wall allocate ( vy0all ( ib - 1 : ie + 1 , jgb - 1 : jge + 1 , kb - 1 : ke + 1 )) ! This contains ux0 + the lower and (possibly) the upper wall allocate ( wz0all ( ib - 1 : ie + 1 , jgb - 1 : jge + 1 , kb - 1 : ke + 1 )) ! This contains ux0 + the lower and (possibly) the upper wall allocate ( distxh ( ib : ie , ib : ie + 1 )) allocate ( distxf ( ib : ie , ib : ie + 1 )) allocate ( distyh ( jb : je , jgb : jge + 1 )) allocate ( distyf ( jb : je , jgb : jge + 1 )) allocate ( distzh ( kb : ke , kb : ke + 1 )) allocate ( distzf ( kb : ke , kb : ke + 1 )) allocate ( distxh2 ( ib : ie , ib : ie + 1 )) allocate ( distxf2 ( ib : ie , ib : ie + 1 )) allocate ( distyh2 ( jb : je , jgb : jge + 1 )) allocate ( distyf2 ( jb : je , jgb : jge + 1 )) allocate ( distzh2 ( kb : ke , kb : ke + 1 )) allocate ( distzf2 ( kb : ke , kb : ke + 1 )) allocate ( distance ( 4 )) ! initialize wall indicators ux0all = 0 vy0all = 0 wz0all = 0 ! Determine for each cell face if an x/y/z-wall is present ! from immersed boundaries if ( libm ) then ! do loop over blocks do n = 1 , nblocks il = block ( n , 1 ) iu = block ( n , 2 ) jl = block ( n , 3 ) ju = block ( n , 4 ) kl = block ( n , 5 ) ku = block ( n , 6 ) do k = kl , ku do j = jl , ju ux0all ( il , j , k ) = 1 ! lower x-wall ux0all ( iu + 1 , j , k ) = 1 ! upper x-wall end do end do do k = kl , ku do i = il , iu vy0all ( i , jl , k ) = 1 ! lower y-wall vy0all ( i , ju + 1 , k ) = 1 ! upper y-wall end do end do do j = jl , ju do i = il , iu wz0all ( i , j , kl ) = 1 ! lower z-wall wz0all ( i , j , ku + 1 ) = 1 ! upper z-wall end do end do end do ! loop over nblocks end if ! libm = .true. ! add the global walls (probably upper and lower wall, or only lower wall) if ( lzerogradtop ) then do i = ib , ie do j = jgb , jge wz0all ( i , j , kb ) = 1 ! ground wall end do end do else do i = ib , ie do j = jgb , jge wz0all ( i , j , kb ) = 1 ! ground wall wz0all ( i , j , ke + 1 ) = 1 ; ! top wall end do end do end if write ( 6 , * ) 'Determing distance matrices, proc=' , myid ! Determine x-distance matrices: do ic = ib , ie ! cell-center index do i = ib , ie + 1 ! vertex-index (1 more than cell centers) distxh ( ic , i ) = xf ( ic ) - xh ( i ) end do end do do ic = ib , ie ! cell-center index do i = ib , ie + 1 ! center -index distxf ( ic , i ) = xf ( ic ) - xf ( i ) end do end do ! Determine y-distance matrices: do jc = jb , je ! cell-center index do j = jgb , jge + 1 ! vertex-index (1 more than cell centers) (global index to make sure distance to all cells is determined) distyh ( jc , j ) = ( jc + myid * jmax - j ) * dy + 0.5 * dy end do end do do jc = jb , je ! cell-center index do j = jgb , jge + 1 ! center-index  (global index to make sure distance to all cells is determined) distyf ( jc , j ) = ( jc + myid * jmax - j ) * dy end do end do ! Determine z-distance matrices: do kc = kb , ke ! cell-center index do k = kb , ke + 1 ! vertex-index (1 more than cell centers) distzh ( kc , k ) = zf ( kc ) - zh ( k ) end do end do do kc = kb , ke ! cell-center index do k = kb , ke + 1 ! vertex-index (1 more than cell centers) distzf ( kc , k ) = zf ( kc ) - zf ( k ) end do end do distxh2 = distxh ** 2 distyh2 = distyh ** 2 distzh2 = distzh ** 2 distxf2 = distxf ** 2 distyf2 = distyf ** 2 distzf2 = distzf ** 2 write ( 6 , * ) 'Finished determing distance matrices, proc=' , myid write ( 6 , * ) 'determing distance to nearest wall for each cell center, proc=' , myid ! Loop over cells (ic,jc,kc) for which minimal wall-to-cell-center-distance needs to be determined !  do jc=jgb,jge do kc = kb , ke do jc = jb , je do ic = ib , ie ! Determine distance between cc of cell (ic,jc,kc) and faces of all cells (i,j,k) do k = kb , ke + 1 ! Level ke+1 is computed in a separate loop (only necessary with upper wall-> global approach=faster) do j = jgb , jge + 1 ! loop goes up to jge+1 because jge+1 contains the last vy0-wall do i = ib , ie + 1 ! loop goes up to ie+1 because ie+1 contains the last ux0-wall if ( ux0all ( i , j , k ) == 1 . OR . vy0all ( i , j , k ) == 1 . OR . wz0all ( i , j , k ) == 1 ) then distx = 1.0e10 ! make sure distx is very large when no x-wall is present disty = 1.0e10 ! make sure disty is very large when no y-wall is present distz = 1.0e10 ! make sure distz is very large when no z-wall is present if ( ux0all ( i , j , k ) == 1 ) then distx = sqrt ( distxh2 ( ic , i ) + distyf2 ( jc , j ) + distzf2 ( kc , k )) end if if ( vy0all ( i , j , k ) == 1 ) then disty = sqrt ( distxf2 ( ic , i ) + distyh2 ( jc , j ) + distzf2 ( kc , k )) end if if ( wz0all ( i , j , k ) == 1 ) then distz = sqrt ( distxf2 ( ic , i ) + distyf2 ( jc , j ) + distzh2 ( kc , k )) end if else ! no walls are present in cell (i,j,k) -> distance does not need to be determined for this cell cycle ! go to next cell (i,j,k) end if ! determine minimal wall distance between cc of (ic,jc,kc) and faces of cell (i,j,k) distance = ( / mindist ( ic , jc , kc ), distx , disty , distz / ) optie = minloc ( distance , 1 ) ! write(6,*) 'optie=', optie if ( optie == 1 ) then cycle else if ( optie == 2 ) then mindist ( ic , jc , kc ) = distx wall ( ic , jc , kc , 2 ) = j wall ( ic , jc , kc , 3 ) = k ! wall(ic,jc,kc,4) = 1     ! This means the wall closest to the cc of (ic,jc,kc) is at an x-wall at (i,j,k) if ( ic >= i ) then wall ( ic , jc , kc , 1 ) = i wall ( ic , jc , kc , 4 ) = 5 ! shear component index (variable: shear) wall ( ic , jc , kc , 5 ) = 9 ! shear component index (variable: shear) else wall ( ic , jc , kc , 1 ) = i - 1 ! in the subgrid this stress is computed in the cell i-1 wall ( ic , jc , kc , 4 ) = 6 ! shear component index (variable: shear) wall ( ic , jc , kc , 5 ) = 10 ! shear component index (variable: shear) end if else if ( optie == 3 ) then mindist ( ic , jc , kc ) = disty wall ( ic , jc , kc , 1 ) = i wall ( ic , jc , kc , 3 ) = k ! wall(ic,jc,kc,4) = 2     ! This means the wall closest to the cc of (ic,jc,kc) is at a y-wall at (i,j,k) if ( jc + myid * jmax >= j ) then wall ( ic , jc , kc , 2 ) = j wall ( ic , jc , kc , 4 ) = 1 ! shear component index (variable: shear) wall ( ic , jc , kc , 5 ) = 11 ! shear component index (variable: shear) else wall ( ic , jc , kc , 2 ) = j - 1 ! in the subgrid this stress is computed in the cell j-1 wall ( ic , jc , kc , 4 ) = 2 ! shear component index (variable: shear) wall ( ic , jc , kc , 5 ) = 12 ! shear component index (variable: shear) end if else if ( optie == 4 ) then mindist ( ic , jc , kc ) = distz wall ( ic , jc , kc , 1 ) = i wall ( ic , jc , kc , 2 ) = j ! wall(ic,jc,kc,4) = 3     ! This means the wall closest to the cc of (ic,jc,kc) is at a z-wall at (i,j,k) if ( kc >= k ) then wall ( ic , jc , kc , 3 ) = k wall ( ic , jc , kc , 4 ) = 3 ! shear component index (variable: shear) wall ( ic , jc , kc , 5 ) = 7 ! shear component index (variable: shear) else wall ( ic , jc , kc , 3 ) = k - 1 ! in the subgrid this stress is computed in the cel k-1 wall ( ic , jc , kc , 4 ) = 4 ! shear component index (variable: shear) wall ( ic , jc , kc , 5 ) = 8 ! shear component index (variable: shear) end if end if ! mindist(ic,jc+myid*jmax,kc)=min(mindist(ic,jc+myid*jmax,kc),distx,disty,distz)   ! global j index end do end do end do ! if (myid==0) write(6,*) 'finished for cell (ic,jc,kc)=',ic,jc,kc end do end do end do write ( 6 , * ) 'Finished determing distance to nearest wall for each cell center, proc=' , myid ! write(6,*) 'mindist(ib,jb+myid*jmax,kb),mindist(ib,je+myid*jmax,kb)',mindist(ib,jb+myid*jmax,kb),mindist(ib,je+myid*jmax,kb) else return end if !(lwarmstart) deallocate ( ux0all , vy0all , wz0all ) deallocate ( xwallsglobal , ywallsglobal , zwallsglobal , block ) ! used for determining boundaries return end subroutine nearwall","tags":"","loc":"proc/nearwall.html"},{"title":"bottom – uDALES","text":"public subroutine bottom() Uses modglobal modfields modsurfdata modsubgriddata modmpi proc~~bottom~~UsesGraph proc~bottom bottom module~modsurfdata modsurfdata proc~bottom->module~modsurfdata module~modmpi modmpi proc~bottom->module~modmpi module~modsubgriddata modsubgriddata proc~bottom->module~modsubgriddata module~modfields modfields proc~bottom->module~modfields module~modglobal modglobal proc~bottom->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~bottom~~CallsGraph proc~bottom bottom proc~wfmneutral wfmneutral proc~bottom->proc~wfmneutral proc~wfuno wfuno proc~bottom->proc~wfuno proc~unoh unoh proc~wfuno->proc~unoh Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~bottom~~CalledByGraph proc~bottom bottom program~dalesurban DALESURBAN program~dalesurban->proc~bottom Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code bottom Source Code subroutine bottom !kind of obsolete when road facets are being used !vegetated floor not added (could simply be copied from vegetated horizontal facets) use modglobal , only : ib , ie , ih , jh , kh , jb , je , kb , numol , prandtlmol , dzh , nsv , & dxf , dxhi , dzf , dzfi , numoli , ltempeq , khc , lmoist , BCbotT , BCbotq , BCbotm , BCbots , dzh2i use modfields , only : u0 , v0 , e120 , um , vm , w0 , wm , e12m , thl0 , qt0 , sv0 , thlm , qtm , svm , up , vp , thlp , qtp , svp , shear , momfluxb , tfluxb , cth use modsurfdata , only : thlflux , qtflux , svflux , ustar , thvs , wtsurf , wqsurf , thls , z0 , z0h use modsubgriddata , only : ekm , ekh use modmpi , only : myid implicit none integer :: i , j , jp , jm , m !momentum if ( BCbotm . eq . 2 ) then call wfuno ( ih , jh , kh , up , vp , thlp , momfluxb , tfluxb , cth , bcTfluxA , u0 , v0 , thl0 , thls , z0 , z0h , 0 , 1 , 91 ) elseif ( BCbotm . eq . 3 ) then call wfmneutral ( ih , jh , kh , up , vp , momfluxb , u0 , v0 , z0 , 0 , 1 , 91 ) else write ( 0 , * ) \"ERROR: bottom boundary type for momentum undefined\" stop 1 end if if ( ltempeq ) then if ( BCbotT . eq . 1 ) then !neumann/fixed flux bc for temperature do j = jb , je do i = ib , ie thlp ( i , j , kb ) = thlp ( i , j , kb ) & + ( & 0.5 * ( dzf ( kb - 1 ) * ekh ( i , j , kb ) + dzf ( kb ) * ekh ( i , j , kb - 1 )) & * ( thl0 ( i , j , kb ) - thl0 ( i , j , kb - 1 )) & * dzh2i ( kb ) & - wtsurf & ) * dzfi ( kb ) end do end do else if ( BCbotT . eq . 2 ) then !wall function bc for temperature (fixed temperature) call wfuno ( ih , jh , kh , up , vp , thlp , momfluxb , tfluxb , cth , bcTfluxA , u0 , v0 , thl0 , thls , z0 , z0h , 0 , 1 , 92 ) else write ( 0 , * ) \"ERROR: bottom boundary type for temperature undefined\" stop 1 end if end if ! ltempeq if ( lmoist ) then if ( BCbotq . eq . 1 ) then !neumann/fixed flux bc for moisture do j = jb , je do i = ib , ie qtp ( i , j , kb ) = qtp ( i , j , kb ) + ( & 0.5 * ( dzf ( kb - 1 ) * ekh ( i , j , kb ) + dzf ( kb ) * ekh ( i , j , kb - 1 )) & * ( qt0 ( i , j , kb ) - qt0 ( i , j , kb - 1 )) & * dzh2i ( kb ) & + wqsurf & ) * dzfi ( kb ) end do end do else write ( 0 , * ) \"ERROR: bottom boundary type for moisture undefined\" stop 1 end if ! end if !lmoist if ( nsv > 0 ) then if ( BCbots . eq . 1 ) then !neumann/fixed flux bc for moisture do j = jb , je do i = ib , ie do m = 1 , nsv svp ( i , j , kb , m ) = svp ( i , j , kb , m ) + ( & 0.5 * ( dzf ( kb - 1 ) * ekh ( i , j , kb ) + dzf ( kb ) * ekh ( i , j , kb - 1 )) & * ( sv0 ( i , j , kb , m ) - sv0 ( i , j , kb - 1 , m )) & * dzh2i ( kb ) & + 0. & ) * dzfi ( kb ) end do end do end do else write ( 0 , * ) \"ERROR: bottom boundary type for scalars undefined\" stop 1 end if ! end if e120 (:, :, kb - 1 ) = e120 (:, :, kb ) e12m (:, :, kb - 1 ) = e12m (:, :, kb ) wm (:, :, kb ) = 0. w0 (:, :, kb ) = 0. return end subroutine bottom","tags":"","loc":"proc/bottom.html"},{"title":"initstat_nc – uDALES","text":"public subroutine initstat_nc() Uses modglobal modmpi proc~~initstat_nc~~UsesGraph proc~initstat_nc initstat_nc module~modmpi modmpi proc~initstat_nc->module~modmpi module~modglobal modglobal proc~initstat_nc->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~initstat_nc~~CalledByGraph proc~initstat_nc initstat_nc program~dalesurban DALESURBAN program~dalesurban->proc~initstat_nc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code initstat_nc Source Code subroutine initstat_nc use modglobal , only : kmax , ifnamopt , fname_options , iexpnr use modmpi , only : mpierr , mpi_logical , comm3d , myid implicit none integer :: ierr end subroutine initstat_nc","tags":"","loc":"proc/initstat_nc.html"},{"title":"open_nc – uDALES","text":"public subroutine open_nc(fname, ncid, nrec, n1, n2, n3, ns, nfcts, nlyrs) Uses modglobal proc~~open_nc~~UsesGraph proc~open_nc open_nc module~modglobal modglobal proc~open_nc->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name character(len=40), intent(in) :: fname integer, intent(out) :: ncid integer, intent(out) :: nrec integer, intent(in), optional :: n1 integer, intent(in), optional :: n2 integer, intent(in), optional :: n3 integer, intent(in), optional :: ns integer, intent(in), optional :: nfcts integer, intent(in), optional :: nlyrs Calls proc~~open_nc~~CallsGraph proc~open_nc open_nc nf90_put_att nf90_put_att proc~open_nc->nf90_put_att nf90_def_dim nf90_def_dim proc~open_nc->nf90_def_dim nf90_inquire_dimension nf90_inquire_dimension proc~open_nc->nf90_inquire_dimension nf90_inquire nf90_inquire proc~open_nc->nf90_inquire nf90_def_var nf90_def_var proc~open_nc->nf90_def_var nf90_inq_varid nf90_inq_varid proc~open_nc->nf90_inq_varid nf90_open nf90_open proc~open_nc->nf90_open nf90_create nf90_create proc~open_nc->nf90_create nf90_get_var nf90_get_var proc~open_nc->nf90_get_var nf90_inq_dimid nf90_inq_dimid proc~open_nc->nf90_inq_dimid nf90_enddef nf90_enddef proc~open_nc->nf90_enddef nf90_sync nf90_sync proc~open_nc->nf90_sync Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~open_nc~~CalledByGraph proc~open_nc open_nc proc~initstatsdump initstatsdump proc~initstatsdump->proc~open_nc proc~initfielddump initfielddump proc~initfielddump->proc~open_nc proc~initeb initEB proc~initeb->proc~open_nc program~dalesurban DALESURBAN program~dalesurban->proc~initstatsdump program~dalesurban->proc~initfielddump program~dalesurban->proc~initeb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code open_nc Source Code subroutine open_nc ( fname , ncid , nrec , n1 , n2 , n3 , ns , nfcts , nlyrs ) use modglobal , only : author , version , timee implicit none integer , intent ( out ) :: ncid , nrec integer , optional , intent ( in ) :: n1 , n2 , n3 , ns , nfcts , nlyrs character ( len = 40 ), intent ( in ) :: fname character ( len = 12 ) :: date = '' , time = '' integer :: iret , varid , ncall , RecordDimID real , allocatable :: xtimes (:) logical :: exans inquire ( file = trim ( fname ), exist = exans ) !write(*,*) 'opennc' ncall = 0 if (. not . exans ) then call date_and_time ( date , time ) iret = nf90_create ( fname , NF90_SHARE , ncid ) iret = nf90_put_att ( ncid , NF90_GLOBAL , 'title' , fname ) iret = nf90_put_att ( ncid , NF90_GLOBAL , 'history' , 'Created on ' // trim ( date ) // ' at ' // trim ( time )) iret = nf90_put_att ( ncid , NF90_GLOBAL , 'Source' , trim ( version )) iret = nf90_put_att ( ncid , NF90_GLOBAL , 'Author' , trim ( author )) iret = nf90_def_dim ( ncID , 'time' , NF90_UNLIMITED , timeID ) if ( present ( n1 )) then iret = nf90_def_dim ( ncID , 'xt' , n1 , xtID ) iret = nf90_def_dim ( ncID , 'xm' , n1 , xmID ) iret = nf90_def_var ( ncID , 'xt' , NF90_FLOAT ,( / xtID / ) , VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'West-East displacement of cell centers' ) iret = nf90_put_att ( ncID , VarID , 'units' , 'm' ) iret = nf90_def_var ( ncID , 'xm' , NF90_FLOAT ,( / xmID / ), VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'West-East displacement of cell edges' ) iret = nf90_put_att ( ncID , VarID , 'units' , 'm' ) end if if ( present ( n2 )) then iret = nf90_def_dim ( ncID , 'yt' , n2 , ytID ) iret = nf90_def_dim ( ncID , 'ym' , n2 , ymID ) iret = nf90_def_var ( ncID , 'yt' , NF90_FLOAT , ytID , VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'South-North displacement of cell centers' ) iret = nf90_put_att ( ncID , VarID , 'units' , 'm' ) iret = nf90_def_var ( ncID , 'ym' , NF90_FLOAT , ymID , VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'South-North displacement of cell edges' ) iret = nf90_put_att ( ncID , VarID , 'units' , 'm' ) end if if ( present ( n3 )) then iret = nf90_def_dim ( ncID , 'zt' , n3 , ztID ) iret = nf90_def_dim ( ncID , 'zm' , n3 , zmID ) iret = nf90_def_var ( ncID , 'zt' , NF90_FLOAT ,( / ztID / ) , VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'Vertical displacement of cell centers' ) iret = nf90_put_att ( ncID , VarID , 'units' , 'm' ) iret = nf90_def_var ( ncID , 'zm' , NF90_FLOAT ,( / zmID / ), VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'Vertical displacement of cell edges' ) iret = nf90_put_att ( ncID , VarID , 'units' , 'm' ) end if if ( present ( ns )) then iret = nf90_def_dim ( ncID , 'zts' , ns , ztsID ) iret = nf90_def_var ( ncID , 'zts' , NF90_FLOAT ,( / ztsID / ) , VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'Soil level depth of cell centers' ) iret = nf90_put_att ( ncID , VarID , 'units' , 'm' ) end if if ( present ( nfcts )) then iret = nf90_def_dim ( ncID , 'fct' , nfcts , fctID ) iret = nf90_def_var ( ncID , 'fct' , NF90_INT ,( / fctID / ) , VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'Facet number' ) end if if ( present ( nlyrs )) then iret = nf90_def_dim ( ncID , 'lyr' , nlyrs , lyrID ) iret = nf90_def_var ( ncID , 'lyr' , NF90_INT ,( / lyrID / ) , VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'Number of wall layers' ) end if else nrec = 0 ncall = 0 iret = nf90_open ( trim ( fname ), NF90_WRITE , ncid ) iret = nf90_inquire ( ncid , unlimitedDimId = RecordDimID ) iret = nf90_inquire_dimension ( ncid , RecordDimID , len = nrec ) if ( nrec > 0 ) then iret = nf90_inq_varid ( ncid , 'time' , timeID ) allocate ( xtimes ( nrec )) iret = nf90_get_var ( ncid , timeId , xtimes ( 1 : nrec )) do while ( xtimes ( ncall + 1 ) < timee - spacing ( 1. )) ncall = ncall + 1 if ( ncall >= nrec ) exit end do deallocate ( xtimes ) end if if ( present ( n1 )) then iret = nf90_inq_dimid ( ncid , 'xt' , xtId ) iret = nf90_inq_dimid ( ncid , 'xm' , xmId ) end if if ( present ( n2 )) then iret = nf90_inq_dimid ( ncid , 'yt' , ytId ) iret = nf90_inq_dimid ( ncid , 'ym' , ymId ) end if if ( present ( n3 )) then iret = nf90_inq_dimid ( ncid , 'zt' , ztId ) iret = nf90_inq_dimid ( ncid , 'zm' , zmId ) end if if ( present ( ns )) then iret = nf90_inq_dimid ( ncid , 'zts' , ztsId ) end if if ( present ( nfcts )) then iret = nf90_inq_dimid ( ncid , 'fct' , fctId ) end if end if nrec = ncall iret = nf90_sync ( ncid ) iret = nf90_enddef ( ncID ) end subroutine open_nc","tags":"","loc":"proc/open_nc.html"},{"title":"define_nc – uDALES","text":"public subroutine define_nc(ncID, nVar, sx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncID integer, intent(in) :: nVar character(len=*), intent(in) :: sx (nVar,4) Calls proc~~define_nc~~CallsGraph proc~define_nc define_nc nf90_put_att nf90_put_att proc~define_nc->nf90_put_att nf90_redef nf90_redef proc~define_nc->nf90_redef nf90_def_var nf90_def_var proc~define_nc->nf90_def_var nf90_inq_varid nf90_inq_varid proc~define_nc->nf90_inq_varid nf90_inq_dimid nf90_inq_dimid proc~define_nc->nf90_inq_dimid nf90_enddef nf90_enddef proc~define_nc->nf90_enddef proc~nchandle_error nchandle_error proc~define_nc->proc~nchandle_error nf90_strerror nf90_strerror proc~nchandle_error->nf90_strerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~define_nc~~CalledByGraph proc~define_nc define_nc proc~initstatsdump initstatsdump proc~initstatsdump->proc~define_nc proc~initfielddump initfielddump proc~initfielddump->proc~define_nc proc~initeb initEB proc~initeb->proc~define_nc program~dalesurban DALESURBAN program~dalesurban->proc~initstatsdump program~dalesurban->proc~initfielddump program~dalesurban->proc~initeb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code define_nc Source Code subroutine define_nc ( ncID , nVar , sx ) implicit none integer , intent ( in ) :: nVar , ncID character ( * ), intent ( in ) :: sx ( nVar , 4 ) integer , save :: dim_mttt ( 4 ) = 0 , dim_tmtt ( 4 ) = 0 , dim_ttmt ( 4 ) = 0 , dim_tttt ( 4 ) = 0 , & dim_tt ( 2 ) = 0 , dim_mt ( 2 ) = 0 , dim_t0tt ( 3 ) = 0 , dim_m0tt ( 3 ) = 0 , dim_t0mt ( 3 ) = 0 ,& dim_m0mt ( 3 ) = 0 , dim_tt0t ( 3 ) = 0 , & dim_mt0t ( 3 ) = 0 , dim_tm0t ( 3 ) = 0 , dim_0ttt ( 3 ) = 0 , dim_0mtt ( 3 ) = 0 , dim_0tmt ( 3 ) = 0 ,& dim_tts ( 2 ) = 0 , dim_t0tts ( 3 ) = 0 , dim_0ttts ( 3 ) = 0 , dim_tttts ( 4 ) = 0 , dim_ttt0 ( 3 ) = 0 ,& !tg3315 added last one dim_mtmt ( 4 ), dim_tmmt ( 4 ), dim_mmtt ( 4 ),& !bss116 dim_ft ( 2 ), dim_flt ( 3 ) !SO integer :: iret , n , VarID !write(*,*) 'definenc' iret = nf90_inq_dimid ( ncid , 'time' , timeId ) iret = nf90_inq_dimid ( ncid , 'xt' , xtId ) iret = nf90_inq_dimid ( ncid , 'xm' , xmId ) iret = nf90_inq_dimid ( ncid , 'yt' , ytId ) iret = nf90_inq_dimid ( ncid , 'ym' , ymId ) iret = nf90_inq_dimid ( ncid , 'zt' , ztId ) iret = nf90_inq_dimid ( ncid , 'zm' , zmId ) iret = nf90_inq_dimid ( ncid , 'zts' , ztsId ) iret = nf90_inq_dimid ( ncid , 'fct' , fctId ) ! so4718 for energy balance output iret = nf90_inq_dimid ( ncid , 'lyr' , lyrId ) ! so4718 for energy balance output iret = nf90_redef ( ncid ) dim_tt = ( / ztId , timeId / ) dim_mt = ( / zmId , timeId / ) dim_t0tt = ( / xtID , ztID , timeId / ) ! thermo point dim_t0mt = ( / xtID , zmID , timeId / ) ! zpoint dim_m0tt = ( / xmID , ztID , timeId / ) ! upoint dim_m0mt = ( / xmID , ztID , timeId / ) ! uw stats point dim_tt0t = ( / xtID , ytID , timeId / ) ! thermo point dim_tm0t = ( / xtID , ymID , timeId / ) ! vpoint dim_mt0t = ( / xmID , ytID , timeId / ) ! upoint dim_0ttt = ( / ytID , ztID , timeId / ) ! thermo point dim_0tmt = ( / ytID , zmID , timeId / ) ! wpoint dim_0mtt = ( / ymID , ztID , timeId / ) ! vpoint dim_tttt = ( / xtID , ytID , ztID , timeId / ) ! thermo point dim_ttmt = ( / xtID , ytID , zmID , timeId / ) ! zpoint dim_mttt = ( / xmID , ytID , ztID , timeId / ) ! upoint dim_tmtt = ( / xtID , ymID , ztId , timeId / ) ! ypoint dim_mtmt = ( / xmID , ytID , zmId , timeId / ) ! uw stats point bss116 dim_tmmt = ( / xtID , ymID , zmId , timeId / ) ! vw stats point bss116 dim_mmtt = ( / xmID , ymID , ztId , timeId / ) ! uv stats point bss116 dim_ttt0 = ( / xtID , ytID , ztID / ) ! stats point tg3315 dim_tts = ( / ztsId , timeId / ) dim_t0tts = ( / xtID , ztsID , timeId / ) ! thermo soil point dim_0ttts = ( / ytID , ztsID , timeId / ) ! thermo point dim_tttts = ( / xtID , ytID , ztsID , timeId / ) ! thermo point dim_ft = ( / fctID , timeId / ) dim_flt = ( / fctID , lyrID , timeId / ) do n = 1 , nVar !      write(*,*) 'n', n !      write(*,*) \"dummyline1\" !      write(*,*) 'sx1', sx(1,:) !      write(*,*) 'sx2', sx(2,:) !      write(*,*) \"dummyline2\" !      write(*,*) 'trim(sx(n,1))', trim(sx(n,1)) !      write(*,*) 'trim(sx(n,2))', trim(sx(n,2)) !      write(*,*) 'trim(sx(n,3))', trim(sx(n,3)) !      write(*,*) 'trim(sx(n,4))', trim(sx(n,4)) !      write (*,*) 'ncID', ncID iret = nf90_inq_varid ( ncid , trim ( sx ( n , 1 )), VarID ) if ( iret == 0 ) cycle select case ( trim ( sx ( n , 4 ))) case ( 'time' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT ,( / timeID / ) , VarID ) case ( 'tt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_tt , VarID ) case ( 'mt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_mt , VarID ) !2D Fields case ( 't0tt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_t0tt , VarID ) case ( 't0mt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_t0mt , VarID ) case ( 'm0tt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_m0tt , VarID ) case ( 'm0mt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_m0mt , VarID ) case ( 'tt0t' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_tt0t , VarID ) case ( 'tm0t' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_tm0t , VarID ) case ( 'mt0t' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_mt0t , VarID ) case ( '0ttt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_0ttt , VarID ) case ( '0tmt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_0tmt , VarID ) case ( '0mtt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_0mtt , VarID ) case ( 'ttt0' ) !tg3315 for uav,vav,wav etc. iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_ttt0 , VarID ) !3D Fields case ( 'tttt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_tttt , VarID ) case ( 'mttt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_mttt , VarID ) case ( 'tmtt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_tmtt , VarID ) case ( 'ttmt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_ttmt , VarID ) case ( 'mtmt' ) ! bss116 iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_mtmt , VarID ) case ( 'tmmt' ) ! bss116 iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_tmmt , VarID ) case ( 'mmtt' ) ! bss116 iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_mmtt , VarID ) !Soil fields case ( 'tts' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_tts , VarID ) case ( 't0tts' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_t0tts , VarID ) case ( '0ttts' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_0ttts , VarID ) case ( 'tttts' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_tttts , VarID ) !Facet information case ( 'ft' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_ft , VarID ) case ( 'flt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_flt , VarID ) case default write ( 0 , * ) 'nvar' , nvar , sx ( n ,:) write ( 0 , * ) 'ERROR: Bad dimensional information ' , sx ( n ,:) stop 1 ! call appl_abort(0) end select if ( iret /= 0 ) then !        write (*,*) 'nvar', nvar, sx(n,:) !        write (*,*) 'ncID', ncID call nchandle_error ( iret ) end if iret = nf90_put_att ( ncID , VarID , 'longname' , sx ( n , 2 )) iret = nf90_put_att ( ncID , VarID , 'units' , sx ( n , 3 )) iret = nf90_put_att ( ncid , VarID , '_FillValue' , nc_fillvalue ) end do iret = nf90_enddef ( ncID ) end subroutine define_nc","tags":"","loc":"proc/define_nc.html"},{"title":"redefine_nc – uDALES","text":"public subroutine redefine_nc(ncid) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid Calls proc~~redefine_nc~~CallsGraph proc~redefine_nc redefine_nc nf90_redef nf90_redef proc~redefine_nc->nf90_redef Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code redefine_nc Source Code subroutine redefine_nc ( ncid ) implicit none integer , intent ( in ) :: ncid integer :: iret iret = nf90_redef ( ncid ) end subroutine redefine_nc","tags":"","loc":"proc/redefine_nc.html"},{"title":"exitstat_nc – uDALES","text":"public subroutine exitstat_nc(ncid) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid Calls proc~~exitstat_nc~~CallsGraph proc~exitstat_nc exitstat_nc nf90_close nf90_close proc~exitstat_nc->nf90_close Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code exitstat_nc Source Code subroutine exitstat_nc ( ncid ) implicit none integer , intent ( in ) :: ncid integer status status = nf90_close ( ncid ) if ( status /= nf90_noerr ) call nchandle_error ( status ) end subroutine exitstat_nc","tags":"","loc":"proc/exitstat_nc.html"},{"title":"writestat_dims_nc – uDALES","text":"public subroutine writestat_dims_nc(ncid) Uses modglobal modmpi proc~~writestat_dims_nc~~UsesGraph proc~writestat_dims_nc writestat_dims_nc module~modmpi modmpi proc~writestat_dims_nc->module~modmpi module~modglobal modglobal proc~writestat_dims_nc->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid Calls proc~~writestat_dims_nc~~CallsGraph proc~writestat_dims_nc writestat_dims_nc nf90_inq_varid nf90_inq_varid proc~writestat_dims_nc->nf90_inq_varid nf90_put_var nf90_put_var proc~writestat_dims_nc->nf90_put_var nf90_inquire_dimension nf90_inquire_dimension proc~writestat_dims_nc->nf90_inquire_dimension Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writestat_dims_nc~~CalledByGraph proc~writestat_dims_nc writestat_dims_nc proc~initstatsdump initstatsdump proc~initstatsdump->proc~writestat_dims_nc proc~initfielddump initfielddump proc~initfielddump->proc~writestat_dims_nc proc~initeb initEB proc~initeb->proc~writestat_dims_nc program~dalesurban DALESURBAN program~dalesurban->proc~initstatsdump program~dalesurban->proc~initfielddump program~dalesurban->proc~initeb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code writestat_dims_nc Source Code subroutine writestat_dims_nc ( ncid ) use modglobal , only : xf , xh , dy , zf , zh , jmax use modmpi , only : myid implicit none integer , intent ( in ) :: ncid integer :: i = 0 , iret , length , varid write ( * , * ) 'writestat_dims_nc' iret = nf90_inq_varid ( ncid , 'xt' , VarID ) if ( iret == 0 ) iret = nf90_inquire_dimension ( ncid , xtID , len = length ) !if (iret==0) iret = nf90_put_var(ncid, varID, zf(1:length),(/1/)) if ( iret == 0 ) iret = nf90_put_var ( ncid , varID , xf ( 1 : length ),( / 1 / )) iret = nf90_inq_varid ( ncid , 'xm' , VarID ) if ( iret == 0 ) iret = nf90_inquire_dimension ( ncid , xmID , len = length ) if ( iret == 0 ) iret = nf90_put_var ( ncid , varID , xh ( 1 : length ),( / 1 / )) iret = nf90_inq_varid ( ncid , 'yt' , VarID ) if ( iret == 0 ) iret = nf90_inquire_dimension ( ncid , ytID , len = length ) if ( iret == 0 ) iret = nf90_put_var ( ncid , varID , ( / ( dy * ( 0.5 + i ) + myid * jmax * dy , i = 0 , length - 1 ) / ),( / 1 / )) iret = nf90_inq_varid ( ncid , 'ym' , VarID ) if ( iret == 0 ) iret = nf90_inquire_dimension ( ncid , ymID , len = length ) if ( iret == 0 ) iret = nf90_put_var ( ncid , varID , ( / ( dy * i + myid * jmax * dy , i = 0 , length - 1 ) / ),( / 1 / )) iret = nf90_inq_varid ( ncid , 'zt' , VarID ) if ( iret == 0 ) iret = nf90_inquire_dimension ( ncid , ztID , len = length ) if ( iret == 0 ) iret = nf90_put_var ( ncid , varID , zf ( 0 : length - 1 ),( / 1 / )) !ils13, 29.06.2017 zf starts at 0, not at 1 iret = nf90_inq_varid ( ncid , 'zm' , VarID ) if ( iret == 0 ) iret = nf90_inquire_dimension ( ncid , zmID , len = length ) if ( iret == 0 ) iret = nf90_put_var ( ncid , varID , zh ( 0 : length - 1 ),( / 1 / )) !same for zh !if (isurf==1) then !iret = nf90_inq_varid(ncid, 'zts', VarID) !if (iret==0) iret = nf90_inquire_dimension(ncid, ztsID, len=length) !if (iret==0) iret = nf90_put_var(ncid, varID, zsoilc(1:length),(/1/)) !end if end subroutine writestat_dims_nc","tags":"","loc":"proc/writestat_dims_nc.html"},{"title":"writestat_time_nc – uDALES","text":"public subroutine writestat_time_nc(ncid, nvar, ncname, vars, nrec, lraise) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname real, intent(in), dimension(nvar) :: vars integer, intent(inout) :: nrec logical, intent(in) :: lraise Calls proc~~writestat_time_nc~~CallsGraph proc~writestat_time_nc writestat_time_nc nf90_inq_varid nf90_inq_varid proc~writestat_time_nc->nf90_inq_varid nf90_put_var nf90_put_var proc~writestat_time_nc->nf90_put_var nf90_sync nf90_sync proc~writestat_time_nc->nf90_sync Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writestat_time_nc~~CalledByGraph proc~writestat_time_nc writestat_time_nc interface~writestat_nc writestat_nc interface~writestat_nc->proc~writestat_time_nc proc~fielddump fielddump proc~fielddump->interface~writestat_nc proc~statsdump statsdump proc~statsdump->interface~writestat_nc proc~eb EB proc~eb->interface~writestat_nc program~dalesurban DALESURBAN program~dalesurban->proc~fielddump program~dalesurban->proc~statsdump program~dalesurban->proc~eb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code writestat_time_nc Source Code subroutine writestat_time_nc ( ncid , nvar , ncname , vars , nrec , lraise ) implicit none integer , intent ( in ) :: ncid , nvar integer , intent ( inout ) :: nrec real , dimension ( nvar ), intent ( in ) :: vars character ( * ), dimension (:,:), intent ( in ) :: ncname logical , intent ( in ) :: lraise integer :: iret , n , varid !write(*,*) 'time-nc' if ( lraise ) then nrec = nrec + 1 end if do n = 1 , nvar iret = nf90_inq_varid ( ncid , ncname ( n , 1 ), VarID ) iret = nf90_put_var ( ncid , VarID , vars ( n ), start = ( / nrec / )) end do iret = nf90_sync ( ncid ) end subroutine writestat_time_nc","tags":"","loc":"proc/writestat_time_nc.html"},{"title":"writestat_1D_nc – uDALES","text":"public subroutine writestat_1D_nc(ncid, nvar, ncname, vars, nrec, dim1) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname real, intent(in), dimension(dim1,nvar) :: vars integer, intent(in) :: nrec integer, intent(in) :: dim1 Calls proc~~writestat_1d_nc~~CallsGraph proc~writestat_1d_nc writestat_1D_nc nf90_inq_varid nf90_inq_varid proc~writestat_1d_nc->nf90_inq_varid nf90_put_var nf90_put_var proc~writestat_1d_nc->nf90_put_var nf90_sync nf90_sync proc~writestat_1d_nc->nf90_sync Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writestat_1d_nc~~CalledByGraph proc~writestat_1d_nc writestat_1D_nc proc~statsdump statsdump proc~statsdump->proc~writestat_1d_nc interface~writestat_nc writestat_nc proc~statsdump->interface~writestat_nc proc~eb EB proc~eb->proc~writestat_1d_nc proc~eb->interface~writestat_nc interface~writestat_nc->proc~writestat_1d_nc proc~fielddump fielddump proc~fielddump->interface~writestat_nc program~dalesurban DALESURBAN program~dalesurban->proc~statsdump program~dalesurban->proc~eb program~dalesurban->proc~fielddump Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code writestat_1D_nc Source Code subroutine writestat_1D_nc ( ncid , nvar , ncname , vars , nrec , dim1 ) implicit none integer , intent ( in ) :: ncid , nvar , dim1 integer , intent ( in ) :: nrec real , dimension ( dim1 , nvar ), intent ( in ) :: vars character ( * ), dimension (:,:), intent ( in ) :: ncname integer :: iret , n , varid do n = 1 , nvar iret = nf90_inq_varid ( ncid , ncname ( n , 1 ), VarID ) iret = nf90_put_var ( ncid , VarID , vars ( 1 : dim1 , n ),( / 1 , nrec / ),( / dim1 , 1 / )) end do iret = nf90_sync ( ncid ) end subroutine writestat_1D_nc","tags":"","loc":"proc/writestat_1d_nc.html"},{"title":"writestat_2D_nc – uDALES","text":"public subroutine writestat_2D_nc(ncid, nvar, ncname, vars, nrec, dim1, dim2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname real, intent(in), dimension(:,:,:) :: vars integer, intent(in) :: nrec integer, intent(in) :: dim1 integer, intent(in) :: dim2 Calls proc~~writestat_2d_nc~~CallsGraph proc~writestat_2d_nc writestat_2D_nc nf90_inq_varid nf90_inq_varid proc~writestat_2d_nc->nf90_inq_varid nf90_put_var nf90_put_var proc~writestat_2d_nc->nf90_put_var nf90_sync nf90_sync proc~writestat_2d_nc->nf90_sync Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writestat_2d_nc~~CalledByGraph proc~writestat_2d_nc writestat_2D_nc proc~eb EB proc~eb->proc~writestat_2d_nc interface~writestat_nc writestat_nc proc~eb->interface~writestat_nc interface~writestat_nc->proc~writestat_2d_nc proc~fielddump fielddump proc~fielddump->interface~writestat_nc proc~statsdump statsdump proc~statsdump->interface~writestat_nc program~dalesurban DALESURBAN program~dalesurban->proc~eb program~dalesurban->proc~fielddump program~dalesurban->proc~statsdump Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code writestat_2D_nc Source Code subroutine writestat_2D_nc ( ncid , nvar , ncname , vars , nrec , dim1 , dim2 ) implicit none integer , intent ( in ) :: ncid , nvar , dim1 , dim2 integer , intent ( in ) :: nrec real , dimension (:,:,:), intent ( in ) :: vars character ( * ), dimension (:,:), intent ( in ) :: ncname integer :: iret , n , varid do n = 1 , nvar iret = nf90_inq_varid ( ncid , ncname ( n , 1 ), VarID ) iret = nf90_put_var ( ncid , VarID , vars ( 1 : dim1 , 1 : dim2 , n ),( / 1 , 1 , nrec / ),( / dim1 , dim2 , 1 / )) end do iret = nf90_sync ( ncid ) end subroutine writestat_2D_nc","tags":"","loc":"proc/writestat_2d_nc.html"},{"title":"writestat_3D_nc – uDALES","text":"public subroutine writestat_3D_nc(ncid, nvar, ncname, vars, nrec, dim1, dim2, dim3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname real, intent(in), dimension(dim1,dim2,dim3,nvar) :: vars integer, intent(in) :: nrec integer, intent(in) :: dim1 integer, intent(in) :: dim2 integer, intent(in) :: dim3 Calls proc~~writestat_3d_nc~~CallsGraph proc~writestat_3d_nc writestat_3D_nc nf90_inq_varid nf90_inq_varid proc~writestat_3d_nc->nf90_inq_varid nf90_put_var nf90_put_var proc~writestat_3d_nc->nf90_put_var nf90_sync nf90_sync proc~writestat_3d_nc->nf90_sync Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writestat_3d_nc~~CalledByGraph proc~writestat_3d_nc writestat_3D_nc interface~writestat_nc writestat_nc interface~writestat_nc->proc~writestat_3d_nc proc~fielddump fielddump proc~fielddump->interface~writestat_nc proc~statsdump statsdump proc~statsdump->interface~writestat_nc proc~eb EB proc~eb->interface~writestat_nc program~dalesurban DALESURBAN program~dalesurban->proc~fielddump program~dalesurban->proc~statsdump program~dalesurban->proc~eb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code writestat_3D_nc Source Code subroutine writestat_3D_nc ( ncid , nvar , ncname , vars , nrec , dim1 , dim2 , dim3 ) implicit none integer , intent ( in ) :: ncid , nvar , dim1 , dim2 , dim3 integer , intent ( in ) :: nrec real , dimension ( dim1 , dim2 , dim3 , nvar ), intent ( in ) :: vars character ( * ), dimension (:,:), intent ( in ) :: ncname integer :: iret , n , varid !write(*,*) 'write 3Dnc' do n = 1 , nvar iret = nf90_inq_varid ( ncid , ncname ( n , 1 ), VarID ) !write(*,*) 'MYID,.', myid !write(*,*) \"nth netcdf variable\",n !write(*,*) 'ncid',ncid !write(*,*) \"n\",n !write(*,*) 'ncname(n,1)',ncname(n,1) !write(*,*) 'VarID',VarID !write(*,*) 'nrec',nrec !write(*,*) 'imax',dim1 !write(*,*) 'jmax',dim2 !write(*,*) 'kmax',dim3 !write(*,*) 'shape(vars)',shape(vars) iret = nf90_put_var ( ncid , VarID , vars ( 1 : dim1 , 1 : dim2 , 1 : dim3 , n ),( / 1 , 1 , 1 , nrec / ),( / dim1 , dim2 , dim3 , 1 / )) end do iret = nf90_sync ( ncid ) end subroutine writestat_3D_nc","tags":"","loc":"proc/writestat_3d_nc.html"},{"title":"writestat_3D_short_nc – uDALES","text":"public subroutine writestat_3D_short_nc(ncid, nvar, ncname, vars, nrec, dim1, dim2, dim3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname integer(kind=selected_int_kind(4)), intent(in), dimension(dim1,dim2,dim3,nvar) :: vars integer, intent(in) :: nrec integer, intent(in) :: dim1 integer, intent(in) :: dim2 integer, intent(in) :: dim3 Calls proc~~writestat_3d_short_nc~~CallsGraph proc~writestat_3d_short_nc writestat_3D_short_nc nf90_inq_varid nf90_inq_varid proc~writestat_3d_short_nc->nf90_inq_varid nf90_put_var nf90_put_var proc~writestat_3d_short_nc->nf90_put_var nf90_sync nf90_sync proc~writestat_3d_short_nc->nf90_sync Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writestat_3d_short_nc~~CalledByGraph proc~writestat_3d_short_nc writestat_3D_short_nc interface~writestat_nc writestat_nc interface~writestat_nc->proc~writestat_3d_short_nc proc~fielddump fielddump proc~fielddump->interface~writestat_nc proc~statsdump statsdump proc~statsdump->interface~writestat_nc proc~eb EB proc~eb->interface~writestat_nc program~dalesurban DALESURBAN program~dalesurban->proc~fielddump program~dalesurban->proc~statsdump program~dalesurban->proc~eb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code writestat_3D_short_nc Source Code subroutine writestat_3D_short_nc ( ncid , nvar , ncname , vars , nrec , dim1 , dim2 , dim3 ) implicit none integer , intent ( in ) :: ncid , nvar , dim1 , dim2 , dim3 integer , intent ( in ) :: nrec integer ( KIND = selected_int_kind ( 4 )), dimension ( dim1 , dim2 , dim3 , nvar ), intent ( in ) :: vars character ( * ), dimension (:,:), intent ( in ) :: ncname integer :: iret , n , varid !write(*,*) '3Dnc short' do n = 1 , nvar iret = nf90_inq_varid ( ncid , ncname ( n , 1 ), VarID ) iret = nf90_put_var ( ncid , VarID , vars ( 1 : dim1 , 1 : dim2 , 1 : dim3 , n ),( / 1 , 1 , 1 , nrec / ),( / dim1 , dim2 , dim3 , 1 / )) end do iret = nf90_sync ( ncid ) end subroutine writestat_3D_short_nc","tags":"","loc":"proc/writestat_3d_short_nc.html"},{"title":"ncinfo – uDALES","text":"public subroutine ncinfo(out, in1, in2, in3, in4) Arguments Type Intent Optional Attributes Name character(len=*), intent(out), dimension(4) :: out character(len=*), intent(in) :: in1 character(len=*), intent(in) :: in2 character(len=*), intent(in) :: in3 character(len=*), intent(in) :: in4 Contents Source Code ncinfo Source Code subroutine ncinfo ( out , in1 , in2 , in3 , in4 ) implicit none character ( * ), dimension ( 4 ), intent ( out ) :: out character ( * ), intent ( in ) :: in1 , in2 , in3 , in4 out ( 1 ) = in1 out ( 2 ) = in2 out ( 3 ) = in3 out ( 4 ) = in4 end subroutine ncinfo","tags":"","loc":"proc/ncinfo.html"},{"title":"nchandle_error – uDALES","text":"public subroutine nchandle_error(status) Uses netcdf proc~~nchandle_error~~UsesGraph proc~nchandle_error nchandle_error netcdf netcdf proc~nchandle_error->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: status Calls proc~~nchandle_error~~CallsGraph proc~nchandle_error nchandle_error nf90_strerror nf90_strerror proc~nchandle_error->nf90_strerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~nchandle_error~~CalledByGraph proc~nchandle_error nchandle_error proc~define_nc define_nc proc~define_nc->proc~nchandle_error proc~initstatsdump initstatsdump proc~initstatsdump->proc~define_nc proc~initfielddump initfielddump proc~initfielddump->proc~define_nc proc~initeb initEB proc~initeb->proc~define_nc program~dalesurban DALESURBAN program~dalesurban->proc~initstatsdump program~dalesurban->proc~initfielddump program~dalesurban->proc~initeb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code nchandle_error Source Code subroutine nchandle_error ( status ) use netcdf implicit none integer , intent ( in ) :: status if ( status /= nf90_noerr ) then write ( 0 , * ) trim ( nf90_strerror ( status )) write ( 0 , * ) 'ERROR: status' , status stop 1 end if end subroutine nchandle_error","tags":"","loc":"proc/nchandle_error.html"},{"title":"writestat_nc – uDALES","text":"public interface writestat_nc Calls interface~~writestat_nc~~CallsGraph interface~writestat_nc writestat_nc proc~writestat_2d_nc writestat_2D_nc interface~writestat_nc->proc~writestat_2d_nc proc~writestat_1d_nc writestat_1D_nc interface~writestat_nc->proc~writestat_1d_nc proc~writestat_time_nc writestat_time_nc interface~writestat_nc->proc~writestat_time_nc proc~writestat_3d_nc writestat_3D_nc interface~writestat_nc->proc~writestat_3d_nc proc~writestat_3d_short_nc writestat_3D_short_nc interface~writestat_nc->proc~writestat_3d_short_nc nf90_inq_varid nf90_inq_varid proc~writestat_2d_nc->nf90_inq_varid nf90_put_var nf90_put_var proc~writestat_2d_nc->nf90_put_var nf90_sync nf90_sync proc~writestat_2d_nc->nf90_sync proc~writestat_1d_nc->nf90_inq_varid proc~writestat_1d_nc->nf90_put_var proc~writestat_1d_nc->nf90_sync proc~writestat_time_nc->nf90_inq_varid proc~writestat_time_nc->nf90_put_var proc~writestat_time_nc->nf90_sync proc~writestat_3d_nc->nf90_inq_varid proc~writestat_3d_nc->nf90_put_var proc~writestat_3d_nc->nf90_sync proc~writestat_3d_short_nc->nf90_inq_varid proc~writestat_3d_short_nc->nf90_put_var proc~writestat_3d_short_nc->nf90_sync Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~writestat_nc~~CalledByGraph interface~writestat_nc writestat_nc proc~fielddump fielddump proc~fielddump->interface~writestat_nc proc~statsdump statsdump proc~statsdump->interface~writestat_nc proc~eb EB proc~eb->interface~writestat_nc program~dalesurban DALESURBAN program~dalesurban->proc~fielddump program~dalesurban->proc~statsdump program~dalesurban->proc~eb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures writestat_time_nc writestat_1D_nc writestat_2D_nc writestat_3D_nc writestat_3D_short_nc Module Procedures public subroutine writestat_time_nc (ncid, nvar, ncname, vars, nrec, lraise) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname real, intent(in), dimension(nvar) :: vars integer, intent(inout) :: nrec logical, intent(in) :: lraise public subroutine writestat_1D_nc (ncid, nvar, ncname, vars, nrec, dim1) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname real, intent(in), dimension(dim1,nvar) :: vars integer, intent(in) :: nrec integer, intent(in) :: dim1 public subroutine writestat_2D_nc (ncid, nvar, ncname, vars, nrec, dim1, dim2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname real, intent(in), dimension(:,:,:) :: vars integer, intent(in) :: nrec integer, intent(in) :: dim1 integer, intent(in) :: dim2 public subroutine writestat_3D_nc (ncid, nvar, ncname, vars, nrec, dim1, dim2, dim3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname real, intent(in), dimension(dim1,dim2,dim3,nvar) :: vars integer, intent(in) :: nrec integer, intent(in) :: dim1 integer, intent(in) :: dim2 integer, intent(in) :: dim3 public subroutine writestat_3D_short_nc (ncid, nvar, ncname, vars, nrec, dim1, dim2, dim3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname integer(kind=selected_int_kind(4)), intent(in), dimension(dim1,dim2,dim3,nvar) :: vars integer, intent(in) :: nrec integer, intent(in) :: dim1 integer, intent(in) :: dim2 integer, intent(in) :: dim3","tags":"","loc":"interface/writestat_nc.html"},{"title":"qsat – uDALES","text":"public function qsat(T) Arguments Type Intent Optional Attributes Name real, intent(in) :: T Return Value real Called by proc~~qsat~~CalledByGraph proc~qsat qsat proc~readfacetfiles readfacetfiles proc~readfacetfiles->proc~qsat proc~updategr updateGR proc~updategr->proc~qsat proc~eb EB proc~eb->proc~updategr program~dalesurban DALESURBAN program~dalesurban->proc~readfacetfiles program~dalesurban->proc~eb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code qsat Source Code real function qsat ( T ) implicit none real , intent ( in ) :: T real :: gres gres = 61 1.00 * exp ( 1 7.27 * ( T - 27 3.15 ) / ( T - 3 5.85 )) ![Pa] Bolton 1980 qsat = 0.62198 * 0.01 * gres / ( 1000 - 0.01 * gres ) ![kg/kg] Murphy & Koop 2005 !1000 can be replaced with actual air pressure if desired end function qsat","tags":"","loc":"proc/qsat.html"},{"title":"dqsatdT – uDALES","text":"public function dqsatdT(T) Arguments Type Intent Optional Attributes Name real, intent(in) :: T Return Value real Contents Source Code dqsatdT Source Code real function dqsatdT ( T ) implicit none real , intent ( in ) :: T dqsatdT = 0.1384832710e-2 + 0.7708409674e-4 * ( T - 300 ) + 0.2022064593e-5 * ( T - 300 ) ** 2 + 0.000000036561 * ( T - 300 ) ** 3 !expansion of qsat(T) end function dqsatdt","tags":"","loc":"proc/dqsatdt.html"},{"title":"readfacetfiles – uDALES","text":"public subroutine readfacetfiles() Uses modglobal proc~~readfacetfiles~~UsesGraph proc~readfacetfiles readfacetfiles module~modglobal modglobal proc~readfacetfiles->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~readfacetfiles~~CallsGraph proc~readfacetfiles readfacetfiles proc~qsat qsat proc~readfacetfiles->proc~qsat nf90_inq_varid nf90_inq_varid proc~readfacetfiles->nf90_inq_varid nf90_open nf90_open proc~readfacetfiles->nf90_open nf90_get_var nf90_get_var proc~readfacetfiles->nf90_get_var mpi_bcast mpi_bcast proc~readfacetfiles->mpi_bcast Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readfacetfiles~~CalledByGraph proc~readfacetfiles readfacetfiles program~dalesurban DALESURBAN program~dalesurban->proc~readfacetfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code readfacetfiles Source Code subroutine readfacetfiles use modglobal , only : block , cexpnr , iwalltemp implicit none !use modglobal, only:block !read initial&unchangeable facet values from files !read blocks and facet Nr corresponding to block faces (Order: Top, West, East, North, South) !define facets with properties and initial temperature !read facets.inp.xxx facetarea.inp.xxx vf.inp.xxx walltypes.inp.xxx !read netsw.inp.xxx (if sun is not constant, K needs to be calculated at every EB-timestep) !read tfacinit.inp.xxx !use modglobal, only : nblocks, nfcts, cexpnr, ifinput character ( len = 13 ) :: FILE_VF = 'vf.nc.inp.xxx' integer :: ncid , varid integer :: n = 0 , m = 0 , i = 0 , j = 0 , k = 0 , io = 0 integer :: iret if (. not .( nfcts > 0 )) return nwallprops = 6 + 4 * nwalllayers + 1 !allocate (block(nblocks, 11)) allocate ( faclGR ( 0 : nfcts )) allocate ( facz0 ( 0 : nfcts )) !0 is the default value (e.g. for internal walls) allocate ( facz0h ( 0 : nfcts )) allocate ( facalb ( 0 : nfcts )) allocate ( facem ( 0 : nfcts )) allocate ( facdi ( 0 : nfcts , nwalllayers )) allocate ( facd ( 0 : nfcts , nwalllayers )) allocate ( faccp ( 0 : nfcts , nwalllayers )) allocate ( faclami ( 0 : nfcts , nwalllayers )) allocate ( fackappa ( 0 : nfcts , nwalllayers + 1 )) allocate ( faca ( 0 : nfcts )) allocate ( facain ( 0 : nfcts )) allocate ( facets ( nfcts , 4 )) if ( lEB . eqv . . true .) then allocate ( vf ( 1 : nfcts , 1 : nfcts )) allocate ( svf ( 1 : nfcts )) allocate ( netsw ( 1 : nfcts )) allocate ( facLWin ( 1 : nfcts )) end if allocate ( Tfacinit ( 1 : nfcts )) allocate ( facT ( 0 : nfcts , nwalllayers + 1 )) allocate ( facTdash ( 1 : nfcts , nwalllayers + 1 )) allocate ( facef ( 1 : nfcts )) allocate ( facefi ( 1 : nfcts )) allocate ( facefsum ( 1 : nfcts )) allocate ( fachf ( 0 : nfcts )) allocate ( fachfi ( 0 : nfcts )) allocate ( fachfsum ( 1 : nfcts )) allocate ( facf ( 0 : nfcts , 5 )) allocate ( fachurel ( 0 : nfcts )) allocate ( facwsoil ( 0 : nfcts )) allocate ( faccth ( 0 : nfcts )) allocate ( facqsat ( 0 : nfcts )) !block = 0; faclGR = . false .; facz0 = 0. ; facz0h = 0. ; facalb = 0. ; facem = 0. ; facd = 0. ; facdi = 0. ; faccp = 0. faclami = 0. ; fackappa = 0. ; faca = 0. ; facain = 0 ; facets = 0 if ( lEB . eqv . . true .) then vf = 0. ; svf = 0. ; netsw = 0. ; facLWin = 0. end if Tfacinit = 0. ; facT = 0. ; facTdash = 0. facef = 0. ; facefi = 0. ; facefsum = 0. ; fachf = 0. ; fachfi = 0. ; fachfsum = 0. facf = 0. ; fachurel = 0. ; facwsoil = 0. ; faccth = 0. ; facqsat = 0. ; if ( myid == 0 . and . libm ) then ! read blocks corner coordinates and facet-Nr correspoinding to the block sides !   open (ifinput, file='blocks.inp.'//cexpnr) !   read (ifinput, '(a80)') chmess !   read (ifinput, '(a80)') chmess !   do n = 1, nblocks !     blockfile is :ilow iheigh jlow jheigh klow kheigh facTop facWest facEast facNorth facSouth !     read (ifinput, *) & !         block(n, 1), & !         block(n, 2), & !         block(n, 3), & !         block(n, 4), & !         block(n, 5), & !         block(n, 6), & !         block(n, 7), & !         block(n, 8), & !         block(n, 9), & !         block(n, 10), & !         block(n, 11) !   end do !   close (ifinput) if ( lEB ) then ! read facet areas open ( ifinput , file = 'facetarea.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess do n = 1 , nfcts read ( ifinput , * ) & faca ( n ) end do close ( ifinput ) write ( * , * ) \"faca\" , faca end if !lEB ! read wall & (green) roof types ! read once to determine number of types, allocate, read again nwalltypes = - 3 !3 lines as headers open ( ifinput , file = 'walltypes.inp.' // cexpnr ) do read ( ifinput , * , iostat = io ) if ( io /= 0 ) exit nwalltypes = nwalltypes + 1 end do close ( ifinput ) end if !(myid == 0 .and. libm) call MPI_BCAST ( nwalltypes , 1 , MPI_Integer , 0 , comm3d , mpierr ) allocate ( walltypes ( 1 : nwalltypes , nwallprops )) if ( myid == 0 ) then walltypes = 0. open ( ifinput , file = 'walltypes.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do n = 1 , nwalltypes read ( ifinput , * ) ( walltypes ( n , m ), m = 1 , nwallprops ) end do close ( ifinput ) end if !myid==0 call MPI_BCAST ( nwalltypes , 1 , MPI_Integer , 0 , comm3d , mpierr ) call MPI_BCAST ( walltypes , nwallprops * nwalltypes , MY_REAL , 0 , comm3d , mpierr ) !create an array mapping walltypes to sequential integers for indexing !e.g. lets assume walltype -3,-1,1,2,3 and 5 are defined. !index: [-3,-2,-1,0,1,2,3,4,5]  -> [-3,-2,-1,0,1,2,3,4,5] !value: [ 0, 0, 0,0,0,0,0,0,0]  -> [ 1, 0, 2,0,3,4,5,0,6] allocate ( typeloc ( int ( minval ( walltypes (:, 1 ))): int ( maxval ( walltypes (:, 1 ))))) if ( myid . eq . 0 ) then !all the read processes just need to be done on one processor typeloc = 0 do n = 1 , nwalltypes typeloc ( int ( walltypes ( n , 1 ))) = n end do ! read the facets open ( ifinput , file = 'facets.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess !orientation, walltype, block in block.inp, original block/building do n = 1 , nfcts read ( ifinput , * ) & facets ( n , 1 ), & facets ( n , 2 ), & facets ( n , 3 ), & facets ( n , 4 ) end do close ( ifinput ) ! calculate the number of indeces per facet in both dimensions (~area) do n = 1 , nfcts if ( facets ( n , 1 ) . eq . 1 ) then facain ( n ) = ( block ( facets ( n , 3 ), 2 ) - block ( facets ( n , 3 ), 1 ) + 1 ) * ( block ( facets ( n , 3 ), 4 ) - block ( facets ( n , 3 ), 3 ) + 1 ) else if ( facets ( n , 1 ) . eq . 2 ) then facain ( n ) = ( block ( facets ( n , 3 ), 6 ) - block ( facets ( n , 3 ), 5 ) + 1 ) * ( block ( facets ( n , 3 ), 4 ) - block ( facets ( n , 3 ), 3 ) + 1 ) else if ( facets ( n , 1 ) . eq . 3 ) then facain ( n ) = ( block ( facets ( n , 3 ), 6 ) - block ( facets ( n , 3 ), 5 ) + 1 ) * ( block ( facets ( n , 3 ), 4 ) - block ( facets ( n , 3 ), 3 ) + 1 ) else if ( facets ( n , 1 ) . eq . 4 ) then facain ( n ) = ( block ( facets ( n , 3 ), 2 ) - block ( facets ( n , 3 ), 1 ) + 1 ) * ( block ( facets ( n , 3 ), 6 ) - block ( facets ( n , 3 ), 5 ) + 1 ) else if ( facets ( n , 1 ) . eq . 5 ) then facain ( n ) = ( block ( facets ( n , 3 ), 2 ) - block ( facets ( n , 3 ), 1 ) + 1 ) * ( block ( facets ( n , 3 ), 6 ) - block ( facets ( n , 3 ), 5 ) + 1 ) end if end do ! assign the facet properties to their own arrays do n = 1 , nfcts i = typeloc ( facets ( n , 2 )) faclGR ( n ) = ( abs ( walltypes ( i , 2 ) - 1.00 ) < 1.0D-5 ) !logic for green surface, conversion from real to logical facz0 ( n ) = walltypes ( i , 3 ) !surface momentum roughness facz0h ( n ) = walltypes ( i , 4 ) !surface heat & moisture roughness facalb ( n ) = walltypes ( i , 5 ) !surface shortwave albedo facem ( n ) = walltypes ( i , 6 ) !surface longwave emissivity if ( facets ( n , 2 ) . lt . - 100 ) then !it's a bounding wall do j = 1 , nwalllayers !bounding walls don't need properties facdi ( n , j ) = 0. !bounding walls have no energy balance facd ( n , j ) = 0. !bounding walls have no thickness faclami ( n , j ) = 0. !bounding walls have no energy balance faccp ( n , j ) = 0. !bounding walls have no heat capacity end do else do j = 1 , nwalllayers !for all layers facdi ( n , j ) = 1 / walltypes ( i , j + 6 ) !inverse of facet thickness of layer j facd ( n , j ) = walltypes ( i , j + 6 ) !facet thickness of layer j faclami ( n , j ) = 1 / walltypes ( i , j + 12 ) !inverse of heat conductivity of layer j faccp ( n , j ) = walltypes ( i , j + 9 ) !specific heat capacity of layer j end do end if do j = 1 , nwalllayers + 1 fackappa ( n , j ) = walltypes ( i , j + 15 ) !heat duffusivity of layer 1 end do end do !give some dummy values for block internal facets (i.e. facets with walltype 0) facz0 ( 0 ) = 0.00999 ; facz0h ( 0 ) = 0.00999 ; facalb ( 0 ) = 0.999 ; facem ( 0 ) = 0.999 ; facd ( 0 , 1 ) = 0.999 ; facd ( 0 , 2 ) = 0.999 ; facdi ( 0 , 1 ) = 0.999 ; facdi ( 0 , 2 ) = 0.999 ; facdi ( 0 , 3 ) = 0.999 ; faccp ( 0 , 1 ) = 99 9. ; faccp ( 0 , 2 ) = 99 9. faccp ( 0 , 3 ) = 99 9. ; faclami ( 0 , 1 ) = 0.999 ; faclami ( 0 , 2 ) = 0.999 ; faclami ( 0 , 3 ) = 0.999 ; fackappa ( 0 , 1 ) = 0.00000999 ; fackappa ( 0 , 2 ) = 0.00000999 ; fackappa ( 0 , 3 ) = 0.00000999 ; faclGR ( 0 ) = . false . if ( lEB ) then ! read viewfactors between facets ! Open the file. NF90_NOWRITE tells netCDF we want read-only access to ! the file. FILE_VF = 'vf.nc.inp.' // cexpnr iret = nf90_open ( FILE_VF , NF90_NOWRITE , ncid ) ! Get the varid of the data variable, based on its name. iret = nf90_inq_varid ( ncid , \"view factor\" , varid ) ! Read the data. iret = nf90_get_var ( ncid , varid , vf ) write ( * , * ) \"vf(1,6),vf(1,7),vf(6,1),vf(7,1)\" , vf ( 1 , 6 ), vf ( 1 , 7 ), vf ( 6 , 1 ), vf ( 7 , 1 ) ! read skyviewfactors open ( ifinput , file = 'svf.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess do n = 1 , nfcts read ( ifinput , * ) & svf ( n ) end do close ( ifinput ) ! read net shortwave radiation open ( ifinput , file = 'netsw.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess do n = 1 , nfcts read ( ifinput , * ) & netsw ( n ) end do close ( ifinput ) end if !lEB if (( lEB ) . or . ( iwalltemp == 2 )) then ! read initial facet temepratures open ( ifinput , file = 'Tfacinit.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess do n = 1 , nfcts read ( ifinput , * ) & Tfacinit ( n ) end do close ( ifinput ) do n = 1 , nfcts facT ( n , 1 ) = Tfacinit ( n ) !building surfaces is given an initial temperature facT ( n , nwalllayers + 1 ) = bldT !inner most layer has the same temperature as the building interior do j = 2 , nwalllayers facT ( n , j ) = Tfacinit ( n ) - ( Tfacinit ( n ) - bldT ) / nwalllayers * ( j - 1 ) !scale linearly inside the wall end do end do do n = 1 , nwalllayers facT ( 0 , n ) = 28 8. end do facT ( 0 , nwalllayers + 1 ) = 29 9. end if !((lEB) .or. (iwalltemp == 2)) ! assign initial soil moisture (only outermost layer) do n = 1 , nfcts if ( faclGR ( n )) then facwsoil ( n ) = wsoil fachurel ( n ) = 0.5 * ( 1. - cos ( 3.14159 * wsoil / wfc )) end if end do end if !(myid .eq. 0) !write (*, *) \"starting broadcast of facet properties\" call MPI_BCAST ( block , 11 * nblocks , MPI_INTEGER , 0 , comm3d , mpierr ) !many of these are actually only needed on processor 0... call MPI_BCAST ( faclGR ( 0 : nfcts ), nfcts + 1 , mpi_logical , 0 , comm3d , mpierr ) call MPI_BCAST ( facz0 ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facz0h ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facalb ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facem ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facd ( 0 : nfcts , 1 : nwalllayers ),( nfcts + 1 ) * nwalllayers , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facdi ( 0 : nfcts , 1 : nwalllayers ), ( nfcts + 1 ) * nwalllayers , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( faccp ( 0 : nfcts , 1 : nwalllayers ), ( nfcts + 1 ) * nwalllayers , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( faclami ( 0 : nfcts , 1 : nwalllayers ), ( nfcts + 1 ) * nwalllayers , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( fackappa ( 0 : nfcts , 1 : nwalllayers + 1 ), ( nfcts + 1 ) * ( nwalllayers + 1 ), MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( faca ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facain ( 0 : nfcts ), nfcts + 1 , MPI_Integer , 0 , comm3d , mpierr ) call MPI_BCAST ( facets , 4 * nfcts , MPI_Integer , 0 , comm3d , mpierr ) !walltypes is broadcast further up if ( lEB . eqv . . true .) then call MPI_BCAST ( svf ( 1 : nfcts ), nfcts , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( netsw ( 1 : nfcts ), nfcts , MY_REAL , 0 , comm3d , mpierr ) end if !facLWin currently not being broadcast.. !vf currently not being broadcast call MPI_BCAST ( Tfacinit ( 1 : nfcts ), nfcts , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facT ( 0 : nfcts , 1 : nwalllayers + 1 ), ( nfcts + 1 ) * ( nwalllayers + 1 ), MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facTdash ( 1 : nfcts , 1 : nwalllayers + 1 ), ( nfcts ) * ( nwalllayers + 1 ), MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facef ( 1 : nfcts ), nfcts , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facefi ( 1 : nfcts ), nfcts , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facefsum ( 1 : nfcts ), nfcts , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( fachf ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( fachfi ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( fachfsum ( 1 : nfcts ), nfcts , MY_REAL , 0 , comm3d , mpierr ) ! standard plant & soil resistance for grass (Manickathan2018) in s/m facf (:, 4 ) = 20 0. facf (:, 5 ) = 5 0. call MPI_BCAST ( facf ( 0 : nfcts , 1 : 5 ), ( nfcts + 1 ) * 5 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( fachurel ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facwsoil ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( faccth ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) do n = 1 , nfcts facqsat ( n ) = qsat ( facT ( n , 1 )) end do call MPI_BCAST ( facqsat ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) end subroutine readfacetfiles","tags":"","loc":"proc/readfacetfiles.html"},{"title":"initinlet – uDALES","text":"public subroutine initinlet() Uses modglobal modfields modmpi proc~~initinlet~~UsesGraph proc~initinlet initinlet module~modmpi modmpi proc~initinlet->module~modmpi module~modfields modfields proc~initinlet->module~modfields module~modglobal modglobal proc~initinlet->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~initinlet~~CallsGraph proc~initinlet initinlet trec trec proc~initinlet->trec wrec wrec proc~initinlet->wrec proc~readzincoord readzincoord proc~initinlet->proc~readzincoord uinl uinl proc~initinlet->uinl winl winl proc~initinlet->winl urec urec proc~initinlet->urec ttav ttav proc~initinlet->ttav tinl tinl proc~initinlet->tinl utav utav proc~initinlet->utav mpi_bcast mpi_bcast proc~readzincoord->mpi_bcast Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~initinlet~~CalledByGraph proc~initinlet initinlet proc~startup startup proc~startup->proc~initinlet program~dalesurban DALESURBAN program~dalesurban->proc~startup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code initinlet Source Code subroutine initinlet use modglobal , only : ih , ib , ie , jh , jb , je , kb , ke , kh , iinletgen , iplane , xf , lstoreplane , nstore , Uinf , ltempeq , pi , zf , zh use modfields , only : um use modmpi , only : myid , nprocs implicit none real :: pfi , epsi integer :: k if ( iinletgen == 1 ) then allocate ( Utav ( ib : ie , kb : ke )) allocate ( Uinl ( kb : ke )) allocate ( Winl ( kb : ke + 1 )) allocate ( Urec ( kb : ke )) allocate ( Wrec ( kb : ke + 1 )) allocate ( u0inletbc ( jb : je , kb : ke )) allocate ( v0inletbc ( jb : je , kb : ke )) allocate ( w0inletbc ( jb : je , kb : ke + 1 )) allocate ( u0inletbcold ( jb : je , kb : ke )) allocate ( v0inletbcold ( jb : je , kb : ke )) allocate ( w0inletbcold ( jb : je , kb : ke + 1 )) allocate ( uminletbc ( jb : je , kb : ke )) allocate ( vminletbc ( jb : je , kb : ke )) allocate ( wminletbc ( jb : je , kb : ke + 1 )) allocate ( uaver ( ib : ie , kb : ke )) allocate ( zirf ( kb : ke )) allocate ( ziif ( kb : ke )) allocate ( zirh ( kb : ke + 1 )) allocate ( ziih ( kb : ke + 1 )) allocate ( zorf ( kb : ke )) allocate ( zoif ( kb : ke )) allocate ( zorh ( kb : ke + 1 )) allocate ( zoih ( kb : ke + 1 )) allocate ( loclowif ( kb : ke )) allocate ( locupif ( kb : ke )) allocate ( loclowih ( kb : ke + 1 )) allocate ( locupih ( kb : ke + 1 )) allocate ( loclowof ( kb : ke )) allocate ( locupof ( kb : ke )) allocate ( loclowoh ( kb : ke + 1 )) allocate ( locupoh ( kb : ke + 1 )) allocate ( displ ( ib : ie )) allocate ( displold ( ib : ie )) allocate ( upupavinl ( kb : ke )) allocate ( vpvpavinl ( kb : ke )) allocate ( wpwpavinl ( kb : ke )) allocate ( upwpavinl ( kb : ke )) allocate ( thlpthlpavinl ( kb : ke )) allocate ( thlpupavinl ( kb : ke )) allocate ( thlpwpavinl ( kb : ke )) allocate ( heavif ( kb : ke )) allocate ( heavih ( kb : ke + 1 )) if ( lstoreplane ) then allocate ( storeu0inletbc ( jb : je , kb : ke , 1 : nstore )) allocate ( storev0inletbc ( jb : je , kb : ke , 1 : nstore )) allocate ( storew0inletbc ( jb : je , kb : ke + 1 , 1 : nstore )) end if epsi = 0.25 * di do k = kb , ke pfi = zf ( k ) - 1.2 * di - epsi if ( pfi < - epsi ) then heavif ( k ) = 1. elseif ( pfi <= epsi ) then heavif ( k ) = 0.5 * ( 1. - ( pfi / epsi ) - ( 1. / pi ) * sin ( pi * pfi / epsi )) elseif ( pfi > epsi ) then heavif ( k ) = 0. end if end do do k = kb , ke + 1 pfi = zh ( k ) - 1.2 * di - epsi if ( pfi < - epsi ) then heavih ( k ) = 1. elseif ( pfi <= epsi ) then heavih ( k ) = 0.5 * ( 1. - ( pfi / epsi ) - ( 1. / pi ) * sin ( pi * pfi / epsi )) elseif ( pfi > epsi ) then heavih ( k ) = 0. end if end do if ( ltempeq ) then allocate ( Ttav ( ib : ie , kb : ke )) allocate ( taver ( ib : ie , kb : ke )) allocate ( Tinl ( kb : ke )) allocate ( Trec ( kb : ke )) allocate ( t0inletbc ( jb : je , kb : ke )) allocate ( t0inletbcold ( jb : je , kb : ke )) allocate ( tminletbc ( jb : je , kb : ke )) allocate ( zotr ( kb : ke )) allocate ( zoti ( kb : ke )) allocate ( loclowot ( kb : ke )) allocate ( locupot ( kb : ke )) allocate ( heavit ( kb : ke )) if ( lstoreplane ) then allocate ( storet0inletbc ( jb : je , kb : ke , 1 : nstore )) end if ! Heaviside function for temperature epsi = 0.25 * dti do k = kb , ke pfi = zf ( k ) - 1.2 * dti - epsi if ( pfi < - epsi ) then heavit ( k ) = 1. elseif ( pfi <= epsi ) then heavit ( k ) = 0.5 * ( 1. - ( pfi / epsi ) - ( 1. / pi ) * sin ( pi * pfi / epsi )) elseif ( pfi > epsi ) then heavit ( k ) = 0. end if end do end if displ = 0. displold = 0. irecy = ib + iplane ! index of recycle plane equals iplane (read from namoptions) xfm = sum ( xf ( ib : ie )) / ( ie - ib + 1 ) ! mean(xf) xf2m = sum ( xf ( ib : ie ) ** 2. ) / ( ie - ib + 1 ) ! mean(xf&#94;2) !  btime = timee                              ! this is done to make sure btime is set when avint is computed correctly at startup (only for RA) else if ( iinletgen == 2 ) then allocate ( storeu0inletbc ( jb : je , kb : ke , 1 : nstore )) allocate ( storev0inletbc ( jb : je , kb : ke , 1 : nstore )) allocate ( storew0inletbc ( jb : je , kb : ke + 1 , 1 : nstore )) allocate ( u0rot ( 1 : nstore , jb - jh : je + jh , kb : ke )) allocate ( v0rot ( 1 : nstore , jb - jh : je + jh , kb : ke )) allocate ( u0inletbc ( jb : je , kb : ke )) allocate ( v0inletbc ( jb : je , kb : ke )) allocate ( w0inletbc ( jb : je , kb : ke + 1 )) allocate ( u0inletbcold ( jb : je , kb : ke )) allocate ( v0inletbcold ( jb : je , kb : ke )) allocate ( w0inletbcold ( jb : je , kb : ke + 1 )) allocate ( uminletbc ( jb : je , kb : ke )) allocate ( vminletbc ( jb : je , kb : ke )) allocate ( wminletbc ( jb : je , kb : ke + 1 )) if ( ltempeq ) then allocate ( storet0inletbc ( jb : je , kb : ke , 1 : nstore )) allocate ( t0inletbc ( jb : je , kb : ke )) allocate ( t0inletbcold ( jb : je , kb : ke )) allocate ( tminletbc ( jb : je , kb : ke )) end if !iangle = iangledeg * pi / 180.  ! convert degrees to radians irecy = ib + iplane ! read coordinates of inletprofile call readzincoord !    ddispdx      = 0.00038/Uinf        ! this value should becomputed from the w0 computed in the inletgenerator ddispdx = wtop / Uinf ! wtop is read from zgrid.inf ddispdxold = ddispdx ! this value should becomputed from the w0 computed in the inletgenerator !    inlfactor    = nprocs/nprocsinl     ! nprocs should be larger or equal to nprocsin! !    write(6,*) 'inlfactor= ',inlfactor else return end if end subroutine initinlet","tags":"","loc":"proc/initinlet.html"},{"title":"inletgen – uDALES","text":"public subroutine inletgen() Uses modglobal modfields modsurfdata modsave modmpi proc~~inletgen~~UsesGraph proc~inletgen inletgen module~modsurfdata modsurfdata proc~inletgen->module~modsurfdata module~modmpi modmpi proc~inletgen->module~modmpi module~modsave modsave proc~inletgen->module~modsave module~modfields modfields proc~inletgen->module~modfields module~modglobal modglobal proc~inletgen->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~inletgen~~CallsGraph proc~inletgen inletgen proc~enthalpythickness enthalpythickness proc~inletgen->proc~enthalpythickness trec trec proc~inletgen->trec wrec wrec proc~inletgen->wrec uinl uinl proc~inletgen->uinl urec urec proc~inletgen->urec ttav ttav proc~inletgen->ttav proc~writerestartfiles writerestartfiles proc~inletgen->proc~writerestartfiles proc~writeinletfile writeinletfile proc~inletgen->proc~writeinletfile proc~momentumthicknessexp momentumthicknessexp proc~inletgen->proc~momentumthicknessexp proc~blthicknesst blthicknesst proc~inletgen->proc~blthicknesst proc~readinletfile readinletfile proc~inletgen->proc~readinletfile proc~slabsum slabsum proc~inletgen->proc~slabsum tinl tinl proc~inletgen->tinl proc~dispthicknessexp dispthicknessexp proc~inletgen->proc~dispthicknessexp utav utav proc~inletgen->utav proc~excjs excjs proc~readinletfile->proc~excjs proc~yinterpolate yinterpolate proc~readinletfile->proc~yinterpolate mpi_allreduce mpi_allreduce proc~slabsum->mpi_allreduce proc~dispthicknessexp->utav mpi_sendrecv mpi_sendrecv proc~excjs->mpi_sendrecv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~inletgen~~CalledByGraph proc~inletgen inletgen proc~boundary boundary proc~boundary->proc~inletgen proc~readinitfiles readinitfiles proc~readinitfiles->proc~boundary program~dalesurban DALESURBAN program~dalesurban->proc~boundary proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code inletgen Source Code subroutine inletgen use modglobal , only : ib , ie , jb , je , jgb , jge , kb , ke , zf , zh , dzf , dzhi , timee , btime , totavtime , rk3step , dt , numol , iplane , lles , iinletgen , inletav , runavtime , Uinf , lwallfunc , linletRA , totinletav , lstoreplane , nstore , prandtlmoli , numol , grav , lbuoyancy , lfixinlet , luvolflowr , lfixutauin use modfields , only : u0 , v0 , w0 , thl0 , wm , uprof use modsurfdata , only : thls , thl_top use modsave , only : writerestartfiles use modmpi , only : slabsum , myid implicit none real , dimension ( ib : ib , jb : je , kb : ke ) :: uinletbc2 ! dummy variable real , dimension ( ib : ib , jb : je , kb : ke ) :: tinletbc2 ! dummy variable real , dimension ( jb : je , kb : ke ) :: uprec ! velocity fluctuation (up_rec = u0 - Urec) real , dimension ( jb : je , kb : ke ) :: vprec ! velocity fluctuation (vp_rec = v0 - 0) real , dimension ( jb : je , kb : ke + 1 ) :: wprec ! velocity fluctuation (wp_rec = w0 - Wrec) real , dimension ( jb : je , kb : ke ) :: tprec ! temperature fluctuation (tp_rec = t0 - Trec) real , dimension ( jb : je , kb : ke ) :: upinli , vpinli ! = gamma * (uprec,v interpolated to zii grid) real , dimension ( jb : je , kb : ke ) :: tpinli ! = lambda  * (tprec   interpolated to zii grid) real , dimension ( jb : je , kb : ke ) :: upinlo , vpinlo ! = gamma * (uprec,v interpolated to zoi grid) real , dimension ( jb : je , kb : ke ) :: tpinlo ! = lambda  * (tprec   interpolated to zoti grid) real , dimension ( jb : je , kb : ke + 1 ) :: wpinli ! = gamma * (wprec   interpolated to zii grid) real , dimension ( jb : je , kb : ke + 1 ) :: wpinlo ! = gamma * (wprec   interpolated to zoi grid) real , dimension ( kb : ke ) :: udiff ! difference between Uinl and Urec !    real,dimension(kb:ke)   :: Urecdiff                ! difference between Urec new and old real , dimension ( kb : ke ) :: urav ! j-averaged u-velocity (not time-averaged) real , dimension ( kb : ke ) :: trav ! j-averaged temperature (not time-averaged) real , dimension ( kb : ke ) :: uravdzf ! j-averaged u-velocity (not time-averaged) times dzf real , dimension ( kb : ke ) :: uinldzf ! j-averaged u-velocity (not time-averaged) times dzf real , dimension ( kb : ke ) :: Urecdzf ! Urec times dzf real , dimension ( kb : ke + 1 ) :: wrav ! j-averaged w-velocity (not time-averaged) real , dimension ( kb : ke ) :: Uinli ! = gamma * (Urec interpolated to ziif grid points) real , dimension ( kb : ke + 1 ) :: Winli ! = gamma * (Wrec interpolated to ziih grid points) real , dimension ( kb : ke ) :: Tinli ! = lambda  * (Trec interpolated to ziif grid points) real , dimension ( kb : ke ) :: Uinlo ! = gamma * (Urec interpolated to zioif grid points) real , dimension ( kb : ke + 1 ) :: Winlo ! = gamma * (Wrec interpolated to zoih grid points) real , dimension ( kb : ke ) :: Tinlo ! = lambda  * (Trec interpolated to zoti grid points) real , dimension ( kb : ke ) :: wfuncf ! weight function at full level real , dimension ( kb : ke + 1 ) :: wfunch ! weight function at half level real , dimension ( kb : ke ) :: wfunct ! weight function at full level real :: utaur2 , utaui2 ! (utau)&#94;2 at recycle station and inlet real :: gamm ! utaui / utaur real :: lamb ! ttaui / ttaur real :: avint , avinti ! avering interval real :: alpha , beta ! factors used in the Weight function !    real                    :: totalu                  ! total u-velocity at outlet real :: Urectot ! total u-velocity at recycle plane real :: rk3coef !    real                    :: di_test                 ! BL thickness as measured from Uinl real :: utop ! j-averaged top velocity real :: interval real :: dtinrk ! RK time step in inlet data real :: rk3coefin ! Cumulative RK time step in inlet data real :: dr_old real :: scalef ! scale factor to scale instantaneous velocity profile with to get constant mass flux real :: totaluinl ! bulk velocity at the inlet !    real                    :: q0                      ! heat flux integer i , j , k , kk , kdamp if ( iinletgen == 1 ) then u0inletbcold = u0inletbc v0inletbcold = v0inletbc w0inletbcold = w0inletbc t0inletbcold = t0inletbc ! temperature totaluold = totalu displold = displ ddispdxold = ddispdx ! compute time-average velocities rk3coef = dt / ( 4. - dble ( rk3step )) if ( rk3step == 1 ) then deltat = rk3coef elseif ( rk3step == 2 ) then deltat = rk3coef - ( dt / 3. ) elseif ( rk3step == 3 ) then deltat = rk3coef - ( dt / 2. ) end if if ( linletRA ) then ! this is a switch to use 'running average' avint = totinletav + timee - btime ! runav interval = averaging interval previuous sim  + current elapsed sim time else avint = inletav end if avinti = 1. / avint uaver = 0. taver = 0. do i = ib , ie call slabsum ( uaver ( i ,:), kb , ke , u0 ( i : i , jb : je , kb : ke ), i , i , jb , je , kb , ke , i , i , jb , je , kb , ke ) call slabsum ( taver ( i ,:), kb , ke , thl0 ( i : i , jb : je , kb : ke ), i , i , jb , je , kb , ke , i , i , jb , je , kb , ke ) end do wrav = 0. call slabsum ( wrav ( kb : ke + 1 ), kb , ke , w0 ( irecy - 1 : irecy - 1 , jb : je , kb : ke + 1 ), irecy - 1 , irecy - 1 , jb , je , kb , ke + 1 , irecy - 1 , irecy - 1 , jb , je , kb , ke + 1 ) trav = 0. call slabsum ( trav ( kb : ke ), kb , ke , thl0 ( irecy - 1 : irecy - 1 , jb : je , kb : ke ), irecy - 1 , irecy - 1 , jb , je , kb , ke , irecy - 1 , irecy - 1 , jb , je , kb , ke ) uaver = uaver / ( jge - jgb + 1 ) ! average over j-direction taver = taver / ( jge - jgb + 1 ) ! average over j-direction urav = uaver ( irecy ,:) wrav = wrav / ( jge - jgb + 1 ) ! average over j-direction trav = trav / ( jge - jgb + 1 ) ! average over j-direction do k = kb , ke Urec ( k ) = urav ( k ) * deltat * avinti + ( 1. - deltat * avinti ) * Urec ( k ) Trec ( k ) = trav ( k ) * deltat * avinti + ( 1. - deltat * avinti ) * Trec ( k ) end do do k = kb , ke + 1 Wrec ( k ) = wrav ( k ) * deltat * avinti + ( 1. - deltat * avinti ) * Wrec ( k ) end do do k = kb , ke do i = ib , ie Utav ( i , k ) = uaver ( i , k ) * deltat * avinti + ( 1. - deltat * avinti ) * Utav ( i , k ) Ttav ( i , k ) = taver ( i , k ) * deltat * avinti + ( 1. - deltat * avinti ) * Ttav ( i , k ) end do end do !    Urec = Urec +(Uinf-Urec(ke))     ! make sure at the recycle plane the top velocity equals Uinf !    Urecdiff = Urecdiff - Urec !    if (myid==0) then !      write(6,*) 'Urec_old - Urec_new (kb+40)=',Urecdiff(kb+40) !    end if !! check if Urec contains NaN !    if (myid==0) then !      write(6,*) 'Checking Urec for NaN' !      do k=kb,ke !        if (ISNAN(Urec(k))) then !          write(6,*) 'Urec(k)=NaN at k=kb+', k-kb !        end if !      end do !      write(6,*) 'Finished checking Urec for NaN' !    end if !    if (myid==0) then !      write(6,*) 'myid, Urec(ke)=',myid, Urec(ke) !      write(6,*) 'wrav(ke), Wrec(ke)=',wrav(ke), Wrec(ke) !      write(6,*) 'wrav(ke-1), Wrec(ke-1)=',wrav(ke-1), Wrec(ke-1) !      write(6,*) 'wrav(ke-10), Wrec(ke-10)=',wrav(ke-10), Wrec(ke-10) !      write(6,*) 'wrav(ke-30), Wrec(ke-30)=',wrav(ke-30), Wrec(ke-30) !      write(6,*) 'wrav(kb+10), Wrec(kb+10)=',wrav(kb+10), Wrec(kb+10) !      write(6,*) 'wrav(kb+11), Wrec(kb+11)=',wrav(kb+11), Wrec(kb+11) !    end if ! compute velocity fluctuation at recycle station do k = kb , ke do j = jb , je uprec ( j , k ) = u0 ( irecy , j , k ) - Urec ( k ) vprec ( j , k ) = v0 ( irecy - 1 , j , k ) ! mean v is zero tprec ( j , k ) = thl0 ( irecy - 1 , j , k ) - Trec ( k ) end do end do do k = kb , ke + 1 do j = jb , je wprec ( j , k ) = w0 ( irecy - 1 , j , k ) - Wrec ( k ) ! note that w-velocity is taken at i=irecy-1 !! end do end do if ( lwallfunc ) then call wallawinlet ( Urec ( kb ), dzf ( kb ), numol , utaur2 ) ! compute wall shear stress at recycle station else utaur2 = 2. * numol * Urec ( kb ) / dzf ( kb ) end if utaur = sqrt ( abs ( utaur2 )) ! compute utau at recycle station ! heat flux at recycle station (isothermal wall) q = alpha * dT/dz = (nu/prandtl) * dT/dz !    q0 = numol*prandtlmoli*(Trec(kb) - Trec(kb-1)) * dzhi(kb) q0 = numol * prandtlmoli * 2 * ( Trec ( kb ) - thls ) / dzf ( kb ) ttaur = q0 / utaur ! ttau = q/(rho*cp*utau) =  (alpha *dT/dz) / utau ! compute momentum thickness at inlet and recycle plane if ( lbuoyancy ) then lmor = ( thls * utaur ** 2 ) / ( 0.41 * grav * ttaur ) ! L = -T0*utau&#94;3 / kappa*g*<w'T'> = !     write(6,*) 'Initial dr,myid, utaur, ttaur, Lmor =', dr,myid,utaur,ttaur,lmor !     lmor = 0.3; lmoi = ( thls * utaui ** 2 ) / ( 0.41 * grav * ttaui ) ! L = -T0*utau&#94;3 / kappa*g*<w'T'> = !     lmoi = 0.3; !     write(6,*) 'Initial di_test,myid, utaui, ttaui, Lmoi =', di_test,myid,utaui,ttaui,lmoi dr_old = dr !     call blthicknessmo(dr,utaur,lmor)                    ! Also needed for momentumthickness call blthicknesst ( dr , Urec , 0.99 ) ! changed back to this one (instead of the above) !     call momentumthicknessmo(thetai,utaui,di,lmoi) !     call momentumthicknessmo(thetar,utaur,dr,lmor) call momentumthicknessexp ( thetai , Uinl ) call momentumthicknessexp ( thetar , Urec ) else !     call blthickness(dr,utaur)                           ! Also needed for momentumthickness call blthicknesst ( dr , Urec , 0.99 ) !     call momentumthickness(thetai,utaui,di) !     call momentumthickness(thetar,utaur,dr) call momentumthicknessexp ( thetai , Uinl ) call momentumthicknessexp ( thetar , Urec ) end if call enthalpythickness ( thetati , Tinl , Uinl ) call enthalpythickness ( thetatr , Trec , Urec ) !   call blthickness(dr,utaur) call blthicknesst ( dtr , Trec - thls , 0.99 ) ! compute utau at inlet from interior field !    if (thetai == 0.) then !      write(6,*) '!!! thetai = 0, myid=',myid !    else if (thetar == 0.) then !      write(6,*) '!!! thetar = 0, myid=',myid !      thetar=0.00001 !    else !      utaui = utaur* (thetar/thetai)**(1./8.)    ! See Lund (1998): 'Similar to Ludwig-Tillmann correlation' if (. not . lfixutauin ) then utaui = utaur * abs ( thetar / thetai ) ** ( 1. / 8. ) ! See Lund (1998): 'Similar to Ludwig-Tillmann correlation' end if if ( thetati == 0. ) then thetati = 0.0000001 end if ttaui = ttaur * abs ( thetatr / thetati ) ** ( 1. / 8. ) ! See Kong (2000): !    end if gamm = utaui / utaur ! Gamma in Lund (1998) if ( ttaur == 0. ) then ttaur = 0.0000001 end if lamb = ttaui / ttaur ! Lambda in Kong (2000) ! compute inner scaling coordinates zirf = utaur * zf / numol ! inner scaling zf-coordinate at recycle station zirh = utaur * zh / numol ! inner scaling zh-coordinate at recycle station ziif = utaui * zf / numol ! inner scaling zf-coordinate at inlet station ziih = utaui * zh / numol ! inner scaling zh-coordinate at inlet station ! compute outer scaling coordinates zorf = zf / dr ! outer scaling zf-coor as measured from Uinldinate at recycle station zorh = zh / dr ! outer scaling zh-coordinate at recycle station zoif = zf / di ! outer scaling zf-coordinate at inlet station  (could be done once, actually..) zoih = zh / di ! outer scaling zf-coordinate at inlet station  (could be done once, actually..) zotr = zf / dtr ! temperature outer scaling zf-coordinate at recycle station zoti = zf / dti ! temperature outer scaling zf-coordinate at inlet station !!!!! Interpolation starts here !!! First inner coordinates ! determine which elements are needed when recycle velocity profile is interpolated on inlet plane ! for u(,v)-components (zf) do k = kb , ke do kk = kb , ke if ( zirf ( kk ) >= ziif ( k )) then locupif ( k ) = kk loclowif ( k ) = kk - 1 exit elseif ( kk == ke ) then locupif ( k ) = ke + 1 ! this means extrapolation! loclowif ( k ) = ke - 1 ! waarom niet ke? of wordt dit niet gebruikt? end if end do end do ! for w-components (zh) do k = kb , ke + 1 do kk = kb , ke + 1 if ( zirh ( kk ) >= ziih ( k )) then locupih ( k ) = kk loclowih ( k ) = kk - 1 exit elseif ( kk == ke + 1 ) then locupih ( k ) = ke + 2 ! this means extrapolation! loclowih ( k ) = ke end if end do end do !!! Finished with inner coordinates !!! Do the same trick for outer coordinates ! determine which elements are needed when recycle velocity profile is interpolated on inlet plane ! for u(,v)-components (zf) do k = kb , ke do kk = kb , ke if ( zorf ( kk ) >= zoif ( k )) then locupof ( k ) = kk loclowof ( k ) = kk - 1 exit elseif ( kk == ke ) then locupof ( k ) = ke + 1 ! this means extrapolation! loclowof ( k ) = ke - 1 end if end do end do ! for w-components (zh) do k = kb , ke + 1 do kk = kb , ke + 1 if ( zorh ( kk ) >= zoih ( k )) then locupoh ( k ) = kk loclowoh ( k ) = kk - 1 exit elseif ( kk == ke + 1 ) then locupoh ( k ) = ke + 2 ! this means extrapolation! loclowoh ( k ) = ke end if end do end do !!! Finished with outer coordinates !!! Outer coordinates for temperature do k = kb , ke do kk = kb , ke if ( zotr ( kk ) >= zoti ( k )) then locupot ( k ) = kk loclowot ( k ) = kk - 1 exit elseif ( kk == ke ) then locupot ( k ) = ke + 1 ! this means extrapolation! loclowot ( k ) = ke - 1 end if end do end do !!! Finished with outer coordinates temperature !!! Now really interpolate !!! First inner coordinates ! compute Urec on zii grid do k = kb , ke if ( locupif ( k ) == ke + 1 ) then ! indicator for extrapolation! !        Uinli(k) = Urec(ke) + (Urec(ke) - Urec(ke-1)) / (zirf(ke)-zirf(ke-1)) * (ziif(k)-zirf(ke)) Uinli ( k ) = Urec ( ke ) Tinli ( k ) = Trec ( ke ) elseif ( loclowif ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) Uinli ( k ) = Urec ( kb ) / zirf ( kb ) * ziif ( k ) !        Tinli(k) = thls + Trec(kb)/zirf(kb)*ziif(k) !        Tinli(k) = (Trec(kb)-thls)/zirf(kb)*ziif(k) Tinli ( k ) = thls + ( Trec ( kb ) - thls ) / zirf ( kb ) * ziif ( k ) else ! normal interpolation Uinli ( k ) = Urec ( loclowif ( k )) + ( Urec ( locupif ( k )) - Urec ( loclowif ( k ))) / ( zirf ( locupif ( k )) - zirf ( loclowif ( k ))) * ( ziif ( k ) - zirf ( loclowif ( k ))) Tinli ( k ) = Trec ( loclowif ( k )) + ( Trec ( locupif ( k )) - Trec ( loclowif ( k ))) / ( zirf ( locupif ( k )) - zirf ( loclowif ( k ))) * ( ziif ( k ) - zirf ( loclowif ( k ))) if (( ziif ( k ) . gt . zirf ( locupif ( k ))) . or . ( ziif ( k ) . lt . zirf ( loclowif ( k )))) then write ( 6 , * ) '!!!Mistake in Interpolation !!!!' end if end if end do ! compute Wrec on zii grid Winli ( kb ) = 0.0 ! corresponds to ground level do k = kb + 1 , ke + 1 if ( locupih ( k ) == ke + 2 ) then ! indicator for extrapolation! !        Winli(k) = Wrec(ke+1) + (Wrec(ke+1) - Wrec(ke)) / (zirh(ke+1)-zirh(ke)) * (ziih(k)-zirh(ke+1)) Winli ( k ) = Wrec ( ke + 1 ) else ! normal interpolation Winli ( k ) = Wrec ( loclowih ( k )) + ( Wrec ( locupih ( k )) - Wrec ( loclowih ( k ))) / ( zirh ( locupih ( k )) - zirh ( loclowih ( k ))) * ( ziih ( k ) - zirh ( loclowih ( k ))) end if end do ! compute u- and v- and t-fluctuation on zii grid do k = kb , ke if ( locupif ( k ) == ke + 1 ) then ! indicator for extrapolation! !        upinli(:,k) = uprec(:,ke) + (uprec(:,ke) - uprec(:,ke-1)) / (zirf(ke)-zirf(ke-1)) * (ziif(k)-zirf(ke)) upinli (:, k ) = 0. vpinli (:, k ) = 0. tpinli (:, k ) = 0. elseif ( loclowif ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) upinli (:, k ) = uprec (:, kb ) / zirf ( kb ) * ziif ( k ) vpinli (:, k ) = vprec (:, kb ) / zirf ( kb ) * ziif ( k ) tpinli (:, k ) = tprec (:, kb ) / zirf ( kb ) * ziif ( k ) else ! normal interpolation upinli (:, k ) = uprec (:, loclowif ( k )) + ( uprec (:, locupif ( k )) - uprec (:, loclowif ( k ))) / ( zirf ( locupif ( k )) - zirf ( loclowif ( k ))) * ( ziif ( k ) - zirf ( loclowif ( k ))) vpinli (:, k ) = vprec (:, loclowif ( k )) + ( vprec (:, locupif ( k )) - vprec (:, loclowif ( k ))) / ( zirf ( locupif ( k )) - zirf ( loclowif ( k ))) * ( ziif ( k ) - zirf ( loclowif ( k ))) tpinli (:, k ) = tprec (:, loclowif ( k )) + ( tprec (:, locupif ( k )) - tprec (:, loclowif ( k ))) / ( zirf ( locupif ( k )) - zirf ( loclowif ( k ))) * ( ziif ( k ) - zirf ( loclowif ( k ))) end if end do ! compute w-fluctuation on zii grid do k = kb + 1 , ke + 1 !      if (locupih(k) == ke+1) then      ! indicator for extrapolation! if ( locupih ( k ) == ke + 2 ) then ! indicator for extrapolation! !        wpinli(:,k) = wprec(:,ke+1) + (wprec(:,ke+1) - wprec(:,ke)) / (zirh(ke+1)-zirh(ke)) * (ziih(k)-zirh(ke+1)) wpinli (:, k ) = 0. else ! normal interpolation wpinli (:, k ) = wprec (:, loclowih ( k )) + ( wprec (:, locupih ( k )) - wprec (:, loclowih ( k ))) / ( zirh ( locupih ( k )) - zirh ( loclowih ( k ))) * ( ziih ( k ) - zirh ( loclowih ( k ))) end if end do !! Finished with interpolating inner variables !! Continue with interpolating outer variables ! compute Urec on zoi grid do k = kb , ke if ( locupof ( k ) == ke + 1 ) then ! indicator for extrapolation! !        Uinlo(k) = Urec(ke) + (Urec(ke) - Urec(ke-1)) / (zorf(ke)-zorf(ke-1)) * (zoif(k)-zorf(ke)) !        Uinlo(k) = Urec(ke) Uinlo ( k ) = Uinf elseif ( loclowof ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) Uinlo ( k ) = Urec ( kb ) / zorf ( kb ) * zoif ( k ) else ! normal interpolation Uinlo ( k ) = Urec ( loclowof ( k )) + ( Urec ( locupof ( k )) - Urec ( loclowof ( k ))) / ( zorf ( locupof ( k )) - zorf ( loclowof ( k ))) * ( zoif ( k ) - zorf ( loclowof ( k ))) end if end do ! compute Wrec on zii grid Winlo ( kb ) = 0.0 ! corresponds to ground level do k = kb + 1 , ke + 1 if ( locupoh ( k ) == ke + 2 ) then ! indicator for extrapolation! !        Winlo(k) = Wrec(ke+1) + (Wrec(ke+1) - Wrec(ke)) / (zorh(ke+1)-zorh(ke)) * (zoih(k)-zorh(ke+1)) Winlo ( k ) = Wrec ( ke + 1 ) else ! normal interpolation Winlo ( k ) = Wrec ( loclowoh ( k )) + ( Wrec ( locupoh ( k )) - Wrec ( loclowoh ( k ))) / ( zorh ( locupoh ( k )) - zorh ( loclowoh ( k ))) * ( zoih ( k ) - zorh ( loclowoh ( k ))) end if end do ! compute u- and v-fluctuation on zoi grid do k = kb , ke if ( locupof ( k ) == ke + 1 ) then ! indicator for extrapolation! !        upinlo(:,k) = uprec(:,ke) + (uprec(:,ke) - uprec(:,ke-1)) / (zorf(ke)-zorf(ke-1)) * (zoif(k)-zorf(ke)) upinlo (:, k ) = 0. vpinlo (:, k ) = 0. elseif ( loclowof ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) upinlo (:, k ) = uprec (:, kb ) / zorf ( kb ) * zoif ( k ) vpinlo (:, k ) = vprec (:, kb ) / zorf ( kb ) * zoif ( k ) else ! normal interpolation upinlo (:, k ) = uprec (:, loclowof ( k )) + ( uprec (:, locupof ( k )) - uprec (:, loclowof ( k ))) / ( zorf ( locupof ( k )) - zorf ( loclowof ( k ))) * ( zoif ( k ) - zorf ( loclowof ( k ))) vpinlo (:, k ) = vprec (:, loclowof ( k )) + ( vprec (:, locupof ( k )) - vprec (:, loclowof ( k ))) / ( zorf ( locupof ( k )) - zorf ( loclowof ( k ))) * ( zoif ( k ) - zorf ( loclowof ( k ))) end if end do ! compute w-fluctuation on zoi grid do k = kb + 1 , ke + 1 if ( locupoh ( k ) == ke + 2 ) then ! indicator for extrapolation! !        wpinlo(:,k) = wprec(:,ke+1) + (wprec(:,ke+1) - wprec(:,ke)) / (zorh(ke+1)-zorh(ke)) * (zoih(k)-zorh(ke+1)) wpinlo (:, k ) = 0. else ! normal interpolation wpinlo (:, k ) = wprec (:, loclowoh ( k )) + ( wprec (:, locupoh ( k )) - wprec (:, loclowoh ( k ))) / ( zorh ( locupoh ( k )) - zorh ( loclowoh ( k ))) * ( zoih ( k ) - zorh ( loclowoh ( k ))) end if end do !! Finished interpolating outer velocity variables !! Interpolating outer temperature ! mean temperature do k = kb , ke if ( locupot ( k ) == ke + 1 ) then ! indicator for extrapolation! Tinlo ( k ) = thl_top elseif ( loclowot ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use Tinlo=thls at z+=0) !        Tinlo(k) = Trec(kb)/zotr(kb) * zoti(k) !        Tinlo(k) = (Trec(kb)-thls)/zotr(kb) * zoti(k) Tinlo ( k ) = thls + ( Trec ( kb ) - thls ) / zotr ( kb ) * zoti ( k ) else ! normal interpolation Tinlo ( k ) = Trec ( loclowot ( k )) + ( Trec ( locupot ( k )) - Trec ( loclowot ( k ))) / ( zotr ( locupot ( k )) - zotr ( loclowot ( k ))) * ( zoti ( k ) - zotr ( loclowot ( k ))) end if end do ! fluctuating temperature do k = kb , ke if ( locupot ( k ) == ke + 1 ) then ! indicator for extrapolation! !        upinlo(:,k) = uprec(:,ke) + (uprec(:,ke) - uprec(:,ke-1)) / (zorf(ke)-zorf(ke-1)) * (zoif(k)-zorf(ke)) tpinlo (:, k ) = 0. elseif ( loclowot ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use t=0 at z+=0) tpinlo (:, k ) = tprec (:, kb ) / zotr ( kb ) * zoti ( k ) else ! normal interpolation tpinlo (:, k ) = tprec (:, loclowot ( k )) + ( tprec (:, locupot ( k )) - tprec (:, loclowot ( k ))) / ( zotr ( locupot ( k )) - zotr ( loclowot ( k ))) * ( zoti ( k ) - zotr ( loclowot ( k ))) end if end do !! Finished interpolating out temperature !!!!! Finished Interpolation! !!!!! ! compute rescaled inner variables ! Winli = Winli (interpolation is enough) Uinli = gamm * Uinli Tinli = lamb * Tinli + ( 1. - lamb ) * thls ! this is different for isoflux wall! upinli = gamm * upinli vpinli = gamm * vpinli wpinli = gamm * wpinli tpinli = lamb * tpinli ! See Kong (2000) ! compute rescaled outer variables ! Winlo = Winlo (interpolation is enough) Uinlo = gamm * Uinlo + ( 1. - gamm ) * Uinf Tinlo = lamb * Tinlo + ( 1. - lamb ) * thl_top !    Uinlo = gamm* Uinlo  + (1.- gamm)*Urec(ke) upinlo = gamm * upinlo vpinlo = gamm * vpinlo wpinlo = gamm * wpinlo tpinlo = lamb * tpinlo ! See Kong (2000) !    utop = Uinlo(ke) !    Uinlo = Uinlo +(Uinf-utop)     ! make sure at the inlet the mean top velocity equals Uinf !! add defect velocity to make sure the j-averaged velocity at the top equals Uinf !    utop = Uinlo(ke) !    do k=kb,ke !        Uinlo(k) = Uinlo(k)*Uinf/utop !    end do ! Compute weight function (alpha=4, b=0.2) alpha = 4. beta = 0.2 wfuncf = 0.5 * ( 1. + tanh ( alpha * ( zoif - beta ) / (( 1. - 2. * beta ) * zoif + beta ) ) / tanh ( alpha ) ) ! for full level height wfunch = 0.5 * ( 1. + tanh ( alpha * ( zoih - beta ) / (( 1. - 2. * beta ) * zoih + beta ) ) / tanh ( alpha ) ) ! for half level height wfunct = 0.5 * ( 1. + tanh ( alpha * ( zoti - beta ) / (( 1. - 2. * beta ) * zoti + beta ) ) / tanh ( alpha ) ) ! for temperature (full level height) do k = kb , ke if ( wfuncf ( k ) . gt . 1. ) then wfuncf ( k ) = 1. end if if ( wfunct ( k ) . gt . 1. ) then wfunct ( k ) = 1. end if end do do k = kb , ke + 1 if ( wfunch ( k ) . gt . 1. ) then wfunch ( k ) = 1. end if end do !    write(6,*) 'maxval(wfuncf)=', maxval(wfuncf) !    write(6,*) 'maxval(wfunch)=', maxval(wfunch) ! Compute the velocity components for the inlet BC do k = kb , ke do j = jb , je !      u0inletbc(j,k) = (Uinli(k)+ upinli(j,k))*(1.-wfuncf(k)) +  (Uinlo(k) + upinlo(j,k))* wfuncf(k) !      v0inletbc(j,k) =            vpinli(j,k) *(1.-wfuncf(k)) +              vpinlo(j,k) * wfuncf(k) !      t0inletbc(j,k) = (Tinli(k)+ tpinli(j,k))*(1.-wfunct(k)) +  (Tinlo(k) + tpinlo(j,k))* wfunct(k) u0inletbc ( j , k ) = ( Uinli ( k ) + upinli ( j , k ) * heavif ( k )) * ( 1. - wfuncf ( k )) + ( Uinlo ( k ) + upinlo ( j , k ) * heavif ( k )) * wfuncf ( k ) v0inletbc ( j , k ) = vpinli ( j , k ) * heavif ( k ) * ( 1. - wfuncf ( k )) + vpinlo ( j , k ) * heavif ( k ) * wfuncf ( k ) t0inletbc ( j , k ) = ( Tinli ( k ) + tpinli ( j , k ) * heavit ( k )) * ( 1. - wfunct ( k )) + ( Tinlo ( k ) + tpinlo ( j , k ) * heavit ( k )) * wfunct ( k ) end do end do do k = kb , ke + 1 do j = jb , je w0inletbc ( j , k ) = ( Winli ( k ) + wpinli ( j , k ) * heavih ( k )) * ( 1 - wfunch ( k )) + ( Winlo ( k ) + wpinlo ( j , k ) * heavih ( k )) * wfunch ( k ) end do end do w0inletbc (:, kb ) = 0. w0inletbc (:, ke + 1 ) = 0. !!    kdamp = kb + floor(0.75*(ke-kb+1)) !    kdamp = kb + 144  ! => zf = 2.24 !    do k=kdamp,ke !    do j=jb,je !      if (u0inletbc(j,k) > Uinf) then !        u0inletbc(j,k) = Uinf !      end if !    end do !    end do ! Compute j-averaged inlet U  (used for compute thetai) uinletbc2 ( ib , jb : je , kb : ke ) = u0inletbc ( jb : je , kb : ke ) ! this is just a dummy variable to give uninletbc the right dimension in slabsum tinletbc2 ( ib , jb : je , kb : ke ) = t0inletbc ( jb : je , kb : ke ) ! this is just a dummy variable to give tninletbc the right dimension in slabsum urav = 0. trav = 0. call slabsum ( urav , kb , ke , uinletbc2 , ib , ib , jb , je , kb , ke , ib , ib , jb , je , kb , ke ) call slabsum ( trav , kb , ke , tinletbc2 , ib , ib , jb , je , kb , ke , ib , ib , jb , je , kb , ke ) !    call slabsum(urav  ,kb,ke,u0 ,ib-1,ie+1,jb-1,je+1,kb-1,ke+1,ib,ib,jb,je,kb,ke) urav = urav / ( jge - jgb + 1 ) ! average over j-direction trav = trav / ( jge - jgb + 1 ) ! average over j-direction ! determine bulk velocity of new profile do k = kb , ke uravdzf ( k ) = urav ( k ) * dzf ( k ) end do totalu = sum ( uravdzf ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! Area-averaged outflow velocity ! rescale the instantaneous profile to keep mass flux constant (tot avoid pressure fluctuations) if ( luvolflowr ) then do k = kb , ke uinldzf ( k ) = Uinl ( k ) * dzf ( k ) end do totaluinl = sum ( uinldzf ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! Area-averaged inflow velocity scalef = totaluinl / totalu ! compute factor to scale the velocity profile with u0inletbc (:,:) = u0inletbc (:,:) * scalef ! rescale the velocity profile to have constant mass-flux urav (:) = urav (:) * scalef ! also rescale the part that is added to the mean end if !! add defect velocity to make sure the mass flow is the same as the initial mass flow !   u0inletbc = u0inletbc + (ubulk-totalu) !   urav      = urav      + (ubulk-totalu) !! add defect velocity to make sure the j-averaged velocity at the top equals Uinf !    utop = urav(ke) !    do k=kb,ke !      do j=jb,je !        u0inletbc(j,k) = u0inletbc(j,k)*Uinf/utop !      end do !      urav(k) = urav(k)*Uinf/utop !    end do !    u0inletbc = u0inletbc + (Uinf-utop) !    urav      = urav      + (Uinf-utop) !    if (myid==0) then !    write(6,*) 'u0inletbc(jb+2,ke)', u0inletbc !    end if ! Compute j- and time-averaged  inlet U  (used for compute thetai) if (. not . lfixinlet ) then ! only update the average inlet profiles when lfixinlet .eqv..false. do k = kb , ke Uinl ( k ) = urav ( k ) * deltat * avinti + ( 1. - deltat * avinti ) * Uinl ( k ) end do end if do k = kb , ke Tinl ( k ) = trav ( k ) * deltat * avinti + ( 1. - deltat * avinti ) * Tinl ( k ) end do !    utop = Uinl(ke) !    Uinl = Uinl +(Uinf-utop)     ! make sure at the inlet the mean top velocity equals Uinf !    uminletbc = uminletbc + (Uinf-utop) ! write inletplane to array (and to file after 1000 time steps) if ( lstoreplane ) then storeu0inletbc (:,:, nstepread ) = u0inletbc (:,:) storev0inletbc (:,:, nstepread ) = v0inletbc (:,:) storew0inletbc (:,:, nstepread ) = w0inletbc (:,:) storet0inletbc (:,:, nstepread ) = t0inletbc (:,:) nstepread = nstepread + 1 if ( nstepread == nstore + 1 ) then nfile = nfile + 1 ! next file number call writeinletfile ! write 1000 time steps to file call writerestartfiles nstepread = 1 ! reset counter end if ! nstepread == 1001 end if ! lstoreplane if ( rk3step == 1 ) then uminletbc = u0inletbc vminletbc = v0inletbc wminletbc = w0inletbc tminletbc = t0inletbc end if if ( lbuoyancy ) then !     call blthicknessmo(di_test,utaui,lmoi) call blthicknesst ( di_test , Uinl , 0.99 ) !     call dispthicknessmo(displ)  ! needed in top BC call dispthicknessexp ( displ ) else !     call blthickness(di_test,utaui) call blthicknesst ( di_test , Uinl , 0.99 ) !     call dispthickness(displ)  ! needed in top BC call dispthicknessexp ( displ ) end if call blthicknesst ( dti_test , Tinl - thls , 0.99 ) if (( myid == 0 ) . and . ( rk3step == 3 )) then write ( 6 , * ) 'Inlet Gen: gamma,lambda=' , gamm , lamb write ( 6 , * ) 'Inlet Gen: Uinl(ke),Tinl(ke)=' , Uinl ( ke ), Tinl ( ke ) write ( 6 , * ) 'Inlet Gen: utaui,utaur =' , utaui , utaur write ( 6 , * ) 'Inlet Gen: ttaui,ttaur =' , ttaui , ttaur write ( 6 , * ) 'Inlet Gen: Lmoi,Lmor =' , lmoi , lmor write ( 6 , * ) 'Inlet Gen: deltar, deltai_test' , dr , di_test write ( 6 , * ) 'Inlet Gen: deltatr, deltati_test' , dtr , dti_test write ( 6 , * ) 'Inlet Gen: d*i, d*r=' , displ ( ib ), displ ( irecy ) write ( 6 , * ) 'Inlet Gen: thetai,thetar' , thetai , thetar write ( 6 , * ) 'Inlet Gen: thetati,thetatr' , thetati , thetatr if ( luvolflowr ) then write ( 6 , * ) 'Inlet Gen: mass flux correction factor = ' , scalef !       write(6,*) 'Inlet Gen: mass flux                   = ',totalreadu write ( 6 , * ) 'Inlet Gen: mass flux                   = ' , totaluinl end if end if elseif ( iinletgen == 2 ) then if ( myid == 0 ) then write ( 6 , * ) 'nstepread=' , nstepread end if u0inletbcold = u0inletbc v0inletbcold = v0inletbc w0inletbcold = w0inletbc t0inletbcold = t0inletbc ! determine time step interval in simulation rk3coef = dt / ( 4. - dble ( rk3step )) if ( rk3step == 1 ) then deltat = rk3coef elseif ( rk3step == 2 ) then deltat = rk3coef - ( dt / 3. ) elseif ( rk3step == 3 ) then deltat = rk3coef - ( dt / 2. ) end if ! determine time step interval in inlet data rk3coefin = dtin / ( 4. - dble ( rk3stepin )) if ( rk3stepin == 1 ) then dtinrk = rk3coefin elseif ( rk3stepin == 2 ) then dtinrk = rk3coefin - ( dtin / 3. ) elseif ( rk3stepin == 3 ) then dtinrk = rk3coefin - ( dtin / 2. ) end if interval = dtinrk - elapstep elapstep = elapstep + deltat if ( elapstep > dtinrk ) then ! use new value at next time step nstepread = nstepread + 1 elapstep = mod ( elapstep , dtinrk ) rk3stepin = mod ( rk3stepin , 3 ) + 1 rk3coefin = dtin / ( 4. - dble ( rk3stepin )) if ( rk3stepin == 1 ) then dtinrk = rk3coefin elseif ( rk3stepin == 2 ) then dtinrk = rk3coefin - ( dtin / 3. ) elseif ( rk3stepin == 3 ) then dtinrk = rk3coefin - ( dtin / 2. ) end if u0inletbc (:,:) = storeu0inletbc (:,:, nstepread ) v0inletbc (:,:) = storev0inletbc (:,:, nstepread ) w0inletbc (:,:) = storew0inletbc (:,:, nstepread ) t0inletbc (:,:) = storet0inletbc (:,:, nstepread ) if ( nstepread == nstore ) then nfile = nfile + 1 call readinletfile call writerestartfiles nstepread = 0 end if interval = dtinrk deltat = elapstep !        write(6,*) 'dtinrk,deltat=', dtinrk,deltat end if u0inletbc (:,:) = ( 1. - deltat / interval ) * u0inletbc (:,:) + ( deltat / interval ) * storeu0inletbc (:,:, nstepread + 1 ) v0inletbc (:,:) = ( 1. - deltat / interval ) * v0inletbc (:,:) + ( deltat / interval ) * storev0inletbc (:,:, nstepread + 1 ) w0inletbc (:,:) = ( 1. - deltat / interval ) * w0inletbc (:,:) + ( deltat / interval ) * storew0inletbc (:,:, nstepread + 1 ) t0inletbc (:,:) = ( 1. - deltat / interval ) * t0inletbc (:,:) + ( deltat / interval ) * storet0inletbc (:,:, nstepread + 1 ) !! massflow correction uinletbc2 ( ib , jb : je , kb : ke ) = u0inletbc ( jb : je , kb : ke ) ! this is just a dummy variable to give uninletbc the right dimension in slabsum urav = 0. call slabsum ( urav , kb , ke , uinletbc2 , ib , ib , jb , je , kb , ke , ib , ib , jb , je , kb , ke ) urav = urav / ( jge - jgb + 1 ) ! average over j-direction ! determine bulk velocity of new (interpolated) profile do k = kb , ke uravdzf ( k ) = urav ( k ) * dzf ( k ) end do totalu = sum ( uravdzf ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! Area-averaged outflow velocity ! rescale the instantaneous profile to keep mass flux constant (tot avoid pressure fluctuations) scalef = totalreadu / totalu ! compute factor to scale the velocity profile with u0inletbc (:,:) = u0inletbc (:,:) * scalef ! rescale the velocity profile to have constant mass-flux !! end of massflow correction of interpolated streamwise velocity if ( rk3step == 1 ) then uminletbc = u0inletbc vminletbc = v0inletbc wminletbc = w0inletbc tminletbc = t0inletbc end if end if ! iinletgen end subroutine inletgen","tags":"","loc":"proc/inletgen.html"},{"title":"inletgennotemp – uDALES","text":"public subroutine inletgennotemp() Uses modglobal modfields modsave modmpi proc~~inletgennotemp~~UsesGraph proc~inletgennotemp inletgennotemp module~modmpi modmpi proc~inletgennotemp->module~modmpi module~modsave modsave proc~inletgennotemp->module~modsave module~modfields modfields proc~inletgennotemp->module~modfields module~modglobal modglobal proc~inletgennotemp->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~inletgennotemp~~CallsGraph proc~inletgennotemp inletgennotemp wrec wrec proc~inletgennotemp->wrec uinl uinl proc~inletgennotemp->uinl urec urec proc~inletgennotemp->urec proc~writerestartfiles writerestartfiles proc~inletgennotemp->proc~writerestartfiles proc~writeinletfile writeinletfile proc~inletgennotemp->proc~writeinletfile proc~momentumthicknessexp momentumthicknessexp proc~inletgennotemp->proc~momentumthicknessexp proc~blthicknesst blthicknesst proc~inletgennotemp->proc~blthicknesst proc~readinletfile readinletfile proc~inletgennotemp->proc~readinletfile proc~slabsum slabsum proc~inletgennotemp->proc~slabsum utav utav proc~inletgennotemp->utav proc~dispthicknessexp dispthicknessexp proc~inletgennotemp->proc~dispthicknessexp proc~excjs excjs proc~readinletfile->proc~excjs proc~yinterpolate yinterpolate proc~readinletfile->proc~yinterpolate mpi_allreduce mpi_allreduce proc~slabsum->mpi_allreduce proc~dispthicknessexp->utav mpi_sendrecv mpi_sendrecv proc~excjs->mpi_sendrecv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~inletgennotemp~~CalledByGraph proc~inletgennotemp inletgennotemp proc~boundary boundary proc~boundary->proc~inletgennotemp proc~readinitfiles readinitfiles proc~readinitfiles->proc~boundary program~dalesurban DALESURBAN program~dalesurban->proc~boundary proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code inletgennotemp Source Code subroutine inletgennotemp use modglobal , only : ib , ie , jb , je , jgb , jge , kb , ke , zf , zh , dzf , dzhi , timee , btime , totavtime , rk3step , dt , numol , iplane , lles , iinletgen , inletav , runavtime , Uinf , lwallfunc , linletRA , totinletav , lstoreplane , nstore , lfixinlet , lfixutauin , luvolflowr use modfields , only : u0 , v0 , w0 , wm , uprof use modsave , only : writerestartfiles use modmpi , only : slabsum , myid implicit none real , dimension ( ib : ib , jb : je , kb : ke ) :: uinletbc2 ! dummy variable real , dimension ( jb : je , kb : ke ) :: uprec ! velocity fluctuation (up_rec = u0 - Urec) real , dimension ( jb : je , kb : ke ) :: vprec ! velocity fluctuation (vp_rec = v0 - 0) real , dimension ( jb : je , kb : ke + 1 ) :: wprec ! velocity fluctuation (wp_rec = w0 - Wrec) real , dimension ( jb : je , kb : ke ) :: upinli , vpinli ! = gamma * (uprec,v interpolated to zii grid) real , dimension ( jb : je , kb : ke ) :: upinlo , vpinlo ! = gamma * (uprec,v interpolated to zoi grid) real , dimension ( jb : je , kb : ke + 1 ) :: wpinli ! = gamma * (wprec   interpolated to zii grid) real , dimension ( jb : je , kb : ke + 1 ) :: wpinlo ! = gamma * (wprec   interpolated to zoi grid) real , dimension ( kb : ke ) :: udiff ! difference between Uinl and Urec !    real,dimension(kb:ke)   :: Urecdiff                ! difference between Urec new and old real , dimension ( kb : ke ) :: urav ! j-averaged u-velocity (not time-averaged) real , dimension ( kb : ke ) :: uravdzf ! j-averaged u-velocity (not time-averaged) times dzf real , dimension ( kb : ke ) :: uinldzf ! j-averaged u-velocity (not time-averaged) times dzf real , dimension ( kb : ke ) :: Urecdzf ! Urec times dzf real , dimension ( kb : ke + 1 ) :: wrav ! j-averaged w-velocity (not time-averaged) real , dimension ( kb : ke ) :: Uinli ! = gamma * (Urec interpolated to ziif grid points) real , dimension ( kb : ke + 1 ) :: Winli ! = gamma * (Wrec interpolated to ziih grid points) real , dimension ( kb : ke ) :: Uinlo ! = gamma * (Urec interpolated to zioif grid points) real , dimension ( kb : ke + 1 ) :: Winlo ! = gamma * (Wrec interpolated to zoih grid points) real , dimension ( kb : ke ) :: wfuncf ! weight function at full level real , dimension ( kb : ke + 1 ) :: wfunch ! weight function at half level real :: utaur2 , utaui2 ! (utau)&#94;2 at recycle station and inlet real :: gamm ! utaui / utaur real :: avint , avinti ! avering interval real :: alpha , beta ! factors used in the Weight function !    real                    :: totalu                  ! total u-velocity at outlet real :: Urectot ! total u-velocity at recycle plane real :: rk3coef !    real                    :: di_test                 ! BL thickness as measured from Uinl real :: utop ! j-averaged top velocity real :: interval real :: dtinrk ! RK time step in inlet data real :: rk3coefin ! Cumulative RK time step in inlet data real :: dr_old real :: scalef ! scale factor to scale instantaneous velocity profile with to get constant mass flux real :: totaluinl ! bulk velocity at the inlet integer i , j , k , kk if ( iinletgen == 1 ) then u0inletbcold = u0inletbc v0inletbcold = v0inletbc w0inletbcold = w0inletbc totaluold = totalu displold = displ ddispdxold = ddispdx ! compute time-average velocities rk3coef = dt / ( 4. - dble ( rk3step )) if ( rk3step == 1 ) then deltat = rk3coef elseif ( rk3step == 2 ) then deltat = rk3coef - ( dt / 3. ) elseif ( rk3step == 3 ) then deltat = rk3coef - ( dt / 2. ) end if if ( linletRA ) then ! this is a switch to use 'running average' avint = totinletav + timee - btime ! runav interval = averaging interval previuous sim  + current elapsed sim time else avint = inletav end if avinti = 1. / avint uaver = 0. do i = ib , ie call slabsum ( uaver ( i ,:), kb , ke , u0 ( i : i , jb : je , kb : ke ), i , i , jb , je , kb , ke , i , i , jb , je , kb , ke ) end do wrav = 0. call slabsum ( wrav ( kb : ke + 1 ), kb , ke , w0 ( irecy - 1 : irecy - 1 , jb : je , kb : ke + 1 ), irecy - 1 , irecy - 1 , jb , je , kb , ke + 1 , irecy - 1 , irecy - 1 , jb , je , kb , ke + 1 ) uaver = uaver / ( jge - jgb + 1 ) ! average over j-direction urav = uaver ( irecy ,:) wrav = wrav / ( jge - jgb + 1 ) ! average over j-direction do k = kb , ke Urec ( k ) = urav ( k ) * deltat * avinti + ( 1. - deltat * avinti ) * Urec ( k ) end do do k = kb , ke + 1 Wrec ( k ) = wrav ( k ) * deltat * avinti + ( 1. - deltat * avinti ) * Wrec ( k ) end do do k = kb , ke do i = ib , ie Utav ( i , k ) = uaver ( i , k ) * deltat * avinti + ( 1. - deltat * avinti ) * Utav ( i , k ) end do end do ! compute velocity fluctuation at recycle station do k = kb , ke do j = jb , je uprec ( j , k ) = u0 ( irecy , j , k ) - Urec ( k ) vprec ( j , k ) = v0 ( irecy - 1 , j , k ) ! mean v is zero end do end do do k = kb , ke + 1 do j = jb , je wprec ( j , k ) = w0 ( irecy - 1 , j , k ) - Wrec ( k ) ! note that w-velocity is taken at i=irecy-1 !! end do end do if ( lwallfunc ) then call wallawinlet ( Urec ( kb ), dzf ( kb ), numol , utaur2 ) ! compute wall shear stress at recycle station else utaur2 = 2. * numol * Urec ( kb ) / dzf ( kb ) end if utaur = sqrt ( abs ( utaur2 )) ! compute utau at recycle station ! compute momentum thickness at inlet and recycle plane dr_old = dr !   call blthickness(dr,utaur)                     ! also needed for thetar call blthicknesst ( dr , Urec , 0.99 ) !   call momentumthickness(thetai,utaui,di)        ! di is kept fixed call momentumthicknessexp ( thetai , Uinl ) !   call momentumthickness(thetar,utaur,dr) call momentumthicknessexp ( thetar , Urec ) !   call blthickness(dr,utaur) if (. not . lfixutauin ) then utaui = utaur * abs ( thetar / thetai ) ** ( 1. / 8. ) ! See Lund (1998): 'Similar to Ludwig-Tillmann correlation' end if gamm = utaui / utaur ! Gamma in Lund (1998) ! compute inner scaling coordinates zirf = utaur * zf / numol ! inner scaling zf-coordinate at recycle station zirh = utaur * zh / numol ! inner scaling zh-coordinate at recycle station ziif = utaui * zf / numol ! inner scaling zf-coordinate at inlet station ziih = utaui * zh / numol ! inner scaling zh-coordinate at inlet station ! compute outer scaling coordinates zorf = zf / dr ! outer scaling zf-coor as measured from Uinldinate at recycle station zorh = zh / dr ! outer scaling zh-coordinate at recycle station zoif = zf / di ! outer scaling zf-coordinate at inlet station  (could be done once, actually..) zoih = zh / di ! outer scaling zf-coordinate at inlet station  (could be done once, actually..) !!!!! Interpolation starts here !!! First inner coordinates ! determine which elements are needed when recycle velocity profile is interpolated on inlet plane ! for u(,v)-components (zf) do k = kb , ke do kk = kb , ke if ( zirf ( kk ) >= ziif ( k )) then locupif ( k ) = kk loclowif ( k ) = kk - 1 exit elseif ( kk == ke ) then locupif ( k ) = ke + 1 ! this means extrapolation! loclowif ( k ) = ke - 1 ! waarom niet ke? of wordt dit niet gebruikt? end if end do end do ! for w-components (zh) do k = kb , ke + 1 do kk = kb , ke + 1 if ( zirh ( kk ) >= ziih ( k )) then locupih ( k ) = kk loclowih ( k ) = kk - 1 exit elseif ( kk == ke + 1 ) then locupih ( k ) = ke + 2 ! this means extrapolation! loclowih ( k ) = ke end if end do end do !!! Finished with inner coordinates !!! Do the same trick for outer coordinates ! determine which elements are needed when recycle velocity profile is interpolated on inlet plane ! for u(,v)-components (zf) do k = kb , ke do kk = kb , ke if ( zorf ( kk ) >= zoif ( k )) then locupof ( k ) = kk loclowof ( k ) = kk - 1 exit elseif ( kk == ke ) then locupof ( k ) = ke + 1 ! this means extrapolation! loclowof ( k ) = ke - 1 end if end do end do ! for w-components (zh) do k = kb , ke + 1 do kk = kb , ke + 1 if ( zorh ( kk ) >= zoih ( k )) then locupoh ( k ) = kk loclowoh ( k ) = kk - 1 exit elseif ( kk == ke + 1 ) then locupoh ( k ) = ke + 2 ! this means extrapolation! loclowoh ( k ) = ke end if end do end do !!! Finished with outer coordinates !!! Now really interpolate !!! First inner coordinates ! compute Urec on zii grid do k = kb , ke if ( locupif ( k ) == ke + 1 ) then ! indicator for extrapolation! !        Uinli(k) = Urec(ke) + (Urec(ke) - Urec(ke-1)) / (zirf(ke)-zirf(ke-1)) * (ziif(k)-zirf(ke)) Uinli ( k ) = Urec ( ke ) elseif ( loclowif ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) Uinli ( k ) = Urec ( kb ) / zirf ( kb ) * ziif ( k ) else ! normal interpolation Uinli ( k ) = Urec ( loclowif ( k )) + ( Urec ( locupif ( k )) - Urec ( loclowif ( k ))) / ( zirf ( locupif ( k )) - zirf ( loclowif ( k ))) * ( ziif ( k ) - zirf ( loclowif ( k ))) if (( ziif ( k ) . gt . zirf ( locupif ( k ))) . or . ( ziif ( k ) . lt . zirf ( loclowif ( k )))) then write ( 6 , * ) '!!!Mistake in Interpolation !!!!' end if end if end do ! compute Wrec on zii grid Winli ( kb ) = 0.0 ! corresponds to ground level do k = kb + 1 , ke + 1 if ( locupih ( k ) == ke + 2 ) then ! indicator for extrapolation! !        Winli(k) = Wrec(ke+1) + (Wrec(ke+1) - Wrec(ke)) / (zirh(ke+1)-zirh(ke)) * (ziih(k)-zirh(ke+1)) Winli ( k ) = Wrec ( ke + 1 ) else ! normal interpolation Winli ( k ) = Wrec ( loclowih ( k )) + ( Wrec ( locupih ( k )) - Wrec ( loclowih ( k ))) / ( zirh ( locupih ( k )) - zirh ( loclowih ( k ))) * ( ziih ( k ) - zirh ( loclowih ( k ))) end if end do ! compute u- and v- and t-fluctuation on zii grid do k = kb , ke if ( locupif ( k ) == ke + 1 ) then ! indicator for extrapolation! !        upinli(:,k) = uprec(:,ke) + (uprec(:,ke) - uprec(:,ke-1)) / (zirf(ke)-zirf(ke-1)) * (ziif(k)-zirf(ke)) upinli (:, k ) = 0. vpinli (:, k ) = 0. elseif ( loclowif ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) upinli (:, k ) = uprec (:, kb ) / zirf ( kb ) * ziif ( k ) vpinli (:, k ) = vprec (:, kb ) / zirf ( kb ) * ziif ( k ) else ! normal interpolation upinli (:, k ) = uprec (:, loclowif ( k )) + ( uprec (:, locupif ( k )) - uprec (:, loclowif ( k ))) / ( zirf ( locupif ( k )) - zirf ( loclowif ( k ))) * ( ziif ( k ) - zirf ( loclowif ( k ))) vpinli (:, k ) = vprec (:, loclowif ( k )) + ( vprec (:, locupif ( k )) - vprec (:, loclowif ( k ))) / ( zirf ( locupif ( k )) - zirf ( loclowif ( k ))) * ( ziif ( k ) - zirf ( loclowif ( k ))) end if end do ! compute w-fluctuation on zii grid do k = kb + 1 , ke + 1 !      if (locupih(k) == ke+1) then      ! indicator for extrapolation! if ( locupih ( k ) == ke + 2 ) then ! indicator for extrapolation! !        wpinli(:,k) = wprec(:,ke+1) + (wprec(:,ke+1) - wprec(:,ke)) / (zirh(ke+1)-zirh(ke)) * (ziih(k)-zirh(ke+1)) wpinli (:, k ) = 0. else ! normal interpolation wpinli (:, k ) = wprec (:, loclowih ( k )) + ( wprec (:, locupih ( k )) - wprec (:, loclowih ( k ))) / ( zirh ( locupih ( k )) - zirh ( loclowih ( k ))) * ( ziih ( k ) - zirh ( loclowih ( k ))) end if end do !! Finished with interpolating inner variables !! Continue with interpolating outer variables ! compute Urec on zoi grid do k = kb , ke if ( locupof ( k ) == ke + 1 ) then ! indicator for extrapolation! !        Uinlo(k) = Urec(ke) + (Urec(ke) - Urec(ke-1)) / (zorf(ke)-zorf(ke-1)) * (zoif(k)-zorf(ke)) !        Uinlo(k) = Urec(ke) Uinlo ( k ) = Uinf elseif ( loclowof ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) Uinlo ( k ) = Urec ( kb ) / zorf ( kb ) * zoif ( k ) else ! normal interpolation Uinlo ( k ) = Urec ( loclowof ( k )) + ( Urec ( locupof ( k )) - Urec ( loclowof ( k ))) / ( zorf ( locupof ( k )) - zorf ( loclowof ( k ))) * ( zoif ( k ) - zorf ( loclowof ( k ))) end if end do ! compute Wrec on zii grid Winlo ( kb ) = 0.0 ! corresponds to ground level do k = kb + 1 , ke + 1 if ( locupoh ( k ) == ke + 2 ) then ! indicator for extrapolation! !        Winlo(k) = Wrec(ke+1) + (Wrec(ke+1) - Wrec(ke)) / (zorh(ke+1)-zorh(ke)) * (zoih(k)-zorh(ke+1)) Winlo ( k ) = Wrec ( ke + 1 ) else ! normal interpolation Winlo ( k ) = Wrec ( loclowoh ( k )) + ( Wrec ( locupoh ( k )) - Wrec ( loclowoh ( k ))) / ( zorh ( locupoh ( k )) - zorh ( loclowoh ( k ))) * ( zoih ( k ) - zorh ( loclowoh ( k ))) end if end do ! compute u- and v-fluctuation on zoi grid do k = kb , ke if ( locupof ( k ) == ke + 1 ) then ! indicator for extrapolation! !        upinlo(:,k) = uprec(:,ke) + (uprec(:,ke) - uprec(:,ke-1)) / (zorf(ke)-zorf(ke-1)) * (zoif(k)-zorf(ke)) upinlo (:, k ) = 0. vpinlo (:, k ) = 0. elseif ( loclowof ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) upinlo (:, k ) = uprec (:, kb ) / zorf ( kb ) * zoif ( k ) vpinlo (:, k ) = vprec (:, kb ) / zorf ( kb ) * zoif ( k ) else ! normal interpolation upinlo (:, k ) = uprec (:, loclowof ( k )) + ( uprec (:, locupof ( k )) - uprec (:, loclowof ( k ))) / ( zorf ( locupof ( k )) - zorf ( loclowof ( k ))) * ( zoif ( k ) - zorf ( loclowof ( k ))) vpinlo (:, k ) = vprec (:, loclowof ( k )) + ( vprec (:, locupof ( k )) - vprec (:, loclowof ( k ))) / ( zorf ( locupof ( k )) - zorf ( loclowof ( k ))) * ( zoif ( k ) - zorf ( loclowof ( k ))) end if end do ! compute w-fluctuation on zoi grid do k = kb + 1 , ke + 1 if ( locupoh ( k ) == ke + 2 ) then ! indicator for extrapolation! !        wpinlo(:,k) = wprec(:,ke+1) + (wprec(:,ke+1) - wprec(:,ke)) / (zorh(ke+1)-zorh(ke)) * (zoih(k)-zorh(ke+1)) wpinlo (:, k ) = 0. else ! normal interpolation wpinlo (:, k ) = wprec (:, loclowoh ( k )) + ( wprec (:, locupoh ( k )) - wprec (:, loclowoh ( k ))) / ( zorh ( locupoh ( k )) - zorh ( loclowoh ( k ))) * ( zoih ( k ) - zorh ( loclowoh ( k ))) end if end do !! Finished interpolating outer velocity variables !!!!! Finished Interpolation! !!!!! ! compute rescaled inner variables ! Winli = Winli (interpolation is enough) Uinli = gamm * Uinli upinli = gamm * upinli vpinli = gamm * vpinli wpinli = gamm * wpinli ! compute rescaled outer variables ! Winlo = Winlo (interpolation is enough) Uinlo = gamm * Uinlo + ( 1. - gamm ) * Uinf !    Uinlo = gamm* Uinlo  + (1.- gamm)*Urec(ke) upinlo = gamm * upinlo vpinlo = gamm * vpinlo wpinlo = gamm * wpinlo ! Compute weight function (alpha=4, b=0.2) alpha = 4. beta = 0.2 wfuncf = 0.5 * ( 1. + tanh ( alpha * ( zoif - beta ) / (( 1. - 2. * beta ) * zoif + beta ) ) / tanh ( alpha ) ) ! for full level height wfunch = 0.5 * ( 1. + tanh ( alpha * ( zoih - beta ) / (( 1. - 2. * beta ) * zoih + beta ) ) / tanh ( alpha ) ) ! for half level height do k = kb , ke if ( wfuncf ( k ) . gt . 1. ) then wfuncf ( k ) = 1. end if end do do k = kb , ke + 1 if ( wfunch ( k ) . gt . 1. ) then wfunch ( k ) = 1. end if end do ! Compute the velocity components for the inlet BC do k = kb , ke do j = jb , je u0inletbc ( j , k ) = ( Uinli ( k ) + upinli ( j , k )) * ( 1. - wfuncf ( k )) + ( Uinlo ( k ) + upinlo ( j , k )) * wfuncf ( k ) v0inletbc ( j , k ) = vpinli ( j , k ) * ( 1. - wfuncf ( k )) + vpinlo ( j , k ) * wfuncf ( k ) end do end do do k = kb , ke + 1 do j = jb , je w0inletbc ( j , k ) = ( Winli ( k ) + wpinli ( j , k )) * ( 1 - wfunch ( k )) + ( Winlo ( k ) + wpinlo ( j , k )) * wfunch ( k ) end do end do w0inletbc (:, kb ) = 0. w0inletbc (:, ke + 1 ) = 0. ! Compute j-averaged inlet U  (used for compute thetai) uinletbc2 ( ib , jb : je , kb : ke ) = u0inletbc ( jb : je , kb : ke ) ! this is just a dummy variable to give uninletbc the right dimension in slabsum urav = 0. call slabsum ( urav , kb , ke , uinletbc2 , ib , ib , jb , je , kb , ke , ib , ib , jb , je , kb , ke ) urav = urav / ( jge - jgb + 1 ) ! average over j-direction ! determine bulk velocity of new profile do k = kb , ke uravdzf ( k ) = urav ( k ) * dzf ( k ) end do totalu = sum ( uravdzf ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! Area-averaged outflow velocity ! correct instantaneous inflow velocity for constant mass-flux if ( luvolflowr ) then do k = kb , ke uinldzf ( k ) = Uinl ( k ) * dzf ( k ) end do totaluinl = sum ( uinldzf ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! Area-averaged inflow velocity that should be kept scalef = totaluinl / totalu ! compute factor to scale the velocity profile with u0inletbc (:,:) = u0inletbc (:,:) * scalef ! rescale the velocity profile to have constant mass-flux urav (:) = urav (:) * scalef ! also rescale the part that is added to the mean end if ! Compute j- and time-averaged  inlet U  (used for compute thetai) if (. not . lfixinlet ) then ! only update the average inlet profiles when lfixinlet .eqv..false. do k = kb , ke Uinl ( k ) = urav ( k ) * deltat * avinti + ( 1. - deltat * avinti ) * Uinl ( k ) end do end if ! write inletplane to array (and to file after 1000 time steps) if ( lstoreplane ) then storeu0inletbc (:,:, nstepread ) = u0inletbc (:,:) storev0inletbc (:,:, nstepread ) = v0inletbc (:,:) storew0inletbc (:,:, nstepread ) = w0inletbc (:,:) nstepread = nstepread + 1 if ( nstepread == nstore + 1 ) then nfile = nfile + 1 ! next file number call writeinletfile ! write 1000 time steps to file call writerestartfiles nstepread = 1 ! reset counter end if ! nstepread == 1001 end if ! lstoreplane if ( rk3step == 1 ) then uminletbc = u0inletbc vminletbc = v0inletbc wminletbc = w0inletbc end if !   call blthickness(di_test,utaui) call blthicknesst ( di_test , Uinl , 0.99 ) !   call dispthickness(displ)  ! needed in top BC call dispthicknessexp ( displ ) ! needed in top BC if (( myid == 0 ) . and . ( rk3step == 3 )) then write ( 6 , * ) 'Inlet Gen: gamma=' , gamm write ( 6 , * ) 'Inlet Gen: Uinl(ke)=' , Uinl ( ke ) write ( 6 , * ) 'Inlet Gen: utaui,utaur =' , utaui , utaur write ( 6 , * ) 'Inlet Gen: deltar, deltai_test' , dr , di_test write ( 6 , * ) 'Inlet Gen: d*i, d*r=' , displ ( ib ), displ ( irecy ) write ( 6 , * ) 'Inlet Gen: thetai,thetar' , thetai , thetar if ( luvolflowr ) then write ( 6 , * ) 'Inlet Gen: mass flux correction factor = ' , scalef !       write(6,*) 'Inlet Gen: mass flux                   = ',totalreadu write ( 6 , * ) 'Inlet Gen: mass flux                   = ' , totaluinl end if end if elseif ( iinletgen == 2 ) then if ( myid == 0 ) then write ( 6 , * ) 'nstepread=' , nstepread end if u0inletbcold = u0inletbc v0inletbcold = v0inletbc w0inletbcold = w0inletbc ! determine time step interval in simulation rk3coef = dt / ( 4. - dble ( rk3step )) if ( rk3step == 1 ) then deltat = rk3coef elseif ( rk3step == 2 ) then deltat = rk3coef - ( dt / 3. ) elseif ( rk3step == 3 ) then deltat = rk3coef - ( dt / 2. ) end if ! determine time step interval in inlet data rk3coefin = dtin / ( 4. - dble ( rk3stepin )) if ( rk3stepin == 1 ) then dtinrk = rk3coefin elseif ( rk3stepin == 2 ) then dtinrk = rk3coefin - ( dtin / 3. ) elseif ( rk3stepin == 3 ) then dtinrk = rk3coefin - ( dtin / 2. ) end if interval = dtinrk - elapstep elapstep = elapstep + deltat if ( elapstep > dtinrk ) then ! use new value at next time step nstepread = nstepread + 1 elapstep = mod ( elapstep , dtinrk ) rk3stepin = mod ( rk3stepin , 3 ) + 1 rk3coefin = dtin / ( 4. - dble ( rk3stepin )) if ( rk3stepin == 1 ) then dtinrk = rk3coefin elseif ( rk3stepin == 2 ) then dtinrk = rk3coefin - ( dtin / 3. ) elseif ( rk3stepin == 3 ) then dtinrk = rk3coefin - ( dtin / 2. ) end if u0inletbc (:,:) = storeu0inletbc (:,:, nstepread ) v0inletbc (:,:) = storev0inletbc (:,:, nstepread ) w0inletbc (:,:) = storew0inletbc (:,:, nstepread ) if ( nstepread == nstore ) then nfile = nfile + 1 call readinletfile call writerestartfiles nstepread = 0 end if interval = dtinrk deltat = elapstep !        write(6,*) 'dtinrk,deltat=', dtinrk,deltat end if u0inletbc (:,:) = ( 1. - deltat / interval ) * u0inletbc (:,:) + ( deltat / interval ) * storeu0inletbc (:,:, nstepread + 1 ) v0inletbc (:,:) = ( 1. - deltat / interval ) * v0inletbc (:,:) + ( deltat / interval ) * storev0inletbc (:,:, nstepread + 1 ) w0inletbc (:,:) = ( 1. - deltat / interval ) * w0inletbc (:,:) + ( deltat / interval ) * storew0inletbc (:,:, nstepread + 1 ) !! massflow correction uinletbc2 ( ib , jb : je , kb : ke ) = u0inletbc ( jb : je , kb : ke ) ! this is just a dummy variable to give uninletbc the right dimension in slabsum urav = 0. call slabsum ( urav , kb , ke , uinletbc2 , ib , ib , jb , je , kb , ke , ib , ib , jb , je , kb , ke ) urav = urav / ( jge - jgb + 1 ) ! average over j-direction ! determine bulk velocity of new (interpolated) profile do k = kb , ke uravdzf ( k ) = urav ( k ) * dzf ( k ) end do totalu = sum ( uravdzf ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! Area-averaged outflow velocity ! rescale the instantaneous profile to keep mass flux constant (tot avoid pressure fluctuations) scalef = totalreadu / totalu ! compute factor to scale the velocity profile with u0inletbc (:,:) = u0inletbc (:,:) * scalef ! rescale the velocity profile to have constant mass-flux !! end of massflow correction of interpolated streamwise velocity if ( rk3step == 1 ) then uminletbc = u0inletbc vminletbc = v0inletbc wminletbc = w0inletbc end if end if ! iinletgen end subroutine inletgennotemp","tags":"","loc":"proc/inletgennotemp.html"},{"title":"momentumthicknessexp – uDALES","text":"public subroutine momentumthicknessexp(output, uinput) Uses modglobal modinletdata modmpi proc~~momentumthicknessexp~~UsesGraph proc~momentumthicknessexp momentumthicknessexp module~modmpi modmpi proc~momentumthicknessexp->module~modmpi module~modinletdata modinletdata proc~momentumthicknessexp->module~modinletdata module~modglobal modglobal proc~momentumthicknessexp->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(out) :: output real, intent(in), dimension(kb:ke) :: uinput Called by proc~~momentumthicknessexp~~CalledByGraph proc~momentumthicknessexp momentumthicknessexp proc~inletgennotemp inletgennotemp proc~inletgennotemp->proc~momentumthicknessexp proc~inletgen inletgen proc~inletgen->proc~momentumthicknessexp proc~boundary boundary proc~boundary->proc~inletgennotemp proc~boundary->proc~inletgen proc~readinitfiles readinitfiles proc~readinitfiles->proc~boundary program~dalesurban DALESURBAN program~dalesurban->proc~boundary proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code momentumthicknessexp Source Code subroutine momentumthicknessexp ( output , uinput ) use modglobal , only : jb , kb , ke , dzf !,Uinf use modinletdata , only : ubulk use modmpi , only : myid implicit none real , dimension ( kb : ke ), intent ( in ) :: uinput !< input velocity real , intent ( out ) :: output !< momentum thickness real , dimension ( kb : ke ) :: mthick !       real    :: umax integer :: k !      write(6,*) 'uinletbc(jb,ke),Uinl(ke)=', uinletbc(jb,ke),uinput(ke) !       umax = maxval(uinput) do k = kb , ke mthick ( k ) = (( uinput ( k ) / uinput ( ke )) - ( uinput ( k ) ** 2. / uinput ( ke ) ** 2. ) ) * dzf ( k ) !         mthick(k) = ((uinput(k)/umax) - (uinput(k)**2. / umax**2.) )*dzf(k) end do output = sum ( mthick ) ! momentum thickness end subroutine momentumthicknessexp","tags":"","loc":"proc/momentumthicknessexp.html"},{"title":"momentumthickness – uDALES","text":"public subroutine momentumthickness(output, ustar, blth) Uses modglobal proc~~momentumthickness~~UsesGraph proc~momentumthickness momentumthickness module~modglobal modglobal proc~momentumthickness->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(out) :: output real, intent(in) :: ustar real, intent(in) :: blth Contents Source Code momentumthickness Source Code subroutine momentumthickness ( output , ustar , blth ) use modglobal , only : pi , Uinf !    use modinletdata, only : ubulk !   use modmpi, only    : myid implicit none real , intent ( in ) :: ustar ! friction velocity real , intent ( in ) :: blth ! boundary layer thickness real , intent ( out ) :: output ! momentum thickness real :: B = 5.0 ! Wake parameter real :: C = 0.5 ! Coles parameter real :: kappa = 0.41 ! Von k�r�n constant real :: lam ! = Uinf/ustar lam = Uinf / ustar output = (( 1. + C ) / ( kappa * lam ) - ( 1. / (( kappa ** 2 ) * ( lam ** 2 ))) * ( 2. + 2. * C * ( 1.852 / pi + 1. ) + ( 3. / 2. ) * ( C ** 2 ))) * blth end subroutine momentumthickness","tags":"","loc":"proc/momentumthickness.html"},{"title":"momentumthicknessmo – uDALES","text":"public subroutine momentumthicknessmo(output, ustar, blth, lmo) Uses modglobal proc~~momentumthicknessmo~~UsesGraph proc~momentumthicknessmo momentumthicknessmo module~modglobal modglobal proc~momentumthicknessmo->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(out) :: output real, intent(in) :: ustar real, intent(in) :: blth real, intent(in) :: lmo Contents Source Code momentumthicknessmo Source Code subroutine momentumthicknessmo ( output , ustar , blth , lmo ) use modglobal , only : pi , Uinf !    use modinletdata, only : ubulk !   use modmpi, only    : myid implicit none real , intent ( in ) :: ustar ! friction velocity real , intent ( in ) :: lmo ! Obukhov length real , intent ( in ) :: blth ! boundary layer thickness real , intent ( out ) :: output ! momentum thickness real :: B = 5.0 ! Wake parameter real :: C = 0.5 ! Coles parameter real :: kappa = 0.41 ! Von k�r�n constant real :: cmo = 0.702 ! constant in MO theory (0.135*5.2) real :: lam ! = Uinf/ustar lam = Uinf / ustar output = ( 1. + C + 0.5 * cmo * blth / lmo ) / ( kappa * lam ) - ( 1. / (( kappa ** 2 ) * ( lam ** 2 ))) * ( 2. + 2. * C * ( 1.852 / pi + 1. ) + ( 3. / 2. ) * ( C ** 2 ) + ( blth - 0.25 ) * 2. * cmo / lmo + ( 1. + 4. / pi ) * blth * C * cmo / lmo + ( 1. / 6. ) * (( cmo / lmo ) ** 2 ) * ( blth ** 2 ) ) * blth end subroutine momentumthicknessmo","tags":"","loc":"proc/momentumthicknessmo.html"},{"title":"enthalpythickness – uDALES","text":"public subroutine enthalpythickness(output, tinput, uinput) Uses modglobal modinletdata modsurfdata modmpi proc~~enthalpythickness~~UsesGraph proc~enthalpythickness enthalpythickness module~modmpi modmpi proc~enthalpythickness->module~modmpi module~modinletdata modinletdata proc~enthalpythickness->module~modinletdata module~modglobal modglobal proc~enthalpythickness->module~modglobal module~modsurfdata modsurfdata proc~enthalpythickness->module~modsurfdata mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(out) :: output real, intent(in), dimension(kb:ke) :: tinput real, intent(in), dimension(kb:ke) :: uinput Called by proc~~enthalpythickness~~CalledByGraph proc~enthalpythickness enthalpythickness proc~inletgen inletgen proc~inletgen->proc~enthalpythickness proc~boundary boundary proc~boundary->proc~inletgen proc~readinitfiles readinitfiles proc~readinitfiles->proc~boundary program~dalesurban DALESURBAN program~dalesurban->proc~boundary proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code enthalpythickness Source Code subroutine enthalpythickness ( output , tinput , uinput ) use modglobal , only : jb , kb , ke , dzf !,Uinf use modinletdata , only : ubulk use modsurfdata , only : thls use modmpi , only : myid implicit none real , dimension ( kb : ke ), intent ( in ) :: tinput !< input temperature real , dimension ( kb : ke ), intent ( in ) :: uinput !< input velocity real , intent ( out ) :: output !< momentum thickness real , dimension ( kb : ke ) :: ethick real thlsdummy integer :: k thlsdummy = thls if ( tinput ( ke ) == thls ) then thlsdummy = thls - 0.000001 end if do k = kb , ke !         ethick(k) = (uinput(k)/uinput(ke)) * ((tinput(k) - tinput(ke)) /(thls - tinput(ke)) )*dzf(k) ethick ( k ) = ( uinput ( k ) / uinput ( ke )) * (( tinput ( k ) - tinput ( ke )) / ( thlsdummy - tinput ( ke )) ) * dzf ( k ) end do output = sum ( ethick ) ! enthalpy thickness if ( output == 0. ) then output = 0.000001 end if end subroutine enthalpythickness","tags":"","loc":"proc/enthalpythickness.html"},{"title":"dispthicknessexp – uDALES","text":"public subroutine dispthicknessexp(output) Uses modglobal proc~~dispthicknessexp~~UsesGraph proc~dispthicknessexp dispthicknessexp module~modglobal modglobal proc~dispthicknessexp->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(out), dimension(ib:ie) :: output Calls proc~~dispthicknessexp~~CallsGraph proc~dispthicknessexp dispthicknessexp utav utav proc~dispthicknessexp->utav Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~dispthicknessexp~~CalledByGraph proc~dispthicknessexp dispthicknessexp proc~inletgennotemp inletgennotemp proc~inletgennotemp->proc~dispthicknessexp proc~inletgen inletgen proc~inletgen->proc~dispthicknessexp proc~boundary boundary proc~boundary->proc~inletgennotemp proc~boundary->proc~inletgen proc~readinitfiles readinitfiles proc~readinitfiles->proc~boundary program~dalesurban DALESURBAN program~dalesurban->proc~boundary proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code dispthicknessexp Source Code subroutine dispthicknessexp ( output ) ! output is an array of length (ib:ie)) containing displacement thickness values use modglobal , only : ib , ie , kb , ke , dzf , xf !,Uinf implicit none real , dimension ( ib : ie ), intent ( out ) :: output !< dispacement thickness real , dimension ( kb : ke ) :: dthick !       real    :: umax real :: dispm real :: disp2m real :: xfdispm integer :: i , k ! write(6,*) 'Uinl(ke)=', uinput(ke) do i = ib , ie !       umax = maxval(Utav(i,:)) do k = kb , ke dthick ( k ) = ( 1. - Utav ( i , k ) / Utav ( i , ke )) * dzf ( k ) ! time-averaged, j-averaged velocity !         dthick(k) = (1.- Utav(i,k)/ umax) *dzf(k)       ! time-averaged, j-averaged velocity end do output ( i ) = sum ( dthick ) ! displacement thickness end do dispm = sum ( output ( ib : ie )) / ( ie - ib + 1 ) ! mean(displacement) disp2m = sum ( output ( ib : ie ) ** 2. ) / ( ie - ib + 1 ) ! mean(displacement&#94;2) xfdispm = sum ( xf ( ib : ie ) * output ( ib : ie )) / ( ie - ib + 1 ) ! mean(xf*displ) ddispdx = ( xfdispm - ( xfm * dispm )) / ( xf2m - xfm ** 2. ) ! this is d/dx(delta*) !       ddispdx = 0.    ! for the test !       dinl    = dispm - ddispdx*xfm                         ! this is the starting value (delta* = dinl + d/dx(delta)*x) end subroutine dispthicknessexp","tags":"","loc":"proc/dispthicknessexp.html"},{"title":"dispthickness – uDALES","text":"public subroutine dispthickness(output) Uses modglobal proc~~dispthickness~~UsesGraph proc~dispthickness dispthickness module~modglobal modglobal proc~dispthickness->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(out), dimension(ib:ie) :: output Calls proc~~dispthickness~~CallsGraph proc~dispthickness dispthickness utav utav proc~dispthickness->utav Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code dispthickness Source Code subroutine dispthickness ( output ) ! output is an array of length (ib:ie)) containing displacement thickness values use modglobal , only : ib , ie , kb , ke , dzf , xf , Uinf , numol implicit none real , dimension ( ib : ie ), intent ( out ) :: output !< dispacement thickness !       real, dimension(kb:ke)                    :: dthick real :: dispm real :: disp2m real :: xfdispm real :: ustar , blth real :: B = 5.0 ! Wake parameter real :: C = 0.5 ! Coles parameter real :: kappa = 0.41 ! Von k�r�n constant real :: lam ! = Uinf/ustar integer :: i do i = ib , ie ustar = sqrt ( abs ( 2 * numol * Utav ( i , kb ) / dzf ( kb ))) ! average streamwise friction lam = Uinf / ustar blth = ( lam * numol / Uinf ) * exp ( kappa * ( lam - B ) - 2. * C ) ! See App. Lund et al. output ( i ) = (( 1. + C ) / ( kappa * lam ) ) * blth end do dispm = sum ( output ( ib : ie )) / ( ie - ib + 1 ) ! mean(displacement) disp2m = sum ( output ( ib : ie ) ** 2. ) / ( ie - ib + 1 ) ! mean(displacement&#94;2) xfdispm = sum ( xf ( ib : ie ) * output ( ib : ie )) / ( ie - ib + 1 ) ! mean(xf*displ) ddispdx = ( xfdispm - ( xfm * dispm )) / ( xf2m - xfm ** 2. ) ! this is d/dx(delta*) end subroutine dispthickness","tags":"","loc":"proc/dispthickness.html"},{"title":"dispthicknessmo – uDALES","text":"public subroutine dispthicknessmo(output) Uses modglobal modsurfdata proc~~dispthicknessmo~~UsesGraph proc~dispthicknessmo dispthicknessmo module~modglobal modglobal proc~dispthicknessmo->module~modglobal module~modsurfdata modsurfdata proc~dispthicknessmo->module~modsurfdata Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(out), dimension(ib:ie) :: output Calls proc~~dispthicknessmo~~CallsGraph proc~dispthicknessmo dispthicknessmo utav utav proc~dispthicknessmo->utav ttav ttav proc~dispthicknessmo->ttav Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code dispthicknessmo Source Code subroutine dispthicknessmo ( output ) ! output is an array of length (ib:ie)) containing displacement thickness values use modglobal , only : ib , ie , kb , ke , dzf , xf , Uinf , numol , grav , prandtlmoli use modsurfdata , only : thls implicit none real , dimension ( ib : ie ), intent ( out ) :: output !< dispacement thickness !       real, dimension(kb:ke)                    :: dthick real :: dispm real :: disp2m real :: xfdispm real :: ustar , tstar , blth real :: B = 5.0 ! Wake parameter real :: C = 0.5 ! Coles parameter real :: kappa = 0.41 ! Von k�rm�n constant real :: cmo = 0.702 ! constant in MO theory (0.135*5.2) real :: lam ! = Uinf/ustar real :: func , dfunc , utaunu , lmo integer :: i , n blth = di ! initial value do i = ib , ie ustar = sqrt ( abs ( 2. * numol * Utav ( i , kb ) / dzf ( kb ))) ! average streamwise friction at x-location tstar = numol * prandtlmoli * 2. * ( Ttav ( i , kb ) - thls ) / ( dzf ( kb ) * ustar ) ! average shear temp. at x-location lmo = ( thls * ustar ** 2 ) / ( kappa * grav * tstar ) ! obukhov length at this x-location if (( lmo >= 1000 0. ) . or . ( lmo <= 0.01 )) then lmo = 100 0. end if !         lmo = 0.3  !! TEMPORARY utaunu = ustar / numol lam = Uinf / ustar do n = 1 , 10 ! Newton Raphson method to find BL height !           write(6,*) 'blth,ustar,tstar,Lmo =',blth,ustar,tstar,lmo func = log ( blth ) + ( cmo * blth / lmo ) + log ( utaunu ) - kappa * ( lam - B ) + 2. * C !           func   = log(blth) + log(utaunu) - kappa*(lam-B) +2.*C dfunc = 1. / blth + cmo / lmo blth = blth - ( func / dfunc ) if ( blth <= 0. ) then blth = di end if end do output ( i ) = (( 1. + C + 0.5 * cmo * blth / lmo ) / ( kappa * lam ) ) * blth end do dispm = sum ( output ( ib : ie )) / ( ie - ib + 1 ) ! mean(displacement) disp2m = sum ( output ( ib : ie ) ** 2. ) / ( ie - ib + 1 ) ! mean(displacement&#94;2) xfdispm = sum ( xf ( ib : ie ) * output ( ib : ie )) / ( ie - ib + 1 ) ! mean(xf*displ) ddispdx = ( xfdispm - ( xfm * dispm )) / ( xf2m - xfm ** 2. ) ! this is d/dx(delta*) end subroutine dispthicknessmo","tags":"","loc":"proc/dispthicknessmo.html"},{"title":"blthicknesst – uDALES","text":"public subroutine blthicknesst(output, uinput, criterion) Uses modglobal proc~~blthicknesst~~UsesGraph proc~blthicknesst blthicknesst module~modglobal modglobal proc~blthicknesst->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(out) :: output real, intent(in), dimension(kb:ke) :: uinput real, intent(in) :: criterion Called by proc~~blthicknesst~~CalledByGraph proc~blthicknesst blthicknesst proc~inletgennotemp inletgennotemp proc~inletgennotemp->proc~blthicknesst proc~inletgen inletgen proc~inletgen->proc~blthicknesst proc~boundary boundary proc~boundary->proc~inletgennotemp proc~boundary->proc~inletgen proc~readinitfiles readinitfiles proc~readinitfiles->proc~boundary program~dalesurban DALESURBAN program~dalesurban->proc~boundary proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code blthicknesst Source Code subroutine blthicknesst ( output , uinput , criterion ) use modglobal , only : kb , ke , zh , zf implicit none real , dimension ( kb : ke ), intent ( in ) :: uinput !< input velocity real , intent ( in ) :: criterion !< criterion for BL thickness computation (e.g. 0.95 or 0.99) real , intent ( out ) :: output !< BL thickness based on input criterion !       real, dimension(kb:ke)             :: mthick real :: ucrit !       real                               :: umax integer :: k !     umax = maxval(uinput) ucrit = uinput ( ke ) * criterion ! Velocity at which BL-thickness is reached !     ucrit = umax*criterion  ! Velocity at which BL-thickness is reached do k = kb , ke if ( uinput ( k ) . GT . criterion * uinput ( ke )) then if ( k == kb ) then output = zh ( kb ) + ( zf ( k ) - zh ( k )) / uinput ( k ) * ucrit ! interpolate z to BL-height exit else output = zf ( k - 1 ) + ( zf ( k ) - zf ( k - 1 )) / ( uinput ( k ) - uinput ( k - 1 )) * ( ucrit - uinput ( k - 1 )) !  interpolate z to BL-height exit end if else if ( k == ke ) then output = zf ( ke ) ! maximum BL thickness end if end do end subroutine blthicknesst","tags":"","loc":"proc/blthicknesst.html"},{"title":"blthickness – uDALES","text":"public subroutine blthickness(output, ustar) Uses modglobal proc~~blthickness~~UsesGraph proc~blthickness blthickness module~modglobal modglobal proc~blthickness->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(out) :: output real, intent(in) :: ustar Contents Source Code blthickness Source Code subroutine blthickness ( output , ustar ) use modglobal , only : numol , Uinf implicit none real , intent ( in ) :: ustar ! friction velocity real , intent ( out ) :: output !< BL thickness based on law of the wake !       real, dimension(kb:ke)             :: mthick !       real                               :: ucrit !       real                               :: umax !       integer :: k real :: B = 5.0 ! Wake parameter real :: C = 0.5 ! Coles parameter real :: kappa = 0.41 ! Von k�r�n constant real :: lam ! = Uinf/ustar lam = Uinf / ustar output = ( lam * numol / Uinf ) * exp ( kappa * ( lam - B ) - 2. * C ) ! See App. Lund et al. end subroutine blthickness","tags":"","loc":"proc/blthickness.html"},{"title":"blthicknessmo – uDALES","text":"public subroutine blthicknessmo(output, ustar, lmo) Uses modglobal proc~~blthicknessmo~~UsesGraph proc~blthicknessmo blthicknessmo module~modglobal modglobal proc~blthicknessmo->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(inout) :: output real, intent(in) :: ustar real, intent(in) :: lmo Contents Source Code blthicknessmo Source Code subroutine blthicknessmo ( output , ustar , lmo ) ! This routine compute the BL thicknes for a buoyancy affected boundary layer: ! Newton-Raphson method is used use modglobal , only : numol , Uinf implicit none real , intent ( in ) :: ustar ! friction velocity real , intent ( in ) :: lmo ! Obukhov length real , intent ( inout ) :: output !< BL thickness based on law of the wake !       real, dimension(kb:ke)             :: mthick !       real                               :: ucrit !       real                               :: umax !       integer :: k real :: B = 5.0 ! Wake parameter real :: C = 0.5 ! Coles parameter real :: kappa = 0.41 ! Von k�r�n constant real :: cmo = 0.702 ! Constant in MO theory (0.135*5.2) real :: lam ! = Uinf/ustar real :: func , dfunc , utaunu integer :: n utaunu = ustar / numol lam = Uinf / ustar !       write(6,*) 'Initial delta, Lmo =', output,lmo do n = 1 , 10 func = log ( output ) + ( cmo * output / lmo ) + log ( utaunu ) - kappa * ( lam - B ) + 2. * C !         func   = log(output) + log(utaunu) - kappa*(lam-B) +2.*C dfunc = 1. / output + cmo / lmo output = output - ( func / dfunc ) if ( output <= 0. ) then output = di end if end do !       write(6,*) 'Computed delta, Lmo =', output,lmo end subroutine blthicknessmo","tags":"","loc":"proc/blthicknessmo.html"},{"title":"wallawinlet – uDALES","text":"public subroutine wallawinlet(utan, dx, visc, tau) Arguments Type Intent Optional Attributes Name real, intent(in) :: utan real, intent(in) :: dx real, intent(in) :: visc real, intent(out) :: tau Contents Source Code wallawinlet Source Code subroutine wallawinlet ( utan , dx , visc , tau ) ! this should be the same as wallaw in modboundary!!! This routine is just ! copied to avoid circular dependencies implicit none real , intent ( in ) :: utan , dx , visc real , intent ( out ) :: tau real const1 , const2 , const3 , const4 real tausub , taupow real sub , dutan , utankr , utanabs real aaa , bbb real dxi parameter ( aaa = 8.3 ) parameter ( bbb = 0.1428571429 ) dxi = 1. / dx const1 = 0.5 * ( 1. - bbb ) * aaa ** (( 1. + bbb ) / ( 1. - bbb )) const2 = ( 1. + bbb ) / aaa const3 = aaa ** ( 2. / ( 1. - bbb )) const4 = 2. / ( 1. + bbb ) utanabs = abs ( utan ) utankr = 0.5 * visc * dxi * const3 dutan = utankr - utanabs sub = max ( sign ( 1. , dutan ), 0. ) tausub = 2. * visc * utanabs * dxi !      taupow3   =   const1 * (visc * dxi)**(1.+bbb) + (const2 * (visc * !      dxi)**bbb) * utanabs taupow = ( const1 * ( visc * dxi ) ** ( 1. + bbb ) + ( const2 * ( visc * dxi ) ** bbb ) * utanabs ) ** const4 !      if (taupow3<=0) then !        write(6,*) 'taupow3 <=0!!!' !      end if tau = sub * tausub + ( 1. - sub ) * taupow tau = sign ( tau , utan ) ! give tau the same sign as utan return end subroutine wallawinlet","tags":"","loc":"proc/wallawinlet.html"},{"title":"writeinletfile – uDALES","text":"public subroutine writeinletfile() Uses modglobal modmpi proc~~writeinletfile~~UsesGraph proc~writeinletfile writeinletfile module~modmpi modmpi proc~writeinletfile->module~modmpi module~modglobal modglobal proc~writeinletfile->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~writeinletfile~~CalledByGraph proc~writeinletfile writeinletfile proc~inletgennotemp inletgennotemp proc~inletgennotemp->proc~writeinletfile proc~inletgen inletgen proc~inletgen->proc~writeinletfile proc~boundary boundary proc~boundary->proc~inletgennotemp proc~boundary->proc~inletgen proc~readinitfiles readinitfiles proc~readinitfiles->proc~boundary program~dalesurban DALESURBAN program~dalesurban->proc~boundary proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code writeinletfile Source Code subroutine writeinletfile use modglobal , only : jb , je , kb , ke , cexpnr , ifoutput , nstore , ltempeq use modmpi , only : cmyid , myid !    use modinletdata, only : storeu0inletbc,storev0inletbc,storew0inletbc,nfile implicit none integer fileid integer j , k , n character ( 24 ) name name = 'inlet/inlet_    k   .' write ( name ( 13 : 16 ) , '(i4.4)' ) nfile name ( 18 : 20 ) = cmyid name ( 22 : 24 ) = cexpnr write ( 6 , * ) 'Writing Inlet velocity: ' , name open ( ifoutput , file = name , form = 'unformatted' , position = 'append' ) write ( ifoutput ) ((( storeu0inletbc ( j , k , n ), j = jb , je ), k = kb , ke ), n = 1 , nstore ) write ( ifoutput ) ((( storev0inletbc ( j , k , n ), j = jb , je ), k = kb , ke ), n = 1 , nstore ) write ( ifoutput ) ((( storew0inletbc ( j , k , n ), j = jb , je ), k = kb , ke + 1 ), n = 1 , nstore ) close ( ifoutput ) if ( ltempeq ) then name = 'inlet/itemp_    k   .' write ( name ( 13 : 16 ) , '(i4.4)' ) nfile name ( 18 : 20 ) = cmyid name ( 22 : 24 ) = cexpnr write ( 6 , * ) 'Writing Inlet temperature: ' , name open ( ifoutput , file = name , form = 'unformatted' , position = 'append' ) write ( ifoutput ) ((( storet0inletbc ( j , k , n ), j = jb , je ), k = kb , ke ), n = 1 , nstore ) close ( ifoutput ) end if end subroutine writeinletfile","tags":"","loc":"proc/writeinletfile.html"},{"title":"readinletfile – uDALES","text":"public subroutine readinletfile() Uses modglobal modmpi proc~~readinletfile~~UsesGraph proc~readinletfile readinletfile module~modmpi modmpi proc~readinletfile->module~modmpi module~modglobal modglobal proc~readinletfile->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~readinletfile~~CallsGraph proc~readinletfile readinletfile proc~excjs excjs proc~readinletfile->proc~excjs proc~yinterpolate yinterpolate proc~readinletfile->proc~yinterpolate mpi_sendrecv mpi_sendrecv proc~excjs->mpi_sendrecv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readinletfile~~CalledByGraph proc~readinletfile readinletfile proc~inletgennotemp inletgennotemp proc~inletgennotemp->proc~readinletfile proc~inletgen inletgen proc~inletgen->proc~readinletfile proc~readinitfiles readinitfiles proc~readinitfiles->proc~readinletfile proc~boundary boundary proc~readinitfiles->proc~boundary proc~startup startup proc~startup->proc~readinitfiles proc~boundary->proc~inletgennotemp proc~boundary->proc~inletgen program~dalesurban DALESURBAN program~dalesurban->proc~startup program~dalesurban->proc~boundary Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code readinletfile Source Code subroutine readinletfile use modglobal , only : ib , jb , je , jmax , kb , ke , cexpnr , ifinput , nstore , ltempeq , ntrun , zh , jgb , jge , jh use modmpi , only : cmyid , myid , nprocs , slabsum , excjs !    use modinletdata, only : storeu0inletbc,storev0inletbc,storew0inletbc,nfile implicit none real , dimension ( ib : ib , jb : jb + inlfactor * jmax - 1 , kbin : kein ) :: udummy real , dimension ( kbin : kein ) :: uread real , dimension ( kbin : kein ) :: ureaddzfin real , dimension ( jb : jb + jtotin - 1 , kbin : kein , 1 : nstore ) :: storeu0inold real , dimension ( jb : jb + jtotin - 1 , kbin : kein , 1 : nstore ) :: storev0inold real , dimension ( jb : jb + jtotin - 1 , kbin : kein + 1 , 1 : nstore ) :: storew0inold real , dimension ( jb : jb + jtotin - 1 , kbin : kein , 1 : nstore ) :: storet0inold real , dimension ( jb : jb + jtotdum - 1 , kbin : kein , 1 : nstore ) :: storeu0indum real , dimension ( jb : jb + jtotdum - 1 , kbin : kein , 1 : nstore ) :: storev0indum real , dimension ( jb : jb + jtotdum - 1 , kbin : kein + 1 , 1 : nstore ) :: storew0indum real , dimension ( jb : jb + jtotdum - 1 , kbin : kein , 1 : nstore ) :: storet0indum real , dimension ( jb : je , kbin : kein , 1 : nstore ) :: storeu0innew real , dimension ( jb : je , kbin : kein , 1 : nstore ) :: storev0innew real , dimension ( jb : je , kbin : kein + 1 , 1 : nstore ) :: storew0innew real , dimension ( jb : je , kbin : kein , 1 : nstore ) :: storet0innew integer filen , filee integer fileid integer j , k , n , js , jf , jfdum , jsdum character ( 24 ) name jfdum = jbdum - 1 ! initial value do fileid = filenumstart , filenumstart + ( filestoread - 1 ) if ( filen == - 1 ) then filen = nprocsinl - 1 ! -1 means the last proc (periodic) else filen = fileid - floor ( real ( fileid ) / real ( nprocsinl )) * nprocsinl ! loop over proc's end if !        write(6,*) '!!!!! filen = ', filen name = 'inlet/inlet_    k   .' write ( name ( 13 : 16 ) , '(i4.4)' ) nfile write ( name ( 18 : 20 ) , '(i3.3)' ) filen name ( 22 : 24 ) = cexpnr write ( 6 , * ) 'Reading Inlet velocity: ' , name open ( unit = ifinput , file = name , form = 'unformatted' ) read ( ifinput ) ((( storeu0inold ( j , k , n ), j = jbin , jein ), k = kbin , kein ), n = 1 , nstore ) read ( ifinput ) ((( storev0inold ( j , k , n ), j = jbin , jein ), k = kbin , kein ), n = 1 , nstore ) read ( ifinput ) ((( storew0inold ( j , k , n ), j = jbin , jein ), k = kbin , kein + 1 ), n = 1 , nstore ) close ( ifinput ) if ( ltempeq ) then name = 'inlet/itemp_    k   .' write ( name ( 13 : 16 ) , '(i4.4)' ) nfile write ( name ( 18 : 20 ) , '(i3.3)' ) filen name ( 22 : 24 ) = cexpnr write ( 6 , * ) 'Reading Inlet temperature: ' , name open ( unit = ifinput , file = name , form = 'unformatted' ) read ( ifinput ) ((( storet0inold ( j , k , n ), j = jbin , jein ), k = kbin , kein ), n = 1 , nstore ) close ( ifinput ) end if ! determine start and end indices if ( filen == procinlo ) then js = jbeg else js = jbin end if if ( filen == procinup ) then jf = jend else jf = jein end if jsdum = jfdum + 1 jfdum = jsdum + ( jf - js ) !        if (jsdum >= 3) write(6,*) 'myid, jsdum = ',myid, jsdum !        if (jfdum >= 3) write(6,*) 'myid, jfdum = ',myid, jfdum !!! put values from original in dummy variable storeu0indum ( jsdum : jfdum ,:,:) = storeu0inold ( js : jf ,:,:) ! s: start  f: final storev0indum ( jsdum : jfdum ,:,:) = storev0inold ( js : jf ,:,:) ! s: start  f: final storew0indum ( jsdum : jfdum ,:,:) = storew0inold ( js : jf ,:,:) ! s: start  f: final if ( ltempeq ) then storet0indum ( jsdum : jfdum ,:,:) = storet0inold ( js : jf ,:,:) ! s: start  f: final end if end do ! loop over original inlet files ! now interpolate in y call yinterpolate ( storeu0indum , storeu0innew , kbin , kein ) call yinterpolate ( storev0indum , storev0innew , kbin , kein ) call yinterpolate ( storew0indum , storew0innew , kbin , kein + 1 ) call yinterpolate ( storet0indum , storet0innew , kbin , kein ) if (. not . lzinzsim ) then ! interpolate when zin =/ zsim call zinterpolate ( storeu0innew (:,:,:), storeu0inletbc ) ! interpolate inlet profile to zgrid call zinterpolate ( storev0innew (:,:,:), storev0inletbc ) ! interpolate inlet profile to zgrid call zinterpolatew ( storew0innew (:,:,:), storew0inletbc ) ! interpolate inlet profile to zgrid if ( ltempeq ) then call zinterpolatet ( storet0innew (:,:,:), storet0inletbc ) ! interpolate inlet profile to zgrid end if else storeu0inletbc (:,:,:) = storeu0inold (:,:,:) storev0inletbc (:,:,:) = storev0inold (:,:,:) storew0inletbc (:,:,:) = storew0inold (:,:,:) if ( ltempeq ) then storet0inletbc (:,:,:) = storet0inold (:,:,:) end if end if if ( iangle /= 0.0 ) then ! modify for inflow angle do n = 1 , nstore do k = kb , ke do j = jb , je u0rot ( n , j , k ) = storeu0inletbc ( j , k , n ) ! swap indices in order v0rot ( n , j , k ) = storev0inletbc ( j , k , n ) ! to use excjs end do end do end do call excjs ( u0rot , 1 , nstore , jb , je , kb , ke , 0 , jh ) call excjs ( v0rot , 1 , nstore , jb , je , kb , ke , 0 , jh ) !         write(6,*) 'v0rot(1,je+1,30) = ',v0rot(1,je+1,30) do n = 1 , nstore do k = kb , ke do j = jb , je ! apply horizontal rotation (neglecting the delta_x difference) storeu0inletbc ( j , k , n ) = u0rot ( n , j , k ) * cos ( iangle ) - 0.5 * sin ( iangle ) * ( v0rot ( n , j , k ) + v0rot ( n , j + 1 , k )) storev0inletbc ( j , k , n ) = v0rot ( n , j , k ) * cos ( iangle ) + 0.5 * sin ( iangle ) * ( u0rot ( n , j , k ) + u0rot ( n , j - 1 , k )) end do end do end do end if ! iangle =/0.0 end subroutine readinletfile","tags":"","loc":"proc/readinletfile.html"},{"title":"zinterpolate – uDALES","text":"public subroutine zinterpolate(input, output) Uses modglobal proc~~zinterpolate~~UsesGraph proc~zinterpolate zinterpolate module~modglobal modglobal proc~zinterpolate->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(jb:je,kbin:kein,1:nstore) :: input real, intent(inout), dimension(jb:je,kb:ke,1:nstore) :: output Contents Source Code zinterpolate Source Code subroutine zinterpolate ( input , output ) use modglobal , only : jb , je , kb , ke , zf , nstore implicit none real , dimension ( jb : je , kbin : kein , 1 : nstore ), intent ( in ) :: input real , dimension ( jb : je , kb : ke , 1 : nstore ), intent ( inout ) :: output integer k do k = kb , ke if ( linuf ( k ) == kein + 1 ) then ! indicator for extrapolation! output (:, k ,:) = input (:, kein ,:) elseif ( linlf ( k ) == kbin - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) output (:, k ,:) = input (:, kbin ,:) / zfin ( kbin ) * zf ( k ) !        output(:,k,:) = input(:,kbin,:)   ! temeperature is not zero at the wall, so line above is wrong else ! normal interpolation output (:, k ,:) = input (:, linlf ( k ),:) + ( input (:, linuf ( k ),:) - input (:, linlf ( k ),:)) / ( zfin ( linuf ( k )) - zfin ( linlf ( k ))) * ( zf ( k ) - zfin ( linlf ( k ))) if (( zf ( k ) . gt . zfin ( linuf ( k ))) . or . ( zf ( k ) . lt . zfin ( linlf ( k )))) then write ( 6 , * ) '!!!Mistake in zinterpolate !!!!' end if end if end do end subroutine zinterpolate","tags":"","loc":"proc/zinterpolate.html"},{"title":"zinterpolate1d – uDALES","text":"public subroutine zinterpolate1d(input, output) Uses modglobal proc~~zinterpolate1d~~UsesGraph proc~zinterpolate1d zinterpolate1d module~modglobal modglobal proc~zinterpolate1d->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(kbin:kein) :: input real, intent(inout), dimension(kb:ke) :: output Called by proc~~zinterpolate1d~~CalledByGraph proc~zinterpolate1d zinterpolate1d proc~readrestartfiles readrestartfiles proc~readrestartfiles->proc~zinterpolate1d proc~readinitfiles readinitfiles proc~readinitfiles->proc~readrestartfiles proc~startup startup proc~startup->proc~readinitfiles program~dalesurban DALESURBAN program~dalesurban->proc~startup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code zinterpolate1d Source Code subroutine zinterpolate1d ( input , output ) use modglobal , only : kb , ke , zf implicit none real , dimension ( kbin : kein ), intent ( in ) :: input real , dimension ( kb : ke ), intent ( inout ) :: output integer k do k = kb , ke if ( linuf ( k ) == kein + 1 ) then ! indicator for extrapolation! output ( k ) = input ( kein ) elseif ( linlf ( k ) == kbin - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) output ( k ) = input ( kbin ) / zfin ( kbin ) * zf ( k ) !        output(:,k,:) = input(:,kbin,:)   ! temeperature is not zero at the wall, so line above is wrong else ! normal interpolation output ( k ) = input ( linlf ( k )) + ( input ( linuf ( k )) - input ( linlf ( k ))) / ( zfin ( linuf ( k )) - zfin ( linlf ( k ))) * ( zf ( k ) - zf ( linlf ( k ))) if (( zf ( k ) . gt . zfin ( linuf ( k ))) . or . ( zf ( k ) . lt . zfin ( linlf ( k )))) then write ( 6 , * ) '!!!Mistake in zinterpolate1d !!!!' end if end if end do end subroutine zinterpolate1d","tags":"","loc":"proc/zinterpolate1d.html"},{"title":"zinterpolate2d – uDALES","text":"public subroutine zinterpolate2d(input, output) Uses modglobal proc~~zinterpolate2d~~UsesGraph proc~zinterpolate2d zinterpolate2d module~modglobal modglobal proc~zinterpolate2d->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(ib:ie,kbin:kein) :: input real, intent(inout), dimension(ib:ie,kb:ke) :: output Called by proc~~zinterpolate2d~~CalledByGraph proc~zinterpolate2d zinterpolate2d proc~readrestartfiles readrestartfiles proc~readrestartfiles->proc~zinterpolate2d proc~readinitfiles readinitfiles proc~readinitfiles->proc~readrestartfiles proc~startup startup proc~startup->proc~readinitfiles program~dalesurban DALESURBAN program~dalesurban->proc~startup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code zinterpolate2d Source Code subroutine zinterpolate2d ( input , output ) use modglobal , only : ib , ie , kb , ke , zf , nstore implicit none real , dimension ( ib : ie , kbin : kein ), intent ( in ) :: input real , dimension ( ib : ie , kb : ke ), intent ( inout ) :: output integer k do k = kb , ke if ( linuf ( k ) == kein + 1 ) then ! indicator for extrapolation! output (:, k ) = input (:, kein ) elseif ( linlf ( k ) == kbin - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) output (:, k ) = input (:, kbin ) / zfin ( kbin ) * zf ( k ) !        output(:,k,:) = input(:,kbin,:)   ! temeperature is not zero at the wall, so line above is wrong else ! normal interpolation output (:, k ) = input (:, linlf ( k )) + ( input (:, linuf ( k )) - input (:, linlf ( k ))) / ( zfin ( linuf ( k )) - zfin ( linlf ( k ))) * ( zf ( k ) - zf ( linlf ( k ))) if (( zf ( k ) . gt . zfin ( linuf ( k ))) . or . ( zf ( k ) . lt . zfin ( linlf ( k )))) then write ( 6 , * ) '!!!Mistake in zinterpolate2d !!!!' end if end if end do end subroutine zinterpolate2d","tags":"","loc":"proc/zinterpolate2d.html"},{"title":"zinterpolatew – uDALES","text":"public subroutine zinterpolatew(input, output) Uses modglobal proc~~zinterpolatew~~UsesGraph proc~zinterpolatew zinterpolatew module~modglobal modglobal proc~zinterpolatew->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(jb:je,kbin:kein+1,1:nstore) :: input real, intent(inout), dimension(jb:je,kb:ke+1,1:nstore) :: output Contents Source Code zinterpolatew Source Code subroutine zinterpolatew ( input , output ) use modglobal , only : jb , je , kb , ke , zh , nstore implicit none real , dimension ( jb : je , kbin : kein + 1 , 1 : nstore ), intent ( in ) :: input real , dimension ( jb : je , kb : ke + 1 , 1 : nstore ), intent ( inout ) :: output integer k do k = kb , ke + 1 if ( linuh ( k ) == kein + 2 ) then ! indicator for extrapolation! output (:, k ,:) = input (:, kein + 1 ,:) elseif ( linlh ( k ) == kbin - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) output (:, k ,:) = input (:, kbin ,:) ! =0 !        output(:,k,:) = input(:,kbin,:)/zhin(kbin) * zh(k) !        output(:,k,:) = input(:,kbin,:)   ! temeperature is not zero at the wall, so line above is wrong else ! normal interpolation output (:, k ,:) = input (:, linlh ( k ),:) + ( input (:, linuh ( k ),:) - input (:, linlh ( k ),:)) / ( zhin ( linuh ( k )) - zhin ( linlh ( k ))) * ( zh ( k ) - zhin ( linlh ( k ))) if (( zh ( k ) . gt . zhin ( linuh ( k ))) . or . ( zh ( k ) . lt . zhin ( linlh ( k )))) then write ( 6 , * ) '!!!Mistake in zinterpolatew !!!!' end if end if end do end subroutine zinterpolatew","tags":"","loc":"proc/zinterpolatew.html"},{"title":"zinterpolatew1d – uDALES","text":"public subroutine zinterpolatew1d(input, output) Uses modglobal proc~~zinterpolatew1d~~UsesGraph proc~zinterpolatew1d zinterpolatew1d module~modglobal modglobal proc~zinterpolatew1d->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(kbin:kein+1) :: input real, intent(inout), dimension(kb:ke+1) :: output Called by proc~~zinterpolatew1d~~CalledByGraph proc~zinterpolatew1d zinterpolatew1d proc~readrestartfiles readrestartfiles proc~readrestartfiles->proc~zinterpolatew1d proc~readinitfiles readinitfiles proc~readinitfiles->proc~readrestartfiles proc~startup startup proc~startup->proc~readinitfiles program~dalesurban DALESURBAN program~dalesurban->proc~startup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code zinterpolatew1d Source Code subroutine zinterpolatew1d ( input , output ) use modglobal , only : kb , ke , zh implicit none real , dimension ( kbin : kein + 1 ), intent ( in ) :: input real , dimension ( kb : ke + 1 ), intent ( inout ) :: output integer k do k = kb , ke + 1 if ( linuh ( k ) == kein + 2 ) then ! indicator for extrapolation! output ( k ) = input ( kein + 1 ) elseif ( linlh ( k ) == kbin - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) output ( k ) = input ( kbin ) !=0 !        output(k) = input(kbin)/zhin(kbin) * zh(k) !        output(:,k,:) = input(:,kbin,:)   ! temeperature is not zero at the wall, so line above is wrong else ! normal interpolation output ( k ) = input ( linlh ( k )) + ( input ( linuh ( k )) - input ( linlh ( k ))) / ( zhin ( linuh ( k )) - zhin ( linlh ( k ))) * ( zh ( k ) - zh ( linlh ( k ))) if (( zh ( k ) . gt . zhin ( linuh ( k ))) . or . ( zh ( k ) . lt . zhin ( linlh ( k )))) then write ( 6 , * ) '!!!Mistake in zinterpolatew1d !!!!' end if end if end do end subroutine zinterpolatew1d","tags":"","loc":"proc/zinterpolatew1d.html"},{"title":"zinterpolatet – uDALES","text":"public subroutine zinterpolatet(input, output) Uses modglobal modsurfdata proc~~zinterpolatet~~UsesGraph proc~zinterpolatet zinterpolatet module~modglobal modglobal proc~zinterpolatet->module~modglobal module~modsurfdata modsurfdata proc~zinterpolatet->module~modsurfdata Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(jb:je,kbin:kein,1:nstore) :: input real, intent(inout), dimension(jb:je,kb:ke,1:nstore) :: output Contents Source Code zinterpolatet Source Code subroutine zinterpolatet ( input , output ) use modglobal , only : jb , je , kb , ke , zf , nstore use modsurfdata , only : thls implicit none real , dimension ( jb : je , kbin : kein , 1 : nstore ), intent ( in ) :: input real , dimension ( jb : je , kb : ke , 1 : nstore ), intent ( inout ) :: output integer k do k = kb , ke if ( linuf ( k ) == kein + 1 ) then ! indicator for extrapolation! output (:, k ,:) = input (:, kein ,:) elseif ( linlf ( k ) == kbin - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) output (:, k ,:) = thls + ( input (:, kb ,:) - thls ) / zfin ( kbin ) * zf ( k ) !         output(:,k,:) = (input(:,kb,:)-thls)/zfin(kbin)*zf(k) !        output(:,k,:) = input(:,kbin,:)/zfin(kbin) * zf(k) !        output(:,k,:) = input(:,kbin,:)   ! temeperature is not zero at the wall, so line above is wrong else ! normal interpolation output (:, k ,:) = input (:, linlf ( k ),:) + ( input (:, linuf ( k ),:) - input (:, linlf ( k ),:)) / ( zfin ( linuf ( k )) - zfin ( linlf ( k ))) * ( zf ( k ) - zfin ( linlf ( k ))) if (( zf ( k ) . gt . zfin ( linuf ( k ))) . or . ( zf ( k ) . lt . zfin ( linlf ( k )))) then write ( 6 , * ) '!!!Mistake in zinterpolatet !!!!' end if end if end do end subroutine zinterpolatet","tags":"","loc":"proc/zinterpolatet.html"},{"title":"zinterpolatet1d – uDALES","text":"public subroutine zinterpolatet1d(input, output) Uses modglobal modsurfdata proc~~zinterpolatet1d~~UsesGraph proc~zinterpolatet1d zinterpolatet1d module~modglobal modglobal proc~zinterpolatet1d->module~modglobal module~modsurfdata modsurfdata proc~zinterpolatet1d->module~modsurfdata Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(kbin:kein) :: input real, intent(inout), dimension(kb:ke) :: output Called by proc~~zinterpolatet1d~~CalledByGraph proc~zinterpolatet1d zinterpolatet1d proc~readrestartfiles readrestartfiles proc~readrestartfiles->proc~zinterpolatet1d proc~readinitfiles readinitfiles proc~readinitfiles->proc~readrestartfiles proc~startup startup proc~startup->proc~readinitfiles program~dalesurban DALESURBAN program~dalesurban->proc~startup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code zinterpolatet1d Source Code subroutine zinterpolatet1d ( input , output ) use modglobal , only : jb , je , kb , ke , zf , nstore use modsurfdata , only : thls implicit none real , dimension ( kbin : kein ), intent ( in ) :: input real , dimension ( kb : ke ), intent ( inout ) :: output integer k do k = kb , ke if ( linuf ( k ) == kein + 1 ) then ! indicator for extrapolation! output ( k ) = input ( kein ) elseif ( linlf ( k ) == kbin - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) output ( k ) = ( input ( kb ) - thls ) / zfin ( kbin ) * zf ( k ) !        output(:,k,:) = input(:,kbin,:)/zfin(kbin) * zf(k) !        output(:,k,:) = input(:,kbin,:)   ! temeperature is not zero at the wall, so line above is wrong else ! normal interpolation output ( k ) = input ( linlf ( k )) + ( input ( linuf ( k )) - input ( linlf ( k ))) / ( zfin ( linuf ( k )) - zfin ( linlf ( k ))) * ( zf ( k ) - zf ( linlf ( k ))) if (( zf ( k ) . gt . zfin ( linuf ( k ))) . or . ( zf ( k ) . lt . zfin ( linlf ( k )))) then write ( 6 , * ) '!!!Mistake in zinterpolatet1d !!!!' end if end if end do end subroutine zinterpolatet1d","tags":"","loc":"proc/zinterpolatet1d.html"},{"title":"yinterpolate – uDALES","text":"public subroutine yinterpolate(input, output, ks, kf) Uses modglobal proc~~yinterpolate~~UsesGraph proc~yinterpolate yinterpolate module~modglobal modglobal proc~yinterpolate->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(jbdum:jedum,ks:kf,1:nstore) :: input real, intent(inout), dimension(jb   :je   ,ks:kf,1:nstore) :: output integer, intent(in) :: ks integer, intent(in) :: kf Called by proc~~yinterpolate~~CalledByGraph proc~yinterpolate yinterpolate proc~readinletfile readinletfile proc~readinletfile->proc~yinterpolate proc~inletgennotemp inletgennotemp proc~inletgennotemp->proc~readinletfile proc~inletgen inletgen proc~inletgen->proc~readinletfile proc~readinitfiles readinitfiles proc~readinitfiles->proc~readinletfile proc~boundary boundary proc~readinitfiles->proc~boundary proc~startup startup proc~startup->proc~readinitfiles proc~boundary->proc~inletgennotemp proc~boundary->proc~inletgen program~dalesurban DALESURBAN program~dalesurban->proc~startup program~dalesurban->proc~boundary Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code yinterpolate Source Code subroutine yinterpolate ( input , output , ks , kf ) use modglobal , only : jb , je , nstore integer , intent ( in ) :: ks integer , intent ( in ) :: kf real , dimension ( jbdum : jedum , ks : kf , 1 : nstore ), intent ( in ) :: input real , dimension ( jb : je , ks : kf , 1 : nstore ), intent ( inout ) :: output integer j do j = jb , je !      if (np==0 .and. yloclowf(j)==) output ( j ,:,:) = input ( yloclowf ( j ),:,:) + ( input ( ylocupf ( j ),:,:) - input ( yloclowf ( j ),:,:)) / ( yfdum ( ylocupf ( j )) - yfdum ( yloclowf ( j ))) * ( yf ( j ) - yfdum ( yloclowf ( j ))) end do end subroutine yinterpolate","tags":"","loc":"proc/yinterpolate.html"},{"title":"yinterpolateh – uDALES","text":"public subroutine yinterpolateh(input, output, ks, kf) Uses modglobal proc~~yinterpolateh~~UsesGraph proc~yinterpolateh yinterpolateh module~modglobal modglobal proc~yinterpolateh->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(jbdum:jedum,ks:kf,1:nstore) :: input real, intent(inout), dimension(jb   :je   ,ks:kf,1:nstore) :: output integer, intent(in) :: ks integer, intent(in) :: kf Contents Source Code yinterpolateh Source Code subroutine yinterpolateh ( input , output , ks , kf ) use modglobal , only : jb , je , nstore integer , intent ( in ) :: ks integer , intent ( in ) :: kf real , dimension ( jbdum : jedum , ks : kf , 1 : nstore ), intent ( in ) :: input real , dimension ( jb : je , ks : kf , 1 : nstore ), intent ( inout ) :: output integer j , jj do j = jb , je !      if (np==0 .and. yloclowf(j)==) output ( j ,:,:) = input ( yloclowh ( j ),:,:) + ( input ( ylocuph ( j ),:,:) - input ( yloclowh ( j ),:,:)) / ( yhdum ( ylocuph ( j )) - yhdum ( yloclowh ( j ))) * ( yh ( j ) - yhdum ( yloclowh ( j ))) end do end subroutine yinterpolateh","tags":"","loc":"proc/yinterpolateh.html"},{"title":"readzincoord – uDALES","text":"public subroutine readzincoord() Uses modglobal modmpi proc~~readzincoord~~UsesGraph proc~readzincoord readzincoord module~modmpi modmpi proc~readzincoord->module~modmpi module~modglobal modglobal proc~readzincoord->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~readzincoord~~CallsGraph proc~readzincoord readzincoord mpi_bcast mpi_bcast proc~readzincoord->mpi_bcast Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readzincoord~~CalledByGraph proc~readzincoord readzincoord proc~initinlet initinlet proc~initinlet->proc~readzincoord proc~startup startup proc~startup->proc~initinlet program~dalesurban DALESURBAN program~dalesurban->proc~startup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code readzincoord Source Code subroutine readzincoord use modglobal , only : kb , ke , kh , ifinput , zf , zh , ysize , jb , je , dy use modmpi , only : myid , mpi_integer , comm3d , mpierr , my_real , nprocs implicit none character ( 72 ) chmess character ( 20 ) namezinlet character ( 20 ) namezinfo integer ierr , k , kk , kmaxin , j , jj real ysizeproc namelist / INFO / nprocsinl , jgtotinl , kmaxin , dtin , wtop , totalreadu namezinlet = 'zgrid.inl' namezinfo = 'zgrid.inf' if ( myid == 0 ) then open ( ifinput , file = namezinfo , status = 'old' , iostat = ierr ) if ( ierr /= 0 ) then write ( 0 , * ) 'ERROR: zgrid.inf does not exist' stop 1 end if read ( ifinput , INFO , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'Problem in zgrid.inf INFO' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif write ( 6 , INFO ) close ( ifinput ) end if kbin = 0 kein = kmaxin - 1 call MPI_BCAST ( nprocsinl , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( jgtotinl , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( kbin , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( kein , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( dtin , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wtop , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( totalreadu , 1 , MY_REAL , 0 , comm3d , mpierr ) allocate ( zhin ( kbin : kein + 1 )) allocate ( zfin ( kbin : kein + 1 )) allocate ( dzfin ( kbin - 1 : kein + 1 )) allocate ( dzhin ( kbin : kein + 1 )) if ( myid == 0 ) then write ( 6 , * ) 'loading ' , namezinlet open ( ifinput , file = namezinlet ) read ( ifinput , '(a72)' ) chmess read ( ifinput , '(a72)' ) chmess do k = kbin , kein read ( ifinput , * ) zfin ( k ) end do close ( ifinput ) zhin ( kbin ) = 0.0 do k = kbin , kein zhin ( k + 1 ) = zhin ( k ) + 2.0 * ( zfin ( k ) - zhin ( k )) end do zfin ( kein + kh ) = zfin ( kein ) + 2.0 * ( zhin ( kein + kh ) - zfin ( kein )) do k = kbin , kein dzfin ( k ) = zhin ( k + 1 ) - zhin ( k ) end do dzfin ( kein + 1 ) = dzfin ( kein ) dzfin ( kbin - 1 ) = dzfin ( kbin ) dzhin ( kbin ) = 2 * zfin ( kbin ) do k = kbin + 1 , kein + kh dzhin ( k ) = zfin ( k ) - zfin ( k - 1 ) end do ! check if the inlet mesh and the simulation mesh differ do k = kb , min ( ke , kein ) if ( abs ( zfin ( k ) - zf ( k )) > 1e-7 ) then lzinzsim = . false . end if enddo end if ! myid==0 ! MPI broadcast kmax elements from zf call MPI_BCAST ( zfin , kein - kbin + 2 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( zhin , kein - kbin + 2 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dzfin , kein - kbin + 3 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dzhin , kein - kbin + 2 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lzinzsim , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) if (. not . lzinzsim ) then if ( myid == 0 ) then write ( 6 , * ) 'zgrid.inl does not equal zgrid.inp: Inlet will be interpolated in z' end if !      allocate(linlf(kbin:kein)) !      allocate(linuf(kbin:kein)) !      allocate(linlh(kbin:kein+1)) !      allocate(linuh(kbin:kein+1)) allocate ( linlf ( kb : ke )) allocate ( linuf ( kb : ke )) allocate ( linlh ( kb : ke + 1 )) allocate ( linuh ( kb : ke + 1 )) ! zf do k = kb , ke do kk = kbin , kein if ( zfin ( kk ) >= zf ( k )) then linuf ( k ) = kk linlf ( k ) = kk - 1 exit elseif ( kk == kein ) then linuf ( k ) = kein + 1 ! this means extrapolation! linlf ( k ) = kein - 1 ! waarom niet ke? of wordt dit niet gebruikt? end if end do end do ! for w-components (zh) do k = kb , ke + 1 do kk = kbin , kein + 1 if ( zhin ( kk ) >= zh ( k )) then linuh ( k ) = kk linlh ( k ) = kk - 1 exit elseif ( kk == kein + 1 ) then linuh ( k ) = kein + 2 ! this means extrapolation! linlh ( k ) = kein end if end do end do else ! lzinzsim  -> grids are equal if ( myid == 0 ) then write ( 6 , * ) 'zgrid.inl equals zgrid.inp: Inlet will not be interpolated in z' end if end if ! Now prepare everything for interpolation in y-direction jgbin = 1 jgein = jgbin + jgtotinl - 1 jtotin = jgtotinl / nprocsinl jbin = 1 jein = 1 + jtotin - 1 ysizeproc = ysize / nprocs dyin = ysize / jgtotinl jbdum = 1 jtotdum = ceiling ( ysizeproc / real ( dyin )) + 1 ! dummy indices jedum = jbdum + jtotdum - 1 !     allocate(yf   (jb    :je)) allocate ( yf ( jb : je + 1 )) allocate ( yh ( jb : je + 1 )) allocate ( yfin ( jgbin : jgein + 1 )) allocate ( yhin ( jgbin - 1 : jgein + 1 )) !     allocate(yfdum(jbdum :jedum)) allocate ( yfdum ( jbdum : jedum + 1 )) allocate ( yhdum ( jbdum : jedum + 1 )) allocate ( yloclowf ( jb : je + 1 )) allocate ( ylocupf ( jb : je + 1 )) allocate ( yloclowh ( jb : je + 1 )) allocate ( ylocuph ( jb : je + 1 )) ! make global y-grid (equidistant) for inlet data do j = jgbin - 1 , jgein + 1 yhin ( j ) = ( j - jgbin ) * dyin end do do j = jgbin , jgein + 1 yfin ( j ) = yhin ( j ) + 0.5 * dyin end do ! make new y-grid (equidistant) do j = jb , je + 1 yh ( j ) = myid * ( ysize / nprocs ) + ( j - jb ) * dy yf ( j ) = yh ( j ) + 0.5 * dy end do ! check which original cells are needed for interpolation do j = jgein + 1 , jgbin , - 1 if ( yhin ( j ) <= yh ( jb )) then if ( yfin ( j ) <= yf ( jb )) then procinlo = floor ( real ( j - jgbin ) / real ( jtotin )) ! this is the first cell to consider filenumstart = procinlo jgbeg = j jbeg = j - ( procinlo * jtotin ) !            jend = jbeg+jtotdum-1 jj = j + jtotdum - 1 !            procinup = floor((j-jgbin)/real(jtotin)) !            procinup = floor((j-jgbin+1)/real(jtotin)) procinup = floor ( real ( jj - jgbin ) / real ( jtotin )) filenumend = procinup jend = jj - ( procinup * jtotin ) procinup = procinup - floor ( real ( procinup ) / real ( nprocsinl )) * nprocsinl ! continue on first procinl again else if ( j == jgbin ) then jgbeg = j - 1 jbeg = jein procinlo = nprocsinl - 1 filenumstart = - 1 jj = j + jtotdum - 2 procinup = floor ( real ( jj - jgbin ) / real ( jtotin )) filenumend = procinup jend = jj - ( procinup * jtotin ) procinup = procinup - floor ( real ( procinup ) / real ( nprocsinl )) * nprocsinl !continue on first procinl again else procinlo = floor ( real ( j - jgbin - 1 ) / real ( jtotin )) ! One cell lower is needed filenumstart = procinlo jgbeg = j - 1 jbeg = j - ( procinlo * jtotin ) - 1 jj = j + jtotdum - 2 procinup = floor ( real ( jj - jgbin ) / real ( jtotin )) filenumend = procinup jend = jj - ( procinup * jtotin ) procinup = procinup - floor ( real ( procinup ) / real ( nprocsinl )) * nprocsinl ! continue on first procinl again end if ! j=jgbin end if exit end if end do write ( 6 , * ) '!! myid,procinlo,jbeg,procinup,jend,jgbeg = ' , myid , procinlo , jbeg , procinup , jend , jgbeg ! make dummy y-grid (equidistant) do j = jbdum , jedum + 1 yhdum ( j ) = yhin ( jgbeg ) + ( j - jbdum + 1 ) * dyin yfdum ( j ) = yhdum ( j ) + 0.5 * dyin end do !      if (procoldup /= procoldlo) then !        write(6,*) '!!! Start-cell and end-cell are not in the same file!!!' !      end if filestoread = filenumend - filenumstart + 1 ! no. of files to be read !      write(6,*) '!! procinlo,procinup = ',procinlo,procinup !      write(6,*) '!! jbin,jein,jbeg,jend= ',jbin,jein,jbeg,jend ! for components defined on yf do j = jb , je do jj = jbdum + 1 , jedum + 1 if ( yfdum ( jj ) >= yf ( j )) then ylocupf ( j ) = jj yloclowf ( j ) = jj - 1 exit end if end do end do ! for components defined on yh do j = jb , je + 1 do jj = jbdum + 1 , jedum + 1 if ( yhdum ( jj ) >= yh ( j )) then ylocuph ( j ) = jj yloclowh ( j ) = jj - 1 exit end if end do end do end subroutine readzincoord","tags":"","loc":"proc/readzincoord.html"},{"title":"exitinlet – uDALES","text":"public subroutine exitinlet() Uses modglobal proc~~exitinlet~~UsesGraph proc~exitinlet exitinlet module~modglobal modglobal proc~exitinlet->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~exitinlet~~CalledByGraph proc~exitinlet exitinlet proc~exitmodules exitmodules proc~exitmodules->proc~exitinlet program~dalesurban DALESURBAN program~dalesurban->proc~exitmodules Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code exitinlet Source Code subroutine exitinlet use modglobal , only : iinletgen , lstoreplane , ltempeq if ( iinletgen == 1 ) then deallocate ( Uinl , Winl , Urec , Wrec , u0inletbc , v0inletbc , w0inletbc , zirf , ziif , ziih , zirh , zorf , zoif , zorh , zoih , loclowif , locupif , loclowih , locupih , loclowof , locupof , loclowoh , locupoh , uminletbc , vminletbc , wminletbc , u0inletbcold , v0inletbcold , w0inletbcold , Utav , upupavinl , vpvpavinl , wpwpavinl , upwpavinl , thlpthlpavinl , thlpupavinl , thlpwpavinl ) if ( ltempeq ) then deallocate ( t0inletbc , tminletbc , t0inletbcold , loclowot , locupot , zotr , zoti , Tinl , Trec ) end if if ( lstoreplane ) then deallocate ( storeu0inletbc , storev0inletbc , storew0inletbc ) if ( ltempeq ) then deallocate ( storet0inletbc ) end if end if else if ( iinletgen == 2 ) then deallocate ( storeu0inletbc , storev0inletbc , storew0inletbc , u0inletbc , v0inletbc , w0inletbc , uminletbc , vminletbc , wminletbc , u0inletbcold , v0inletbcold , w0inletbcold ) if ( ltempeq ) then deallocate ( t0inletbc , tminletbc , t0inletbcold , storet0inletbc ) end if end if end subroutine exitinlet","tags":"","loc":"proc/exitinlet.html"},{"title":"initboundary – uDALES","text":"public subroutine initboundary() Uses modglobal modinletdata proc~~initboundary~~UsesGraph proc~initboundary initboundary module~modinletdata modinletdata proc~initboundary->module~modinletdata module~modglobal modglobal proc~initboundary->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~initboundary~~CalledByGraph proc~initboundary initboundary proc~startup startup proc~startup->proc~initboundary program~dalesurban DALESURBAN program~dalesurban->proc~startup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code initboundary Source Code subroutine initboundary use modglobal , only : ib , kb , ke , kh , kmax , pi , zf , iplane use modinletdata , only : irecy , irecydriver implicit none real :: zspb , zspt integer :: k allocate ( tsc ( kb : ke + kh )) ! Sponge layer if ( ksp == - 1 ) then !      ksp  = min(3*kmax/4,kmax - 15) ksp = ( kb - 1 ) + max ( min ( 3 * kmax / 4 , kmax - 15 ), 1 ) end if zspb = zf ( ksp ) zspt = zf ( ke ) tsc ( kb : ksp - 1 ) = 0.0 do k = ksp , ke tsc ( k ) = rnu0 * sin ( 0.5 * pi * ( zf ( k ) - zspb ) / ( zspt - zspb )) ** 2 end do tsc ( ke + 1 ) = tsc ( ke ) irecy = ib + iplane irecydriver = iplane ! + ib end subroutine initboundary","tags":"","loc":"proc/initboundary.html"},{"title":"boundary – uDALES","text":"public subroutine boundary() Uses modglobal modfields modsubgriddata modsurfdata modmpi modinlet moddriver modinletdata proc~~boundary~~UsesGraph proc~boundary boundary module~moddriver moddriver proc~boundary->module~moddriver module~modsurfdata modsurfdata proc~boundary->module~modsurfdata module~modinlet modinlet proc~boundary->module~modinlet module~modmpi modmpi proc~boundary->module~modmpi module~modsubgriddata modsubgriddata proc~boundary->module~modsubgriddata module~modinletdata modinletdata proc~boundary->module~modinletdata module~modfields modfields proc~boundary->module~modfields module~modglobal modglobal proc~boundary->module~modglobal module~moddriver->module~modinletdata module~modinlet->module~modinletdata mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~boundary~~CallsGraph proc~boundary boundary proc~cyclicmj cyclicmj proc~boundary->proc~cyclicmj proc~iohi iohi proc~boundary->proc~iohi proc~iolet iolet proc~boundary->proc~iolet proc~drivergen drivergen proc~boundary->proc~drivergen proc~cyclicqi cyclicqi proc~boundary->proc~cyclicqi proc~inletgen inletgen proc~boundary->proc~inletgen proc~cyclichi cyclichi proc~boundary->proc~cyclichi proc~iosi iosi proc~boundary->proc~iosi proc~inletgennotemp inletgennotemp proc~boundary->proc~inletgennotemp proc~fluxtopscal fluxtopscal proc~boundary->proc~fluxtopscal proc~cyclicsi cyclicsi proc~boundary->proc~cyclicsi proc~cyclicqj cyclicqj proc~boundary->proc~cyclicqj proc~valuetop valuetop proc~boundary->proc~valuetop proc~inlettop inlettop proc~boundary->proc~inlettop proc~cyclicmi cyclicmi proc~boundary->proc~cyclicmi proc~scalrec scalrec proc~boundary->proc~scalrec proc~fluxtop fluxtop proc~boundary->proc~fluxtop proc~valuetopscal valuetopscal proc~boundary->proc~valuetopscal proc~cyclicsj cyclicsj proc~boundary->proc~cyclicsj proc~cyclichj cyclichj proc~boundary->proc~cyclichj proc~ioqi ioqi proc~boundary->proc~ioqi proc~scalsirane scalSIRANE proc~boundary->proc~scalsirane proc~excjs excjs proc~cyclicmj->proc~excjs proc~slabsum slabsum proc~iolet->proc~slabsum proc~writedriverfile writedriverfile proc~drivergen->proc~writedriverfile proc~enthalpythickness enthalpythickness proc~inletgen->proc~enthalpythickness trec trec proc~inletgen->trec wrec wrec proc~inletgen->wrec uinl uinl proc~inletgen->uinl urec urec proc~inletgen->urec ttav ttav proc~inletgen->ttav proc~writerestartfiles writerestartfiles proc~inletgen->proc~writerestartfiles proc~dispthicknessexp dispthicknessexp proc~inletgen->proc~dispthicknessexp proc~writeinletfile writeinletfile proc~inletgen->proc~writeinletfile proc~momentumthicknessexp momentumthicknessexp proc~inletgen->proc~momentumthicknessexp proc~blthicknesst blthicknesst proc~inletgen->proc~blthicknesst proc~readinletfile readinletfile proc~inletgen->proc~readinletfile proc~inletgen->proc~slabsum tinl tinl proc~inletgen->tinl utav utav proc~inletgen->utav proc~inletgennotemp->wrec proc~inletgennotemp->uinl proc~inletgennotemp->urec proc~inletgennotemp->proc~writerestartfiles proc~inletgennotemp->proc~dispthicknessexp proc~inletgennotemp->proc~writeinletfile proc~inletgennotemp->proc~momentumthicknessexp proc~inletgennotemp->proc~blthicknesst proc~inletgennotemp->proc~readinletfile proc~inletgennotemp->proc~slabsum proc~inletgennotemp->utav proc~cyclicqj->proc~excjs proc~slabsumi slabsumi proc~inlettop->proc~slabsumi proc~cyclichj->proc~excjs mpi_allreduce mpi_allreduce proc~slabsumi->mpi_allreduce proc~dispthicknessexp->utav mpi_sendrecv mpi_sendrecv proc~excjs->mpi_sendrecv proc~readinletfile->proc~excjs proc~yinterpolate yinterpolate proc~readinletfile->proc~yinterpolate proc~slabsum->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~boundary~~CalledByGraph proc~boundary boundary proc~readinitfiles readinitfiles proc~readinitfiles->proc~boundary program~dalesurban DALESURBAN program~dalesurban->proc~boundary proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code boundary Source Code subroutine boundary use modglobal , only : ib , ie , ih , jb , je , jgb , jge , jh , kb , ke , kh , linoutflow , dzf , zh , dy , & timee , ltempeq , lmoist , BCxm , BCym , BCxT , BCyT , BCxq , BCyq , BCxs , BCys , BCtopm , BCtopT ,& BCtopq , BCtops , e12min , idriver , luvolflowr , luoutflowr use modfields , only : u0 , v0 , w0 , um , vm , wm , thl0 , thlm , qt0 , qtm , uout , uouttot , e120 , e12m ,& u0av use modsubgriddata , only : ekh , ekm use modsurfdata , only : thl_top , qt_top , sv_top , wttop , wqtop , wsvtop use modmpi , only : myid , slabsum use modinlet , only : inletgen , inletgennotemp use moddriver , only : drivergen use modinletdata , only : irecy , ubulk , iangle !    use modsurface, only : getobl implicit none real , dimension ( kb : ke ) :: uaverage integer i , k ! if not using massflowrate need to set outflow velocity if ( luoutflowr ) then ! do nothing - calculated in modforces elseif (. not . luvolflowr ) then !ubulk = sum(u0av)/(ke-kb+1) do k = kb , ke uaverage ( k ) = u0av ( k ) * dzf ( k ) end do ! need a method to know if we have all blocks at lowest cell kb ! assuming this for now (hence kb+1) uouttot = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb + 1 )) else uouttot = ubulk end if !BCxm!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !periodic or inflow/outflow conditions for momentum if ( BCxm . eq . 1 ) then !periodic call cyclicmi if ( idriver == 1 ) then ! write driver files call drivergen end if else if ( BCxm . eq . 2 ) then !previously iinletgen 1 uouttot = cos ( iangle ) * ubulk if ( ltempeq ) then call inletgen else call inletgennotemp end if ! iolet - called due to BCtopm = 3 else if ( BCxm . eq . 3 ) then ! previously iinletgen 2 uouttot = cos ( iangle ) * ubulk if ( ltempeq ) then call inletgen else call inletgennotemp end if ! iolet - called due to BCtopm = 3 else if ( BCxm . eq . 4 ) then !previously (inoutflow without iinlet) uouttot = cos ( iangle ) * ubulk if ( ltempeq ) then call inletgen else call inletgennotemp end if ! iolet - called due to BCtopm = 3 else if ( BCxm . eq . 5 ) then ! driver from drivergen (idriver == 2) uouttot = ubulk ! does this hold for all forcings of precursor simulations? tg3315 call drivergen ! iolet - called due to BCtopm = 3 else write ( 0 , * ) \"ERROR: lateral boundary type for veloctiy in x-direciton undefined\" stop 1 end if !BCym!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !currently BC in y is always periodic for momentum if ( BCym . eq . 1 ) then call cyclicmj else write ( 0 , * ) \"ERROR: lateral boundary type for velocity in y-direction undefined\" stop 1 end if !BCxT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! if ( BCxT . eq . 1 ) then call cyclichi else if ( BCxT . eq . 2 ) then !inoutflow - will be overwritten unless BCxm == 1 call iohi ! make sure uouttot is known and realistic else if ( BCxT . eq . 3 ) then !do nothing, temperature is considered in iolet else write ( 0 , * ) \"ERROR: lateral boundary type for temperature in x-direction undefined\" stop 1 end if !BCyT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! if ( BCyT . eq . 1 ) then call cyclichj else write ( 0 , * ) \"ERROR: lateral boundary type for temperature in y-direction undefined\" stop 1 end if !BCxq!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! if ( BCxq . eq . 1 ) then call cyclicqi else if ( BCxq . eq . 2 ) then !inoutflow  - will be overwritten unless BCxm == 1 call ioqi ! tg3315 - make sure uouttot is known and realistic elseif ( BCxq . eq . 3 ) then !do nothing, temperature is considered in iolet else write ( 0 , * ) \"ERROR: lateral boundary type for humidity in x-direction undefined\" stop 1 end if !BCyq!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! if ( BCyq . eq . 1 ) then call cyclicqj else write ( 0 , * ) \"ERROR: lateral boundary type for humidity in y-direction undefined\" stop 1 end if !BCys!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! if ( BCys . eq . 1 ) then call cyclicsj elseif ( BCys . eq . 5 ) then ! done in scalSIRANE else write ( 0 , * ) \"ERROR: lateral boundary type for scalars in y-direction undefined\" stop 1 end if !BCxs!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! if ( BCxs . eq . 1 ) then call cyclicsi else if ( BCxs . eq . 2 ) then !inoutflow  - will be overwritten unless BCxm == 1 call iosi ! make sure uouttot is known and correct for the running set-up else if ( BCxs . eq . 3 ) then ! do nothing - considered in iolet else if ( BCxs . eq . 4 ) then !scalrec - will be overwritten unless BCxm == 1 call scalrec else if ( BCxs . eq . 5 ) then !previously SIRANE - will be overwritten unless BCxm == 1 call scalSIRANE !  make sure uouttot/ vouttot is known and realistic else write ( 0 , * ) \"ERROR: lateral boundary type for scalars in x-direction undefined\" stop 1 end if !BCtopm!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! if ( BCtopm . eq . 1 ) then !free-slip = zero-flux call fluxtop ( um , ekm , 0.0 ) call fluxtop ( u0 , ekm , 0.0 ) call fluxtop ( vm , ekm , 0.0 ) call fluxtop ( v0 , ekm , 0.0 ) e120 (:, :, ke + 1 ) = e12min ! free slip top wall e12m (:, :, ke + 1 ) = e12min w0 (:, :, ke + 1 ) = 0.0 wm (:, :, ke + 1 ) = 0.0 else if ( BCtopm . eq . 2 ) then !no-slip = zero velocity at wall call valuetop ( um , 0.0 ) call valuetop ( u0 , 0.0 ) call valuetop ( vm , 0.0 ) call valuetop ( v0 , 0.0 ) w0 (:, :, ke + 1 ) = 0.0 wm (:, :, ke + 1 ) = 0.0 else if ( BCtopm . eq . 3 ) then call fluxtop ( um , ekm , 0.0 ) call fluxtop ( u0 , ekm , 0.0 ) call fluxtop ( vm , ekm , 0.0 ) call fluxtop ( v0 , ekm , 0.0 ) e120 (:, :, ke + 1 ) = e12min ! free slip top wall e12m (:, :, ke + 1 ) = e12min if ( idriver == 2 ) then ! does not use ddispdx, Uinf etc. w0 (:, :, ke + 1 ) = 0.0 wm (:, :, ke + 1 ) = 0.0 else call inlettop ! for iinletgen... end if call iolet !ils13, 13.8.18: iolet also deals with lateral boundaries!! else write ( 0 , * ) \"ERROR: top boundary type for velocity undefined\" stop 1 end if !BCtopT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! if ( BCtopT . eq . 1 ) then call fluxtop ( thlm , ekh , wttop ) call fluxtop ( thl0 , ekh , wttop ) else if ( BCtopT . eq . 2 ) then call valuetop ( thlm , thl_top ) call valuetop ( thl0 , thl_top ) else write ( 0 , * ) \"ERROR: top boundary type for temperature undefined\" stop 1 end if !BCtopq!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! if ( BCtopq . eq . 1 ) then call fluxtop ( qtm , ekh , wqtop ) call fluxtop ( qt0 , ekh , wqtop ) else if ( BCtopq . eq . 2 ) then call valuetop ( qtm , qt_top ) call valuetop ( qt0 , qt_top ) else write ( 0 , * ) \"ERROR: top boundary type for humidity undefined\" stop 1 end if !BCtops!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! if ( BCtops . eq . 1 ) then call fluxtopscal ( wsvtop ) call fluxtopscal ( wsvtop ) else if ( BCtops . eq . 2 ) then call valuetopscal ( sv_top ) call valuetopscal ( sv_top ) else write ( 0 , * ) \"ERROR: top boundary type for scalars undefined\" stop 1 end if end subroutine boundary","tags":"","loc":"proc/boundary.html"},{"title":"closurebc – uDALES","text":"public subroutine closurebc() Uses modsubgriddata modglobal modmpi proc~~closurebc~~UsesGraph proc~closurebc closurebc module~modmpi modmpi proc~closurebc->module~modmpi module~modsubgriddata modsubgriddata proc~closurebc->module~modsubgriddata module~modglobal modglobal proc~closurebc->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~closurebc~~CallsGraph proc~closurebc closurebc proc~excjs excjs proc~closurebc->proc~excjs mpi_sendrecv mpi_sendrecv proc~excjs->mpi_sendrecv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~closurebc~~CalledByGraph proc~closurebc closurebc proc~closure closure proc~closure->proc~closurebc proc~subgrid subgrid proc~subgrid->proc~closure program~dalesurban DALESURBAN program~dalesurban->proc~subgrid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code closurebc Source Code subroutine closurebc use modsubgriddata , only : ekm , ekh use modglobal , only : ib , ie , jb , je , kb , ke , ih , jh , kh , numol , prandtlmoli , linoutflow , BCtopm use modmpi , only : excjs integer i , j ! Top and bottom ! ils13, 13.8.18: what should it be for slip or mixed BCs ? if (( BCtopm . eq . 1 ) . or . ( BCtopm . eq . 3 )) then !free-slip do j = jb - 1 , je + 1 do i = ib - 1 , ie + 1 ekm ( i , j , ke + 1 ) = ekm ( i , j , ke ) ! zero-gradient top wall ekh ( i , j , ke + 1 ) = ekh ( i , j , ke ) ! zero-gradient top wall ekm ( i , j , kb - 1 ) = 2. * numol - ekm ( i , j , kb ) ! no-slip lower wall ekh ( i , j , kb - 1 ) = ( 2. * numol * prandtlmoli ) - ekh ( i , j , kb ) ! no-slip lower wall end do end do else if ( BCtopm . eq . 2 ) then !no-slip do j = jb - 1 , je + 1 do i = ib - 1 , ie + 1 ekm ( i , j , ke + 1 ) = 2. * numol - ekm ( i , j , ke ) ! no-slip top wall ekh ( i , j , ke + 1 ) = ( 2. * numol * prandtlmoli ) - ekh ( i , j , ke ) ! no-slip top wall ekm ( i , j , kb - 1 ) = 2. * numol - ekm ( i , j , kb ) ! no-slip lower wall ekh ( i , j , kb - 1 ) = ( 2. * numol * prandtlmoli ) - ekh ( i , j , kb ) ! no-slip lower wall end do end do end if ! horizontal BC's if ( linoutflow ) then ! inflow/outflow ekm ( ib - 1 , :, :) = ekm ( ib , :, :) ekm ( ie + 1 , :, :) = ekm ( ie , :, :) ekh ( ib - 1 , :, :) = ekh ( ib , :, :) ekh ( ie + 1 , :, :) = ekh ( ie , :, :) else ekm ( ib - 1 , :, :) = ekm ( ie , :, :) ! periodic ekm ( ie + 1 , :, :) = ekm ( ib , :, :) ekh ( ib - 1 , :, :) = ekh ( ie , :, :) ekh ( ie + 1 , :, :) = ekh ( ib , :, :) end if call excjs ( ekm , ib , ie , jb , je , kb - kh , ke + kh , ih , jh ) call excjs ( ekh , ib , ie , jb , je , kb - kh , ke + kh , ih , jh ) end subroutine closurebc","tags":"","loc":"proc/closurebc.html"},{"title":"iosi – uDALES","text":"private subroutine iosi() Uses modglobal modfields modinletdata proc~~iosi~~UsesGraph proc~iosi iosi module~modinletdata modinletdata proc~iosi->module~modinletdata module~modfields modfields proc~iosi->module~modfields module~modglobal modglobal proc~iosi->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~iosi~~CalledByGraph proc~iosi iosi proc~boundary boundary proc~boundary->proc~iosi proc~readinitfiles readinitfiles proc~readinitfiles->proc~boundary program~dalesurban DALESURBAN program~dalesurban->proc~boundary proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code iosi Source Code subroutine iosi use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , nsv , dt , rk3step , dxhi , ltempeq , & ihc , jhc , khc , dy use modfields , only : sv0 , svm , svprof , uouttot use modinletdata , only : ubulk real rk3coef integer k , n , m rk3coef = dt / ( 4. - dble ( rk3step )) do n = 1 , nsv do k = kb , ke + 1 sv0 ( ib - 1 , :, k , n ) = 2 * svprof ( k , n ) - sv0 ( ib , :, k , n ) svm ( ib - 1 , :, k , n ) = 2 * svprof ( k , n ) - svm ( ib , :, k , n ) end do sv0 ( ie + 1 , :, :, n ) = sv0 ( ie , :, :, n ) - ( sv0 ( ie + 1 , :, :, n ) - sv0 ( ie , :, :, n )) * dxhi ( ie + 1 ) * rk3coef * uouttot ! tg3315 should be uouttot and will have to change depending on forcing svm ( ie + 1 , :, :, n ) = svm ( ie , :, :, n ) - ( svm ( ie + 1 , :, :, n ) - svm ( ie , :, :, n )) * dxhi ( ie + 1 ) * rk3coef * uouttot enddo return end subroutine iosi","tags":"","loc":"proc/iosi.html"},{"title":"scalrec – uDALES","text":"private subroutine scalrec() Uses modglobal modfields modinletdata proc~~scalrec~~UsesGraph proc~scalrec scalrec module~modinletdata modinletdata proc~scalrec->module~modinletdata module~modfields modfields proc~scalrec->module~modfields module~modglobal modglobal proc~scalrec->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~scalrec~~CalledByGraph proc~scalrec scalrec proc~boundary boundary proc~boundary->proc~scalrec proc~readinitfiles readinitfiles proc~readinitfiles->proc~boundary program~dalesurban DALESURBAN program~dalesurban->proc~boundary proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code scalrec Source Code subroutine scalrec use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , nsv , dt , rk3step , dxhi , ltempeq , & ihc , jhc , khc , dy use modfields , only : sv0 , svm , svprof , uouttot , um , u0 , vm , v0 use modinletdata , only : ubulk real rk3coef integer k , n , m ! recycling method for scalar fields following Matheou and Bowman (2015) if ( nsv > 0 ) then rk3coef = dt / ( 4. - dble ( rk3step )) do m = 1 , ihc ! loop over virtual cells do n = 1 , nsv - 1 sv0 ( ib - m , :, :, n + 1 ) = sv0 ( ie + 1 - m , :, :, n ) sv0 ( ie + m , :, :, n ) = sv0 ( ib - 1 + m , :, :, n + 1 ) svm ( ib - m , :, :, n + 1 ) = svm ( ie + 1 - m , :, :, n ) svm ( ie + m , :, :, n ) = svm ( ib - 1 + m , :, :, n + 1 ) end do ! zero conc. on scalar 1 !tg3315 should be changed to as above in sv0 ( ib - m , :, :, 1 ) = 0. svm ( ib - m , :, :, 1 ) = 0. ! DIY outflow BC (advection step as linout) tg3315 sv0 ( ie + m ,:,:, nsv ) = sv0 ( ie + 1 - m ,:,:, nsv ) - ( sv0 ( ie + m ,:,:, nsv ) - sv0 ( ie + 1 - m ,:,:, nsv )) * dxhi ( ie + m ) * rk3coef * uouttot svm ( ie + m ,:,:, nsv ) = svm ( ie + 1 - m ,:,:, nsv ) - ( svm ( ie + m ,:,:, nsv ) - svm ( ie + 1 - m ,:,:, nsv )) * dxhi ( ie + m ) * rk3coef * uouttot end do end if return end subroutine scalrec","tags":"","loc":"proc/scalrec.html"},{"title":"scalSIRANE – uDALES","text":"private subroutine scalSIRANE() Uses modglobal modfields modinletdata modmpi proc~~scalsirane~~UsesGraph proc~scalsirane scalSIRANE module~modmpi modmpi proc~scalsirane->module~modmpi module~modinletdata modinletdata proc~scalsirane->module~modinletdata module~modfields modfields proc~scalsirane->module~modfields module~modglobal modglobal proc~scalsirane->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~scalsirane~~CalledByGraph proc~scalsirane scalSIRANE proc~boundary boundary proc~boundary->proc~scalsirane proc~readinitfiles readinitfiles proc~readinitfiles->proc~boundary program~dalesurban DALESURBAN program~dalesurban->proc~boundary proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code scalSIRANE Source Code subroutine scalSIRANE use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , nsv , dt , lscalrec , lmoistinout , ltempinout , rk3step , dxhi , ltempeq ,& ihc , jhc , khc , lSIRANEinout , dy use modfields , only : sv0 , svm , svprof use modinletdata , only : ubulk use modmpi , only : myid , nprocs real rk3coef integer k , n , m if ( nsv > 0 ) then !rk3coef = dt / (4. - dble(rk3step)) do n = 1 , nsv do m = 1 , ihc do k = kb , ke + 1 sv0 ( ib - m , :, k , n ) = 2 * svprof ( k , n ) - sv0 ( ib - m + 1 , :, k , n ) !scalars have two ghost cells...??? svm ( ib - m , :, k , n ) = 2 * svprof ( k , n ) - svm ( ib - m + 1 , :, k , n ) end do !              sv0(ie+m,:,:,n)= sv0(ie+m-1,:,:,n) - (sv0(ie+m,:,:,n)-sv0(ie+m-1,:,:,n))*dxhi(ie+m)*rk3coef*ubulk !              svm(ie+m,:,:,n)= svm(ie+m-1,:,:,n) - (svm(ie+m,:,:,n)-svm(ie+m-1,:,:,n))*dxhi(ie+m)*rk3coef*ubulk !changed from uouttot to ubulk here !tg3315 08/11/2017 !              sv0(ie+m,:,:,n)= sv0(ie+m-1,:,:,n) - (sv0(ie+m,:,:,n)-sv0(ie+m-1,:,:,n))*dxhi(ie+m)*rk3coef*u0(ie+m,:,:) !              svm(ie+m,:,:,n)= svm(ie+m-1,:,:,n) - (svm(ie+m,:,:,n)-svm(ie+m-1,:,:,n))*dxhi(ie+m)*rk3coef*um(ie+m,:,:) !changed from uouttot to ubulk here !tg3315 08/11/2017 svm ( ie + m , :, :, n ) = svm ( ie + m - 1 , :, :, n ) sv0 ( ie + m , :, :, n ) = sv0 ( ie + m - 1 , :, :, n ) end do !m, ihc end do !n, nsv do m = 1 , jhc do n = 1 , nsv if ( myid == 0 ) then do k = kb , ke + 1 sv0 (:, jb - m , k , n ) = 2 * svprof ( k , n ) - sv0 (:, jb - m + 1 , k , n ) svm (:, jb - m , k , n ) = 2 * svprof ( k , n ) - svm (:, jb - m + 1 , k , n ) end do end if if ( myid == nprocs - 1 ) then !sv0(:,je+m,:,n)= sv0(:,je+m-1,:,n) - (sv0(:,je+m,:,n)-sv0(:,je+m-1,:,n))*dy*rk3coef*ubulk !svm(:,je+m,:,n)= svm(:,je+m-1,:,n) - (svm(:,je+m,:,n)-svm(:,je+m-1,:,n))*dy*rk3coef*ubulk !changed from uouttot to ubulk here !tg3315 08/11/2017 !      sv0(:,je+m,:,n)= sv0(:,je+m-1,:,n) - (sv0(:,je+m,:,n)-sv0(:,je+m-1,:,n))*dy*rk3coef*v0(:,je+m,:) !      svm(:,je+m,:,n)= svm(:,je+m-1,:,n) - (svm(:,je+m,:,n)-svm(:,je+m-1,:,n))*dy*rk3coef*vm(:,je+m,:) !changed from uouttot to ubulk here !tg3315 08/11/2017 svm (:, je + m , :, n ) = svm (:, je + m - 1 , :, n ) sv0 (:, je + m , :, n ) = sv0 (:, je + m - 1 , :, n ) end if end do !n, nsv end do !m, jhc end if !nsv>0 return end subroutine scalSIRANE","tags":"","loc":"proc/scalsirane.html"},{"title":"cyclichi – uDALES","text":"private subroutine cyclichi() Uses modglobal modfields proc~~cyclichi~~UsesGraph proc~cyclichi cyclichi module~modfields modfields proc~cyclichi->module~modfields module~modglobal modglobal proc~cyclichi->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~cyclichi~~CalledByGraph proc~cyclichi cyclichi proc~boundary boundary proc~boundary->proc~cyclichi proc~readinitfiles readinitfiles proc~readinitfiles->proc~boundary program~dalesurban DALESURBAN program~dalesurban->proc~boundary proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code cyclichi Source Code subroutine cyclichi use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , nsv , dt , rk3step , dxhi , ihc , jhc , khc , dy use modfields , only : thl0 , thlm integer m do m = 1 , ih thl0 ( ib - m , :, :) = thl0 ( ie + 1 - m , :, :) thl0 ( ie + m , :, :) = thl0 ( ib - 1 + m , :, :) thlm ( ib - m , :, :) = thlm ( ie + 1 - m , :, :) thlm ( ie + m , :, :) = thlm ( ib - 1 + m , :, :) end do return end subroutine cyclichi","tags":"","loc":"proc/cyclichi.html"},{"title":"cyclicqi – uDALES","text":"private subroutine cyclicqi() Uses modglobal modfields proc~~cyclicqi~~UsesGraph proc~cyclicqi cyclicqi module~modfields modfields proc~cyclicqi->module~modfields module~modglobal modglobal proc~cyclicqi->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~cyclicqi~~CalledByGraph proc~cyclicqi cyclicqi proc~boundary boundary proc~boundary->proc~cyclicqi proc~readinitfiles readinitfiles proc~readinitfiles->proc~boundary program~dalesurban DALESURBAN program~dalesurban->proc~boundary proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code cyclicqi Source Code subroutine cyclicqi use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , nsv , dt , rk3step , dxhi , ihc , jhc , khc , dy use modfields , only : qt0 , qtm integer m do m = 1 , ih qt0 ( ib - m , :, :) = qt0 ( ie + 1 - m , :, :) qt0 ( ie + m , :, :) = qt0 ( ib - 1 + m , :, :) qtm ( ib - m , :, :) = qtm ( ie + 1 - m , :, :) qtm ( ie + m , :, :) = qtm ( ib - 1 + m , :, :) end do return end subroutine cyclicqi","tags":"","loc":"proc/cyclicqi.html"},{"title":"cyclicsi – uDALES","text":"private subroutine cyclicsi() Uses modglobal modfields proc~~cyclicsi~~UsesGraph proc~cyclicsi cyclicsi module~modfields modfields proc~cyclicsi->module~modfields module~modglobal modglobal proc~cyclicsi->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~cyclicsi~~CalledByGraph proc~cyclicsi cyclicsi proc~boundary boundary proc~boundary->proc~cyclicsi proc~readinitfiles readinitfiles proc~readinitfiles->proc~boundary program~dalesurban DALESURBAN program~dalesurban->proc~boundary proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code cyclicsi Source Code subroutine cyclicsi use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , nsv , dt , rk3step , dxhi , ihc , jhc , khc , dy use modfields , only : sv0 , svm integer m do m = 1 , ihc sv0 ( ib - m , :, :, :) = sv0 ( ie + 1 - m , :, :, :) sv0 ( ie + m , :, :, :) = sv0 ( ib - 1 + m , :, :, :) svm ( ib - m , :, :, :) = svm ( ie + 1 - m , :, :, :) svm ( ie + m , :, :, :) = svm ( ib - 1 + m , :, :, :) end do return end subroutine cyclicsi","tags":"","loc":"proc/cyclicsi.html"},{"title":"ioqi – uDALES","text":"private subroutine ioqi() Uses modglobal modfields modinletdata proc~~ioqi~~UsesGraph proc~ioqi ioqi module~modinletdata modinletdata proc~ioqi->module~modinletdata module~modfields modfields proc~ioqi->module~modfields module~modglobal modglobal proc~ioqi->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~ioqi~~CalledByGraph proc~ioqi ioqi proc~boundary boundary proc~boundary->proc~ioqi proc~readinitfiles readinitfiles proc~readinitfiles->proc~boundary program~dalesurban DALESURBAN program~dalesurban->proc~boundary proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ioqi Source Code subroutine ioqi use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , dxhi , rk3step , dt use modfields , only : qt0 , qtm , qtprof , uouttot use modinletdata , only : ubulk integer k , j real rk3coef rk3coef = dt / ( 4. - dble ( rk3step )) do k = kb , ke do j = jb , je qt0 ( ib - 1 , j , k ) = 2 * qtprof ( k ) - qt0 ( ib , j , k ) !watch! qtm ( ib - 1 , j , k ) = 2 * qtprof ( k ) - qtm ( ib , j , k ) end do end do !uouttot is zero unless lmassflowr qt0 ( ie + 1 , :, :) = qt0 ( ie , :, :) - ( qt0 ( ie + 1 , :, :) - qt0 ( ie , :, :)) * dxhi ( ie + 1 ) * rk3coef * uouttot ! tg3315 should be uouttot and will have to change depending on forcing qtm ( ie + 1 , :, :) = qtm ( ie , :, :) - ( qtm ( ie + 1 , :, :) - qtm ( ie , :, :)) * dxhi ( ie + 1 ) * rk3coef * uouttot end subroutine ioqi","tags":"","loc":"proc/ioqi.html"},{"title":"iohi – uDALES","text":"private subroutine iohi() Uses modglobal modfields modinletdata proc~~iohi~~UsesGraph proc~iohi iohi module~modinletdata modinletdata proc~iohi->module~modinletdata module~modfields modfields proc~iohi->module~modfields module~modglobal modglobal proc~iohi->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~iohi~~CalledByGraph proc~iohi iohi proc~boundary boundary proc~boundary->proc~iohi proc~readinitfiles readinitfiles proc~readinitfiles->proc~boundary program~dalesurban DALESURBAN program~dalesurban->proc~boundary proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code iohi Source Code subroutine iohi use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , dxhi , rk3step , dt use modfields , only : thl0 , thlm , thlprof , uouttot use modinletdata , only : ubulk integer k , j real rk3coef rk3coef = dt / ( 4. - dble ( rk3step )) do k = kb , ke do j = jb , je thl0 ( ib - 1 , j , k ) = 2 * thlprof ( k ) - thl0 ( ib , j , k ) !watch! thlm ( ib - 1 , j , k ) = 2 * thlprof ( k ) - thlm ( ib , j , k ) end do end do thl0 ( ie + 1 , :, :) = thl0 ( ie , :, :) - ( thl0 ( ie + 1 , :, :) - thl0 ( ie , :, :)) * dxhi ( ie + 1 ) * rk3coef * uouttot ! tg3315 should be uouttot and will have to change depending on forcing thlm ( ie + 1 , :, :) = thlm ( ie , :, :) - ( thlm ( ie + 1 , :, :) - thlm ( ie , :, :)) * dxhi ( ie + 1 ) * rk3coef * uouttot end subroutine iohi","tags":"","loc":"proc/iohi.html"},{"title":"cyclichj – uDALES","text":"private subroutine cyclichj() Uses modglobal modfields modmpi proc~~cyclichj~~UsesGraph proc~cyclichj cyclichj module~modmpi modmpi proc~cyclichj->module~modmpi module~modfields modfields proc~cyclichj->module~modfields module~modglobal modglobal proc~cyclichj->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~cyclichj~~CallsGraph proc~cyclichj cyclichj proc~excjs excjs proc~cyclichj->proc~excjs mpi_sendrecv mpi_sendrecv proc~excjs->mpi_sendrecv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~cyclichj~~CalledByGraph proc~cyclichj cyclichj proc~boundary boundary proc~boundary->proc~cyclichj proc~readinitfiles readinitfiles proc~readinitfiles->proc~boundary program~dalesurban DALESURBAN program~dalesurban->proc~boundary proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code cyclichj Source Code subroutine cyclichj use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , nsv , dt , rk3step , dxhi , ihc , jhc , khc , dy use modfields , only : thl0 , thlm use modmpi , only : excjs , myid , nprocs call excjs ( thl0 , ib , ie , jb , je , kb , ke + kh , ih , jh ) call excjs ( thlm , ib , ie , jb , je , kb , ke + kh , ih , jh ) return end subroutine cyclichj","tags":"","loc":"proc/cyclichj.html"},{"title":"cyclicqj – uDALES","text":"private subroutine cyclicqj() Uses modglobal modfields modmpi proc~~cyclicqj~~UsesGraph proc~cyclicqj cyclicqj module~modmpi modmpi proc~cyclicqj->module~modmpi module~modfields modfields proc~cyclicqj->module~modfields module~modglobal modglobal proc~cyclicqj->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~cyclicqj~~CallsGraph proc~cyclicqj cyclicqj proc~excjs excjs proc~cyclicqj->proc~excjs mpi_sendrecv mpi_sendrecv proc~excjs->mpi_sendrecv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~cyclicqj~~CalledByGraph proc~cyclicqj cyclicqj proc~boundary boundary proc~boundary->proc~cyclicqj proc~readinitfiles readinitfiles proc~readinitfiles->proc~boundary program~dalesurban DALESURBAN program~dalesurban->proc~boundary proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code cyclicqj Source Code subroutine cyclicqj use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , nsv , dt , rk3step , dxhi , ihc , jhc , khc , dy use modfields , only : qt0 , qtm use modmpi , only : excjs , myid , nprocs call excjs ( qt0 , ib , ie , jb , je , kb , ke + kh , ih , jh ) call excjs ( qtm , ib , ie , jb , je , kb , ke + kh , ih , jh ) return end subroutine cyclicqj","tags":"","loc":"proc/cyclicqj.html"},{"title":"cyclicsj – uDALES","text":"private subroutine cyclicsj() Uses modglobal modfields modmpi proc~~cyclicsj~~UsesGraph proc~cyclicsj cyclicsj module~modmpi modmpi proc~cyclicsj->module~modmpi module~modfields modfields proc~cyclicsj->module~modfields module~modglobal modglobal proc~cyclicsj->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~cyclicsj~~CalledByGraph proc~cyclicsj cyclicsj proc~boundary boundary proc~boundary->proc~cyclicsj proc~readinitfiles readinitfiles proc~readinitfiles->proc~boundary program~dalesurban DALESURBAN program~dalesurban->proc~boundary proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code cyclicsj Source Code subroutine cyclicsj use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , nsv , dt , rk3step , dxhi , ihc , jhc , khc , dy use modfields , only : sv0 , svm use modmpi , only : excjs , myid , nprocs integer n do n = 1 , nsv call excjs ( sv0 (:, :, :, n ), ib , ie , jb , je , kb - khc , ke + khc , ihc , jhc ) call excjs ( svm (:, :, :, n ), ib , ie , jb , je , kb - khc , ke + khc , ihc , jhc ) enddo return end subroutine cyclicsj","tags":"","loc":"proc/cyclicsj.html"},{"title":"cyclicmi – uDALES","text":"private subroutine cyclicmi() Uses modglobal modfields modsubgriddata proc~~cyclicmi~~UsesGraph proc~cyclicmi cyclicmi module~modfields modfields proc~cyclicmi->module~modfields module~modsubgriddata modsubgriddata proc~cyclicmi->module~modsubgriddata module~modglobal modglobal proc~cyclicmi->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~cyclicmi~~CalledByGraph proc~cyclicmi cyclicmi proc~boundary boundary proc~boundary->proc~cyclicmi proc~readinitfiles readinitfiles proc~readinitfiles->proc~boundary program~dalesurban DALESURBAN program~dalesurban->proc~boundary proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code cyclicmi Source Code subroutine cyclicmi use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , jmax use modfields , only : u0 , um , v0 , vm , w0 , wm , e120 , e12m use modsubgriddata , only : loneeqn , lsmagorinsky integer n , m do m = 1 , ih u0 ( ib - m , :, :) = u0 ( ie + 1 - m , :, :) u0 ( ie + m , :, :) = u0 ( ib - 1 + m , :, :) v0 ( ib - m , :, :) = v0 ( ie + 1 - m , :, :) v0 ( ie + m , :, :) = v0 ( ib - 1 + m , :, :) w0 ( ib - m , :, :) = w0 ( ie + 1 - m , :, :) w0 ( ie + m , :, :) = w0 ( ib - 1 + m , :, :) um ( ib - m , :, :) = um ( ie + 1 - m , :, :) um ( ie + m , :, :) = um ( ib - 1 + m , :, :) vm ( ib - m , :, :) = vm ( ie + 1 - m , :, :) vm ( ie + m , :, :) = vm ( ib - 1 + m , :, :) wm ( ib - m , :, :) = wm ( ie + 1 - m , :, :) wm ( ie + m , :, :) = wm ( ib - 1 + m , :, :) e120 ( ib - m , :, :) = e120 ( ie + 1 - m , :, :) e120 ( ie + m , :, :) = e120 ( ib - 1 + m , :, :) e12m ( ib - m , :, :) = e12m ( ie + 1 - m , :, :) e12m ( ie + m , :, :) = e12m ( ib - 1 + m , :, :) end do if ( loneeqn ) then e120 ( ib - m , :, :) = e120 ( ie + 1 - m , :, :) e120 ( ie + m , :, :) = e120 ( ib - 1 + m , :, :) e12m ( ib - m , :, :) = e12m ( ie + 1 - m , :, :) e12m ( ie + m , :, :) = e12m ( ib - 1 + m , :, :) end if return end subroutine cyclicmi","tags":"","loc":"proc/cyclicmi.html"},{"title":"cyclicmj – uDALES","text":"private subroutine cyclicmj() Uses modglobal modfields modsubgriddata modmpi proc~~cyclicmj~~UsesGraph proc~cyclicmj cyclicmj module~modmpi modmpi proc~cyclicmj->module~modmpi module~modfields modfields proc~cyclicmj->module~modfields module~modsubgriddata modsubgriddata proc~cyclicmj->module~modsubgriddata module~modglobal modglobal proc~cyclicmj->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~cyclicmj~~CallsGraph proc~cyclicmj cyclicmj proc~excjs excjs proc~cyclicmj->proc~excjs mpi_sendrecv mpi_sendrecv proc~excjs->mpi_sendrecv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~cyclicmj~~CalledByGraph proc~cyclicmj cyclicmj proc~boundary boundary proc~boundary->proc~cyclicmj proc~readinitfiles readinitfiles proc~readinitfiles->proc~boundary program~dalesurban DALESURBAN program~dalesurban->proc~boundary proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code cyclicmj Source Code subroutine cyclicmj use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , jmax use modfields , only : u0 , um , v0 , vm , w0 , wm , e120 , e12m , shear use modsubgriddata , only : loneeqn , lsmagorinsky use modmpi , only : excjs integer n , m call excjs ( u0 , ib , ie , jb , je , kb , ke + kh , ih , jh ) call excjs ( v0 , ib , ie , jb , je , kb , ke + kh , ih , jh ) call excjs ( w0 , ib , ie , jb , je , kb , ke + kh , ih , jh ) call excjs ( um , ib , ie , jb , je , kb , ke + kh , ih , jh ) call excjs ( vm , ib , ie , jb , je , kb , ke + kh , ih , jh ) call excjs ( wm , ib , ie , jb , je , kb , ke + kh , ih , jh ) if ( loneeqn ) then call excjs ( e120 , ib , ie , jb , je , kb , ke + kh , ih , jh ) call excjs ( e12m , ib , ie , jb , je , kb , ke + kh , ih , jh ) ! exchange shear components between processors do n = 1 , 12 ! for all 12 components call excjs ( shear (:, :, :, n ), ib , ie , jb , je , kb , ke , 0 , 1 ) end do end if if ( lsmagorinsky ) then ! exchange shear components between processors do n = 1 , 12 ! for all 12 components call excjs ( shear (:, :, :, n ), ib , ie , jb , je , kb , ke , 0 , 1 ) end do end if return end subroutine cyclicmj","tags":"","loc":"proc/cyclicmj.html"},{"title":"iolet – uDALES","text":"private subroutine iolet() Uses modglobal modfields modmpi modinletdata proc~~iolet~~UsesGraph proc~iolet iolet module~modmpi modmpi proc~iolet->module~modmpi module~modinletdata modinletdata proc~iolet->module~modinletdata module~modfields modfields proc~iolet->module~modfields module~modglobal modglobal proc~iolet->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~iolet~~CallsGraph proc~iolet iolet proc~slabsum slabsum proc~iolet->proc~slabsum mpi_allreduce mpi_allreduce proc~slabsum->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~iolet~~CalledByGraph proc~iolet iolet proc~boundary boundary proc~boundary->proc~iolet proc~readinitfiles readinitfiles proc~readinitfiles->proc~boundary program~dalesurban DALESURBAN program~dalesurban->proc~boundary proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code iolet Source Code subroutine iolet use modglobal , only : dxhi , dxhci , xh , zh , ib , ie , jb , je , ih , jh , kb , ke , kh , nsv , rk3step , dt , iinletgen , ltempeq , lmoist , ihc , idriver , dy , dzf , jtot , zh use modfields , only : u0 , um , v0 , vm , w0 , wm , e120 , e12m , thl0 , thlm , qt0 , qtm , sv0 , svm , uprof , vprof , e12prof , thlprof , & qtprof , svprof , uouttot , wouttot use modmpi , only : excjs , myid , slabsum use modinletdata , only : u0inletbcold , v0inletbcold , w0inletbcold , uminletbc , vminletbc , wminletbc , totaluold , & t0inletbcold , tminletbc , u0driver , v0driver , w0driver , e120driver , thl0driver , qt0driver , umdriver , vmdriver , wmdriver ,& e12mdriver , thlmdriver , qtmdriver , sv0driver , svmdriver real rk3coef real , dimension ( kb : ke ) :: uin integer n , i , j , k , m rk3coef = dt / ( 4. - dble ( rk3step )) ! Inlet boundary is located at ib (not ib-1)! ! Inlet if (( iinletgen == 1 ) . or . ( iinletgen == 2 )) then do j = jb , je do k = kb , ke u0 ( ib , j , k ) = u0inletbcold ( j , k ) um ( ib , j , k ) = uminletbc ( j , k ) u0 ( ib - 1 , j , k ) = 2 * u0 ( ib , j , k ) - u0 ( ib + 1 , j , k ) um ( ib - 1 , j , k ) = 2 * um ( ib , j , k ) - um ( ib + 1 , j , k ) v0 ( ib - 1 , j , k ) = v0inletbcold ( j , k ) vm ( ib - 1 , j , k ) = vminletbc ( j , k ) ! to be changed in the future: e12 should be taken from recycle plane! e120 ( ib - 1 , j , k ) = e120 ( ib , j , k ) ! extrapolate e12 from interior e12m ( ib - 1 , j , k ) = e12m ( ib , j , k ) ! extrapolate e12 from interior do n = 1 , nsv do m = 1 , ihc sv0 ( ib - m , j , k , n ) = 2 * svprof ( k , n ) - sv0 ( ib + ( m - 1 ), j , k , n ) svm ( ib - m , j , k , n ) = 2 * svprof ( k , n ) - svm ( ib + ( m - 1 ), j , k , n ) enddo enddo end do do k = kb , ke + 1 w0 ( ib - 1 , j , k ) = w0inletbcold ( j , k ) wm ( ib - 1 , j , k ) = wminletbc ( j , k ) end do end do ! Heat if ( ltempeq ) then do k = kb , ke do j = jb , je thl0 ( ib - 1 , j , k ) = t0inletbcold ( j , k ) thlm ( ib - 1 , j , k ) = tminletbc ( j , k ) end do end do end if if ( lmoist ) then do k = kb , ke do j = jb , je qt0 ( ib - 1 , j , k ) = 2 * qtprof ( k ) - qt0 ( ib , j , k ) !watch! qtm ( ib - 1 , j , k ) = 2 * qtprof ( k ) - qtm ( ib , j , k ) end do end do end if ! Driver inlet elseif ( idriver == 2 ) then do j = jb - 1 , je + 1 do k = kb , ke !tg3315 removed +1 following above... u0 ( ib , j , k ) = u0driver ( j , k ) !max(0.,u0driver(j,k)) um ( ib , j , k ) = umdriver ( j , k ) !max(0.,umdriver(j,k)) u0 ( ib - 1 , j , k ) = u0driver ( j , k ) !max(0.,2.*u0(ib,j,k)-u0(ib+1,j,k)) um ( ib - 1 , j , k ) = umdriver ( j , k ) !max(0.,2.*um(ib,j,k)-um(ib+1,j,k)) v0 ( ib , j , k ) = v0driver ( j , k ) !max(0.,v0driver(j,k)) vm ( ib , j , k ) = vmdriver ( j , k ) !max(0.,vmdriver(j,k)) v0 ( ib - 1 , j , k ) = v0driver ( j , k ) !max(0.,v0driver(j,k)) vm ( ib - 1 , j , k ) = vmdriver ( j , k ) !max(0.,vmdriver(j,k)) ! to be changed in the future: e12 should be taken from recycle plane! !e120(ib-1,j,k) = e120driver(j,k)      ! extrapolate e12 from interior !e12m(ib-1,j,k) = e12mdriver(j,k)      ! extrapolate e12 from interior do n = 1 , nsv do m = 1 , ihc sv0 ( ib - m , j , k , n ) = sv0driver ( j , k , n ) svm ( ib - m , j , k , n ) = svmdriver ( j , k , n ) !sv0(ib-m,j,k,n) = 2*svprof(k,n) - sv0(ib+(m-1),j,k,n) !svm(ib-m,j,k,n) = 2*svprof(k,n) - svm(ib+(m-1),j,k,n) enddo sv0 ( ib , j , k , n ) = sv0driver ( j , k , n ) svm ( ib , j , k , n ) = svmdriver ( j , k , n ) enddo end do do k = kb , ke + 1 w0 ( ib - 1 , j , k ) = w0driver ( j , k ) !max(0.,w0driver(j,k)) wm ( ib - 1 , j , k ) = wmdriver ( j , k ) !max(0.,wmdriver(j,k)) w0 ( ib , j , k ) = w0driver ( j , k ) !max(0.,w0driver(j,k)) wm ( ib , j , k ) = wmdriver ( j , k ) !max(0.,wmdriver(j,k)) end do end do ! Heat if ( ltempeq ) then do j = jb - 1 , je + 1 do k = kb , ke + 1 thl0 ( ib , j , k ) = thl0driver ( j , k ) thlm ( ib , j , k ) = thlmdriver ( j , k ) thl0 ( ib - 1 , j , k ) = thl0driver ( j , k ) thlm ( ib - 1 , j , k ) = thlmdriver ( j , k ) !thlm(ib-1,j,k) = 2*thlm(ib,j,k) - thlm(ib+1,j,k) !thl0(ib-1,j,k) = 2*thl0(ib,j,k) - thl0(ib+1,j,k) end do end do end if if ( lmoist ) then do j = jb - 1 , je + 1 do k = kb , ke + 1 qt0 ( ib , j , k ) = qt0driver ( j , k ) ! qt0(ib-1,j,k) = 2*qtprof(k) - qt0(ib,j,k) qtm ( ib , j , k ) = qtmdriver ( j , k ) ! qtm(ib-1,j,k) = 2*qtprof(k) - qtm(ib,j,k) qt0 ( ib - 1 , j , k ) = qt0driver ( j , k ) ! qt0(ib-1,j,k) = 2*qtprof(k) - qt0(ib,j,k)  !watch! qtm ( ib - 1 , j , k ) = qtmdriver ( j , k ) ! qtm(ib-1,j,k) = 2*qtprof(k) - qtm(ib,j,k) ! qt0(ib-1,j,k) = 2*qt0(ib,j,k) - qt0(ib+1,j,k) ! qtm(ib-1,j,k) = 2*qtm(ib,j,k) - qtm(ib+1,j,k) end do end do end if else ! (if iinetgen==0) do j = jb - 1 , je + 1 do k = kb , ke + 1 ! Momentum u0 ( ib , j , k ) = uprof ( k ) um ( ib , j , k ) = uprof ( k ) v0 ( ib - 1 , j , k ) = 2 * vprof ( k ) - v0 ( ib , j , k ) ! (v(ib)+v(ib-1))/2 = vprof vm ( ib - 1 , j , k ) = 2 * vprof ( k ) - vm ( ib , j , k ) ! (v(ib)+v(ib-1))/2 = vprof e120 ( ib - 1 , j , k ) = 2 * e12prof ( k ) - e120 ( ib , j , k ) ! (e12(ib)+e12(ib-1))/2=e12prof e12m ( ib - 1 , j , k ) = 2 * e12prof ( k ) - e12m ( ib , j , k ) ! (e12(ib)+e12(ib-1))/2=e12prof do n = 1 , nsv do m = 1 , ihc sv0 ( ib - m , j , k , n ) = 2 * svprof ( k , n ) - sv0 ( ib + ( m - 1 ), j , k , n ) svm ( ib - m , j , k , n ) = 2 * svprof ( k , n ) - svm ( ib + ( m - 1 ), j , k , n ) end do end do !end if enddo enddo ! Heat if ( ltempeq ) then do j = jb - 1 , je + 1 do k = kb , ke + 1 thl0 ( ib - 1 , j , k ) = 2 * thlprof ( k ) - thl0 ( ib , j , k ) thlm ( ib - 1 , j , k ) = 2 * thlprof ( k ) - thlm ( ib , j , k ) end do end do end if if ( lmoist ) then do j = jb - 1 , je + 1 do k = kb , ke + 1 qt0 ( ib - 1 , j , k ) = 2 * qtprof ( k ) - qt0 ( ib , j , k ) qtm ( ib - 1 , j , k ) = 2 * qtprof ( k ) - qtm ( ib , j , k ) end do end do end if u0 ( ib - 1 , :, :) = 2 * u0 ( ib , :, :) - u0 ( ib + 1 , :, :) ! (u(ib+1)+u(ib-1))/2 = u(ib) um ( ib - 1 , :, :) = 2 * um ( ib , :, :) - um ( ib + 1 , :, :) ! (u(ib+1)+u(ib-1))/2 = u(ib) w0 ( ib - 1 , :, :) = - w0 ( ib , :, :) ! (w(ib)+w(ib-1))/2 = 0 wm ( ib - 1 , :, :) = - wm ( ib , :, :) end if ! iinletgen==1 .or. iinletgen==2 ! tg3315 added to ensure that uouttot matches driven inflow regardless of forcing ! set up assuming we have a block at lowest cell kb if ( idriver == 2 ) then uin = 0. uouttot = 0. call slabsum ( uin , kb , ke , um , ib - ih , ie + ih , jb - jh , je + jh , kb - kh , ke + kh , ie , ie , jb , je , kb , ke ) ! determine horizontal (j) average outflow velocity old do k = kb , ke uin ( k ) = uin ( k ) * dzf ( k ) * dy ! flow rate through each slab at ib end do uouttot = sum ( uin ( kb + 1 : ke )) / (( zh ( ke + 1 ) - zh ( kb + 1 )) * jtot * dy ) ! convective outflow velocity end if ! Outlet ! Momentum v0 ( ie + 1 , :, :) = v0 ( ie , :, :) - ( v0 ( ie + 1 , :, :) - v0 ( ie , :, :)) * dxhi ( ie + 1 ) * rk3coef * uouttot w0 ( ie + 1 , :, :) = w0 ( ie , :, :) - ( w0 ( ie + 1 , :, :) - w0 ( ie , :, :)) * dxhi ( ie + 1 ) * rk3coef * uouttot vm ( ie + 1 , :, :) = vm ( ie , :, :) - ( vm ( ie + 1 , :, :) - vm ( ie , :, :)) * dxhi ( ie + 1 ) * rk3coef * uouttot wm ( ie + 1 , :, :) = wm ( ie , :, :) - ( wm ( ie + 1 , :, :) - wm ( ie , :, :)) * dxhi ( ie + 1 ) * rk3coef * uouttot e120 ( ie + 1 , :, :) = e120 ( ie , :, :) - ( e120 ( ie + 1 , :, :) - e120 ( ie , :, :)) * dxhi ( ie + 1 ) * rk3coef * uouttot e12m ( ie + 1 , :, :) = e12m ( ie , :, :) - ( e12m ( ie + 1 , :, :) - e12m ( ie , :, :)) * dxhi ( ie + 1 ) * rk3coef * uouttot ! Heat if ( ltempeq ) then thl0 ( ie + 1 , :, :) = thl0 ( ie , :, :) - ( thl0 ( ie + 1 , :, :) - thl0 ( ie , :, :)) * dxhi ( ie + 1 ) * rk3coef * uouttot thlm ( ie + 1 , :, :) = thlm ( ie , :, :) - ( thlm ( ie + 1 , :, :) - thlm ( ie , :, :)) * dxhi ( ie + 1 ) * rk3coef * uouttot end if if ( lmoist ) then qt0 ( ie + 1 , :, :) = qt0 ( ie , :, :) - ( qt0 ( ie + 1 , :, :) - qt0 ( ie , :, :)) * dxhi ( ie + 1 ) * rk3coef * uouttot qtm ( ie + 1 , :, :) = qtm ( ie , :, :) - ( qtm ( ie + 1 , :, :) - qtm ( ie , :, :)) * dxhi ( ie + 1 ) * rk3coef * uouttot end if ! tg3315 !changed dxhi to dxhci!? do n = 1 , nsv sv0 ( ie + 1 , :, :, n ) = sv0 ( ie , :, :, n ) - ( sv0 ( ie + 1 , :, :, n ) - sv0 ( ie , :, :, n )) * dxhci ( ie + 1 ) * rk3coef * uouttot svm ( ie + 1 , :, :, n ) = svm ( ie , :, :, n ) - ( svm ( ie + 1 , :, :, n ) - svm ( ie , :, :, n )) * dxhci ( ie + 1 ) * rk3coef * uouttot end do return end subroutine iolet","tags":"","loc":"proc/iolet.html"},{"title":"bcpup – uDALES","text":"public subroutine bcpup(pup, pvp, pwp, rk3coef) Uses modglobal modfields modmpi modinletdata proc~~bcpup~~UsesGraph proc~bcpup bcpup module~modmpi modmpi proc~bcpup->module~modmpi module~modinletdata modinletdata proc~bcpup->module~modinletdata module~modfields modfields proc~bcpup->module~modfields module~modglobal modglobal proc~bcpup->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(ib - ih:ie + ih, jb - jh:je + jh, kb:ke + kh) :: pup real, intent(inout), dimension(ib - ih:ie + ih, jb - jh:je + jh, kb:ke + kh) :: pvp real, intent(inout), dimension(ib - ih:ie + ih, jb - jh:je + jh, kb:ke + kh) :: pwp real, intent(in) :: rk3coef Calls proc~~bcpup~~CallsGraph proc~bcpup bcpup proc~excjs excjs proc~bcpup->proc~excjs mpi_sendrecv mpi_sendrecv proc~excjs->mpi_sendrecv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~bcpup~~CalledByGraph proc~bcpup bcpup proc~fillps fillps proc~fillps->proc~bcpup proc~poisson poisson proc~poisson->proc~fillps program~dalesurban DALESURBAN program~dalesurban->proc~poisson Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code bcpup Source Code subroutine bcpup ( pup , pvp , pwp , rk3coef ) use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , linoutflow , dxfi , iinletgen , & Uinf , libm , jmax , idriver use modfields , only : pres0 , up , vp , wp , um , w0 , u0 , uouttot use modmpi , only : excjs , myid use modinletdata , only : irecy , u0inletbc , ddispdx , u0driver real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ), intent ( inout ) :: pup real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ), intent ( inout ) :: pvp real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ), intent ( inout ) :: pwp real , intent ( in ) :: rk3coef real rk3coefi integer i , j , k rk3coefi = 1. / rk3coef if ( linoutflow ) then if (( iinletgen == 1 ) . or . ( iinletgen == 2 )) then do j = jb , je do i = ib , ie pwp ( i , j , kb ) = 0. pwp ( i , j , ke + kh ) = ( Uinf * ddispdx ) * rk3coefi end do end do do k = kb , ke do j = jb , je pup ( ie + 1 , j , k ) = - ( u0 ( ie + 1 , j , k ) - u0 ( ie , j , k )) * dxfi ( ie ) * uouttot + um ( ie + 1 , j , k ) * rk3coefi ! du/dt +u*du/dx=0 -> pup(i)=um(i)/rk3coef -um(i)*(um(i)-um(i-1))/dxf(i-1) pup ( ib , j , k ) = u0inletbc ( j , k ) * rk3coefi end do end do elseif ( idriver == 2 ) then do j = jb , je do i = ib , ie pwp ( i , j , kb ) = 0. pwp ( i , j , ke + kh ) = 0. !(Uinf*ddispdx ) *rk3coefi ! tg3315 - idriver does not use Uinf ddisp etc. end do end do do k = kb , ke do j = jb , je pup ( ie + 1 , j , k ) = - ( u0 ( ie + 1 , j , k ) - u0 ( ie , j , k )) * dxfi ( ie ) * uouttot + um ( ie + 1 , j , k ) * rk3coefi ! du/dt +u*du/dx=0 -> pup(i)=um(i)/rk3coef -um(i)*(um(i)-um(i-1))/dxf(i-1) pup ( ib , j , k ) = u0driver ( j , k ) * rk3coefi end do end do else ! if not iinletgen do j = jb , je do i = ib , ie pwp ( i , j , kb ) = 0. pwp ( i , j , ke + kh ) = 0. end do end do do k = kb , ke do j = jb , je pup ( ie + 1 , j , k ) = - ( u0 ( ie + 1 , j , k ) - u0 ( ie , j , k )) * dxfi ( ie ) * uouttot + um ( ie + 1 , j , k ) * rk3coefi ! du/dt +u*du/dx=0 -> pup(i)=um(i)/rk3coef -um(i)*(um(i)-um(i-1))/dxf(i-1) pup ( ib , j , k ) = pup ( ib , j , k ) - up ( ib , j , k ) ! pup(ib)= up(ib) + um(ib)/rk3coef, where up should be zero! end do end do end if ! inletgen else ! if not linoutflow do j = jb , je do i = ib , ie pwp ( i , j , kb ) = 0. pwp ( i , j , ke + kh ) = 0. end do end do do k = kb , ke do j = jb , je pup ( ie + 1 , j , k ) = pup ( ib , j , k ) ! cyclic !pup(ib - 1, j, k) = pup(ie, j, k) ! tg3315 is this condition not needed? Was not here before but I think exists in Dales4.0 in modpois...!? end do end do endif call excjs ( pup , ib , ie , jb , je , kb , ke + kh , ih , jh ) ! cyclic call excjs ( pvp , ib , ie , jb , je , kb , ke + kh , ih , jh ) ! cyclic call excjs ( pwp , ib , ie , jb , je , kb , ke + kh , ih , jh ) ! cyclic end subroutine bcpup","tags":"","loc":"proc/bcpup.html"},{"title":"bcp – uDALES","text":"public subroutine bcp(p) Uses modglobal modfields modmpi proc~~bcp~~UsesGraph proc~bcp bcp module~modmpi modmpi proc~bcp->module~modmpi module~modfields modfields proc~bcp->module~modfields module~modglobal modglobal proc~bcp->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(ib - ih:ie + ih, jb - jh:je + jh, kb - kh:ke + kh) :: p Calls proc~~bcp~~CallsGraph proc~bcp bcp proc~excj excj proc~bcp->proc~excj mpi_sendrecv mpi_sendrecv proc~excj->mpi_sendrecv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~bcp~~CalledByGraph proc~bcp bcp proc~tderive tderive proc~tderive->proc~bcp proc~poisson poisson proc~poisson->proc~tderive program~dalesurban DALESURBAN program~dalesurban->proc~poisson Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code bcp Source Code subroutine bcp ( p ) use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , linoutflow , dxfi use modfields , only : pres0 , up , u0 , um , uouttot use modmpi , only : excj real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ), intent ( inout ) :: p !< pressure integer i , j , k if ( linoutflow ) then do k = kb , ke do j = jb , je p ( ib - 1 , j , k ) = p ( ib , j , k ) ! inflow:  dp/dn=0 pres0 ( ib - 1 , j , k ) = pres0 ( ib , j , k ) ! inflow:  dp/dn=0 p ( ie + 1 , j , k ) = - p ( ie , j , k ) ! outflow: p=0 pres0 ( ie + 1 , j , k ) = - pres0 ( ie , j , k ) ! outflow: p=0 up ( ie + 1 , j , k ) = - ( u0 ( ie + 1 , j , k ) - u0 ( ie , j , k )) * dxfi ( ie ) * uouttot enddo enddo else do k = kb , ke do j = jb , je p ( ib - 1 , j , k ) = p ( ie , j , k ) p ( ie + 1 , j , k ) = p ( ib , j , k ) enddo enddo endif call excj ( p , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 ) ! cyclic call excj ( pres0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 ) ! cyclic end subroutine bcp","tags":"","loc":"proc/bcp.html"},{"title":"grwdamp – uDALES","text":"public subroutine grwdamp() Uses modglobal modfields modmpi proc~~grwdamp~~UsesGraph proc~grwdamp grwdamp module~modmpi modmpi proc~grwdamp->module~modmpi module~modfields modfields proc~grwdamp->module~modfields module~modglobal modglobal proc~grwdamp->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~grwdamp~~CalledByGraph proc~grwdamp grwdamp program~dalesurban DALESURBAN program~dalesurban->proc~grwdamp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code grwdamp Source Code subroutine grwdamp use modglobal , only : ke , kmax , lcoriol , igrw_damp , geodamptime use modfields , only : up , vp , wp , thlp , qtp , u0 , v0 , w0 , thl0 , qt0 , ug , vg , thl0av , qt0av , u0av , v0av use modmpi , only : myid implicit none integer k select case ( igrw_damp ) case ( 0 ) !do nothing case ( 1 ) do k = ksp , ke up (:, :, k ) = up (:, :, k ) - ( u0 (:, :, k ) - u0av ( k )) * tsc ( k ) vp (:, :, k ) = vp (:, :, k ) - ( v0 (:, :, k ) - v0av ( k )) * tsc ( k ) wp (:, :, k ) = wp (:, :, k ) - w0 (:, :, k ) * tsc ( k ) thlp (:, :, k ) = thlp (:, :, k ) - ( thl0 (:, :, k ) - thl0av ( k )) * tsc ( k ) qtp (:, :, k ) = qtp (:, :, k ) - ( qt0 (:, :, k ) - qt0av ( k )) * tsc ( k ) end do if ( lcoriol ) then do k = ksp , ke up (:, :, k ) = up (:, :, k ) - ( u0 (:, :, k ) - ug ( k )) * (( 1. / ( geodamptime * rnu0 )) * tsc ( k )) vp (:, :, k ) = vp (:, :, k ) - ( v0 (:, :, k ) - vg ( k )) * (( 1. / ( geodamptime * rnu0 )) * tsc ( k )) end do end if case ( 2 ) do k = ksp , ke up (:, :, k ) = up (:, :, k ) - ( u0 (:, :, k ) - ug ( k )) * tsc ( k ) vp (:, :, k ) = vp (:, :, k ) - ( v0 (:, :, k ) - vg ( k )) * tsc ( k ) wp (:, :, k ) = wp (:, :, k ) - w0 (:, :, k ) * tsc ( k ) thlp (:, :, k ) = thlp (:, :, k ) - ( thl0 (:, :, k ) - thl0av ( k )) * tsc ( k ) qtp (:, :, k ) = qtp (:, :, k ) - ( qt0 (:, :, k ) - qt0av ( k )) * tsc ( k ) end do case ( 3 ) do k = ksp , ke up (:, :, k ) = up (:, :, k ) - ( u0 (:, :, k ) - u0av ( k )) * tsc ( k ) vp (:, :, k ) = vp (:, :, k ) - ( v0 (:, :, k ) - v0av ( k )) * tsc ( k ) wp (:, :, k ) = wp (:, :, k ) - w0 (:, :, k ) * tsc ( k ) thlp (:, :, k ) = thlp (:, :, k ) - ( thl0 (:, :, k ) - thl0av ( k )) * tsc ( k ) qtp (:, :, k ) = qtp (:, :, k ) - ( qt0 (:, :, k ) - qt0av ( k )) * tsc ( k ) end do case default write ( 0 , * ) \"ERROR: no gravity wave damping option selected\" stop 1 end select return end subroutine grwdamp","tags":"","loc":"proc/grwdamp.html"},{"title":"fluxtop – uDALES","text":"private subroutine fluxtop(field, ek, flux) Uses modglobal proc~~fluxtop~~UsesGraph proc~fluxtop fluxtop module~modglobal modglobal proc~fluxtop->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(inout) :: field (ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) real, intent(in) :: ek (ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) real, intent(in) :: flux Called by proc~~fluxtop~~CalledByGraph proc~fluxtop fluxtop proc~boundary boundary proc~boundary->proc~fluxtop proc~readinitfiles readinitfiles proc~readinitfiles->proc~boundary program~dalesurban DALESURBAN program~dalesurban->proc~boundary proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code fluxtop Source Code subroutine fluxtop ( field , ek , flux ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , dzf , dzh , dzhi , eps1 real , intent ( inout ) :: field ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) real , intent ( in ) :: ek ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) real , intent ( in ) :: flux ! if ( abs ( flux ) . le . eps1 ) then !it's zero-flux, we don't need to do the calculation field (:, :, ke + 1 ) = field (:, :, ke ) else field (:, :, ke + 1 ) = field (:, :, ke ) + dzh ( ke + 1 ) * flux / ( dzhi ( ke + 1 ) * ( 0.5 * ( dzf ( ke ) * ek (:, :, ke + 1 ) + dzf ( ke + 1 ) * ek (:, :, ke )))) end if ! end subroutine fluxtop","tags":"","loc":"proc/fluxtop.html"},{"title":"valuetop – uDALES","text":"private subroutine valuetop(field, val) Uses modglobal proc~~valuetop~~UsesGraph proc~valuetop valuetop module~modglobal modglobal proc~valuetop->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(inout) :: field (ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) real, intent(in) :: val Called by proc~~valuetop~~CalledByGraph proc~valuetop valuetop proc~boundary boundary proc~boundary->proc~valuetop proc~readinitfiles readinitfiles proc~readinitfiles->proc~boundary program~dalesurban DALESURBAN program~dalesurban->proc~boundary proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code valuetop Source Code subroutine valuetop ( field , val ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , eps1 real , intent ( inout ) :: field ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) real , intent ( in ) :: val ! field (:, :, ke + 1 ) = 2 * val - field (:, :, ke ) ! end subroutine valuetop","tags":"","loc":"proc/valuetop.html"},{"title":"fluxtopscal – uDALES","text":"private subroutine fluxtopscal(flux) Uses modglobal modfields modsubgriddata proc~~fluxtopscal~~UsesGraph proc~fluxtopscal fluxtopscal module~modfields modfields proc~fluxtopscal->module~modfields module~modsubgriddata modsubgriddata proc~fluxtopscal->module~modsubgriddata module~modglobal modglobal proc~fluxtopscal->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(in) :: flux (1:nsv) Called by proc~~fluxtopscal~~CalledByGraph proc~fluxtopscal fluxtopscal proc~boundary boundary proc~boundary->proc~fluxtopscal proc~readinitfiles readinitfiles proc~readinitfiles->proc~boundary program~dalesurban DALESURBAN program~dalesurban->proc~boundary proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code fluxtopscal Source Code subroutine fluxtopscal ( flux ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , dzf , dzh , dzhi , nsv , khc use modfields , only : sv0 , svm use modsubgriddata , only : ekh real , intent ( in ) :: flux ( 1 : nsv ) integer :: m , n ! !all the ghost cells have the same value? do m = 1 , khc do n = 1 , nsv sv0 ( ib - ih : ie + ih , jb - jh : je + jh , ke + m , n ) = sv0 ( ib - ih : ie + ih , jb - jh : je + jh , ke , n ) + dzh ( ke + 1 ) * flux ( n ) / ( dzhi ( ke + 1 ) * ( 0.5 * ( dzf ( ke ) * ekh ( ib - ih : ie + ih , jb - jh : je + jh , ke + 1 ) + dzf ( ke + 1 ) * ekh ( ib - ih : ie + ih , jb - jh : je + jh , ke )))) svm ( ib - ih : ie + ih , jb - jh : je + jh , ke + m , n ) = svm ( ib - ih : ie + ih , jb - jh : je + jh , ke , n ) + dzh ( ke + 1 ) * flux ( n ) / ( dzhi ( ke + 1 ) * ( 0.5 * ( dzf ( ke ) * ekh ( ib - ih : ie + ih , jb - jh : je + jh , ke + 1 ) + dzf ( ke + 1 ) * ekh ( ib - ih : ie + ih , jb - jh : je + jh , ke )))) end do end do ! end subroutine fluxtopscal","tags":"","loc":"proc/fluxtopscal.html"},{"title":"valuetopscal – uDALES","text":"private subroutine valuetopscal(val) Uses modglobal modfields proc~~valuetopscal~~UsesGraph proc~valuetopscal valuetopscal module~modfields modfields proc~valuetopscal->module~modfields module~modglobal modglobal proc~valuetopscal->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(in) :: val (1:nsv) Called by proc~~valuetopscal~~CalledByGraph proc~valuetopscal valuetopscal proc~boundary boundary proc~boundary->proc~valuetopscal proc~readinitfiles readinitfiles proc~readinitfiles->proc~boundary program~dalesurban DALESURBAN program~dalesurban->proc~boundary proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code valuetopscal Source Code subroutine valuetopscal ( val ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , eps1 , nsv , khc use modfields , only : sv0 , svm real , intent ( in ) :: val ( 1 : nsv ) integer :: m , n ! ! all the ghost cells have the same vlaue? do m = 1 , khc do n = 1 , nsv sv0 (: , : , ke + m , n ) = 2 * val ( n ) - sv0 (: , : , ke , n ) svm (: , : , ke + m , n ) = 2 * val ( n ) - svm (: , : , ke , n ) end do end do ! end subroutine valuetopscal","tags":"","loc":"proc/valuetopscal.html"},{"title":"inlettop – uDALES","text":"private subroutine inlettop() Uses modglobal modfields modinletdata modmpi proc~~inlettop~~UsesGraph proc~inlettop inlettop module~modmpi modmpi proc~inlettop->module~modmpi module~modinletdata modinletdata proc~inlettop->module~modinletdata module~modfields modfields proc~inlettop->module~modfields module~modglobal modglobal proc~inlettop->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~inlettop~~CallsGraph proc~inlettop inlettop proc~slabsumi slabsumi proc~inlettop->proc~slabsumi mpi_allreduce mpi_allreduce proc~slabsumi->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~inlettop~~CalledByGraph proc~inlettop inlettop proc~boundary boundary proc~boundary->proc~inlettop proc~readinitfiles readinitfiles proc~readinitfiles->proc~boundary program~dalesurban DALESURBAN program~dalesurban->proc~boundary proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code inlettop Source Code subroutine inlettop use modglobal , only : ib , ie , jb , je , kb , ke , ih , jh , kh , dzh , dzf , & e12min , dxfi , dxf , dxhi , xh , jgb , jge , Uinf , dzfi use modfields , only : w0 , wm , wout , wouttot use modinletdata , only : Uinl , ddispdxold use modmpi , only : slabsumi , myid implicit none integer :: i real :: nji do i = ib , ie w0 ( i , :, ke + 1 ) = Uinf * ddispdxold wm ( i , :, ke + 1 ) = Uinf * ddispdxold end do call slabsumi ( wout , ib , ie , w0 , ib - ih , ie + ih , jb - jh , je + jh , kb - kh , ke + kh , ib , ie , jb , je , ke + 1 , ke + 1 ) ! determine vertical (j) average outflow velocity nji = 1. / ( jge - jgb + 1 ) do i = ib , ie wout ( i ) = wout ( i ) * dxf ( i ) * nji end do wouttot = sum ( wout ( ib : ie )) / ( xh ( ie + 1 ) - xh ( ib )) ! Area-averaged outflow velocity return end subroutine inlettop","tags":"","loc":"proc/inlettop.html"},{"title":"tqaver – uDALES","text":"public subroutine tqaver() Uses modmpi modglobal modfields proc~~tqaver~~UsesGraph proc~tqaver tqaver module~modmpi modmpi proc~tqaver->module~modmpi module~modfields modfields proc~tqaver->module~modfields module~modglobal modglobal proc~tqaver->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~tqaver~~CallsGraph proc~tqaver tqaver mpi_allreduce mpi_allreduce proc~tqaver->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code tqaver Source Code subroutine tqaver use modmpi , only : comm3d , mpierr , my_real , mpi_sum use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , nsv , rslabs use modfields , only : thl0 , qt0 , sv0 implicit none real thl0a , qt0a real thl0al , qt0al integer n real , allocatable , dimension (:) :: sv0al , sv0a allocate ( sv0al ( nsv ), sv0a ( nsv )) thl0al = sum ( thl0 ( ib : ie , jb : je , ke )) qt0al = sum ( qt0 ( ib : ie , jb : je , ke )) do n = 1 , nsv sv0al ( n ) = sum ( sv0 ( ib : ie , jb : je , ke , n )) enddo call MPI_ALLREDUCE ( thl0al , thl0a , 1 , MY_REAL , & MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( qt0al , qt0a , 1 , MY_REAL , & MPI_SUM , comm3d , mpierr ) if ( nsv > 0 ) then call MPI_ALLREDUCE ( sv0al , sv0a , nsv , MY_REAL , & MPI_SUM , comm3d , mpierr ) end if thl0a = thl0a / rslabs qt0a = qt0a / rslabs sv0a = sv0a / rslabs thl0 ( ib : ie , jb : je , ke ) = thl0a qt0 ( ib : ie , jb : je , ke ) = qt0a do n = 1 , nsv sv0 ( ib : ie , jb : je , ke , n ) = sv0a ( n ) enddo deallocate ( sv0al , sv0a ) return end subroutine tqaver","tags":"","loc":"proc/tqaver.html"},{"title":"writerestartfiles – uDALES","text":"public subroutine writerestartfiles() Uses modsurfdata modfields modglobal modmpi modsubgriddata modibmdata initfac modinletdata proc~~writerestartfiles~~UsesGraph proc~writerestartfiles writerestartfiles module~modibmdata modibmdata proc~writerestartfiles->module~modibmdata module~modsurfdata modsurfdata proc~writerestartfiles->module~modsurfdata module~modmpi modmpi proc~writerestartfiles->module~modmpi module~modsubgriddata modsubgriddata proc~writerestartfiles->module~modsubgriddata module~modinletdata modinletdata proc~writerestartfiles->module~modinletdata module~initfac initfac proc~writerestartfiles->module~initfac module~modfields modfields proc~writerestartfiles->module~modfields module~modglobal modglobal proc~writerestartfiles->module~modglobal mpi mpi module~modmpi->mpi module~initfac->module~modmpi module~initfac->module~modglobal netcdf netcdf module~initfac->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~writerestartfiles~~CalledByGraph proc~writerestartfiles writerestartfiles proc~inletgennotemp inletgennotemp proc~inletgennotemp->proc~writerestartfiles proc~inletgen inletgen proc~inletgen->proc~writerestartfiles program~dalesurban DALESURBAN program~dalesurban->proc~writerestartfiles proc~boundary boundary program~dalesurban->proc~boundary proc~startup startup program~dalesurban->proc~startup proc~boundary->proc~inletgennotemp proc~boundary->proc~inletgen proc~readinitfiles readinitfiles proc~readinitfiles->proc~boundary proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code writerestartfiles Source Code subroutine writerestartfiles use modsurfdata , only : ustar , thlflux , qtflux , svflux , dudz , dvdz , dthldz , dqtdz , ps , thls , qts , thvs , oblav use modfields , only : u0 , v0 , w0 , thl0 , qt0 , ql0 , ql0h , e120 , dthvdz , presf , presh , sv0 , mindist , wall ,& uav , vav , wav , uuav , vvav , wwav , uvav , uwav , vwav , thlav , thl2av , qtav , qlav , ql2av , qt2av , svav , sv2av , momthick ,& friction , displthick , pres0 , viscratioav , thluav , thlvav , thlwav , qtuav , qtvav , qtwav , qluav , qlvav , qlwav , svuav , svvav , svwav ,& upupav , vpvpav , wpwpav , thlpthlpav , qlpqlpav , qtpqtpav , svpsvpav , upvpav , upwpav , vpwpav , thlpupav , thlpvpav ,& thlpwpav , qlpupav , qlpvpav , qlpwpav , qtpupav , qtpvpav , qtpwpav , svpupav , svpvpav , svpwpav , presav ,& uusgsav , vvsgsav , wwsgsav , uwsgsav , thlusgsav , thlwsgsav , qlusgsav , qlwsgsav , qtusgsav , qtwsgsav , svusgsav , svwsgsav , tkesgsav ,& strain2av , disssgsav , t_vav , tvmx , tvmy , tvmz , tsgsmx1 , tsgsmx2 , tsgsmy1 , tsgsmy2 , tsgsmz1 ,& tsgsmz2 , t_sgsav , nusgsav , tpm , t_pav , ttmx , ttmy , ttmz , t_tav , p_bav , d_sgsav , p_tav , tkeadv use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , trestart , tnextrestart , dt_lim , timee , btime , xh ,& cexpnr , ntimee , rk3step , ifoutput , nsv , timeleft , dt , ntrun , totavtime ,& iinletgen , timee , runavtime , inletav , totinletav , linletRA , ltempeq , lmoist , jgb , jge ,& dzf , dzfi , dzhi , dxf , dxfi , dyi , dxhi , nstore , numol , dy2i , grav , libm , jmax , nblocks use modmpi , only : cmyid , myid , slabsum , excjs use modsubgriddata , only : ekm use modibmdata , only : ibmxforcevol use initfac , only : block use modinletdata , only : Urec , Wrec , Uinl , Utav , QLinl , QTinl , QLrec , QTrec , QTtav , QLtav , Ttav , upupavinl , vpvpavinl , wpwpavinl , upwpavinl ,& thlpthlpavinl , thlpupavinl , thlpwpavinl , qlpqlpavinl , qlpupavinl , qlpwpavinl , qtpqtpavinl , qtpupavinl , qtpwpavinl , Tinl , Trec , nstepread implicit none logical :: lexitnow = . false . integer imin , ihour integer i , j , k , n , im , ip , jm , jp , jpp , km , kp , kpp , il , iu , jl , ju , kl , ku character ( 21 ) name , name2 , name3 , name4 , linkname if ( timee == 0 ) return !    if (rk3step /=3) return if (( iinletgen == 2 ) . and . ( nstepread == nstore )) then ! This overrules the need for rk3step to be 3 in case of reading inletfiles write ( 6 , * ) 'Writing restartfiles after reading in new inletfiles' else if ( rk3step /= 3 ) return ! Normal check end if name = 'exit_now.' // cexpnr inquire ( file = trim ( name ), EXIST = lexitnow ) if ((( timee >= tnextrestart )) . or . (( lexitnow ) . or . ( nstepread == nstore + 1 ))) then tnextrestart = tnextrestart + trestart name = 'initd        _   .' write ( name ( 6 : 13 ) , '(i8.8)' ) ntrun name ( 15 : 17 ) = cmyid name ( 19 : 21 ) = cexpnr open ( ifoutput , file = name , form = 'unformatted' , status = 'replace' ) write ( ifoutput ) ((( mindist ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke ) write ( ifoutput ) (((( wall ( i , j , k , n ), i = ib , ie ), j = jb , je ), k = kb , ke ), n = 1 , 5 ) write ( ifoutput ) ((( u0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( v0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( w0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( pres0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( thl0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( e120 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( ekm ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( qt0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( ql0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( ql0h ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) timee , dt if ( myid == 0 ) then write ( * , * ) '-------------------------' write ( * , * ) 'Saving initd restart file' write ( * , * ) 'ntrun ::: ' , ntrun write ( * , * ) 'timee ::: ' , timee write ( * , * ) '-------------------------' endif close ( ifoutput ) if ( nsv > 0 ) then name = 'inits        _   .' write ( name ( 6 : 13 ) , '(i8.8)' ) ntrun name ( 15 : 17 ) = cmyid name ( 19 : 21 ) = cexpnr open ( ifoutput , file = name , form = 'unformatted' ) write ( ifoutput ) (((( sv0 ( i , j , k , n ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ), n = 1 , nsv ) write ( ifoutput ) timee close ( ifoutput ) end if if ( myid == 0 ) then write ( * , '(A,F15.7,A,I4)' ) 'dump at time = ' , timee , ' unit = ' , ifoutput end if end if end subroutine writerestartfiles","tags":"","loc":"proc/writerestartfiles.html"},{"title":"initpois – uDALES","text":"public subroutine initpois() Uses modglobal proc~~initpois~~UsesGraph proc~initpois initpois module~modglobal modglobal proc~initpois->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~initpois~~CalledByGraph proc~initpois initpois proc~startup startup proc~startup->proc~initpois program~dalesurban DALESURBAN program~dalesurban->proc~startup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code initpois Source Code subroutine initpois use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh implicit none allocate ( p ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) end subroutine initpois","tags":"","loc":"proc/initpois.html"},{"title":"poisson – uDALES","text":"public subroutine poisson() Uses modglobal modmpi proc~~poisson~~UsesGraph proc~poisson poisson module~modmpi modmpi proc~poisson->module~modmpi module~modglobal modglobal proc~poisson->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~poisson~~CallsGraph proc~poisson poisson proc~solmpj solmpj proc~poisson->proc~solmpj proc~fillps fillps proc~poisson->proc~fillps proc~poisr poisr proc~poisson->proc~poisr proc~tderive tderive proc~poisson->proc~tderive rffti rffti proc~solmpj->rffti float float proc~solmpj->float proc~all_all_j ALL_ALL_j proc~solmpj->proc~all_all_j mpi_comm_size mpi_comm_size proc~solmpj->mpi_comm_size rfftf rfftf proc~solmpj->rfftf rfftb rfftb proc~solmpj->rfftb mpi_comm_rank mpi_comm_rank proc~solmpj->mpi_comm_rank proc~bcpup bcpup proc~fillps->proc~bcpup proc~poisr->float blktri blktri proc~poisr->blktri vrfftb vrfftb proc~poisr->vrfftb proc~barrou barrou proc~poisr->proc~barrou vrffti vrffti proc~poisr->vrffti proc~all_all_j2 ALL_ALL_j2 proc~poisr->proc~all_all_j2 vrfftf vrfftf proc~poisr->vrfftf proc~bcp bcp proc~tderive->proc~bcp proc~excj excj proc~bcp->proc~excj proc~excjs excjs proc~bcpup->proc~excjs mpi_barrier mpi_barrier proc~barrou->mpi_barrier mpi_alltoall mpi_alltoall proc~all_all_j->mpi_alltoall proc~all_all_j2->proc~barrou proc~all_all_j2->mpi_alltoall mpi_sendrecv mpi_sendrecv proc~excjs->mpi_sendrecv proc~excj->mpi_sendrecv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~poisson~~CalledByGraph proc~poisson poisson program~dalesurban DALESURBAN program~dalesurban->proc~poisson Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code poisson Source Code subroutine poisson use modglobal , only : ib , ie , ih , kb , ke , kh , kmax , dxh , dxf , dy , dzf , dzh , linoutflow , iinletgen , ipoiss , POISS_FFT , POISS_CYC use modmpi , only : myid , nprocs , barrou implicit none integer ibc1 , ibc2 , kbc1 , kbc2 , ksen call fillps !  ibc?=1: neumann !  ibc?=2: periodic !  ibc?=3: dirichlet select case ( ipoiss ) case ( POISS_FFT ) call solmpj ( p ) case ( POISS_CYC ) if ( linoutflow ) then ibc1 = 1 ! inlet ibc2 = 3 ! outlet else ibc1 = 2 ibc2 = 2 endif kbc1 = 1 kbc2 = 1 ksen = kmax / nprocs call poisr ( p , dxf , dxh , dy , dzf , dzh , & ibc1 , ibc2 , kbc1 , kbc2 , ksen ) case default write ( 0 , * ) \"Invalid choice for Poisson solver\" stop 1 end select call tderive end subroutine poisson","tags":"","loc":"proc/poisson.html"},{"title":"exitpois – uDALES","text":"public subroutine exitpois() Arguments None Called by proc~~exitpois~~CalledByGraph proc~exitpois exitpois proc~exitmodules exitmodules proc~exitmodules->proc~exitpois program~dalesurban DALESURBAN program~dalesurban->proc~exitmodules Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code exitpois Source Code subroutine exitpois implicit none deallocate ( p ) end subroutine exitpois","tags":"","loc":"proc/exitpois.html"},{"title":"fillps – uDALES","text":"private subroutine fillps() Uses modfields modglobal modmpi modboundary proc~~fillps~~UsesGraph proc~fillps fillps module~modmpi modmpi proc~fillps->module~modmpi module~modboundary modboundary proc~fillps->module~modboundary module~modfields modfields proc~fillps->module~modfields module~modglobal modglobal proc~fillps->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~fillps~~CallsGraph proc~fillps fillps proc~bcpup bcpup proc~fillps->proc~bcpup proc~excjs excjs proc~bcpup->proc~excjs mpi_sendrecv mpi_sendrecv proc~excjs->mpi_sendrecv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~fillps~~CalledByGraph proc~fillps fillps proc~poisson poisson proc~poisson->proc~fillps program~dalesurban DALESURBAN program~dalesurban->proc~poisson Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code fillps Source Code subroutine fillps ! Chiel van Heerwaarden,  19 June 2007 ! Adapted fillps for RK3 time loop use modfields , only : up , vp , wp , um , vm , wm , u0 , v0 , w0 use modglobal , only : rk3step , ib , ie , jb , je , kb , ke , ih , jh , kh , dxfi , dyi , dzfi , dt ,& linoutflow , libm use modmpi , only : excjs use modboundary , only : bcpup !    use modibm,    only : ibmnorm implicit none real , allocatable :: pup (:,:,:), pvp (:,:,:), pwp (:,:,:) integer i , j , k real rk3coef , rk3coefi allocate ( pup ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( pvp ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( pwp ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) rk3coef = dt / ( 4. - dble ( rk3step )) rk3coefi = 1. / rk3coef do k = kb , ke do j = jb , je do i = ib , ie pup ( i , j , k ) = up ( i , j , k ) + um ( i , j , k ) * rk3coefi ! see equation 5.81 pvp ( i , j , k ) = vp ( i , j , k ) + vm ( i , j , k ) * rk3coefi pwp ( i , j , k ) = wp ( i , j , k ) + wm ( i , j , k ) * rk3coefi end do end do end do !**************************************************************** !     Fill the right hand for the poisson solver. !     The values for up(i2,j,k) and vp(i,j2,k) are still !     unknown and have to be set cyclic. !     Also we take wp(i,j,1) and wp(i,j,k1) equal to zero. !     NOTE: !     The poisson-solver only accepts values for i from 2 to i1, !     for j from 1 to jmax and for k from 1 to kmax. !     The right-hand p is therefore filled in this partical way. !************************************************************** call bcpup ( pup , pvp , pwp , rk3coef ) ! boundary conditions for pup,pvp,pwp do k = kb , ke do j = jb , je do i = ib , ie p ( i , j , k ) = ( pup ( i + 1 , j , k ) - pup ( i , j , k ) ) * dxfi ( i ) & ! see equation 5.72 + ( pvp ( i , j + 1 , k ) - pvp ( i , j , k ) ) * dyi & + ( pwp ( i , j , k + 1 ) - pwp ( i , j , k ) ) * dzfi ( k ) end do end do end do deallocate ( pup , pvp , pwp ) end subroutine fillps","tags":"","loc":"proc/fillps.html"},{"title":"tderive – uDALES","text":"private subroutine tderive() Uses modfields modglobal modmpi modboundary proc~~tderive~~UsesGraph proc~tderive tderive module~modmpi modmpi proc~tderive->module~modmpi module~modboundary modboundary proc~tderive->module~modboundary module~modfields modfields proc~tderive->module~modfields module~modglobal modglobal proc~tderive->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~tderive~~CallsGraph proc~tderive tderive proc~bcp bcp proc~tderive->proc~bcp proc~excj excj proc~bcp->proc~excj mpi_sendrecv mpi_sendrecv proc~excj->mpi_sendrecv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~tderive~~CalledByGraph proc~tderive tderive proc~poisson poisson proc~poisson->proc~tderive program~dalesurban DALESURBAN program~dalesurban->proc~poisson Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code tderive Source Code subroutine tderive !-----------------------------------------------------------------| !                                                                 | !*** *tderive*  read input fields for initialisation              | !                                                                 | !      Hans Cuijpers   I.M.A.U.     06/01/1995                    | !                                                                 | !     purpose.                                                    | !     --------                                                    | !                                                                 | !     Refill array p with pressure values. The poisson-solver     | !     produced a pressure array p in which the i-index varied     | !     between 2 and i1, the j- and k-index between 1 and resp.    | !     jmax and kmax. For our further calculations we'll change    | !     the range for the j-index to vary between 2 and j1.         | !                                                                 | !     Further we set cyclic boundary conditions for the pressure- | !     fluctuations in the x-y plane.                              | !                                                                 | !**   interface.                                                  | !     ----------                                                  | !                                                                 | !             *tderive* is called from *program*.                 | !                                                                 | !-----------------------------------------------------------------| use modfields , only : up , vp , wp , pres0 , IIc , IIcs use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , dxhi , dyi , dzhi , linoutflow , rslabs use modmpi , only : myid , excj , slabsum , avexy_ibm use modboundary , only : bcp implicit none integer i , j , k real , dimension ( kb - kh : ke + kh ) :: pij !    logical, dimension(ib:ie, jb:je, kb:ke) :: pnan real :: pijk !    integer :: ipnan ! Mathieu ATTTT: CHANGED!!! Loop removed!!! ! **  Boundary conditions ************** call bcp ( p ) ! boundary conditions for p. !***************************************************************** ! **  Calculate time-derivative for the velocities with known **** ! **  pressure gradients.  *************************************** !***************************************************************** !   if (myid == 0) then !     write(*,*) \"net ts\", p(ib, jb, :) !   end if !pnan = isnan(p(ib:ie, jb:je, kb:ke)) !ipnan = 0 !do k=kb,ke !do j=jb,je !do i=ib,ie !  if (pnan(i,j,k)) then !    ipnan = ipnan + 1 !  end if !end do !end do !end do !   write(*,*) \"NaN\", myid, ipnan !    write(*,*) \"NaN\", myid, dble(isnan(p)) !sum(real(isnan(p))) do k = kb , ke do j = jb , je do i = ib , ie vp ( i , j , k ) = vp ( i , j , k ) - ( p ( i , j , k ) - p ( i , j - 1 , k )) * dyi end do end do end do if ( linoutflow ) then do k = kb , ke do j = jb , je do i = ib , ie + 1 up ( i , j , k ) = up ( i , j , k ) - ( p ( i , j , k ) - p ( i - 1 , j , k )) * dxhi ( i ) ! see equation 5.82 (u is computed from the mass conservation) end do end do end do else do k = kb , ke do j = jb , je do i = ib , ie up ( i , j , k ) = up ( i , j , k ) - ( p ( i , j , k ) - p ( i - 1 , j , k )) * dxhi ( i ) ! see equation 5.82 (u is computed from the mass conservation) end do end do end do endif do k = kb + 1 , ke do j = jb , je do i = ib , ie wp ( i , j , k ) = wp ( i , j , k ) - ( p ( i , j , k ) - p ( i , j , k - 1 )) * dzhi ( k ) end do end do end do ! tg3315 02/02/2019 ! account for pressure offset that results from ill-defined problem in pressure ! correction method when periodic horizontal BCs are applied. Arises within cyclic ! reduction scheme (called by BLKTRI) and due to the numerics in PRODP in ! cycred.f which define the BC in the periodic case. A linear offset existed in ! the pressure correction term (p) and this can be controlled by subtracting ! the volume averaged modified pressure from this value at all time steps. ! Periodic: p - <p>_ijk ! Makes no change on physical effect of modified pressure in code. ! tg3315 - update 24/06/19 -- there is a missing term in the application of the periodic BCs for pup, could this be part of the problem? Test with this to see if can avoid use of pijk below. ! refer to mvr for necessity of this ! useful refs: ! https://opensky.ucar.edu/islandora/object/technotes%3A98/datastream/PDF/download/citation.pdf ! https://epubs.siam.org/doi/pdf/10.1137/0711042 pij = 0. ; pijk = 0. ; if (. not . linoutflow ) then call slabsum ( pij ( kb : ke ), kb , ke , p ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , ib , ie , jb , je , kb , ke ) pij = pij / rslabs pijk = sum ( pij ( kb : ke )) / ( ke - kb ) end if do k = kb - 1 , ke + 1 do j = jb - 1 , je + 1 do i = ib - 1 , ie + 1 pres0 ( i , j , k ) = pres0 ( i , j , k ) + p ( i , j , k ) - pijk ! update of the pressure: P_new = P_old + p enddo enddo enddo return end subroutine tderive","tags":"","loc":"proc/tderive.html"},{"title":"ALL_ALL_j – uDALES","text":"private subroutine ALL_ALL_j(p, ptrans, iaction) Uses modglobal modmpi proc~~all_all_j~~UsesGraph proc~all_all_j ALL_ALL_j module~modmpi modmpi proc~all_all_j->module~modmpi module~modglobal modglobal proc~all_all_j->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real :: p (0:imax+1,0:jmax+1,0:kmax+1) real :: ptrans (1:isen,1:jtot,1:kmax) integer :: iaction Calls proc~~all_all_j~~CallsGraph proc~all_all_j ALL_ALL_j mpi_alltoall mpi_alltoall proc~all_all_j->mpi_alltoall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~all_all_j~~CalledByGraph proc~all_all_j ALL_ALL_j proc~solmpj solmpj proc~solmpj->proc~all_all_j proc~poisson poisson proc~poisson->proc~solmpj program~dalesurban DALESURBAN program~dalesurban->proc~poisson Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ALL_ALL_j Source Code subroutine ALL_ALL_j ( p , ptrans , iaction ) ! purpose: do all-to-all communication ! data are only distributed over the j-direction for p ! data are only distributed over the k-direction for ptrans ! NOTE: p     (0:imax+1  etc !       ptrans(1:imax    etc use modglobal , only : imax , isen , jmax , jsen , jtot , kmax use modmpi , only : comm3d , mpierr , my_real , nprocs , barrou implicit none integer iaction real p ( 0 : imax + 1 , 0 : jmax + 1 , 0 : kmax + 1 ) real ptrans ( 1 : isen , 1 : jtot , 1 : kmax ) ! help arrays for sending and receiving real , allocatable , dimension (:) :: bufin , bufout ! help variables integer ii , jbegin , jend , proc integer ibegin , iend integer i , j , k allocate ( bufin ( imax * jmax * kmax ), bufout ( imax * jmax * kmax )) if ( iaction == 0 ) then ii = 0 do proc = 0 , nprocs - 1 ibegin = ( proc ) * isen + 1 iend = ( proc + 1 ) * isen do i = ibegin , iend do j = 1 , jmax do k = 1 , kmax ii = ii + 1 bufin ( ii ) = p ( i , j , k ) enddo enddo enddo enddo ii = 0 !     call barrou() call MPI_ALLTOALL ( bufin , ( isen * jsen * kmax ), MY_REAL , & bufout ,( isen * jsen * kmax ), MY_REAL , & comm3d , mpierr ) !     call barrou() ii = 0 do proc = 0 , nprocs - 1 jbegin = proc * jsen + 1 jend = ( proc + 1 ) * jsen do i = 1 , isen do j = jbegin , jend do k = 1 , kmax ii = ii + 1 ptrans ( i , j , k ) = bufout ( ii ) enddo enddo enddo enddo !     call barrou() elseif ( iaction == 1 ) then ii = 0 do proc = 0 , nprocs - 1 jbegin = proc * jsen + 1 jend = ( proc + 1 ) * jsen do i = 1 , isen do j = jbegin , jend do k = 1 , kmax ii = ii + 1 bufin ( ii ) = ptrans ( i , j , k ) enddo enddo enddo enddo !     call barrou() call MPI_ALLTOALL ( bufin , ( isen * jsen * kmax ), MY_REAL , & bufout ,( isen * jsen * kmax ), MY_REAL , & comm3d , mpierr ) !     call barrou() ii = 0 do proc = 0 , nprocs - 1 ibegin = ( proc ) * isen + 1 iend = ( proc + 1 ) * isen do i = ibegin , iend do j = 1 , jmax do k = 1 , kmax ii = ii + 1 p ( i , j , k ) = bufout ( ii ) enddo enddo enddo enddo !     call barrou() endif deallocate ( bufin , bufout ) return end subroutine ALL_ALL_j","tags":"","loc":"proc/all_all_j.html"},{"title":"ALL_ALL_j2 – uDALES","text":"private subroutine ALL_ALL_j2(p, ptrans, iaction, ksen) Uses modglobal modmpi proc~~all_all_j2~~UsesGraph proc~all_all_j2 ALL_ALL_j2 module~modmpi modmpi proc~all_all_j2->module~modmpi module~modglobal modglobal proc~all_all_j2->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real :: p (0:imax+1,0:jmax+1,0:kmax+1) real :: ptrans (1:imax,1:jtot,1:ksen) integer :: iaction integer :: ksen Calls proc~~all_all_j2~~CallsGraph proc~all_all_j2 ALL_ALL_j2 mpi_alltoall mpi_alltoall proc~all_all_j2->mpi_alltoall proc~barrou barrou proc~all_all_j2->proc~barrou mpi_barrier mpi_barrier proc~barrou->mpi_barrier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~all_all_j2~~CalledByGraph proc~all_all_j2 ALL_ALL_j2 proc~poisr poisr proc~poisr->proc~all_all_j2 proc~poisson poisson proc~poisson->proc~poisr program~dalesurban DALESURBAN program~dalesurban->proc~poisson Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ALL_ALL_j2 Source Code subroutine ALL_ALL_j2 ( p , ptrans , iaction , ksen ) ! use modglobal , only : imax , isen , jmax , jsen , jtot , kmax use modmpi , only : comm3d , mpierr , my_real , nprocs , barrou implicit none ! !     include 'param.txt' ! !     include 'mpif.h' !     include 'mpi_cons.txt' ! integer iaction , ksen real p ( 0 : imax + 1 , 0 : jmax + 1 , 0 : kmax + 1 ) real ptrans ( 1 : imax , 1 : jtot , 1 : ksen ) integer i , j , k ! ! ! purpose: do all-to-all communication ! ! data are only distributed over the j-direction for p ! data are only distributed over the k-direction for ptrans ! ! help arrays for sending and receiving ! real bufin (( imax ) * jmax * ( kmax )) real bufout (( imax ) * jmax * ( kmax )) ! ! help variables ! integer ii , jstart , jend , proc integer kstart , kend , jvalue , kvalue ! ! if ( iaction . eq . 0 ) then ! ii = 0 do proc = 0 , nprocs - 1 kstart = ( proc ) * ksen + 1 kend = ( proc + 1 ) * ksen do k = kstart , kend do j = 1 , jmax do i = 1 , imax ii = ii + 1 bufin ( ii ) = p ( i , j , k ) enddo enddo enddo enddo ! ! ii = 0 ! ! call barrou () ! call MPI_ALLTOALL ( bufin , ( imax * jsen * ksen ), MY_REAL , & bufout ,( imax * jsen * ksen ), MY_REAL , & comm3d , mpierr ) !      bufout = bufin ! call barrou () ! ii = 0 ! do proc = 0 , nprocs - 1 jstart = proc * jsen + 1 jend = ( proc + 1 ) * jsen do k = 1 , ksen do j = jstart , jend do i = 1 , imax ii = ii + 1 ptrans ( i , j , k ) = bufout ( ii ) enddo enddo enddo ! enddo ! ! call barrou () ! ! elseif ( iaction . eq . 1 ) then ! ii = 0 ! do proc = 0 , nprocs - 1 jstart = proc * jsen + 1 jend = ( proc + 1 ) * jsen do k = 1 , ksen do j = jstart , jend do i = 1 , imax ii = ii + 1 bufin ( ii ) = ptrans ( i , j , k ) enddo enddo enddo ! enddo ! call barrou () ! call MPI_ALLTOALL ( bufin , ( imax * jsen * ksen ), MY_REAL , & bufout ,( imax * jsen * ksen ), MY_REAL , & comm3d , mpierr ) !      bufout = bufin ! call barrou () ! ! ii = 0 ! do proc = 0 , nprocs - 1 kstart = ( proc ) * ksen + 1 kend = ( proc + 1 ) * ksen do k = kstart , kend do j = 1 , jmax do i = 1 , imax ii = ii + 1 p ( i , j , k ) = bufout ( ii ) enddo enddo enddo enddo ! ! call barrou () endif ! return end subroutine ALL_ALL_j2","tags":"","loc":"proc/all_all_j2.html"},{"title":"poisr – uDALES","text":"private subroutine poisr(rhs, dx, dxh, dy, dz, dzh, ibc1, ibc2, kbc1, kbc2, ksen) Uses modglobal modfields modmpi proc~~poisr~~UsesGraph proc~poisr poisr module~modmpi modmpi proc~poisr->module~modmpi module~modfields modfields proc~poisr->module~modfields module~modglobal modglobal proc~poisr->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real :: rhs (0:imax+1,0:jmax+1,0:kmax+1) real :: dx (0:IMAX+1) real :: dxh (1:IMAX+1) real :: dy real :: dz (0:kmax+1) real :: dzh (1:kmax+1) integer :: ibc1 integer :: ibc2 integer :: kbc1 integer :: kbc2 integer :: ksen Calls proc~~poisr~~CallsGraph proc~poisr poisr float float proc~poisr->float blktri blktri proc~poisr->blktri vrfftb vrfftb proc~poisr->vrfftb proc~barrou barrou proc~poisr->proc~barrou vrffti vrffti proc~poisr->vrffti proc~all_all_j2 ALL_ALL_j2 proc~poisr->proc~all_all_j2 vrfftf vrfftf proc~poisr->vrfftf mpi_barrier mpi_barrier proc~barrou->mpi_barrier proc~all_all_j2->proc~barrou mpi_alltoall mpi_alltoall proc~all_all_j2->mpi_alltoall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~poisr~~CalledByGraph proc~poisr poisr proc~poisson poisson proc~poisson->proc~poisr program~dalesurban DALESURBAN program~dalesurban->proc~poisson Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code poisr Source Code SUBROUTINE poisr ( rhs , dx , dxh , dy , dz , dzh , & ibc1 , ibc2 , kbc1 , kbc2 , ksen ) ! ! CHANGES: ! includes jtot and ksen (calculated in poisson.f) in header !          help array rhst with dimensions (imax,jtot,ksen) !          ALL_ALL copy rhs to rhst and back for FFT's ! !  ibc?=1: neumann !  ibc?=2: periodic !  ibc?=3: dirichlet ! ! only FFT in j-direction, cyclic reduction in the others !      include'param.txt' !     include 'mpif.h' !     include 'mpi_cons.txt' use modglobal , only : imax , isen , jmax , jsen , jtot , kmax , poisrcheck use modfields , only : worksave use modmpi , only : myid , comm3d , mpierr , my_real , nprocs , barrou , MPI_SUM implicit none ! authors: m.j.b.m. pourquie, b.j. boersma integer i , j , k , ksen real rhs ( 0 : imax + 1 , 0 : jmax + 1 , 0 : kmax + 1 ), dx ( 0 : IMAX + 1 ), dxh ( 1 : IMAX + 1 ), dy real , allocatable , dimension (:,:,:) :: rhs2 real , allocatable , dimension (:) :: work integer ier , iperio , kperio integer ibc1 , ibc2 , kbc1 , kbc2 real dz ( 0 : kmax + 1 ), dzh ( 1 : kmax + 1 ), pi !   dz: kb-1:ke+1,  dzh: kb:ke+1 real a ( imax ), b ( imax ), c ( imax ), bin ( imax ) real az ( kmax ), bz ( kmax ), cz ( kmax ) real yrt ( jtot ) real , allocatable , dimension (:,:) :: vfftj real , allocatable , dimension (:,:) :: y real wj ( jtot + 15 ) real angle , tst integer ipos , jv real suml , sum ! ! test write !     write(6,*)'POISR, kmax, ksen, nprocs,jmax,jtot ',kmax, ksen, nprocs ,jmax,jtot allocate ( rhs2 ( imax , jtot , ksen )) allocate ( work ( 2 * imax * jmax * kmax )) allocate ( vfftj ( imax * ksen , jtot )) allocate ( y ( imax , kmax )) pi = 4. * atan ( 1. ) do i = 1 , imax a ( i ) = 1. / ( dx ( i ) * dxh ( i )) c ( i ) = 1. / ( dx ( i ) * dxh ( i + 1 )) b ( i ) = - ( a ( i ) + c ( i )) enddo if (( ibc1 ). eq . 1 ) then ! Neumann b ( 1 ) = b ( 1 ) + a ( 1 ) elseif ( ibc1 . eq . 2 ) then ! periodic b ( 1 ) = b ( 1 ) elseif ( ibc1 . eq . 3 ) then ! Dir b ( 1 ) = b ( 1 ) - a ( 1 ) endif if (( ibc2 ). eq . 1 ) then ! Neumann b ( imax ) = b ( imax ) + c ( imax ) elseif (( ibc2 ). eq . 2 ) then b ( imax ) = b ( imax ) elseif (( ibc2 ). eq . 3 ) then !         b(imax) = b(imax) - c(kmax)   ! Jasper T. : bug? Should be b(imax) - c(imax)? b ( imax ) = b ( imax ) - c ( imax ) endif if ( ibc1 . ne . 2 ) then c ( imax ) = 0. a ( 1 ) = 0. endif !     do i=1,imax !        write(6,*)'i, abc(i)',i, a(i),b(i),c(i) !     enddo ! ! fill coefficients in k-direction !      do k=1,kmax                          ! Mathieu's version !         az(k) =  1./(dz(k)*dzh(k-1)) !         cz(k) =  1./(dz(k)*dzh(k)) !         bz(k) =  - (az(k) + cz(k)) !      enddo do k = 1 , kmax az ( k ) = 1. / ( dz ( k ) * dzh ( k )) cz ( k ) = 1. / ( dz ( k ) * dzh ( k + 1 )) bz ( k ) = - ( az ( k ) + cz ( k )) enddo ! ! BC: ! !periodic     bz(1)    = bz(1) - az(1) !periodic      az(1)    = 0. !periodic     bz(kmax) = bz(kmax) - az(kmax) !periodic      az(kmax) = 0. if (( kbc1 ). eq . 1 ) then ! Neumann bz ( 1 ) = bz ( 1 ) + az ( 1 ) elseif ( kbc1 . eq . 2 ) then ! periodic bz ( 1 ) = bz ( 1 ) endif if (( kbc2 ). eq . 1 ) then ! Neumann bz ( kmax ) = bz ( kmax ) + cz ( kmax ) elseif (( kbc2 ). eq . 2 ) then bz ( kmax ) = bz ( kmax ) elseif (( kbc2 ). eq . 3 ) then ! ! p = 0. bz ( kmax ) = bz ( kmax ) - cz ( kmax ) endif if ( kbc1 . ne . 2 ) then cz ( kmax ) = 0. az ( 1 ) = 0. endif !     do k=1,kmax !        write(6,*)'k, abc(k)',k, az(k),bz(k),cz(k) !     enddo ! ! initialise for FFT ! PAR !     call vrffti(jmax,wj) call vrffti ( jtot , wj ) ! yrt ( 1 ) = 0. ! PAR !     yrt(jmax)=-4./(dy*dy) yrt ( jtot ) =- 4. / ( dy * dy ) do j = 3 , jtot , 2 ! ! 2.*(cos2(alpha) -1) = 2.*(-2.*sin(alpha)**2 yrt ( j - 1 ) = ( - 4. / ( dy * dy )) * ( sin ( float (( j - 1 )) * pi / ( 2. * jtot ))) ** 2 yrt ( j ) = yrt ( j - 1 ) enddo !     help = rhs ! ! sum check (comment out if not deeded) ! !!      suml = 0. !!      do k=1,kmax !!         do j=1,jmax !!         do i=1,imax !!         suml = suml + rhs(i,j,k)*dx(i)*dy*dz(k) !!         enddo !!         enddo !!      enddo !!      call MPI_ALLREDUCE(suml, sum, 1, MY_REAL, MPI_SUM, comm3d,mpierr) !!      if(myid.eq.0) write(6,*)'solver sum = ', sum ! ! end sum check ! call barrou () call ALL_ALL_j2 ( rhs , rhs2 , 0 , ksen ) call barrou () do k = 1 , ksen do i = 1 , imax ipos = ( k - 1 ) * imax + i do j = 1 , jtot vfftj ( ipos , j ) = rhs2 ( i , j , k ) !     suml = suml + rhs2(i,j,k)*dy*dz(k)*dx(i) enddo enddo enddo !     call MPI_ALLREDUCE(suml, sum, 1, MY_REAL, MPI_SUM, comm3d,mpierr) !     if(myid.eq.0) write(6,*)'solver sum = ', sum ! call vrfftf ( imax * ksen , jtot , vfftj , rhs2 , imax * ksen , wj ) ! !      goto 1234 do k = 1 , ksen do i = 1 , imax ipos = ( k - 1 ) * imax + i do j = 1 , jtot rhs2 ( i , j , k ) = vfftj ( ipos , j ) enddo enddo enddo call barrou () call ALL_ALL_j2 ( rhs , rhs2 , 1 , ksen ) call barrou () !     call sumchk3(rhs,imax,jmax,kmax,8,1) ! PAR CHECK!!! do j = 1 , jmax ! begin loop over angles !     do j=1,jtot       ! begin loop over angles ! ! add proper part to diagonal jv = j + myid * jmax do i = 1 , imax ! PAR CHECK!! bin ( i ) = b ( i ) + yrt ( jv ) !!!!!!!!!/(Rp(i)**2) enddo !ATTT      do k=1,ksen do k = 1 , kmax do i = 1 , imax ipos = ( k - 1 ) * imax + i !PAR CHECK y ( i , k ) = rhs ( i , j , k ) !vfftj(ipos,j) enddo enddo iperio = 1 kperio = 1 if ( ibc1 . eq . 2 ) iperio = 0 ! i periodic if ( kbc1 . eq . 2 ) kperio = 0 ! k periodic if ( poisrcheck . eq . 0 ) then poisrcheck = 1 CALL BLKTRI ( 0 , kperio , kmax , az , bz , cz , iperio , imax , a , bin , c , imax , y & ! !                   &#94; 0 for periodic BC , ier , work ) !     write(6,*)'ier = ', ier, iperio, kperio !     if(ier.ne.0)stop 'IER' worksave = work write ( 6 , * ) 'First time step in POISR, poisrcheck=' , poisrcheck end if CALL BLKTRI ( 1 , kperio , kmax , az , bz , cz , iperio , imax , a , bin , c , imax , y & , ier , worksave ) ! !     write(6,*)'myid, ier = ', myid, ier, j !      if(ier.ne.0)stop 'IER' do k = 1 , kmax do i = 1 , imax ipos = ( k - 1 ) * imax + i !PAR CHECK !        vfftj(ipos,j) = y(i,k) rhs ( i , j , k ) = y ( i , k ) enddo enddo enddo ! end loop over angles 1234 continue !     call sumchk3(rhs,imax,jmax,kmax,9,1) ! call barrou () call ALL_ALL_j2 ( rhs , rhs2 , 0 , ksen ) call barrou () ! do k = 1 , ksen do i = 1 , imax ipos = ( k - 1 ) * imax + i do j = 1 , jtot vfftj ( ipos , j ) = rhs2 ( i , j , k ) enddo enddo enddo call vrfftb ( imax * ksen , jtot , vfftj , rhs2 , imax * ksen , wj ) !!ATTTT      dok=1,kmax do k = 1 , ksen do i = 1 , imax ipos = ( k - 1 ) * imax + i do j = 1 , jtot rhs2 ( i , j , k ) = vfftj ( ipos , j ) !     if(abs(rhs(i,j,k)-help(i,j,k)).gt.1.e-13)then !       write(6,*)'ERRR', i, j, k, rhs(i,j,k), help(i,j,k) !     endif enddo enddo enddo call barrou () call ALL_ALL_j2 ( rhs , rhs2 , 1 , ksen ) call barrou () !     call sumchk3(rhs,imax,jmax,kmax,2,1) deallocate ( rhs2 ) deallocate ( work ) deallocate ( vfftj ) deallocate ( y ) return end subroutine poisr","tags":"","loc":"proc/poisr.html"},{"title":"solmpj – uDALES","text":"private subroutine solmpj(p1) Uses modmpi modglobal proc~~solmpj~~UsesGraph proc~solmpj solmpj module~modmpi modmpi proc~solmpj->module~modmpi module~modglobal modglobal proc~solmpj->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real :: p1 (0:imax+1,0:jmax+1,0:kmax+1) Calls proc~~solmpj~~CallsGraph proc~solmpj solmpj rffti rffti proc~solmpj->rffti float float proc~solmpj->float proc~all_all_j ALL_ALL_j proc~solmpj->proc~all_all_j mpi_comm_size mpi_comm_size proc~solmpj->mpi_comm_size rfftf rfftf proc~solmpj->rfftf rfftb rfftb proc~solmpj->rfftb mpi_comm_rank mpi_comm_rank proc~solmpj->mpi_comm_rank mpi_alltoall mpi_alltoall proc~all_all_j->mpi_alltoall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~solmpj~~CalledByGraph proc~solmpj solmpj proc~poisson poisson proc~poisson->proc~solmpj program~dalesurban DALESURBAN program~dalesurban->proc~poisson Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code solmpj Source Code subroutine solmpj ( p1 ) ! version: working version, barrou's removed, !          correct timing fft's !          AAPC with MPI-provided routines !          uses only 2 AAPC, using MPI-rovided routines, !          to pre-distribute the arrays s.t. complete !          2-D planes are present on each processor !          uses ALLTOALL instead of ALLTOALLV !          ONLY distribution in j-direction allowed ! NOTE: input array p1 is supposed to have the ip1ray distribution, !       i.e. the entire range of the first index must be present on !       each processor !****************************************************************** !********************  FAST POISSON SOLVER ************************ !*****                                                        ***** !***               P_xx + P_yy + P_zz  =f(x,y,z)                *** !****                                                         ***** !****************************************************************** !   FOURIER TRANSFORMS IN X AND Y DIRECTION   GIVE: !   a&#94;2 P + b&#94;2 P + P_zz =  F(x,y,z) = FFT_i [ FTT_j (f(x,y,z))] !   where a and b are the KNOWN eigenvalues, and P_zz is !   P_zz =[ P_{i,j,k+1} - 2 P_{i,j,k} +P_{i,j,k-1} ] / (dz * dz) !   a&#94;2 P + b&#94;2 +P_zz = !   [P_{i,j,k+1}-(2+a&#94;2+ b&#94;2) P_{i,j,k}+P_{i,j,k-1}]/(dz*dz)=F( x,y,z) !   The equation above results in a tridiagonal system in k which !   can be solved with Gaussian elemination --> P !   The P we have found with the Gaussian elemination is still in !   the Fourier Space and 2 backward FFTS are necessary to compute !   the physical P !****************************************************************** !****************************************************************** !****************************************************************** !****   Programmer: Bendiks Jan Boersma                      ****** !****               email : b.j.boersma@wbmt.tudelft.nl      ****** !****                                                        ****** !****   USES      :  VFFTPACK   (netlib)                     ****** !****             :  FFTPACK    (netlib)                     ****** !****                (B.J. Boersma & L.J.P. Timmermans)      ****** !****                                                        ****** !****************************************************************** !****************************************************************** ! mpi-version, no master region for timing !              copy times all included use modmpi , only : myid , comm3d , mpierr , nprocs , barrou use modglobal , only : imax , jmax , kmax , isen , jtot , pi , dyi , dzf , dzh , dxfi , kb , ke , kh !, rhoa !    use modfields, only : rhobf, rhobh implicit none real :: dxi integer :: i1 , j1 , k1 !   real, intent(inout), dimension(:,:,:) :: p1 real p1 ( 0 : imax + 1 , 0 : jmax + 1 , 0 : kmax + 1 ) real , allocatable , dimension (:,:,:) :: d , p2 real , allocatable , dimension (:,:,:) :: xyzrt real , allocatable , dimension (:) :: xrt , yrt , a , b , c , FFTI , FFTJ , winew , wjnew , rhobf , rhobh real z , ak , bk , bbk , fac integer jv integer i , j , k !real dzl(ke+kh-(kb-kh)),dzhl(ke+kh-(kb-kh)) real dzl ( 0 : kmax + 1 ), dzhl ( 1 : kmax + 1 ) dxi = dxfi ( 1 ) dzl ( 0 : kmax + 1 ) = dzf ( kb - kh : ke + kh ) dzhl ( 1 : kmax + 1 ) = dzh ( kb : ke + kh ) i1 = imax + 1 j1 = jmax + 1 k1 = kmax + 1 !   allocate(p1(0:i1,0:j1,0:k1)) ! p and d distributed equally: allocate ( d ( imax , jmax , kmax )) ! re-distributed p: allocate ( p2 ( isen , jtot , kmax )) ! re-distributed p1: allocate ( rhobf ( 1 : kmax ), rhobh ( 1 : kmax + 1 )) allocate ( xyzrt ( 0 : i1 , 0 : j1 , 0 : k1 ), xrt ( 0 : i1 ), yrt ( 0 : jtot + 1 )) allocate ( a ( 0 : kmax + 1 ), b ( 0 : kmax + 1 ), c ( 0 : kmax + 1 )) allocate ( FFTI ( imax ), FFTJ ( jtot ), winew ( 2 * imax + 15 ), wjnew ( 2 * jtot + 15 )) rhobf = 1 ; rhobh = 1 ; call MPI_COMM_RANK ( comm3d , myid , mpierr ) call MPI_COMM_SIZE ( comm3d , nprocs , mpierr ) call rffti ( imax , winew ) call rffti ( jtot , wjnew ) !     call barrou() !FFT  ---> I direction fac = 1. / sqrt ( imax * 1. ) do k = 1 , kmax do j = 1 , jmax do i = 1 , imax FFTI ( i ) = p1 ( i , j , k ) end do call rfftf ( imax , FFTI , winew ) do i = 1 , imax ! ATT: First back to p1, then re-distribution!!! p1 ( i , j , k ) = FFTI ( i ) * fac end do end do end do call ALL_ALL_j ( p1 , p2 , 0 ) !FFT  ---> J direction fac = 1. / sqrt ( jtot * 1. ) do i = 1 , isen do k = 1 , kmax do j = 1 , jtot FFTJ ( j ) = p2 ( i , j , k ) end do call rfftf ( jtot , FFTJ , wjnew ) do j = 1 , jtot ! ATTT back to pl p2 ( i , j , k ) = FFTJ ( j ) * fac end do end do end do !     call barrou() call ALL_ALL_j ( p1 , p2 , 1 ) !     call barrou() ! Generate Eigenvalues  (xrt and yrt ) !  I --> direction fac = 1. / ( 2. * imax ) do i = 3 , imax , 2 xrt ( i - 1 ) =- 4. * dxi * dxi * ( sin ( float (( i - 1 )) * pi * fac )) ** 2 xrt ( i ) = xrt ( i - 1 ) end do xrt ( 1 ) = 0. xrt ( imax ) = - 4. * dxi * dxi !  J --> direction fac = 1. / ( 2. * jtot ) do j = 3 , jtot , 2 yrt ( j - 1 ) =- 4. * dyi * dyi * ( sin ( float (( j - 1 )) * pi * fac )) ** 2 yrt ( j ) = yrt ( j - 1 ) end do yrt ( 1 ) = 0. yrt ( jtot ) = - 4. * dyi * dyi ! Generate tridiagonal matrix ! NOTE -- dzfm dzh are defined from 0 -- hence ..-1 do k = 1 , kmax ! SB fixed the coefficients a ( k ) = rhobh ( k ) / ( dzl ( k ) * dzhl ( k )) c ( k ) = rhobh ( k + 1 ) / ( dzl ( k ) * dzhl ( k + 1 )) b ( k ) =- ( a ( k ) + c ( k )) end do b ( 1 ) = b ( 1 ) + a ( 1 ) a ( 1 ) = 0. b ( kmax ) = b ( kmax ) + c ( kmax ) c ( kmax ) = 0. do k = 1 , kmax do j = 1 , jmax jv = j + myid * jmax do i = 1 , imax xyzrt ( i , j , k ) = rhobf ( k ) * ( xrt ( i ) + yrt ( jv )) !!! LH end do end do end do ! SOLVE TRIDIAGONAL SYSTEMS WITH GAUSSIAN ELEMINATION do j = 1 , jmax jv = j + myid * jmax do i = 1 , imax z = 1. / ( b ( 1 ) + xyzrt ( i , j , 1 )) d ( i , j , 1 ) = c ( 1 ) * z p1 ( i , j , 1 ) = p1 ( i , j , 1 ) * z end do end do do k = 2 , kmax - 1 do j = 1 , jmax jv = j + myid * jmax do i = 1 , imax bbk = b ( k ) + xyzrt ( i , j , k ) z = 1. / ( bbk - a ( k ) * d ( i , j , k - 1 )) d ( i , j , k ) = c ( k ) * z p1 ( i , j , k ) = ( p1 ( i , j , k ) - a ( k ) * p1 ( i , j , k - 1 )) * z end do end do end do ak = a ( kmax ) bk = b ( kmax ) do j = 1 , jmax jv = j + myid * jmax do i = 1 , imax bbk = bk + xyzrt ( i , j , kmax ) z = bbk - ak * d ( i , j , kmax - 1 ) if ( z /= 0. ) then p1 ( i , j , kmax ) = ( p1 ( i , j , kmax ) - ak * p1 ( i , j , kmax - 1 )) / z else p1 ( i , j , kmax ) = 0. end if end do end do do k = kmax - 1 , 1 , - 1 do j = 1 , jmax do i = 1 , imax p1 ( i , j , k ) = p1 ( i , j , k ) - d ( i , j , k ) * p1 ( i , j , k + 1 ) end do end do end do !     call barrou() ! MPI_ALL CALL!!! call ALL_ALL_j ( p1 , p2 , 0 ) !     call barrou() ! BACKWARD FFT ---> I direction ! BACKWARD FFT ---> J direction fac = 1. / sqrt ( jtot * 1. ) do i = 1 , isen do k = 1 , kmax do j = 1 , jtot ! ATT, ADAPTED!!! FFTJ ( j ) = p2 ( i , j , k ) end do call rfftb ( jtot , FFTJ , wjnew ) do j = 1 , jtot ! ATT back to p2!!! p2 ( i , j , k ) = FFTJ ( j ) * fac end do end do end do !     call barrou() call ALL_ALL_j ( p1 , p2 , 1 ) fac = 1. / sqrt ( imax * 1. ) do k = 1 , kmax do j = 1 , jmax do i = 1 , imax FFTI ( i ) = p1 ( i , j , k ) end do call rfftb ( imax , FFTI , winew ) do i = 1 , imax ! ATT back to p1 !!! p1 ( i , j , k ) = FFTI ( i ) * fac end do end do end do deallocate ( d , p2 , xyzrt , xrt , yrt , a , b , c , FFTI , FFTJ , winew , wjnew ) !     call barrou() return end subroutine solmpj","tags":"","loc":"proc/solmpj.html"},{"title":"initthermodynamics – uDALES","text":"public subroutine initthermodynamics() Uses modglobal proc~~initthermodynamics~~UsesGraph proc~initthermodynamics initthermodynamics module~modglobal modglobal proc~initthermodynamics->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~initthermodynamics~~CalledByGraph proc~initthermodynamics initthermodynamics proc~startup startup proc~startup->proc~initthermodynamics program~dalesurban DALESURBAN program~dalesurban->proc~startup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code initthermodynamics Source Code subroutine initthermodynamics use modglobal , only : kb , ke , kh , ib , ie , jb , je implicit none allocate ( th0av ( kb : ke + kh )) allocate ( thv0 ( ib : ie , jb : je , kb : ke + kh )) th0av = 0. end subroutine initthermodynamics","tags":"","loc":"proc/initthermodynamics.html"},{"title":"thermodynamics – uDALES","text":"public subroutine thermodynamics() Uses modglobal modfields modmpi proc~~thermodynamics~~UsesGraph proc~thermodynamics thermodynamics module~modmpi modmpi proc~thermodynamics->module~modmpi module~modfields modfields proc~thermodynamics->module~modfields module~modglobal modglobal proc~thermodynamics->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~thermodynamics~~CallsGraph proc~thermodynamics thermodynamics proc~diagfld diagfld proc~thermodynamics->proc~diagfld proc~thermo thermo proc~thermodynamics->proc~thermo proc~calc_halflev calc_halflev proc~thermodynamics->proc~calc_halflev proc~calthv calthv proc~thermodynamics->proc~calthv proc~fromztop fromztop proc~diagfld->proc~fromztop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~thermodynamics~~CalledByGraph proc~thermodynamics thermodynamics proc~readinitfiles readinitfiles proc~readinitfiles->proc~thermodynamics program~dalesurban DALESURBAN program~dalesurban->proc~thermodynamics proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code thermodynamics Source Code subroutine thermodynamics use modglobal , only : lmoist , timee , kb , ke , kh , ib , ih , ie , jb , jh , je , rlv , cp , rslabs , rd , rv , libm , eps1 use modfields , only : thl0 , thl0h , qt0 , qt0h , ql0 , ql0h , presf , presh , exnf , exnh , thvh , thv0h , qt0av , ql0av , thvf , rhof , IIc , IIw , IIcs , IIws use modmpi , only : slabsum , avexy_ibm , myid !ILS13 added variables behind \"exnh\" implicit none integer :: k if ( timee == 0 ) call diagfld if ( lmoist ) then call thermo ( thl0 , qt0 , ql0 , presf , exnf ) end if call diagfld call calc_halflev !calculate halflevel values of qt0 and thl0 if ( lmoist ) then call thermo ( thl0h , qt0h , ql0h , presh , exnh ) end if call calthv !ILS13 introduced from DALES4.0   13.05.2015 thvh = 0. !    call slabsum(thvh,kb,ke+kh,thv0h(:,:,kb:ke+kh),ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) !redefine halflevel thv using calculated thv !    thvh = thvh/rslabs call avexy_ibm ( thvh ( kb : ke + kh ), thv0h ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. false .) !    if (libm) then !      call avexy_ibm(thvh(kb:ke),thv0h(ib:ie,jb:je,kb:ke),ib,ie,jb,je,kb,ke,IIw(ib:ie,jb:je,kb:ke),IIws(kb:ke)) !    else !      call slabsum(thvh,kb,ke+kh,thv0h(:,:,kb:ke+kh),ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) !     !redefine halflevel thv using calculated thv !     thvh = thvh/rslabs !    end if thvh ( kb ) = th0av ( kb ) * ( 1 + ( rv / rd - 1 ) * qt0av ( kb ) - rv / rd * ql0av ( kb )) ! override first level if ( abs ( thvh ( kb + 1 )) < eps1 ) then thvh ( kb + 1 ) = th0av ( kb + 1 ) * ( 1 + ( rv / rd - 1 ) * qt0av ( kb + 1 ) - rv / rd * ql0av ( kb + 1 )) ! override second level if all blocks at kb end if !    where (thvh==0) !override slabs completely covered by blocks !      thvh = th0av(kb)*(1+(rv/rd-1)*qt0av(kb)-rv/rd*ql0av(kb)) !    endwhere do k = kb , ke + kh !    thv0(ib+ih:ie,jb+jh:je,k) = (thl0(ib+ih:ie,jb+ih:je,k)+rlv*ql0(ib+ih:ie,jb+ih:je,k)/(cp*exnf(k)))*(1+(rv/rd-1)*qt0(ib+ih:ie,jb+ih:je,k)-rv/rd*ql0(ib+ih:ie,jb+ih:je,k)) thv0 ( ib : ie , jb : je , k ) = ( thl0 ( ib : ie , jb : je , k ) + rlv * ql0 ( ib : ie , jb : je , k ) / ( cp * exnf ( k ))) * ( 1 + ( rv / rd - 1 ) * qt0 ( ib : ie , jb : je , k ) - rv / rd * ql0 ( ib : ie , jb : je , k )) enddo thvf = 0.0 !write(*,*) \"thv0\",thv0 !    call slabsum(thvf,kb,ke+kh,thv0,ib,ie+ih,jb,je+jh,kb,ke+kh,ib+ih,ie,jb+ih,je,kb,ke+kh) !    call slabsum(thvf,kb,ke+kh,thv0,ib,ie,jb,je,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( thvf ( kb : ke + kh ), thv0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) !    write(*,*) 'IIc(2,2,:), myid' , IIc(12,2,:), myid !    where (thvf==0) !override slabs completely covered by blocks !      thvf = th0av(kb)*(1+(rv/rd-1)*qt0av(kb)-rv/rd*ql0av(kb)) !    endwhere !    thvf = thvf/rslabs !write(*,*) \"thvf\",thvf !write(*,*) \"exnf\",exnf !    do k=1,k1 !      rhof(k) = presf(k)/(rd*thvf(k)*exnf(k)) !    end do end subroutine thermodynamics","tags":"","loc":"proc/thermodynamics.html"},{"title":"exitthermodynamics – uDALES","text":"public subroutine exitthermodynamics() Arguments None Called by proc~~exitthermodynamics~~CalledByGraph proc~exitthermodynamics exitthermodynamics proc~exitmodules exitmodules proc~exitmodules->proc~exitthermodynamics program~dalesurban DALESURBAN program~dalesurban->proc~exitmodules Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code exitthermodynamics Source Code subroutine exitthermodynamics implicit none deallocate ( th0av ) end subroutine exitthermodynamics","tags":"","loc":"proc/exitthermodynamics.html"},{"title":"calthv – uDALES","text":"public subroutine calthv() Uses modglobal modfields modsurfdata proc~~calthv~~UsesGraph proc~calthv calthv module~modfields modfields proc~calthv->module~modfields module~modglobal modglobal proc~calthv->module~modglobal module~modsurfdata modsurfdata proc~calthv->module~modsurfdata Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~calthv~~CalledByGraph proc~calthv calthv proc~thermodynamics thermodynamics proc~thermodynamics->proc~calthv proc~readinitfiles readinitfiles proc~readinitfiles->proc~thermodynamics program~dalesurban DALESURBAN program~dalesurban->proc~thermodynamics proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code calthv Source Code subroutine calthv use modglobal , only : lmoist , ib , ie , jb , je , kb , ke , kh , zf , zh , dzh , rlv , rd , rv , cp , eps1 use modfields , only : thl0 , thl0h , ql0 , ql0h , qt0 , qt0h , sv0 , exnf , exnh , thv0h , dthvdz use modsurfdata , only : dthldz , dqtdz implicit none integer i , j , k real qs real c1 , c2 , dq , dth , dthv , temp real a_dry , b_dry , a_moist , b_moist , c_liquid , epsilon , eps_I , chi_sat , chi real del_thv_sat , del_thv_dry dthvdz = 0.0 if ( lmoist ) then do k = kb , ke + kh do j = jb , je do i = ib , ie thv0h ( i , j , k ) = ( thl0h ( i , j , k ) + rlv * ql0h ( i , j , k ) / ( cp * exnh ( k ))) & * ( 1 + ( rv / rd - 1 ) * qt0h ( i , j , k ) - rv / rd * ql0h ( i , j , k )) end do end do end do do k = kb + 1 , ke do j = jb , je do i = ib , ie ! !         default thv jump computed unsaturated ! epsilon = rd / rv eps_I = 1 / epsilon - 1. !cstep approx 0.608 a_dry = 1. + eps_I * qt0 ( i , j , k ) b_dry = eps_I * thl0 ( i , j , k ) dth = thl0 ( i , j , k + 1 ) - thl0 ( i , j , k - 1 ) dq = qt0 ( i , j , k + 1 ) - qt0 ( i , j , k - 1 ) del_thv_dry = a_dry * dth + b_dry * dq dthv = del_thv_dry if ( ql0 ( i , j , k ) > 0 ) then !include moist thermodynamics temp = thl0 ( i , j , k ) * exnf ( k ) + ( rlv / cp ) * ql0 ( i , j , k ) qs = qt0 ( i , j , k ) - ql0 ( i , j , k ) a_moist = ( 1. - qt0 ( i , j , k ) + qs / epsilon * ( 1. + rlv / ( rv * temp ))) & / ( 1. + rlv ** 2 * qs / ( cp * rv * temp ** 2 )) b_moist = a_moist * rlv / cp - temp c_liquid = a_dry * rlv / cp - thl0 ( i , j , k ) / epsilon del_thv_sat = a_moist * dth + b_moist * dq chi = 2 * chi_half * ( zf ( k ) - zf ( k - 1 )) / ( dzh ( k ) + dzh ( k + 1 )) chi_sat = c_liquid * ql0 ( i , j , k ) / ( del_thv_dry - del_thv_sat ) if ( chi < chi_sat ) then !mixed parcel is saturated dthv = del_thv_sat end if end if dthvdz ( i , j , k ) = dthv / ( dzh ( k + 1 ) + dzh ( k )) end do end do end do do j = jb , je do i = ib , ie dthvdz ( i , j , kb ) = 0. end do end do else !      thv0h = thl0h thv0h = thl0h (:,:, kb : ke + kh ) do k = kb + 1 , ke do j = jb , je do i = ib , ie dthvdz ( i , j , k ) = ( thl0 ( i , j , k + 1 ) - thl0 ( i , j , k - 1 )) / ( dzh ( k + 1 ) + dzh ( k )) end do end do end do do j = jb , je do i = ib , ie dthvdz ( i , j , kb ) = 0. end do end do end if !CvH remove WHERE !where (abs(dthvdz)<eps1) !  dthvdz = sign(eps1,dthvdz) !end where do k = kb , ke do j = jb , je do i = ib , ie if ( abs ( dthvdz ( i , j , k )) < eps1 ) then dthvdz ( i , j , k ) = sign ( eps1 , dthvdz ( i , j , k )) end if end do end do end do end subroutine calthv","tags":"","loc":"proc/calthv.html"},{"title":"diagfld – uDALES","text":"public subroutine diagfld() Uses modglobal modfields modsurfdata modmpi proc~~diagfld~~UsesGraph proc~diagfld diagfld module~modmpi modmpi proc~diagfld->module~modmpi module~modfields modfields proc~diagfld->module~modfields module~modglobal modglobal proc~diagfld->module~modglobal module~modsurfdata modsurfdata proc~diagfld->module~modsurfdata mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~diagfld~~CallsGraph proc~diagfld diagfld proc~fromztop fromztop proc~diagfld->proc~fromztop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~diagfld~~CalledByGraph proc~diagfld diagfld proc~thermodynamics thermodynamics proc~thermodynamics->proc~diagfld proc~readinitfiles readinitfiles proc~readinitfiles->proc~thermodynamics program~dalesurban DALESURBAN program~dalesurban->proc~thermodynamics proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code diagfld Source Code subroutine diagfld use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , khc , nsv , zh , zf , rslabs , grav , rlv , cp , rd , rv , pref0 use modfields , only : u0 , v0 , thl0 , qt0 , ql0 , sv0 , u0av , v0av , thl0av , qt0av , ql0av , sv0av , & presf , presh , exnf , exnh , rhof , thvf , IIc , IIcs , IIu , IIus , IIv , IIvs use modsurfdata , only : thls , ps use modmpi , only : slabsum , myid , avexy_ibm implicit none real tv integer k , n !!********************************************************* !!  1.0   calculate average profiles of u,v,thl,qt and ql * !!        assuming hydrostatic equilibrium                * !!********************************************************* ! initialise local MPI arrays u0av = 0.0 v0av = 0.0 thl0av = 0.0 th0av = 0.0 qt0av = 0.0 ql0av = 0.0 sv0av = 0. !CvH changed momentum array dimensions to same value as scalars! !  call slabsum(u0av  ,kb,ke+kh,u0  ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) !    call slabsum(u0av  ,kb,ke+kh,u0(:,:,kb:ke+kh)  ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( u0av ( kb : ke + kh ), u0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIu ( ib : ie , jb : je , kb : ke + kh ), IIus ( kb : ke + kh ),. false .) !  call slabsum(v0av  ,kb,ke+kh,v0  ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) !    call slabsum(v0av  ,kb,ke+kh,v0(:,:,kb:ke+kh)  ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( v0av ( kb : ke + kh ), v0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIv ( ib : ie , jb : je , kb : ke + kh ), IIvs ( kb : ke + kh ),. false .) !  call slabsum(thl0av,kb,ke+kh,thl0,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) !    call slabsum(thl0av,kb,ke+kh,thl0(:,:,kb:ke+kh),ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( thl0av ( kb : ke + kh ), thl0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) !write(*,*) 'thl0av(kb), thl0av(kb+1)', thl0av(kb), thl0av(kb+1) !if (IIbl == 0) then ! as lEB applies blocks to kb and masking matrices average this to zero !  thl0av(kb) = thl0av(kb+1) !end if !  call slabsum(qt0av ,kb,ke+kh,qt0 ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) !    call slabsum(qt0av ,kb,ke+kh,qt0(:,:,kb:ke+kh) ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( qt0av ( kb : ke + kh ), qt0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) !    call slabsum(ql0av ,kb,ke+kh,ql0 ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( ql0av ( kb : ke + kh ), ql0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) exnf = 1 - grav * zf / ( cp * thls ) exnh = 1 - grav * zh / ( cp * thls ) th0av = thl0av + ( rlv / cp ) * ql0av / exnf !write(*,*) 'thl0av',thl0av !write(*,*) 'th0av',th0av do n = 1 , nsv !       call slabsum(sv0av(kb,n),kb,ke+kh,sv0(ib-ih,jb-jh,kb,n),ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( sv0av ( kb : ke + khc , n ), sv0 ( ib : ie , jb : je , kb : ke + khc , n ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + khc ), IIcs ( kb : ke + khc ),. false .) end do !    sv0av = sv0av/rslabs !*********************************************************** !  2.0   calculate average profile of pressure at full and * !        half levels, assuming hydrostatic equilibrium.    * !*********************************************************** !    2.1 Use first guess of theta, then recalculate theta call fromztop exnf = ( presf / pref0 ) ** ( rd / cp ) th0av = thl0av + ( rlv / cp ) * ql0av / exnf !    2.2 Use new updated value of theta for determination of pressure call fromztop !*********************************************************** !  3.0   Construct density profiles and exner function     * !       for further use in the program                     * !*********************************************************** !    3.1 determine exner exnh ( kb ) = ( ps / pref0 ) ** ( rd / cp ) exnf ( kb ) = ( presf ( kb ) / pref0 ) ** ( rd / cp ) do k = kb + 1 , ke + kh exnf ( k ) = ( presf ( k ) / pref0 ) ** ( rd / cp ) exnh ( k ) = ( presh ( k ) / pref0 ) ** ( rd / cp ) end do thvf ( kb ) = th0av ( kb ) * exnf ( kb ) * ( 1 + ( rv / rd - 1 ) * qt0av ( kb ) - rv / rd * ql0av ( kb )) rhof ( kb ) = presf ( kb ) / ( rd * thvf ( kb )) !    3.2 determine rho do k = kb + 1 , ke !+kh    ? !   write(*,*) \"exnf(k)\",exnf(k) !   write(*,*) \"th0av(k)\",th0av(k) !   write(*,*) \"qt0av(k)\",qt0av(k) !   write(*,*) \"ql0av(k)\",ql0av(k) thvf ( k ) = th0av ( k ) * exnf ( k ) * ( 1. + ( rv / rd - 1 ) * qt0av ( k ) - rv / rd * ql0av ( k )) rhof ( k ) = presf ( k ) / ( rd * thvf ( k )) end do return end subroutine diagfld","tags":"","loc":"proc/diagfld.html"},{"title":"fromztop – uDALES","text":"public subroutine fromztop() Uses modglobal modfields modsurfdata proc~~fromztop~~UsesGraph proc~fromztop fromztop module~modfields modfields proc~fromztop->module~modfields module~modglobal modglobal proc~fromztop->module~modglobal module~modsurfdata modsurfdata proc~fromztop->module~modsurfdata Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~fromztop~~CalledByGraph proc~fromztop fromztop proc~diagfld diagfld proc~diagfld->proc~fromztop proc~thermodynamics thermodynamics proc~thermodynamics->proc~diagfld proc~readinitfiles readinitfiles proc~readinitfiles->proc~thermodynamics program~dalesurban DALESURBAN program~dalesurban->proc~thermodynamics proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code fromztop Source Code subroutine fromztop use modglobal , only : kmax , kb , ke , kh , dzf , dzh , rv , rd , cp , tmelt , zf , grav , pref0 , lEB use modfields , only : qt0av , ql0av , presf , presh , thvh , thvf , IIcs use modsurfdata , only : ps , thvs implicit none integer k real rdocp real , allocatable , dimension (:) :: thetah , qth , qlh allocate ( thetah ( kb : ke + kh ), qth ( kb : ke + kh ), qlh ( kb : ke + kh )) rdocp = rd / cp !************************************************** !    1.0 Determine theta and qt at half levels    * !************************************************** do k = kb + 1 , ke + kh thetah ( k ) = ( th0av ( k ) * dzf ( k - 1 ) + th0av ( k - 1 ) * dzf ( k )) / ( 2 * dzh ( k )) qth ( k ) = ( qt0av ( k ) * dzf ( k - 1 ) + qt0av ( k - 1 ) * dzf ( k )) / ( 2 * dzh ( k )) qlh ( k ) = ( ql0av ( k ) * dzf ( k - 1 ) + ql0av ( k - 1 ) * dzf ( k )) / ( 2 * dzh ( k )) end do !************************************************** !     2.1  calculate pressures at full levels     * !          assuming hydrostatic equilibrium       * !************************************************** !     1: lowest level: use thvs thvh ( kb ) = thvs presf ( kb ) = ps ** rdocp - & grav * ( pref0 ** rdocp ) * zf ( kb ) / ( cp * thvh ( kb )) presf ( kb ) = presf ( kb ) ** ( 1. / rdocp ) !     2: higher levels do k = kb + 1 , ke + kh thvh ( k ) = thetah ( k ) * ( 1 + ( rv / rd - 1 ) * qth ( k ) - rv / rd * qlh ( k )) presf ( k ) = presf ( k - 1 ) ** rdocp - grav * ( pref0 ** rdocp ) * dzh ( k ) / ( cp * thvh ( k )) presf ( k ) = presf ( k ) ** ( 1. / rdocp ) end do !************************************************** !     2.2   calculate pressures at half levels    * !           assuming hydrostatic equilibrium      * !************************************************** presh ( kb ) = ps thvf ( kb ) = th0av ( kb ) * ( 1 + ( rv / rd - 1 ) * qt0av ( kb ) - rv / rd * ql0av ( kb )) do k = kb + 1 , ke + kh thvf ( k ) = th0av ( k ) * ( 1 + ( rv / rd - 1 ) * qt0av ( k ) - rv / rd * ql0av ( k )) presh ( k ) = presh ( k - 1 ) ** rdocp - grav * ( pref0 ** rdocp ) * dzf ( k - 1 ) / ( cp * thvf ( k - 1 )) presh ( k ) = presh ( k ) ** ( 1. / rdocp ) end do deallocate ( thetah , qth , qlh ) return end subroutine fromztop","tags":"","loc":"proc/fromztop.html"},{"title":"thermo – uDALES","text":"public subroutine thermo(thl, qt, ql, pressure, exner) Uses modglobal modsurfdata proc~~thermo~~UsesGraph proc~thermo thermo module~modglobal modglobal proc~thermo->module~modglobal module~modsurfdata modsurfdata proc~thermo->module~modsurfdata Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(in) :: thl (ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) real, intent(in) :: qt (ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) real, intent(out) :: ql (ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) real, intent(in) :: pressure (kb:ke+kh) real, intent(in) :: exner (kb:ke+kh) Called by proc~~thermo~~CalledByGraph proc~thermo thermo proc~thermodynamics thermodynamics proc~thermodynamics->proc~thermo proc~readinitfiles readinitfiles proc~readinitfiles->proc~thermodynamics program~dalesurban DALESURBAN program~dalesurban->proc~thermodynamics proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code thermo Source Code subroutine thermo ( thl , qt , ql , pressure , exner ) !  use modglobal, only : ih,jh,i1,j1,k1,es0,at,bt,rd,rv,rlv,cp,tmelt use modglobal , only : ih , jh , ib , ie , jb , je , kb , ke , kh , es0 , at , bt , rd , rv , rlv , cp , tmelt use modsurfdata , only : thls implicit none integer i , j , k real tl , es , qs , qsl , b1 !  real, intent(in)  :: qt(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh),thl(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh),exner(kb:ke+kh),pressure(kb:ke+kh) real , intent ( in ) :: qt ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ), thl ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ), exner ( kb : ke + kh ), pressure ( kb : ke + kh ) real , intent ( out ) :: ql ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) real :: Tnr , qsatur , Tnr_old integer :: niter , nitert if ( lqlnr ) then !mc      calculation of T with Newton-Raphson method !mc      first guess is Tnr=tl !mc nitert = 0 do k = kb , ke + kh do j = jb , je do i = ib , ie tl = thl ( i , j , k ) * exner ( k ) Tnr = tl Tnr_old = 0. do while ( abs ( Tnr - Tnr_old ) / Tnr > 1e-5 ) niter = niter + 1 Tnr_old = Tnr es = es0 * exp ( at * ( Tnr - tmelt ) / ( Tnr - bt )) qsatur = rd / rv * es / ( pressure ( k ) - ( 1 - rd / rv ) * es ) Tnr = Tnr - ( Tnr + ( rlv / cp ) * qsatur - tl - & ( rlv / cp ) * qt ( i , j , k )) / ( 1 + ( rlv ** 2 * qsatur ) / & ( rv * cp * Tnr ** 2 )) end do nitert = max ( nitert , niter ) niter = 0 ql ( i , j , k ) = dim ( qt ( i , j , k ) - qsatur , 0. ) end do end do end do else do k = kb , ke + kh do j = jb , je do i = ib , ie tl = thl ( i , j , k ) * exner ( k ) es = es0 * exp ( at * ( tl - tmelt ) / ( tl - bt )) qsl = rd / rv * es / ( pressure ( k ) - ( 1 - rd / rv ) * es ) b1 = rlv ** 2 / ( tl ** 2 * cp * rv ) qs = qsl * ( 1. + b1 * qt ( i , j , k )) / ( 1. + b1 * qsl ) ql ( i , j , k ) = dim ( qt ( i , j , k ) - qs , 0. ) end do end do end do end if return end subroutine thermo","tags":"","loc":"proc/thermo.html"},{"title":"calc_halflev – uDALES","text":"public subroutine calc_halflev() Uses modglobal modfields modsurfdata proc~~calc_halflev~~UsesGraph proc~calc_halflev calc_halflev module~modfields modfields proc~calc_halflev->module~modfields module~modglobal modglobal proc~calc_halflev->module~modglobal module~modsurfdata modsurfdata proc~calc_halflev->module~modsurfdata Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~calc_halflev~~CalledByGraph proc~calc_halflev calc_halflev proc~thermodynamics thermodynamics proc~thermodynamics->proc~calc_halflev proc~readinitfiles readinitfiles proc~readinitfiles->proc~calc_halflev proc~readinitfiles->proc~thermodynamics proc~startup startup proc~startup->proc~readinitfiles program~dalesurban DALESURBAN program~dalesurban->proc~thermodynamics program~dalesurban->proc~startup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code calc_halflev Source Code subroutine calc_halflev use modglobal , only : ib , ie , jb , je , kb , ke , kh , dzf , dzh , iadv_thl , iadv_qt , iadv_kappa use modfields , only : thl0 , thl0h , qt0 , qt0h use modsurfdata , only : qts , thls implicit none integer :: i , j , k !      do  k=kb+1,ke+kh do k = kb , ke + kh do j = jb , je do i = ib , ie thl0h ( i , j , k ) = ( thl0 ( i , j , k ) * dzf ( k - 1 ) + thl0 ( i , j , k - 1 ) * dzf ( k )) / ( 2 * dzh ( k )) end do end do end do thl0h ( ib : ie , jb : je , kb ) = thls !      do  k=kb+1,ke+kh do k = kb , ke + kh do j = jb , je do i = ib , ie qt0h ( i , j , k ) = ( qt0 ( i , j , k ) * dzf ( k - 1 ) + qt0 ( i , j , k - 1 ) * dzf ( k )) / ( 2 * dzh ( k )) end do end do end do qt0h ( ib : ie , jb : je , kb ) = qts end subroutine calc_halflev","tags":"","loc":"proc/calc_halflev.html"},{"title":"initfielddump – uDALES","text":"public subroutine initfielddump() Uses modmpi modglobal modstat_nc modfields proc~~initfielddump~~UsesGraph proc~initfielddump initfielddump module~modmpi modmpi proc~initfielddump->module~modmpi module~modfields modfields proc~initfielddump->module~modfields module~modstat_nc modstat_nc proc~initfielddump->module~modstat_nc module~modglobal modglobal proc~initfielddump->module~modglobal mpi mpi module~modmpi->mpi module~modstat_nc->module~modmpi netcdf netcdf module~modstat_nc->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~initfielddump~~CallsGraph proc~initfielddump initfielddump proc~writestat_dims_nc writestat_dims_nc proc~initfielddump->proc~writestat_dims_nc mpi_bcast mpi_bcast proc~initfielddump->mpi_bcast proc~define_nc define_nc proc~initfielddump->proc~define_nc proc~open_nc open_nc proc~initfielddump->proc~open_nc nf90_put_var nf90_put_var proc~writestat_dims_nc->nf90_put_var nf90_inquire_dimension nf90_inquire_dimension proc~writestat_dims_nc->nf90_inquire_dimension nf90_inq_varid nf90_inq_varid proc~writestat_dims_nc->nf90_inq_varid nf90_put_att nf90_put_att proc~define_nc->nf90_put_att nf90_redef nf90_redef proc~define_nc->nf90_redef nf90_def_var nf90_def_var proc~define_nc->nf90_def_var proc~define_nc->nf90_inq_varid nf90_inq_dimid nf90_inq_dimid proc~define_nc->nf90_inq_dimid nf90_enddef nf90_enddef proc~define_nc->nf90_enddef proc~nchandle_error nchandle_error proc~define_nc->proc~nchandle_error proc~open_nc->nf90_put_att nf90_def_dim nf90_def_dim proc~open_nc->nf90_def_dim proc~open_nc->nf90_inquire_dimension proc~open_nc->nf90_def_var proc~open_nc->nf90_inq_varid nf90_inquire nf90_inquire proc~open_nc->nf90_inquire nf90_open nf90_open proc~open_nc->nf90_open proc~open_nc->nf90_inq_dimid nf90_create nf90_create proc~open_nc->nf90_create nf90_get_var nf90_get_var proc~open_nc->nf90_get_var proc~open_nc->nf90_enddef nf90_sync nf90_sync proc~open_nc->nf90_sync nf90_strerror nf90_strerror proc~nchandle_error->nf90_strerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~initfielddump~~CalledByGraph proc~initfielddump initfielddump program~dalesurban DALESURBAN program~dalesurban->proc~initfielddump Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code initfielddump Source Code subroutine initfielddump use modmpi , only : myid , my_real , mpierr , comm3d , mpi_logical , mpi_integer , cmyid , mpi_character use modglobal , only : imax , jmax , kmax , cexpnr , ifnamopt , fname_options , dtmax , kb , ke , ladaptive , dt_lim , btime , nsv , fieldvars , ib , ie , jb , je , kb , ke , lfielddump use modstat_nc , only : open_nc , define_nc , ncinfo , writestat_dims_nc use modfields , only : u0 , v0 , w0 , thl0 , sv0 , ql0 , qt0 , pres0 implicit none integer :: ierr !  type(domainptr), dimension(nvar) :: pfields nvar = ( LEN ( trim ( fieldvars )) + 1 ) / 3 if ( nvar == 0 ) then lfielddump = . false . print * , 'empty fieldvars therefore lfielddump = .false. and no instantaneous fields outputted' return else allocate ( ncname ( nvar , 4 )) end if klow = kb khigh = ke !ils13 13.08.18: why is this broadcast, doesn't every processor do it anyway? call MPI_BCAST ( klow , 1 , MPI_INTEGER , 0 , comm3d , ierr ) call MPI_BCAST ( khigh , 1 , MPI_INTEGER , 0 , comm3d , ierr ) call MPI_BCAST ( lfielddump , 1 , MPI_LOGICAL , 0 , comm3d , ierr ) call MPI_BCAST ( ldiracc , 1 , MPI_LOGICAL , 0 , comm3d , ierr ) call MPI_BCAST ( lbinary , 1 , MPI_LOGICAL , 0 , comm3d , ierr ) call MPI_BCAST ( ncname , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( nvar , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) !    dt_lim = min(dt_lim,tnext) if (. not .( lfielddump )) return fname ( 11 : 13 ) = cmyid fname ( 15 : 17 ) = cexpnr call ncinfo ( tncname ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) ! tg3315 reads in fields specified by fieldvars do n = 1 , nvar select case ( fieldvars ( 3 * n - 2 : 3 * n - 1 )) case ( 'u0' ) call ncinfo ( ncname ( n ,:), 'u' , 'West-East velocity' , 'm/s' , 'mttt' ) pfields ( n )% point => u0 ( ib : ie , jb : je , kb : ke ) case ( 'v0' ) call ncinfo ( ncname ( n ,:), 'v' , 'South-North velocity' , 'm/s' , 'tmtt' ) pfields ( n )% point => v0 ( ib : ie , jb : je , kb : ke ) case ( 'w0' ) call ncinfo ( ncname ( n ,:), 'w' , 'Vertical velocity' , 'm/s' , 'ttmt' ) pfields ( n )% point => w0 ( ib : ie , jb : je , kb : ke ) case ( 'th' ) call ncinfo ( ncname ( n ,:), 'thl' , 'Liquid water potential temperature' , 'K' , 'tttt' ) pfields ( n )% point => thl0 ( ib : ie , jb : je , kb : ke ) case ( 'ql' ) call ncinfo ( ncname ( n ,:), 'ql' , 'Liquid water mixing ratio' , '1e-5kg/kg' , 'tttt' ) pfields ( n )% point => ql0 ( ib : ie , jb : je , kb : ke ) case ( 'qt' ) call ncinfo ( ncname ( n ,:), 'qt' , 'Total water mixing ratio' , '1e-5kg/kg' , 'tttt' ) pfields ( n )% point => qt0 ( ib : ie , jb : je , kb : ke ) case ( 's1' ) call ncinfo ( ncname ( n ,:), 'sca1' , 'scalar 1' , 'M' , 'tttt' ) pfields ( n )% point => sv0 ( ib : ie , jb : je , kb : ke , 1 ) case ( 's2' ) call ncinfo ( ncname ( n ,:), 'sca2' , 'scalar 2' , 'M' , 'tttt' ) pfields ( n )% point => sv0 ( ib : ie , jb : je , kb : ke , 2 ) case ( 's3' ) call ncinfo ( ncname ( n ,:), 'sca3' , 'scalar 3' , 'M' , 'tttt' ) pfields ( n )% point => sv0 ( ib : ie , jb : je , kb : ke , 3 ) case ( 's4' ) call ncinfo ( ncname ( n ,:), 'sca4' , 'scalar 4' , 'M' , 'tttt' ) pfields ( n )% point => sv0 ( ib : ie , jb : je , kb : ke , 4 ) case ( 's5' ) call ncinfo ( ncname ( n ,:), 'sca5' , 'scalar 5' , 'M' , 'tttt' ) pfields ( n )% point => sv0 ( ib : ie , jb : je , kb : ke , 5 ) case ( 'p0' ) call ncinfo ( ncname ( n ,:), 'pres' , 'pressure field' , 'M' , 'tttt' ) pfields ( n )% point => pres0 ( ib : ie , jb : je , kb : ke ) case default call ncinfo ( ncname ( n ,:), 'u' , 'West-East velocity' , 'm/s' , 'mttt' ) pfields ( n )% point => u0 ( ib : ie , jb : je , kb : ke ) end select end do call open_nc ( fname , ncid , nrec , n1 = imax , n2 = jmax , n3 = khigh - klow + 1 ) if ( nrec == 0 ) then call define_nc ( ncid , 1 , tncname ) call writestat_dims_nc ( ncid ) end if call define_nc ( ncid , nvar , ncname ) call open_nc ( fname , ncid , nrec , n1 = imax , n2 = jmax , n3 = khigh - klow + 1 ) !        call open_nc( fname, ncid, nrec, n1=imax+2, n2=jmax+2, n3=khigh-klow+1)  !if want to print ghostcells if ( nrec == 0 ) then write ( * , * ) \"calling define_nc\" call define_nc ( ncid , 1 , tncname ) write ( * , * ) \"calling writestat_dims_nc\" call writestat_dims_nc ( ncid ) end if call define_nc ( ncid , nvar , ncname ) end subroutine initfielddump","tags":"","loc":"proc/initfielddump.html"},{"title":"fielddump – uDALES","text":"public subroutine fielddump() Uses modfields modsurfdata modglobal modstat_nc modmpi proc~~fielddump~~UsesGraph proc~fielddump fielddump module~modsurfdata modsurfdata proc~fielddump->module~modsurfdata module~modmpi modmpi proc~fielddump->module~modmpi module~modstat_nc modstat_nc proc~fielddump->module~modstat_nc module~modfields modfields proc~fielddump->module~modfields module~modglobal modglobal proc~fielddump->module~modglobal mpi mpi module~modmpi->mpi module~modstat_nc->module~modmpi netcdf netcdf module~modstat_nc->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~fielddump~~CallsGraph proc~fielddump fielddump interface~writestat_nc writestat_nc proc~fielddump->interface~writestat_nc proc~writestat_2d_nc writestat_2D_nc interface~writestat_nc->proc~writestat_2d_nc proc~writestat_1d_nc writestat_1D_nc interface~writestat_nc->proc~writestat_1d_nc proc~writestat_time_nc writestat_time_nc interface~writestat_nc->proc~writestat_time_nc proc~writestat_3d_nc writestat_3D_nc interface~writestat_nc->proc~writestat_3d_nc proc~writestat_3d_short_nc writestat_3D_short_nc interface~writestat_nc->proc~writestat_3d_short_nc nf90_inq_varid nf90_inq_varid proc~writestat_2d_nc->nf90_inq_varid nf90_put_var nf90_put_var proc~writestat_2d_nc->nf90_put_var nf90_sync nf90_sync proc~writestat_2d_nc->nf90_sync proc~writestat_1d_nc->nf90_inq_varid proc~writestat_1d_nc->nf90_put_var proc~writestat_1d_nc->nf90_sync proc~writestat_time_nc->nf90_inq_varid proc~writestat_time_nc->nf90_put_var proc~writestat_time_nc->nf90_sync proc~writestat_3d_nc->nf90_inq_varid proc~writestat_3d_nc->nf90_put_var proc~writestat_3d_nc->nf90_sync proc~writestat_3d_short_nc->nf90_inq_varid proc~writestat_3d_short_nc->nf90_put_var proc~writestat_3d_short_nc->nf90_sync Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~fielddump~~CalledByGraph proc~fielddump fielddump program~dalesurban DALESURBAN program~dalesurban->proc~fielddump Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code fielddump Source Code subroutine fielddump use modfields , only : u0 , v0 , w0 , thl0 , qt0 , ql0 , sv0 !ILS13 21.04.2015 changed to u0 from um  etc use modsurfdata , only : thls , qts , thvs use modglobal , only : ib , ie , ih , jb , je , jh , ke , kb , kh , rk3step , timee , dt_lim , cexpnr , ifoutput , imax , jmax ,& tfielddump , tnextfielddump , nsv , lfielddump !use modmpi,    only : myid,cmyid !use modsubgriddata, only : ekm,sbshr use modstat_nc , only : writestat_nc use modmpi , only : myid , cmyid implicit none real , allocatable :: vars (:,:,:,:) integer i , j , k integer :: writecounter = 1 if (. not . ( timee >= tnextfielddump )) return if (. not . lfielddump ) return if ( rk3step /= 3 ) return tnextfielddump = tnextfielddump + tfielddump allocate ( vars ( ib : ie , jb : je , kb : ke , nvar )) do n = 1 , nvar vars ( ib : ie , jb : je , kb : ke , n ) = pfields ( n )% point end do call writestat_nc ( ncid , 1 , tncname ,( / timee / ), nrec ,. true .) call writestat_nc ( ncid , nvar , ncname , vars , nrec , imax , jmax , khigh - klow + 1 ) deallocate ( vars ) end subroutine fielddump","tags":"","loc":"proc/fielddump.html"},{"title":"exitfielddump – uDALES","text":"public subroutine exitfielddump() Uses modglobal modstat_nc proc~~exitfielddump~~UsesGraph proc~exitfielddump exitfielddump module~modstat_nc modstat_nc proc~exitfielddump->module~modstat_nc module~modglobal modglobal proc~exitfielddump->module~modglobal module~modmpi modmpi module~modstat_nc->module~modmpi netcdf netcdf module~modstat_nc->netcdf mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~exitfielddump~~CalledByGraph proc~exitfielddump exitfielddump program~dalesurban DALESURBAN program~dalesurban->proc~exitfielddump Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code exitfielddump Source Code subroutine exitfielddump use modglobal , only : lfielddump use modstat_nc , only : exitstat_nc implicit none if ( lfielddump ) call exitstat_nc ( ncid ) end subroutine exitfielddump","tags":"","loc":"proc/exitfielddump.html"},{"title":"chem – uDALES","text":"public subroutine chem() Uses modglobal modfields proc~~chem~~UsesGraph proc~chem chem module~modfields modfields proc~chem->module~modfields module~modglobal modglobal proc~chem->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~chem~~CalledByGraph proc~chem chem proc~tstep_integrate tstep_integrate proc~tstep_integrate->proc~chem program~dalesurban DALESURBAN program~dalesurban->proc~tstep_integrate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code chem Source Code subroutine chem use modglobal , only : lchem , k1 , JNO2 , dt , rk3step , ib , ie , ihc , ih , jb , je , jhc , jh , kb , ke , khc , kh use modfields , only : svp , svm , sv0 , IIc implicit none real , dimension ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc ) :: dummyNO , dummyNO2 , dummyO3 if ( lchem . eqv . . false .) return ! forward Euler ! [NO] !    svp(:,:,:,1) = svp(:,:,:,1) + 30.006 * ( JNO2 * (svm(:,:,:,2)/46.005) - k1 * (svm(:,:,:,1) / 30.006) * (svm(:,:,:,3)/47.997) ) ! [NO2] !    svp(:,:,:,2) = svp(:,:,:,2) + 46.005 * (-JNO2 * (svm(:,:,:,2)/46.005) + k1 * (svm(:,:,:,1) / 30.006) * (svm(:,:,:,3)/47.997) ) ! [O3] !    svp(:,:,:,3) = svp(:,:,:,3) + 47.997 * ( JNO2 * (svm(:,:,:,2)/46.005) - k1 * (svm(:,:,:,1) / 30.006) * (svm(:,:,:,3)/47.997) ) if (. not . rk3step == 3 ) return ! convert into mol/m&#94;3 dummyNO = IIc * sv0 (:,:, kb : ke + khc , 1 ) / 3 0.006 dummyNO2 = IIc * sv0 (:,:, kb : ke + khc , 2 ) / 4 6.005 dummyO3 = IIc * sv0 (:,:, kb : ke + khc , 3 ) / 4 7.997 !backward Euler, semi-implicit !    sv0(:,:,kb:ke+khc,1) = 30.006 * ( ( (sv0(:,:,kb:ke+khc,1)/30.006) + JNO2 * dummyNO2 * dt) / (1. + k1 * dummyO3 * dt) ) !    sv0(:,:,kb:ke+khc,2) = 46.005 * ( ( (sv0(:,:,kb:ke+khc,2)/46.005) + k1 * dummyNO * dummyO3 * dt )  / (1. + JNO2 * dt) ) !    sv0(:,:,kb:ke+khc,3) = 47.997 * ( ( (sv0(:,:,kb:ke+khc,3)/47.997) + JNO2 * dummyNO2 * dt) / (1. + k1 * dummyNO * dt) ) !backward Euler, fully implicit. Derivation at (/projects/Chemistry/FullyImplicit.mw) sv0 (:,:, kb : ke + khc , 1 ) = 3 0.006 * ( ( sv0 (:,:, kb : ke + khc , 1 ) / 3 0.006 ) + ( dt * ( - k1 * dummyNO * dummyO3 + JNO2 * dummyNO2 ) ) / & ( 1. + ( ( dummyNO + dummyO3 ) * k1 + JNO2 ) * dt ) ) sv0 (:,:, kb : ke + khc , 2 ) = 4 6.005 * ( ( sv0 (:,:, kb : ke + khc , 2 ) / 4 6.005 ) - ( dt * ( - k1 * dummyNO * dummyO3 + JNO2 * dummyNO2 ) ) / & ( 1. + ( ( dummyNO + dummyO3 ) * k1 + JNO2 ) * dt ) ) sv0 (:,:, kb : ke + khc , 3 ) = 4 7.997 * ( ( sv0 (:,:, kb : ke + khc , 3 ) / 4 7.997 ) + ( dt * ( - k1 * dummyNO * dummyO3 + JNO2 * dummyNO2 ) ) / & ( 1. + ( ( dummyNO + dummyO3 ) * k1 + JNO2 ) * dt ) ) ! alternative method in Zhong 2017 eqn. 7, analytical solution! end subroutine chem","tags":"","loc":"proc/chem.html"},{"title":"initsubgrid – uDALES","text":"public subroutine initsubgrid() Uses modglobal modmpi proc~~initsubgrid~~UsesGraph proc~initsubgrid initsubgrid module~modmpi modmpi proc~initsubgrid->module~modmpi module~modglobal modglobal proc~initsubgrid->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~initsubgrid~~CallsGraph proc~initsubgrid initsubgrid proc~subgridnamelist subgridnamelist proc~initsubgrid->proc~subgridnamelist mpi_bcast mpi_bcast proc~subgridnamelist->mpi_bcast Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~initsubgrid~~CalledByGraph proc~initsubgrid initsubgrid proc~startup startup proc~startup->proc~initsubgrid program~dalesurban DALESURBAN program~dalesurban->proc~startup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code initsubgrid Source Code subroutine initsubgrid use modglobal , only : ih , ib , ie , jh , jb , je , kb , ke , kh , delta , zf , fkar , & pi , ifnamopt , fname_options use modmpi , only : myid implicit none integer :: i , k real :: ceps , ch real :: mlen call subgridnamelist allocate ( ekm ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( ekh ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( zlt ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( sbdiss ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( sbshr ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( sbbuo ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( csz ( ib - ih : ie + ih , kb : ke + kh )) allocate ( damp ( ib : ie , jb : je , kb : ke )) damp = 1. cm = cf / ( 2. * pi ) * ( 1.5 * alpha_kolm ) ** ( - 1.5 ) !     ch   = 2. * alpha_kolm / beta_kolm ch = prandtl ch2 = ch - ch1 ceps = 2. * pi / cf * ( 1.5 * alpha_kolm ) ** ( - 1.5 ) ce1 = ( cn ** 2 ) * ( cm / Rigc - ch1 * cm ) ce2 = ceps - ce1 if ( cs == - 1. ) then csz (:,:) = ( cm ** 3 / ceps ) ** 0.25 !< Smagorinsky constant else csz (:,:) = cs end if !    if(lmason) then !      do k = kb,ke+kh !        do i=ib-ih,ie+ih !          mlen   = (1. / (csz(i,k) * delta(i,k))**nmason + 1. / (fkar * zf(k))**nmason)**(-1./nmason) !          csz(i,k) = mlen / delta(i,k) !        end do !      end do !    end if if ( myid == 0 ) then write ( 6 , * ) 'cf    = ' , cf write ( 6 , * ) 'cm    = ' , cm write ( 6 , * ) 'ch    = ' , ch write ( 6 , * ) 'ch1   = ' , ch1 write ( 6 , * ) 'ch2   = ' , ch2 write ( 6 , * ) 'ceps  = ' , ceps write ( 6 , * ) 'ceps1 = ' , ce1 write ( 6 , * ) 'ceps2 = ' , ce2 write ( 6 , * ) 'cs    = ' , cs write ( 6 , * ) 'Rigc  = ' , Rigc endif end subroutine initsubgrid","tags":"","loc":"proc/initsubgrid.html"},{"title":"subgridnamelist – uDALES","text":"public subroutine subgridnamelist() Uses modglobal modmpi proc~~subgridnamelist~~UsesGraph proc~subgridnamelist subgridnamelist module~modmpi modmpi proc~subgridnamelist->module~modmpi module~modglobal modglobal proc~subgridnamelist->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~subgridnamelist~~CallsGraph proc~subgridnamelist subgridnamelist mpi_bcast mpi_bcast proc~subgridnamelist->mpi_bcast Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~subgridnamelist~~CalledByGraph proc~subgridnamelist subgridnamelist proc~initsubgrid initsubgrid proc~initsubgrid->proc~subgridnamelist proc~startup startup proc~startup->proc~initsubgrid program~dalesurban DALESURBAN program~dalesurban->proc~startup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code subgridnamelist Source Code subroutine subgridnamelist use modglobal , only : pi , ifnamopt , fname_options , lles use modmpi , only : myid , nprocs , comm3d , mpierr , my_real , mpi_logical , mpi_integer implicit none integer :: ierr namelist / NAMSUBGRID / & ldelta , lmason , cf , cn , Rigc , Prandtl , lsmagorinsky , lvreman , loneeqn , c_vreman , cs , nmason , lbuoycorr if ( myid == 0 ) then open ( ifnamopt , file = fname_options , status = 'old' , iostat = ierr ) read ( ifnamopt , NAMSUBGRID , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions NAMSUBGRID' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif write ( 6 , NAMSUBGRID ) close ( ifnamopt ) end if call MPI_BCAST ( ldelta , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lmason , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( nmason , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lsmagorinsky , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lvreman , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( loneeqn , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( c_vreman , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( cs , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( cf , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( cn , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( Rigc , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( Prandtl , 1 , MY_REAL , 0 , comm3d , mpierr ) prandtli = 1. / Prandtl write ( * , * ) '1/prandtl' , prandtli if (( lsmagorinsky ) . or . ( lvreman ) . or . ( loneeqn )) then lles = . true . endif end subroutine subgridnamelist","tags":"","loc":"proc/subgridnamelist.html"},{"title":"subgrid – uDALES","text":"public subroutine subgrid() Uses modglobal modfields modsurfdata modmpi proc~~subgrid~~UsesGraph proc~subgrid subgrid module~modmpi modmpi proc~subgrid->module~modmpi module~modfields modfields proc~subgrid->module~modfields module~modglobal modglobal proc~subgrid->module~modglobal module~modsurfdata modsurfdata proc~subgrid->module~modsurfdata mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~subgrid~~CallsGraph proc~subgrid subgrid proc~closure closure proc~subgrid->proc~closure proc~diffw diffw proc~subgrid->proc~diffw proc~diffu diffu proc~subgrid->proc~diffu proc~diffv diffv proc~subgrid->proc~diffv proc~closurebc closurebc proc~closure->proc~closurebc proc~excjs excjs proc~closurebc->proc~excjs mpi_sendrecv mpi_sendrecv proc~excjs->mpi_sendrecv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~subgrid~~CalledByGraph proc~subgrid subgrid program~dalesurban DALESURBAN program~dalesurban->proc~subgrid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/subgrid.html"},{"title":"exitsubgrid – uDALES","text":"public subroutine exitsubgrid() Arguments None Called by proc~~exitsubgrid~~CalledByGraph proc~exitsubgrid exitsubgrid proc~exitmodules exitmodules proc~exitmodules->proc~exitsubgrid program~dalesurban DALESURBAN program~dalesurban->proc~exitmodules Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code exitsubgrid Source Code subroutine exitsubgrid implicit none deallocate ( ekm , ekh , zlt , sbdiss , sbbuo , sbshr , csz ) end subroutine exitsubgrid","tags":"","loc":"proc/exitsubgrid.html"},{"title":"closure – uDALES","text":"public subroutine closure() Uses modglobal modfields modsurfdata modmpi modboundary modinletdata proc~~closure~~UsesGraph proc~closure closure module~modsurfdata modsurfdata proc~closure->module~modsurfdata module~modmpi modmpi proc~closure->module~modmpi module~modboundary modboundary proc~closure->module~modboundary module~modinletdata modinletdata proc~closure->module~modinletdata module~modfields modfields proc~closure->module~modfields module~modglobal modglobal proc~closure->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~closure~~CallsGraph proc~closure closure proc~closurebc closurebc proc~closure->proc~closurebc proc~excjs excjs proc~closurebc->proc~excjs mpi_sendrecv mpi_sendrecv proc~excjs->mpi_sendrecv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~closure~~CalledByGraph proc~closure closure proc~subgrid subgrid proc~subgrid->proc~closure program~dalesurban DALESURBAN program~dalesurban->proc~subgrid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code closure Source Code subroutine closure !-----------------------------------------------------------------| !                                                                 | !*** *closure*  calculates K-coefficients                         | !                                                                 | !      Hans Cuijpers   I.M.A.U.   06/01/1995                      | !                                                                 | !     purpose.                                                    | !     --------                                                    | !                                                                 | !     All the K-closure factors are calculated.                   | !                                                                 | !     ekm(i,j,k) = k sub m : for velocity-closure                 | !     ekh(i,j,k) = k sub h : for temperture-closure               | !     ekh(i,j,k) = k sub h = k sub c : for concentration-closure  | !                                                                 | !     We will use the next model for these factors:               | !                                                                 | !     k sub m = 0.12 * l * sqrt(E)                                | !                                                                 | !     k sub h = k sub c = ( 1 + (2*l)/D ) * k sub m               | !                                                                 | !           where : l = mixing length  ( in model = z2 )          | !                   E = subgrid energy                            | !                   D = grid-size distance                        | !                                                                 | !**   interface.                                                  | !     ----------                                                  | !                                                                 | !             *closure* is called from *program*.                 | !                                                                 | !-----------------------------------------------------------------| use modglobal , only : ib , ie , jb , je , kb , ke , kh , ih , jh , jmax , delta , ekmin , grav , zf , fkar , jgb , jge ,& dxf , dxf2 , dxhi , dxfi , dy2 , dyi , dyiq , dzf , dzf2 , dzfi , dzhi , rk3step , rslabs , & numol , numoli , prandtlmoli , lles , rk3step , dxfiq , dzfiq , lbuoyancy , dzh use modfields , only : dthvdz , e120 , u0 , v0 , w0 , thl0 , mindist , wall , shear use modsurfdata , only : dudz , dvdz , thvs , ustar use modmpi , only : excjs , myid , nprocs , comm3d , mpierr , my_real , mpi_sum , slabsumi use modboundary , only : closurebc use modinletdata , only : utaui implicit none real , dimension ( ib : ie ) :: shearbot real :: strain2 , mlen , uhor , distplus , utaubot , a11 , a12 , a13 , & a21 , a22 , a23 , a31 , a32 , a33 , aa , b11 , b12 , b13 , b21 , b22 , & b23 , b33 , bb , const , const2 integer :: i , j , k , kp , km , jp , jm , im , ip , iw , jw , kw , c1 , c2 !  if (lles  .and. rk3step == 1) then        ! compute ekm and ekh only once in complete RK-cycle if ( lsmagorinsky ) then do k = kb , ke kp = k + 1 km = k - 1 do i = ib , ie ip = i + 1 im = i - 1 mlen = csz ( i , k ) * delta ( i , k ) do j = jb , je jp = j + 1 jm = j - 1 iw = wall ( i , j , k , 1 ) ! indices of closest wall jw = wall ( i , j , k , 2 ) - myid * jmax ! indices of closest wall in local j-index kw = wall ( i , j , k , 3 ) c1 = wall ( i , j , k , 4 ) ! shear stress component c2 = wall ( i , j , k , 5 ) ! shear stress component if (( jw >= jb - 1 ) . and . ( jw <= je + 1 )) then ! check if jw is within the halo of this proc !write(*,'(A,E9.2,A,E9.2,A,E9.2,A,E9.2)') 'component1:', c1, 'component2:', c2, 'shear c1:', shear(iw,jw,kw,c1), 'shear c2:', shear(iw,jw,kw,c2) distplus = mindist ( i , j , k ) * sqrt ( abs ( shear ( iw , jw , kw , c1 )) + abs ( shear ( iw , jw , kw , c2 ))) * numoli damp ( i , j , k ) = sqrt ( 1. - exp (( - distplus * 0.04 ) ** 3. )) ! Wall-damping according to Piomelli !    write(*,'(A,2(1pE9.2))') 'damp, distplus', damp(i,j,k), distplus else damp ( i , j , k ) = 1. end if strain2 = ( & (( u0 ( ip , j , k ) - u0 ( i , j , k )) * dxfi ( i ) ) ** 2 + & (( v0 ( i , jp , k ) - v0 ( i , j , k )) * dyi ) ** 2 + & (( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) ) ** 2 ) strain2 = strain2 + 0.125 * ( & (( w0 ( i , j , kp ) - w0 ( im , j , kp )) * dxhi ( i ) + & ( u0 ( i , j , kp ) - u0 ( i , j , k )) * dzhi ( kp ) ) ** 2 + & (( w0 ( i , j , k ) - w0 ( im , j , k )) * dxhi ( i ) + & ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) ) ** 2 + & (( w0 ( ip , j , k ) - w0 ( i , j , k )) * dxhi ( ip ) + & ( u0 ( ip , j , k ) - u0 ( ip , j , km )) * dzhi ( k ) ) ** 2 + & (( w0 ( ip , j , kp ) - w0 ( i , j , kp )) * dxhi ( ip ) + & ( u0 ( ip , j , kp ) - u0 ( ip , j , k )) * dzhi ( kp ) ) ** 2 ) strain2 = strain2 + 0.125 * ( & (( u0 ( i , jp , k ) - u0 ( i , j , k )) * dyi + & ( v0 ( i , jp , k ) - v0 ( im , jp , k )) * dxhi ( i ) ) ** 2 + & (( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi + & ( v0 ( i , j , k ) - v0 ( im , j , k )) * dxhi ( i ) ) ** 2 + & (( u0 ( ip , j , k ) - u0 ( ip , jm , k )) * dyi + & ( v0 ( ip , j , k ) - v0 ( i , j , k )) * dxhi ( ip ) ) ** 2 + & (( u0 ( ip , jp , k ) - u0 ( ip , j , k )) * dyi + & ( v0 ( ip , jp , k ) - v0 ( i , jp , k )) * dxhi ( ip ) ) ** 2 ) strain2 = strain2 + 0.125 * ( & (( v0 ( i , j , kp ) - v0 ( i , j , k )) * dzhi ( kp ) + & ( w0 ( i , j , kp ) - w0 ( i , jm , kp )) * dyi ) ** 2 + & (( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) + & ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi ) ** 2 + & (( v0 ( i , jp , k ) - v0 ( i , jp , km )) * dzhi ( k ) + & ( w0 ( i , jp , k ) - w0 ( i , j , k )) * dyi ) ** 2 + & (( v0 ( i , jp , kp ) - v0 ( i , jp , k )) * dzhi ( kp ) + & ( w0 ( i , jp , kp ) - w0 ( i , j , kp )) * dyi ) ** 2 ) ekm ( i , j , k ) = ( mlen * damp ( i , j , k )) ** 2. * sqrt ( 2. * strain2 ) ekh ( i , j , k ) = ekm ( i , j , k ) * prandtli end do end do end do damp (:,:,:) = max ( damp (:,:,:), dampmin ) ekm (:,:,:) = ekm (:,:,:) + numol ! add molecular viscosity ekh (:,:,:) = ekh (:,:,:) + numol * prandtlmoli ! add molecular diffusivity !write(*,'(A,3(1pE9.2))') 'strain2, ekm, ekh', strain2, ekm(10,10,10), ekh(10,10,10) !    ekm(:,:,:) = max(ekm(:,:,:),ekmin) !    ekh(:,:,:) = max(ekh(:,:,:),ekmin) elseif ( lvreman ) then if (( lbuoyancy ) . and . ( lbuoycorr )) then const = prandtli * grav / ( thvs * sqrt ( 2. * 3. )) do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie ! aij = du_i / dx_i ip = i + 1 im = i - 1 a11 = ( u0 ( ip , j , k ) - u0 ( i , j , k )) * dxfi ( i ) a12 = ((( v0 ( ip , jp , k ) + v0 ( ip , j , k )) * dxf ( i ) + & ( v0 ( i , jp , k ) + v0 ( i , j , k )) * dxf ( ip )) * dxhi ( ip ) & - & (( v0 ( i , jp , k ) + v0 ( i , j , k )) * dxf ( im ) + & ( v0 ( im , jp , k ) + v0 ( im , j , k )) * dxf ( i )) * dxhi ( i )) * dxfiq ( i ) a13 = ((( w0 ( ip , j , kp ) + w0 ( ip , j , k )) * dxf ( i ) + & ( w0 ( i , j , kp ) + w0 ( i , j , k )) * dxf ( ip )) * dxhi ( ip ) & - & (( w0 ( i , j , kp ) + w0 ( i , j , k )) * dxf ( im ) + & ( w0 ( im , j , kp ) + w0 ( im , j , k )) * dxf ( i )) * dxhi ( i )) * dxfiq ( i ) a21 = ( u0 ( ip , jp , k ) + u0 ( i , jp , k ) - u0 ( ip , jm , k ) - u0 ( i , jm , k ) ) * dyiq ! simplified after writing out interpolation. a22 = ( v0 ( i , jp , k ) - v0 ( i , j , k )) * dyi a23 = ( w0 ( i , jp , kp ) + w0 ( i , jp , k ) - w0 ( i , jm , kp ) - w0 ( i , jm , k ) ) * dyiq ! simplified after writing out interpolation. a31 = ((( u0 ( ip , j , kp ) + u0 ( i , j , kp )) * dzf ( k ) + & ( u0 ( ip , j , k ) + u0 ( i , j , k )) * dzf ( kp )) * dzhi ( kp ) & - & (( u0 ( ip , j , k ) + u0 ( i , j , k )) * dzf ( km ) + & ( u0 ( ip , j , km ) + u0 ( i , j , km )) * dzf ( k )) * dzhi ( k ) ) * dzfiq ( k ) a32 = ((( v0 ( i , jp , kp ) + v0 ( i , j , kp )) * dzf ( k ) + & ( v0 ( i , jp , k ) + v0 ( i , j , k )) * dzf ( kp )) * dzhi ( kp ) & - & (( v0 ( i , jp , k ) + v0 ( i , j , k )) * dzf ( km ) + & ( v0 ( i , jp , km ) + v0 ( i , j , km )) * dzf ( k )) * dzhi ( k ) ) * dzfiq ( k ) a33 = ( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) aa = a11 * a11 + a21 * a21 + a31 * a31 + & a12 * a12 + a22 * a22 + a32 * a32 + & a13 * a13 + a23 * a23 + a33 * a33 b11 = dxf2 ( i ) * a11 * a11 + dy2 * a21 * a21 + dzf2 ( k ) * a31 * a31 b22 = dxf2 ( i ) * a12 * a12 + dy2 * a22 * a22 + dzf2 ( k ) * a32 * a32 b12 = dxf2 ( i ) * a11 * a12 + dy2 * a21 * a22 + dzf2 ( k ) * a31 * a32 b33 = dxf2 ( i ) * a13 * a13 + dy2 * a23 * a23 + dzf2 ( k ) * a33 * a33 b13 = dxf2 ( i ) * a11 * a13 + dy2 * a21 * a23 + dzf2 ( k ) * a31 * a33 b23 = dxf2 ( i ) * a12 * a13 + dy2 * a22 * a23 + dzf2 ( k ) * a32 * a33 bb = b11 * b22 - b12 * b12 + b11 * b33 - b13 * b13 + b22 * b33 - b23 * b23 dthvdz ( i , j , k ) = ( thl0 ( i , j , k + 1 ) - thl0 ( i , j , k - 1 )) / ( dzh ( k + 1 ) + dzh ( k )) if ( dthvdz ( i , j , k ) <= 0 ) then const2 = ( bb / aa ) else ! write(*,*) \"const\",const ! write(*,*) \"delta\",delta const2 = ( bb / aa ) - ( delta ( i , k ) ** 4 ) * dthvdz ( i , j , k ) * const if ( const2 < 0.0 ) const2 = 0.0 end if ekm ( i , j , k ) = c_vreman * sqrt ( const2 ) ekh ( i , j , k ) = ekm ( i , j , k ) * prandtli end do end do end do ekm (:,:,:) = ekm (:,:,:) + numol ! add molecular viscosity ekh (:,:,:) = ekh (:,:,:) + numol * prandtlmoli ! add molecular diffusivity else ! neutral case do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie ! aij = du_i / dx_i ip = i + 1 im = i - 1 a11 = ( u0 ( ip , j , k ) - u0 ( i , j , k )) * dxfi ( i ) a12 = ((( v0 ( ip , jp , k ) + v0 ( ip , j , k )) * dxf ( i ) + & ( v0 ( i , jp , k ) + v0 ( i , j , k )) * dxf ( ip )) * dxhi ( ip ) & - & (( v0 ( i , jp , k ) + v0 ( i , j , k )) * dxf ( im ) + & ( v0 ( im , jp , k ) + v0 ( im , j , k )) * dxf ( i )) * dxhi ( i )) * dxfiq ( i ) a13 = ((( w0 ( ip , j , kp ) + w0 ( ip , j , k )) * dxf ( i ) + & ( w0 ( i , j , kp ) + w0 ( i , j , k )) * dxf ( ip )) * dxhi ( ip ) & - & (( w0 ( i , j , kp ) + w0 ( i , j , k )) * dxf ( im ) + & ( w0 ( im , j , kp ) + w0 ( im , j , k )) * dxf ( i )) * dxhi ( i )) * dxfiq ( i ) a21 = ( u0 ( ip , jp , k ) + u0 ( i , jp , k ) - u0 ( ip , jm , k ) - u0 ( i , jm , k ) ) * dyiq !simplified after writing out interpolation. a22 = ( v0 ( i , jp , k ) - v0 ( i , j , k )) * dyi a23 = ( w0 ( i , jp , kp ) + w0 ( i , jp , k ) - w0 ( i , jm , kp ) - w0 ( i , jm , k ) ) * dyiq !simplified after writing out interpolation. a31 = ((( u0 ( ip , j , kp ) + u0 ( i , j , kp )) * dzf ( k ) + & ( u0 ( ip , j , k ) + u0 ( i , j , k )) * dzf ( kp )) * dzhi ( kp ) & - & (( u0 ( ip , j , k ) + u0 ( i , j , k )) * dzf ( km ) + & ( u0 ( ip , j , km ) + u0 ( i , j , km )) * dzf ( k )) * dzhi ( k ) ) * dzfiq ( k ) a32 = ((( v0 ( i , jp , kp ) + v0 ( i , j , kp )) * dzf ( k ) + & ( v0 ( i , jp , k ) + v0 ( i , j , k )) * dzf ( kp )) * dzhi ( kp ) & - & (( v0 ( i , jp , k ) + v0 ( i , j , k )) * dzf ( km ) + & ( v0 ( i , jp , km ) + v0 ( i , j , km )) * dzf ( k )) * dzhi ( k ) ) * dzfiq ( k ) a33 = ( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) aa = a11 * a11 + a21 * a21 + a31 * a31 + & a12 * a12 + a22 * a22 + a32 * a32 + & a13 * a13 + a23 * a23 + a33 * a33 b11 = dxf2 ( i ) * a11 * a11 + dy2 * a21 * a21 + dzf2 ( k ) * a31 * a31 b22 = dxf2 ( i ) * a12 * a12 + dy2 * a22 * a22 + dzf2 ( k ) * a32 * a32 b12 = dxf2 ( i ) * a11 * a12 + dy2 * a21 * a22 + dzf2 ( k ) * a31 * a32 b33 = dxf2 ( i ) * a13 * a13 + dy2 * a23 * a23 + dzf2 ( k ) * a33 * a33 b13 = dxf2 ( i ) * a11 * a13 + dy2 * a21 * a23 + dzf2 ( k ) * a31 * a33 b23 = dxf2 ( i ) * a12 * a13 + dy2 * a22 * a23 + dzf2 ( k ) * a32 * a33 bb = b11 * b22 - b12 * b12 + b11 * b33 - b13 * b13 + b22 * b33 - b23 * b23 if ( bb < 0.00000001 ) then ekm ( i , j , k ) = 0. ekh ( i , j , k ) = 0. else ekm ( i , j , k ) = c_vreman * sqrt ( bb / aa ) ekh ( i , j , k ) = ekm ( i , j , k ) * prandtli end if end do end do end do !    ekm(:,:,:) = max(ekm(:,:,:),ekmin) !    ekh(:,:,:) = max(ekh(:,:,:),ekmin) end if ! lbuoyancy ekm (:,:,:) = ekm (:,:,:) + numol ! add molecular viscosity ekh (:,:,:) = ekh (:,:,:) + numol * prandtlmoli ! add molecular diffusivity !do TKE scheme elseif ( loneeqn ) then do k = kb , ke do j = jb , je do i = ib , ie iw = wall ( i , j , k , 1 ) ! indices of closest wall jw = wall ( i , j , k , 2 ) - myid * jmax ! indices of closest wall in local j-index kw = wall ( i , j , k , 3 ) c1 = wall ( i , j , k , 4 ) ! shear stress component c2 = wall ( i , j , k , 5 ) ! shear stress component !ILS13 removed near-wall damping 25.06.2014 !if (jw >= jb-1 .and. jw <= je+1) then      ! check if jw is within the halo of this proc !  distplus = mindist(i,j,k)*sqrt(abs(shear(iw,jw,kw,c1))+abs(shear(iw,jw,kw,c2)))*numoli !  damp(i,j,k) = sqrt(1. - exp((-distplus*0.04)**3.))            ! Wall-damping according to Piomelli !else damp ( i , j , k ) = 1. !end if if (( ldelta ) . or . ( dthvdz ( i , j , k ) <= 0 )) then zlt ( i , j , k ) = delta ( i , k ) ekm ( i , j , k ) = cm * zlt ( i , j , k ) * damp ( i , j , k ) * e120 ( i , j , k ) !* 0.5! LES with near-wall damping !!! added factor 0.5 for shear-driven flow ekh ( i , j , k ) = ( ch1 + ch2 ) * ekm ( i , j , k ) ! maybe ekh should be calculated from (molecular) Prandtl number ekm ( i , j , k ) = ekm ( i , j , k ) + numol ! add molecular viscosity ekh ( i , j , k ) = ekh ( i , j , k ) + numol * prandtlmoli ! add molecular diffusivity else !            zlt(i,j,k) = min(delta(i,k),cn*e120(i,j,k)/sqrt(grav/thvs*abs(dthvdz(i,j,k)))) zlt ( i , j , k ) = min ( delta ( i , k ), cn * e120 ( i , j , k ) / sqrt ( grav / thvs * abs ( dthvdz ( i , j , k )))) !thls is used ekm ( i , j , k ) = cm * zlt ( i , j , k ) * damp ( i , j , k ) * e120 ( i , j , k ) !* 0.5     ! LES with near-wall damping !!! added factor 0.5 for shear-driven flow ekh ( i , j , k ) = ( ch1 + ch2 * zlt ( i , j , k ) / delta ( i , k )) * ekm ( i , j , k ) !  needed in LES! ekm ( i , j , k ) = ekm ( i , j , k ) + numol ! add molecular viscosity ekh ( i , j , k ) = ekh ( i , j , k ) + numol * prandtlmoli ! add molecular diffusivity endif end do end do end do !   write(*,'(1A,F8.4)') 'ekh', ekh(2,3,3) damp (:,:,:) = max ( damp (:,:,:), dampmin ) !    ekm(:,:,:) = max(ekm(:,:,:),ekmin) !    ekh(:,:,:) = max(ekh(:,:,:),ekmin) else ! no subgrid model (DNS!) ekm = numol ekh = numol * prandtlmoli end if !  write(*,'(A,3(1pE9.2))') 'strain2, ekm, ekh', strain2, ekm(10,10,10), ekh(10,10,10) !do i=ib,ie !write(*,'(A,1(1pE9.2))') 'damp, ekm', damp(i,32,kb), ekm(i,32,kb) !end do !************************************************************* !     Set boundary condition for K-closure factors.          ! Also other BC's!! !************************************************************* call closurebc return end subroutine closure","tags":"","loc":"proc/closure.html"},{"title":"sources – uDALES","text":"public subroutine sources() Uses modglobal modfields modsurfdata proc~~sources~~UsesGraph proc~sources sources module~modfields modfields proc~sources->module~modfields module~modglobal modglobal proc~sources->module~modglobal module~modsurfdata modsurfdata proc~sources->module~modsurfdata Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Contents Source Code sources Source Code subroutine sources ! only in case of LES computation !-----------------------------------------------------------------| !                                                                 | !*** *sources*                                                    | !      calculates various terms from the subgrid TKE equation     | !                                                                 | !     Hans Cuijpers   I.M.A.U.     06/01/1995                     | !                                                                 | !     purpose.                                                    | !     --------                                                    | !                                                                 | !      Subroutine sources calculates all other terms in the       | !      subgrid energy equation, except for the diffusion terms.   | !      These terms are calculated in subroutine diff.             | !                                                                 | !**   interface.                                                  | !     ----------                                                  | !                                                                 | !     *sources* is called from *program*.                         | !                                                                 | !-----------------------------------------------------------------| use modglobal , only : ib , ie , jb , je , kb , ke , delta , dxhi , dxfi , dy , dyi , dzfi , dzhi , grav , numol , prandtlmol ,& dzh , delta use modfields , only : u0 , v0 , w0 , e120 , e12p , dthvdz , thl0 , thvf use modsurfdata , only : dudz , dvdz , thvs !    use modmpi,       only : myid implicit none real tdef2 , prandtlmoli integer i , j , k , im , ip , jm , jp , km , kp prandtlmoli = 1. / prandtlmol ! Added by J. Tomas (thermodynamics routine is bypassed) ! thv does not exist (equals thl), therefore dthvdz is computed here ! IS+HJ: thermodynamics is back in now (which calculates dthvdz) !    do k=kb,ke !      do j=jb,je !        do i=ib,ie !          dthvdz(i,j,k) = (thl0(i,j,k+1)-thl0(i,j,k-1))/(dzh(k+1)+dzh(k)) ! !         if (dthvdz(i,j,k) == 0.0) then ! !           write(6,*) 'dthvdz(i,j,k)=0,i,j,k',i,j,k ! !         end if !        end do !      end do !    end do ! End of addition by J. Tomas (thermodynamics routine is bypassed) do k = kb + 1 , ke do j = jb , je do i = ib , ie kp = k + 1 km = k - 1 jp = j + 1 jm = j - 1 ip = i + 1 im = i - 1 tdef2 = 2. * ( & (( u0 ( ip , j , k ) - u0 ( i , j , k )) * dxfi ( i ) ) ** 2 + & (( v0 ( i , jp , k ) - v0 ( i , j , k )) * dyi ) ** 2 + & (( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) ) ** 2 ) tdef2 = tdef2 + 0.25 * ( & (( w0 ( i , j , kp ) - w0 ( im , j , kp )) * dxhi ( i ) + & ( u0 ( i , j , kp ) - u0 ( i , j , k )) * dzhi ( kp ) ) ** 2 + & ! (( w0 ( i , j , k ) - w0 ( im , j , k )) * dxhi ( i ) + & ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) ) ** 2 + & ! (( w0 ( ip , j , k ) - w0 ( i , j , k )) * dxhi ( ip ) + & ( u0 ( ip , j , k ) - u0 ( ip , j , km )) * dzhi ( k ) ) ** 2 + & ! (( w0 ( ip , j , kp ) - w0 ( i , j , kp )) * dxhi ( ip ) + & ( u0 ( ip , j , kp ) - u0 ( ip , j , k )) * dzhi ( kp ) ) ** 2 ) tdef2 = tdef2 + 0.25 * ( & (( u0 ( i , jp , k ) - u0 ( i , j , k )) * dyi + & ( v0 ( i , jp , k ) - v0 ( im , jp , k )) * dxhi ( i ) ) ** 2 + & ! (( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi + & ( v0 ( i , j , k ) - v0 ( im , j , k )) * dxhi ( i ) ) ** 2 + & ! (( u0 ( ip , j , k ) - u0 ( ip , jm , k )) * dyi + & ( v0 ( ip , j , k ) - v0 ( i , j , k )) * dxhi ( ip )) ** 2 + & ! (( u0 ( ip , jp , k ) - u0 ( ip , j , k )) * dyi + & ( v0 ( ip , jp , k ) - v0 ( i , jp , k )) * dxhi ( ip )) ** 2 ) tdef2 = tdef2 + 0.25 * ( & (( v0 ( i , j , kp ) - v0 ( i , j , k )) * dzhi ( kp ) + & ( w0 ( i , j , kp ) - w0 ( i , jm , kp )) * dyi ) ** 2 + & ! (( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) + & ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi ) ** 2 + & ! (( v0 ( i , jp , k ) - v0 ( i , jp , km )) * dzhi ( k ) + & ( w0 ( i , jp , k ) - w0 ( i , j , k )) * dyi ) ** 2 + & ! (( v0 ( i , jp , kp ) - v0 ( i , jp , k )) * dzhi ( kp ) + & ( w0 ( i , jp , kp ) - w0 ( i , j , kp )) * dyi ) ** 2 ) !    sbshr(i,j,k)  = ekm(i,j,k)*tdef2/ ( 2*e120(i,j,k)) !    sbbuo(i,j,k)  = -ekh(i,j,k)*grav/thvs*dthvdz(i,j,k)/ ( 2*e120(i,j,k)) !    sbdiss(i,j,k) = - (ce1 + ce2*zlt(i,j,k)/delta(i,k)) * e120(i,j,k)**2 /(2.*zlt(i,j,k)) sbshr ( i , j , k ) = ( ekm ( i , j , k ) - numol ) * tdef2 / ( 2 * e120 ( i , j , k )) ! subtract molecular viscosity !    sbbuo(i,j,k)  = -(ekh(i,j,k)-numol*prandtlmoli)*grav/thvs*dthvdz(i,j,k)/ ( 2*e120(i,j,k))     ! subtract molecular diffusivity sbbuo ( i , j , k ) = - ( ekh ( i , j , k ) - numol * prandtlmoli ) * grav / thvs * dthvdz ( i , j , k ) / ( 2 * e120 ( i , j , k )) ! subtract molecular diffusivity and use thls instead of thvs (not defined) !    sbdiss(i,j,k) = - (ce1 + ce2*zlt(i,j,k)/delta(i,k)) * e120(i,j,k)**2 /(2.*damp*zlt(i,j,k))   ! add near-wall damping function ! added factor 2. for shear-driven flow sbdiss ( i , j , k ) = - 2. * ( ce1 + ce2 * zlt ( i , j , k ) / delta ( i , k )) * e120 ( i , j , k ) ** 2 / ( 2. * damp ( i , j , k ) * zlt ( i , j , k )) ! add near-wall damping function !! added f end do end do end do !     ----------------------------------------------end i,j,k-loop !    special treatment for lowest level do j = jb , je do i = ib , ie jp = j + 1 jm = j - 1 tdef2 = 2. * ( & (( u0 ( i + 1 , j , kb ) - u0 ( i , j , kb )) * dxfi ( i )) ** 2 & + (( v0 ( i , jp , kb ) - v0 ( i , j , kb )) * dyi ) ** 2 & + (( w0 ( i , j , kb + 1 ) - w0 ( i , j , kb )) * dzfi ( kb )) ** 2 ) tdef2 = tdef2 + ( 0.25 * ( w0 ( i + 1 , j , kb + 1 ) - w0 ( i - 1 , j , kb + 1 )) * dxfi ( i ) + & dudz ( i , j ) ) ** 2 tdef2 = tdef2 + 0.25 * ( & (( u0 ( i , jp , kb ) - u0 ( i , j , kb )) * dyi + ( v0 ( i , jp , kb ) - v0 ( i - 1 , jp , kb )) * dxfi ( i )) ** 2 & + (( u0 ( i , j , kb ) - u0 ( i , jm , kb )) * dyi + ( v0 ( i , j , kb ) - v0 ( i - 1 , j , kb )) * dxfi ( i )) ** 2 & + (( u0 ( i + 1 , j , kb ) - u0 ( i + 1 , jm , kb )) * dyi + ( v0 ( i + 1 , j , kb ) - v0 ( i , j , kb )) * dxfi ( i )) ** 2 & + (( u0 ( i + 1 , jp , kb ) - u0 ( i + 1 , j , kb )) * dyi + ( v0 ( i + 1 , jp , kb ) - v0 ( i , jp , kb )) * dxfi ( i )) ** 2 ) tdef2 = tdef2 + ( 0.25 * ( w0 ( i , jp , kb + 1 ) - w0 ( i , jm , kb + 1 )) * dyi + & dvdz ( i , j ) ) ** 2 ! **  Include shear and buoyancy production terms and dissipation ** sbshr ( i , j , kb ) = ekm ( i , j , kb ) * tdef2 / ( 2 * e120 ( i , j , kb )) sbbuo ( i , j , kb ) = - ekh ( i , j , kb ) * grav / thvf ( kb ) * dthvdz ( i , j , kb ) / ( 2 * e120 ( i , j , kb )) sbdiss ( i , j , kb ) = - ( ce1 + ce2 * zlt ( i , j , kb ) / delta ( i , kb )) * e120 ( i , j , kb ) ** 2 / ( 2. * zlt ( i , j , kb )) end do end do !    ------------------------------------------------ e12p ( ib : ie , jb : je , kb : ke ) = e12p ( ib : ie , jb : je , kb : ke ) + & sbshr ( ib : ie , jb : je , kb : ke ) + sbbuo ( ib : ie , jb : je , kb : ke ) + sbdiss ( ib : ie , jb : je , kb : ke ) !write(*,'(A,3(1pE9.2))') 'for check if called and e12p =', e12p(32,32,kb) return end subroutine sources","tags":"","loc":"proc/sources.html"},{"title":"diffc – uDALES","text":"public subroutine diffc(hi, hj, hk, putin, putout) Uses modglobal modmpi proc~~diffc~~UsesGraph proc~diffc diffc module~modmpi modmpi proc~diffc->module~modmpi module~modglobal modglobal proc~diffc->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: hi integer, intent(in) :: hj integer, intent(in) :: hk real, intent(in) :: putin (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(inout) :: putout (ib-hi:ie+hi,jb-hj:je+hj,kb:ke+hk) Contents Source Code diffc Source Code subroutine diffc ( hi , hj , hk , putin , putout ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , dxh , dxhi , dxh2i , dxf , dxfi , dzf , dzfi , dyi , dy2i ,& dzhi , dzh2i , jmax , numol , prandtlmoli , lles use modmpi , only : myid implicit none integer , intent ( in ) :: hi !<size of halo in i integer , intent ( in ) :: hj !<size of halo in j integer , intent ( in ) :: hk !<size of halo in k real , intent ( in ) :: putin ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) real , intent ( inout ) :: putout ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) real cekh integer i , j , k , jm , jp , km , kp if ( lles ) then do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie putout ( i , j , k ) = putout ( i , j , k ) & + 0.5 * ( & ( ( ekh ( i + 1 , j , k ) * dxf ( i ) + ekh ( i , j , k ) * dxf ( i + 1 )) * ( putin ( i + 1 , j , k ) - putin ( i , j , k )) * dxh2i ( i + 1 ) & - ( ekh ( i , j , k ) * dxf ( i - 1 ) + ekh ( i - 1 , j , k ) * dxf ( i )) * ( putin ( i , j , k ) - putin ( i - 1 , j , k )) * dxh2i ( i )) * dxfi ( i ) & + & ( ( ekh ( i , jp , k ) + ekh ( i , j , k )) * ( putin ( i , jp , k ) - putin ( i , j , k )) & - ( ekh ( i , j , k ) + ekh ( i , jm , k )) * ( putin ( i , j , k ) - putin ( i , jm , k )) ) * dy2i & + & ( ( dzf ( kp ) * ekh ( i , j , k ) + dzf ( k ) * ekh ( i , j , kp )) & * ( putin ( i , j , kp ) - putin ( i , j , k )) * dzh2i ( kp ) & - & ( dzf ( km ) * ekh ( i , j , k ) + dzf ( k ) * ekh ( i , j , km )) & * ( putin ( i , j , k ) - putin ( i , j , km )) * dzh2i ( k ) ) * dzfi ( k ) & ) end do end do end do else ! DNS cekh = numol * prandtlmoli do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie putout ( i , j , k ) = putout ( i , j , k ) & + ( & ( cekh * ( putin ( i + 1 , j , k ) - putin ( i , j , k )) * dxhi ( i + 1 ) & - cekh * ( putin ( i , j , k ) - putin ( i - 1 , j , k )) * dxhi ( i )) * dxfi ( i ) & + & ( cekh * ( putin ( i , jp , k ) - putin ( i , j , k )) & - cekh * ( putin ( i , j , k ) - putin ( i , jm , k )) ) * dy2i & + & ( cekh * ( putin ( i , j , kp ) - putin ( i , j , k )) * dzhi ( kp ) & - cekh * ( putin ( i , j , k ) - putin ( i , j , km )) * dzhi ( k ) ) * dzfi ( k ) & ) end do end do end do end if ! lles=.true. end subroutine diffc","tags":"","loc":"proc/diffc.html"},{"title":"diffe – uDALES","text":"public subroutine diffe(putout) Uses modglobal modfields modmpi proc~~diffe~~UsesGraph proc~diffe diffe module~modmpi modmpi proc~diffe->module~modmpi module~modfields modfields proc~diffe->module~modfields module~modglobal modglobal proc~diffe->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(inout) :: putout (ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) Contents Source Code diffe Source Code subroutine diffe ( putout ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , dxf , dxfi , dxh2i , dzf , dzfi ,& dy2i , dzhi , dzh2i , jmax use modfields , only : e120 use modmpi , only : myid implicit none real , intent ( inout ) :: putout ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) integer :: i , j , k , jm , jp , km , kp do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie putout ( i , j , k ) = putout ( i , j , k ) & + 1.0 * ( & ( ( ekm ( i + 1 , j , k ) * dxf ( i ) + ekm ( i , j , k ) * dxf ( i + 1 )) * ( e120 ( i + 1 , j , k ) - e120 ( i , j , k )) * dxh2i ( i + 1 ) & - ( ekm ( i , j , k ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k ) * dxf ( i )) * ( e120 ( i , j , k ) - e120 ( i - 1 , j , k )) * dxh2i ( i )) * dxfi ( i ) & + & (( ekm ( i , jp , k ) + ekm ( i , j , k )) * ( e120 ( i , jp , k ) - e120 ( i , j , k )) & - ( ekm ( i , j , k ) + ekm ( i , jm , k )) * ( e120 ( i , j , k ) - e120 ( i , jm , k )) ) * dy2i & + & (( dzf ( kp ) * ekm ( i , j , k ) + dzf ( k ) * ekm ( i , j , kp )) & * ( e120 ( i , j , kp ) - e120 ( i , j , k )) * dzh2i ( kp ) & - ( dzf ( km ) * ekm ( i , j , k ) + dzf ( k ) * ekm ( i , j , km )) & * ( e120 ( i , j , k ) - e120 ( i , j , km )) * dzh2i ( k ) ) * dzfi ( k ) & ) end do end do end do end subroutine diffe","tags":"","loc":"proc/diffe.html"},{"title":"diffu – uDALES","text":"public subroutine diffu(putout) Uses modglobal modfields modsurfdata modmpi proc~~diffu~~UsesGraph proc~diffu diffu module~modmpi modmpi proc~diffu->module~modmpi module~modfields modfields proc~diffu->module~modfields module~modglobal modglobal proc~diffu->module~modglobal module~modsurfdata modsurfdata proc~diffu->module~modsurfdata mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(inout) :: putout (ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) Called by proc~~diffu~~CalledByGraph proc~diffu diffu proc~subgrid subgrid proc~subgrid->proc~diffu program~dalesurban DALESURBAN program~dalesurban->proc~subgrid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code diffu Source Code subroutine diffu ( putout ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , kmax , dxhi , dxf , dxfi , lles ,& dzf , dzfi , dy , dyi , dy2i , dzhi , dzhiq , jmax , numol use modfields , only : u0 , v0 , w0 use modsurfdata , only : ustar use modmpi , only : myid implicit none real , intent ( inout ) :: putout ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) real :: emmo , emom , emop , empo real :: fu , dummy real :: ucu , upcu integer :: i , j , k , jm , jp , km , kp if ( lles ) then do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie emom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k ) * dxf ( i ) ) + & ! dx is non-equidistant dzf ( k ) * ( ekm ( i , j , km ) * dxf ( i - 1 ) + ekm ( i - 1 , j , km ) * dxf ( i ) ) ) * dxhi ( i ) * dzhiq ( k ) emop = ( dzf ( kp ) * ( ekm ( i , j , k ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k ) * dxf ( i ) ) + & ! dx is non-equidistant dzf ( k ) * ( ekm ( i , j , kp ) * dxf ( i - 1 ) + ekm ( i - 1 , j , kp ) * dxf ( i ) ) ) * dxhi ( i ) * dzhiq ( kp ) empo = 0.25 * ( ( ekm ( i , j , k ) + ekm ( i , jp , k )) * dxf ( i - 1 ) + ( ekm ( i - 1 , j , k ) + ekm ( i - 1 , jp , k )) * dxf ( i ) ) * dxhi ( i ) ! dx is non-equidistant emmo = 0.25 * ( ( ekm ( i , j , k ) + ekm ( i , jm , k )) * dxf ( i - 1 ) + ( ekm ( i - 1 , jm , k ) + ekm ( i - 1 , j , k )) * dxf ( i ) ) * dxhi ( i ) ! dx is non-equidistant ! Discretized diffusion term putout ( i , j , k ) = putout ( i , j , k ) & + & ( ekm ( i , j , k ) * ( u0 ( i + 1 , j , k ) - u0 ( i , j , k )) * dxfi ( i ) & - ekm ( i - 1 , j , k ) * ( u0 ( i , j , k ) - u0 ( i - 1 , j , k )) * dxfi ( i - 1 ) ) * 2. * dxhi ( i ) & + & ( empo * ( ( u0 ( i , jp , k ) - u0 ( i , j , k )) * dyi & + ( v0 ( i , jp , k ) - v0 ( i - 1 , jp , k )) * dxhi ( i )) & - emmo * ( ( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi & + ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dxhi ( i )) & ) * dyi & + & ( emop * ( ( u0 ( i , j , kp ) - u0 ( i , j , k )) * dzhi ( kp ) & + ( w0 ( i , j , kp ) - w0 ( i - 1 , j , kp )) * dxhi ( i )) & - emom * ( ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) & + ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dxhi ( i )) & ) * dzfi ( k ) end do end do end do else ! DNS do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie ! Discretized diffusion term putout ( i , j , k ) = putout ( i , j , k ) & + & ( numol * ( u0 ( i + 1 , j , k ) - u0 ( i , j , k )) * dxfi ( i ) & - numol * ( u0 ( i , j , k ) - u0 ( i - 1 , j , k )) * dxfi ( i - 1 ) ) * 2. * dxhi ( i ) & + & ( numol * ( ( u0 ( i , jp , k ) - u0 ( i , j , k )) * dyi & + ( v0 ( i , jp , k ) - v0 ( i - 1 , jp , k )) * dxhi ( i )) & - numol * ( ( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi & + ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dxhi ( i )) & ) * dyi & + & ( numol * ( ( u0 ( i , j , kp ) - u0 ( i , j , k )) * dzhi ( kp ) & + ( w0 ( i , j , kp ) - w0 ( i - 1 , j , kp )) * dxhi ( i )) & - numol * ( ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) & + ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dxhi ( i )) & ) * dzfi ( k ) end do end do end do end if ! lles end subroutine diffu","tags":"","loc":"proc/diffu.html"},{"title":"diffv – uDALES","text":"public subroutine diffv(putout) Uses modglobal modfields modsurfdata modmpi proc~~diffv~~UsesGraph proc~diffv diffv module~modmpi modmpi proc~diffv->module~modmpi module~modfields modfields proc~diffv->module~modfields module~modglobal modglobal proc~diffv->module~modglobal module~modsurfdata modsurfdata proc~diffv->module~modsurfdata mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(inout) :: putout (ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) Called by proc~~diffv~~CalledByGraph proc~diffv diffv proc~subgrid subgrid proc~subgrid->proc~diffv program~dalesurban DALESURBAN program~dalesurban->proc~subgrid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code diffv Source Code subroutine diffv ( putout ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , dxf , dxhi , dxfi , dzf , dzfi , dyi ,& dy2i , dzhi , dzhiq , jmax , numol , lles use modfields , only : u0 , v0 , w0 use modsurfdata , only : ustar use modmpi , only : myid implicit none real , intent ( inout ) :: putout ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) real :: emmo , eomm , eomp , epmo real :: fv , vcv , vpcv integer :: i , j , k , jm , jp , km , kp if ( lles ) then do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie eomm = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i , jm , k ) ) + & dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i , jm , km ) ) ) * dzhiq ( k ) eomp = ( dzf ( kp ) * ( ekm ( i , j , k ) + ekm ( i , jm , k ) ) + & dzf ( k ) * ( ekm ( i , j , kp ) + ekm ( i , jm , kp ) ) ) * dzhiq ( kp ) emmo = 0.25 * ( ( ekm ( i , j , k ) + ekm ( i , jm , k )) * dxf ( i - 1 ) + ( ekm ( i - 1 , jm , k ) + ekm ( i - 1 , j , k )) * dxf ( i ) ) * dxhi ( i ) ! dx is non-equidistant epmo = 0.25 * ( ( ekm ( i , j , k ) + ekm ( i , jm , k )) * dxf ( i + 1 ) + ( ekm ( i + 1 , jm , k ) + ekm ( i + 1 , j , k )) * dxf ( i ) ) * dxhi ( i + 1 ) ! dx is non-equidistant ! discretized diffusion term putout ( i , j , k ) = putout ( i , j , k ) & + & ( epmo * ( ( v0 ( i + 1 , j , k ) - v0 ( i , j , k )) * dxhi ( i + 1 ) & + ( u0 ( i + 1 , j , k ) - u0 ( i + 1 , jm , k )) * dyi ) & - emmo * ( ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dxhi ( i ) & + ( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi ) & ) * dxfi ( i ) & ! = d/dx( Km*(dv/dx + du/dy) ) + & ( ekm ( i , j , k ) * ( v0 ( i , jp , k ) - v0 ( i , j , k )) & - ekm ( i , jm , k ) * ( v0 ( i , j , k ) - v0 ( i , jm , k )) ) * 2. * dy2i & ! = d/dy( 2*Km*(dv/dy) ) + & ( eomp * ( ( v0 ( i , j , kp ) - v0 ( i , j , k )) * dzhi ( kp ) & + ( w0 ( i , j , kp ) - w0 ( i , jm , kp )) * dyi ) & - eomm * ( ( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) & + ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi ) & ) * dzfi ( k ) ! = d/dz( Km*(dv/dz + dw/dy) ) end do end do end do else ! DNS do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie putout ( i , j , k ) = putout ( i , j , k ) & + & ( numol * ( ( v0 ( i + 1 , j , k ) - v0 ( i , j , k )) * dxhi ( i + 1 ) & + ( u0 ( i + 1 , j , k ) - u0 ( i + 1 , jm , k )) * dyi ) & - numol * ( ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dxhi ( i ) & + ( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi ) & ) * dxfi ( i ) & ! = d/dx( Km*(dv/dx + du/dy) ) + & ( numol * ( v0 ( i , jp , k ) - v0 ( i , j , k )) & - numol * ( v0 ( i , j , k ) - v0 ( i , jm , k )) ) * 2. * dy2i & ! = d/dy( 2*Km*(dv/dy) ) + & ( numol * ( ( v0 ( i , j , kp ) - v0 ( i , j , k )) * dzhi ( kp ) & + ( w0 ( i , j , kp ) - w0 ( i , jm , kp )) * dyi ) & - numol * ( ( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) & + ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi ) & ) * dzfi ( k ) ! = d/dz( Km*(dv/dz + dw/dy) ) end do end do end do end if end subroutine diffv","tags":"","loc":"proc/diffv.html"},{"title":"diffw – uDALES","text":"public subroutine diffw(putout) Uses modglobal modfields modmpi proc~~diffw~~UsesGraph proc~diffw diffw module~modmpi modmpi proc~diffw->module~modmpi module~modfields modfields proc~diffw->module~modfields module~modglobal modglobal proc~diffw->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(inout) :: putout (ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) Called by proc~~diffw~~CalledByGraph proc~diffw diffw proc~subgrid subgrid proc~subgrid->proc~diffw program~dalesurban DALESURBAN program~dalesurban->proc~subgrid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code diffw Source Code subroutine diffw ( putout ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , kmax , dxf , dxhi , dxfi , dy ,& dyi , dy2i , dzf , dzfi , dzhi , dzhiq , jmax , numol , lles use modfields , only : u0 , v0 , w0 use modmpi , only : myid implicit none !***************************************************************** real , intent ( inout ) :: putout ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) real :: emom , eomm , eopm , epom integer :: i , j , k , jm , jp , km , kp if ( lles ) then do k = kb + 1 , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie emom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k ) * dxf ( i ) ) * dxhi ( i ) + & dzf ( k ) * ( ekm ( i , j , km ) * dxf ( i - 1 ) + ekm ( i - 1 , j , km ) * dxf ( i ) ) * dxhi ( i ) ) * dzhiq ( k ) eomm = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i , jm , k ) ) + & dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i , jm , km ) ) ) * dzhiq ( k ) eopm = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i , jp , k ) ) + & dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i , jp , km ) ) ) * dzhiq ( k ) epom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( i + 1 ) + ekm ( i + 1 , j , k ) * dxf ( i ) ) * dxhi ( i + 1 ) + & dzf ( k ) * ( ekm ( i , j , km ) * dxf ( i + 1 ) + ekm ( i + 1 , j , km ) * dxf ( i ) ) * dxhi ( i + 1 ) ) * dzhiq ( k ) ! discretized diffusion term putout ( i , j , k ) = putout ( i , j , k ) & + & ( epom * ( ( w0 ( i + 1 , j , k ) - w0 ( i , j , k )) * dxhi ( i + 1 ) & + ( u0 ( i + 1 , j , k ) - u0 ( i + 1 , j , km )) * dzhi ( k ) ) & - emom * ( ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dxhi ( i ) & + ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) ) & ) * dxfi ( i ) & + & ( eopm * ( ( w0 ( i , jp , k ) - w0 ( i , j , k )) * dyi & + ( v0 ( i , jp , k ) - v0 ( i , jp , km )) * dzhi ( k ) ) & - eomm * ( ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi & + ( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) ) & ) * dyi & + & ( ekm ( i , j , k ) * ( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) & - ekm ( i , j , km ) * ( w0 ( i , j , k ) - w0 ( i , j , km )) * dzfi ( km ) ) * 2. & * dzhi ( k ) end do end do end do else ! DNS do k = kb + 1 , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie ! discretized diffusion term putout ( i , j , k ) = putout ( i , j , k ) & + & ( numol * ( ( w0 ( i + 1 , j , k ) - w0 ( i , j , k )) * dxhi ( i + 1 ) & + ( u0 ( i + 1 , j , k ) - u0 ( i + 1 , j , km )) * dzhi ( k ) ) & - numol * ( ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dxhi ( i ) & + ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) ) & ) * dxfi ( i ) & + & ( numol * ( ( w0 ( i , jp , k ) - w0 ( i , j , k )) * dyi & + ( v0 ( i , jp , k ) - v0 ( i , jp , km )) * dzhi ( k ) ) & - numol * ( ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi & + ( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) ) & ) * dyi & + & ( numol * ( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) & - numol * ( w0 ( i , j , k ) - w0 ( i , j , km )) * dzfi ( km ) ) * 2. & * dzhi ( k ) end do end do end do end if end subroutine diffw","tags":"","loc":"proc/diffw.html"},{"title":"startup – uDALES","text":"public subroutine startup() Uses modglobal modsurfdata modfields modpois modboundary modthermodynamics modsubgrid modmpi modinlet modinletdata modibmdata modforces moddriver proc~~startup~~UsesGraph proc~startup startup module~moddriver moddriver proc~startup->module~moddriver module~modibmdata modibmdata proc~startup->module~modibmdata module~modsurfdata modsurfdata proc~startup->module~modsurfdata module~modpois modpois proc~startup->module~modpois module~modmpi modmpi proc~startup->module~modmpi module~modboundary modboundary proc~startup->module~modboundary module~modsubgrid modsubgrid proc~startup->module~modsubgrid module~modinlet modinlet proc~startup->module~modinlet module~modforces modforces proc~startup->module~modforces module~modinletdata modinletdata proc~startup->module~modinletdata module~modthermodynamics modthermodynamics proc~startup->module~modthermodynamics module~modfields modfields proc~startup->module~modfields module~modglobal modglobal proc~startup->module~modglobal module~moddriver->module~modinletdata mpi mpi module~modmpi->mpi module~modsubgriddata modsubgriddata module~modsubgrid->module~modsubgriddata module~modinlet->module~modinletdata Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~startup~~CallsGraph proc~startup startup proc~initglobal initglobal proc~startup->proc~initglobal proc~initpois initpois proc~startup->proc~initpois proc~checkinitvalues checkinitvalues proc~startup->proc~checkinitvalues proc~initthermodynamics initthermodynamics proc~startup->proc~initthermodynamics proc~initinlet initinlet proc~startup->proc~initinlet proc~initfields initfields proc~startup->proc~initfields proc~initdriver initdriver proc~startup->proc~initdriver proc~createmasks createmasks proc~startup->proc~createmasks proc~readinitfiles readinitfiles proc~startup->proc~readinitfiles proc~calcfluidvolumes calcfluidvolumes proc~startup->proc~calcfluidvolumes proc~initboundary initboundary proc~startup->proc~initboundary proc~initsubgrid initsubgrid proc~startup->proc~initsubgrid mpi_bcast mpi_bcast proc~startup->mpi_bcast proc~createscals createscals proc~startup->proc~createscals proc~initglobal->mpi_bcast float float proc~initglobal->float proc~checkinitvalues->mpi_bcast mpi_finalize mpi_finalize proc~checkinitvalues->mpi_finalize proc~readzincoord readzincoord proc~initinlet->proc~readzincoord winl winl proc~initinlet->winl wrec wrec proc~initinlet->wrec tinl tinl proc~initinlet->tinl utav utav proc~initinlet->utav trec trec proc~initinlet->trec urec urec proc~initinlet->urec ttav ttav proc~initinlet->ttav uinl uinl proc~initinlet->uinl proc~createmasks->mpi_bcast mpi_allreduce mpi_allreduce proc~createmasks->mpi_allreduce proc~readinitfiles->mpi_bcast proc~calc_halflev calc_halflev proc~readinitfiles->proc~calc_halflev proc~drivergen drivergen proc~readinitfiles->proc~drivergen proc~thermodynamics thermodynamics proc~readinitfiles->proc~thermodynamics proc~readinletfile readinletfile proc~readinitfiles->proc~readinletfile proc~slabsum slabsum proc~readinitfiles->proc~slabsum proc~randomnize randomnize proc~readinitfiles->proc~randomnize proc~readrestartfiles readrestartfiles proc~readinitfiles->proc~readrestartfiles proc~readdriverfile readdriverfile proc~readinitfiles->proc~readdriverfile proc~boundary boundary proc~readinitfiles->proc~boundary proc~fluidvolume fluidvolume proc~calcfluidvolumes->proc~fluidvolume proc~uoutletarea uoutletarea proc~calcfluidvolumes->proc~uoutletarea proc~voutletarea voutletarea proc~calcfluidvolumes->proc~voutletarea proc~subgridnamelist subgridnamelist proc~initsubgrid->proc~subgridnamelist proc~readzincoord->mpi_bcast proc~writedriverfile writedriverfile proc~drivergen->proc~writedriverfile proc~thermodynamics->proc~calc_halflev proc~calthv calthv proc~thermodynamics->proc~calthv proc~diagfld diagfld proc~thermodynamics->proc~diagfld proc~thermo thermo proc~thermodynamics->proc~thermo proc~yinterpolate yinterpolate proc~readinletfile->proc~yinterpolate proc~excjs excjs proc~readinletfile->proc~excjs proc~slabsum->mpi_allreduce proc~voutletarea->mpi_bcast proc~zinterpolate2d zinterpolate2d proc~readrestartfiles->proc~zinterpolate2d proc~zinterpolatew1d zinterpolatew1d proc~readrestartfiles->proc~zinterpolatew1d proc~zinterpolate1d zinterpolate1d proc~readrestartfiles->proc~zinterpolate1d proc~zinterpolatet1d zinterpolatet1d proc~readrestartfiles->proc~zinterpolatet1d proc~boundary->proc~drivergen proc~cyclicmj cyclicmj proc~boundary->proc~cyclicmj proc~iohi iohi proc~boundary->proc~iohi proc~iolet iolet proc~boundary->proc~iolet proc~cyclicqi cyclicqi proc~boundary->proc~cyclicqi proc~inletgen inletgen proc~boundary->proc~inletgen proc~cyclichi cyclichi proc~boundary->proc~cyclichi proc~iosi iosi proc~boundary->proc~iosi proc~inletgennotemp inletgennotemp proc~boundary->proc~inletgennotemp proc~fluxtopscal fluxtopscal proc~boundary->proc~fluxtopscal proc~cyclicsi cyclicsi proc~boundary->proc~cyclicsi proc~cyclicqj cyclicqj proc~boundary->proc~cyclicqj proc~valuetop valuetop proc~boundary->proc~valuetop proc~inlettop inlettop proc~boundary->proc~inlettop proc~cyclicmi cyclicmi proc~boundary->proc~cyclicmi proc~scalrec scalrec proc~boundary->proc~scalrec proc~fluxtop fluxtop proc~boundary->proc~fluxtop proc~valuetopscal valuetopscal proc~boundary->proc~valuetopscal proc~cyclicsj cyclicsj proc~boundary->proc~cyclicsj proc~cyclichj cyclichj proc~boundary->proc~cyclichj proc~ioqi ioqi proc~boundary->proc~ioqi proc~scalsirane scalSIRANE proc~boundary->proc~scalsirane proc~subgridnamelist->mpi_bcast proc~cyclicmj->proc~excjs proc~iolet->proc~slabsum proc~inletgen->wrec proc~inletgen->proc~readinletfile proc~inletgen->proc~slabsum proc~inletgen->tinl proc~inletgen->utav proc~inletgen->trec proc~inletgen->urec proc~inletgen->ttav proc~inletgen->uinl proc~enthalpythickness enthalpythickness proc~inletgen->proc~enthalpythickness proc~writerestartfiles writerestartfiles proc~inletgen->proc~writerestartfiles proc~writeinletfile writeinletfile proc~inletgen->proc~writeinletfile proc~momentumthicknessexp momentumthicknessexp proc~inletgen->proc~momentumthicknessexp proc~blthicknesst blthicknesst proc~inletgen->proc~blthicknesst proc~dispthicknessexp dispthicknessexp proc~inletgen->proc~dispthicknessexp proc~fromztop fromztop proc~diagfld->proc~fromztop proc~inletgennotemp->wrec proc~inletgennotemp->proc~readinletfile proc~inletgennotemp->proc~slabsum proc~inletgennotemp->utav proc~inletgennotemp->urec proc~inletgennotemp->uinl proc~inletgennotemp->proc~writerestartfiles proc~inletgennotemp->proc~writeinletfile proc~inletgennotemp->proc~momentumthicknessexp proc~inletgennotemp->proc~blthicknesst proc~inletgennotemp->proc~dispthicknessexp proc~cyclicqj->proc~excjs proc~slabsumi slabsumi proc~inlettop->proc~slabsumi mpi_sendrecv mpi_sendrecv proc~excjs->mpi_sendrecv proc~cyclichj->proc~excjs proc~slabsumi->mpi_allreduce proc~dispthicknessexp->utav Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~startup~~CalledByGraph proc~startup startup program~dalesurban DALESURBAN program~dalesurban->proc~startup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code startup Source Code subroutine startup !-----------------------------------------------------------------| !                                                                 | !     Reads all general options from namoptions                   | !                                                                 | !      Jasper Tomas                 31/03/2014                    | !      Chiel van Heerwaarden        15/06/2007                    | !      Thijs Heus                   15/06/2007                    | !-----------------------------------------------------------------| use modglobal , only : initglobal , iexpnr , runtime , dtmax , & lwarmstart , lstratstart , lfielddump , lreadscal , startfile , tfielddump , fieldvars , tsample , tstatsdump , trestart , & nsv , imax , jtot , kmax , xsize , ysize , xlat , xlon , xday , xtime , lwalldist , & lmoist , lcoriol , igrw_damp , geodamptime , ifnamopt , fname_options , & xS , yS , zS , SS , sigS , iwallmom , iwalltemp , iwallmoist , iwallscal , ipoiss , iadv_mom , iadv_tke , iadv_thl , iadv_qt , iadv_sv , courant , diffnr , ladaptive , author ,& linoutflow , lper2inout , libm , lnudge , tnudge , nnudge , lles , luoutflowr , lvoutflowr , luvolflowr , lvvolflowr , & uflowrate , vflowrate , lstoreplane , iplane , & lreadmean , iinletgen , inletav , lreadminl , Uinf , Vinf , linletRA , nblocks , & lscalrec , lSIRANEinout , lscasrc , lscasrcl , lscasrcr , lydump , lytdump , lxydump , lxytdump , lslicedump , ltdump , ltkedump , lzerogradtop ,& lzerogradtopscal , lbuoyancy , ltempeq , & lfixinlet , lfixutauin , pi , & thlsrc , ifixuinf , lvinf , tscale , ltempinout , lmoistinout , & lwallfunc , lprofforc , lchem , k1 , JNO2 , rv , rd , tnextEB , tEB , dtEB , bldT , wsoil , wgrmax , wwilt , wfc , skyLW , GRLAI , rsmin , nfcts , lEB , lwriteEBfiles , nwalllayers , lconstW , & BCxm , BCxT , BCxq , BCxs , BCym , BCyT , BCyq , BCys , & BCtopm , BCtopT , BCtopq , BCtops , BCbotm , BCbotT , BCbotq , BCbots , & idriver , tdriverstart , driverjobnr , dtdriver , driverstore use modsurfdata , only : z0 , z0h , wtsurf , wttop , wqtop , wqsurf , wsvsurf , wsvtop , wsvsurfdum , wsvtopdum , ps , thvs , thls , thl_top , qt_top , qts ! use modsurface,        only : initsurface use modfields , only : initfields , dpdx , ncname use modpois , only : initpois use modboundary , only : initboundary , ksp use modthermodynamics , only : initthermodynamics , lqlnr , chi_half use modsubgrid , only : initsubgrid use modmpi , only : comm3d , myid , mpi_integer , mpi_logical , my_real , mpierr , mpi_character use modinlet , only : initinlet use modinletdata , only : di , dr , di_test , dti , iangledeg , iangle use modibmdata , only : bctfxm , bctfxp , bctfym , bctfyp , bctfz use modforces , only : calcfluidvolumes use moddriver , only : initdriver implicit none integer :: ierr !declare namelists namelist / RUN / & iexpnr , lwarmstart , lstratstart , startfile , & runtime , dtmax , trestart , ladaptive , & irandom , randu , randthl , randqt , krand , & courant , diffnr , author , & libm , lles , & lper2inout , lwalldist , & lreadmean namelist / DOMAIN / & imax , jtot , kmax , xsize , ysize , & xlat , xlon , xday , xtime , ksp namelist / PHYSICS / & ps , igrw_damp , lmoist , lcoriol , lbuoyancy , ltempeq , & lprofforc , ifixuinf , lvinf , tscale , dpdx , & luoutflowr , lvoutflowr , luvolflowr , lvvolflowr , & uflowrate , vflowrate , & lnudge , tnudge , nnudge namelist / DYNAMICS / & lqlnr , ipoiss , & iadv_mom , iadv_tke , iadv_thl , iadv_qt , iadv_sv namelist / BC / & BCxm , BCxT , BCxq , BCxs , & BCym , BCyT , BCyq , BCys , & BCtopm , BCtopT , BCtopq , BCtops , & BCbotm , BCbotT , BCbotq , BCbots , & bctfxm , bctfxp , bctfym , bctfyp , bctfz , & wttop , thl_top , qt_top , qts , wsvsurfdum , wsvtopdum , & wtsurf , wqsurf , thls , z0 , z0h namelist / INLET / & Uinf , Vinf , di , dti , inletav , linletRA , & lstoreplane , lreadminl , lfixinlet , lfixutauin , & lwallfunc namelist / DRIVER / & idriver , tdriverstart , driverjobnr , dtdriver , & driverstore , iplane namelist / WALLS / & nblocks , nfcts , iwallmom , iwalltemp , iwallmoist , iwallscal namelist / ENERGYBALANCE / & lEB , lwriteEBfiles , lconstW , dtEB , bldT , wsoil , wgrmax , wwilt , wfc , & skyLW , GRLAI , rsmin , nwalllayers namelist / SCALARS / & lreadscal , lscasrc , lscasrcl , lscasrcr , & nsv , xS , yS , zS , SS , sigS namelist / CHEMISTRY / & lchem , k1 , JNO2 namelist / OUTPUT / & lfielddump , tfielddump , fieldvars , & ltdump , lydump , lytdump , lxydump , lxytdump , & lslicedump , ltkedump , tstatsdump , tsample if ( myid == 0 ) then if ( command_argument_count () >= 1 ) then call get_command_argument ( 1 , fname_options ) end if write ( * , * ) fname_options open ( ifnamopt , file = fname_options , status = 'old' , iostat = ierr ) if ( ierr /= 0 ) then write ( 0 , * ) 'ERROR: Namoptions does not exist' write ( 0 , * ) 'iostat error: ' , ierr stop 1 end if read ( ifnamopt , RUN , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions RUN' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif write ( 6 , RUN ) rewind ( ifnamopt ) read ( ifnamopt , DOMAIN , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions DOMAIN' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif write ( 6 , DOMAIN ) rewind ( ifnamopt ) read ( ifnamopt , PHYSICS , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions PHYSICS' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif write ( 6 , PHYSICS ) rewind ( ifnamopt ) read ( ifnamopt , DYNAMICS , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions DYNAMICS' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif write ( 6 , DYNAMICS ) rewind ( ifnamopt ) read ( ifnamopt , BC , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions BC' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif write ( 6 , BC ) rewind ( ifnamopt ) read ( ifnamopt , INLET , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions INLET' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif write ( 6 , INLET ) rewind ( ifnamopt ) read ( ifnamopt , DRIVER , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'Problem in namoptions DRIVER' write ( 0 , * ) 'iostat error: ' , ierr stop 'ERROR: Problem in namoptions DRIVER' endif write ( 6 , DRIVER ) rewind ( ifnamopt ) read ( ifnamopt , WALLS , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions WALLS' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif write ( 6 , WALLS ) rewind ( ifnamopt ) read ( ifnamopt , ENERGYBALANCE , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions EB' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif write ( 6 , ENERGYBALANCE ) rewind ( ifnamopt ) read ( ifnamopt , SCALARS , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions SCALARS' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif write ( 6 , SCALARS ) rewind ( ifnamopt ) read ( ifnamopt , CHEMISTRY , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions CHEMISTRY' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif write ( 6 , CHEMISTRY ) rewind ( ifnamopt ) read ( ifnamopt , OUTPUT , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions OUTPUT' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif write ( 6 , OUTPUT ) close ( ifnamopt ) end if thvs = thls * ( 1. + ( rv / rd - 1. ) * qts ) write ( * , * ) \"starting broadcast\" !broadcast namelists call MPI_BCAST ( iexpnr , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( lwarmstart , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lstratstart , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lfielddump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lreadscal , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch to read scalar pollutant fields (warm start) call MPI_BCAST ( lscasrc , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 call MPI_BCAST ( lscasrcl , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 call MPI_BCAST ( lscasrcr , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 call MPI_BCAST ( lbuoyancy , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for buoyancy force in modforces call MPI_BCAST ( ltempeq , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for solving adv/diff equation for temperature call MPI_BCAST ( lper2inout , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for restart periodic flow to inoutflow call MPI_BCAST ( libm , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for turning on/off IBM method call MPI_BCAST ( lnudge , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( nnudge , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( tnudge , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lwalldist , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for computing wall distances call MPI_BCAST ( lles , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for turning on/off LES functionality (subgrid model) call MPI_BCAST ( linletRA , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for turning on/off Running Average in inletgenerator call MPI_BCAST ( lfixinlet , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for keeping average inlet velocit and temp fixed at inlet (iinletgen=1,2) call MPI_BCAST ( lfixutauin , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for keeping utau fixed at inlet (iinletgen=1,2) call MPI_BCAST ( xS , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( yS , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( zS , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( SS , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( sigS , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( idriver , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) ! ae1212: Added switch for driver inlet simulation call MPI_BCAST ( tdriverstart , 1 , MY_REAL , 0 , comm3d , mpierr ) ! ae1212 call MPI_BCAST ( driverjobnr , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) ! ae1212 call MPI_BCAST ( dtdriver , 1 , MY_REAL , 0 , comm3d , mpierr ) ! ae1212 call MPI_BCAST ( driverstore , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) write ( * , * ) \"sec BC\" call MPI_BCAST ( BCxm , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxT , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxq , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxs , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCym , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCyT , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCyq , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCys , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCtopm , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCtopT , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCtopq , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCtops , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCbotm , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCbotT , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCbotq , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCbots , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) write ( * , * ) \"sec c\" call MPI_BCAST ( lwallfunc , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for reading mean inlet/recycle plane profiles (Uinl,Urec,Wrec) call MPI_BCAST ( lreadminl , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for reading mean inlet/recycle plane profiles (Uinl,Urec,Wrec) call MPI_BCAST ( iwalltemp , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) ! case (integer) for wall treatment for temperature (1=no wall function/fixed flux, 2=no wall function/fixed value, 3=uno) call MPI_BCAST ( iwallmoist , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) ! case (integer) for wall treatment for moisture (1=no wall function/fixed flux, 2=no wall function/fixed value, 3=uno) call MPI_BCAST ( iwallscal , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( iwallmom , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) ! case (integer) for wall treatment for momentum (1=no wall function, 2=werner-wengle, 3=uno) write ( * , * ) \"sec d\" call MPI_BCAST ( luoutflowr , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for turning on/off u-velocity correction for fixed mass outflow rate call MPI_BCAST ( lvoutflowr , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315: added switch for turning on/off v-velocity correction for fixed mass outflow rate call MPI_BCAST ( luvolflowr , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! bss166: added switch for turning on/off u-velocity correction for fixed volume flow rate call MPI_BCAST ( lvvolflowr , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! bss116: added switch for turning on/off v-velocity correction for fixed volume flow rate call MPI_BCAST ( lstoreplane , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for turning on/off for storing i-plane data to serve as inlet for future sim. call MPI_BCAST ( lreadmean , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for reading mean variables from means#MYID#.#EXPNR# call MPI_BCAST ( lydump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 added switch for writing statistics files call MPI_BCAST ( lytdump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 added switch for writing statistics files call MPI_BCAST ( lxydump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 added switch for writing statistics files call MPI_BCAST ( lxytdump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 added switch for writing statistics files call MPI_BCAST ( lslicedump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 added switch for writing statistics files call MPI_BCAST ( ltdump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 added switch for writing statistics files call MPI_BCAST ( ltkedump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 added switch for writing tke budget files call MPI_BCAST ( iplane , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) ! J.Tomas: ib+iplane is the i-plane that is stored if lstoreplane is .true. call MPI_BCAST ( startfile , 50 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( author , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( runtime , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( trestart , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( tfielddump , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( tsample , 1 , MY_REAL , 0 , comm3d , mpierr ) !tg3315 call MPI_BCAST ( tstatsdump , 1 , MY_REAL , 0 , comm3d , mpierr ) !tg3315 call MPI_BCAST ( tEB , 1 , MY_REAL , 0 , comm3d , mpierr ) tnextEB = dtEB call MPI_BCAST ( tnextEB , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dtmax , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( nsv , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( fieldvars , 50 , MPI_CHARACTER , 0 , comm3d , mpierr ) !call MPI_BCAST(nstat      ,1,MPI_INTEGER,0,comm3d,mpierr) !tg3315 !call MPI_BCAST(ncstat     ,80,MPI_CHARACTER,0,comm3d,mpierr) !tg3315 call MPI_BCAST ( ifixuinf , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( lvinf , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dpdx , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( tscale , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( imax , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( jtot , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( kmax , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( xsize , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ysize , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( xlat , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( xlon , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( xday , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( xtime , 1 , MY_REAL , 0 , comm3d , mpierr ) write ( * , * ) \"sec f\" call MPI_BCAST ( z0 , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( z0h , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bctfxm , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bctfxp , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bctfym , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bctfyp , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bctfz , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wtsurf , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wqsurf , 1 , MY_REAL , 0 , comm3d , mpierr ) allocate ( wsvsurf ( 1 : nsv )) wsvsurf = wsvsurfdum ( 1 : nsv ) call MPI_BCAST ( wsvsurf ( 1 : nsv ), nsv , MY_REAL , 0 , comm3d , mpierr ) allocate ( wsvtop ( 1 : nsv )) wsvtop = wsvtopdum ( 1 : nsv ) call MPI_BCAST ( wsvtop ( 1 : nsv ), nsv , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ps , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( thvs , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( thls , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( thl_top , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( qt_top , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( qts , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lmoist , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lcoriol , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lprofforc , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lchem , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( k1 , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( JNO2 , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( igrw_damp , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( geodamptime , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wttop , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wqtop , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( thlsrc , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( uflowrate , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( vflowrate , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( Uinf , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( Vinf , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( di , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dti , 1 , MY_REAL , 0 , comm3d , mpierr ) dr = di ! initial value is needed di_test = di ! initial value is needed write ( * , * ) \"sec g\" call MPI_BCAST ( iangledeg , 1 , MY_REAL , 0 , comm3d , mpierr ) iangle = iangledeg * pi / 18 0. call MPI_BCAST ( inletav , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lqlnr , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ksp , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nblocks , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) ! no. of blocks used in IBM call MPI_BCAST ( nfcts , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( lconstW , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lEB , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lwriteEBfiles , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wsoil , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wgrmax , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wwilt , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wfc , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dtEB , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bldT , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( skyLW , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( GRLAI , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( rsmin , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( nwalllayers , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( irandom , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( krand , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( randthl , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( randu , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( randqt , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ladaptive , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( courant , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( diffnr , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ipoiss , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( iadv_mom , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( iadv_tke , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( iadv_thl , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( iadv_qt , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( iadv_sv ( 1 : nsv ), nsv , MPI_INTEGER , 0 , comm3d , mpierr ) !write(*,*) \"sec h\" ! Allocate and initialize core modules call initglobal write ( * , * ) \"done initglobal\" call initfields write ( * , * ) \"done initfields\" call initboundary write ( * , * ) \"done initboundayi\" call initthermodynamics write ( * , * ) \"done initthermodynamics\" !!depreated!! ! call initsurface write ( * , * ) \"done initsurface\" call initsubgrid write ( * , * ) \"done initsubgrid\" call initpois write ( * , * ) \"done initpois\" call initinlet ! added by J. Tomas: initialize inlet generator write ( * , * ) \"done initinlet\" call initdriver ! added by ae1212: initialise driver inlet write ( * , * ) \"done initdriver\" call checkinitvalues write ( * , * ) \"done checkinitvalues\" write ( 6 , * ) 'Determine masking matrices' call createmasks ! determine walls/blocks write ( 6 , * ) 'Finished determining masking matrices' ! calculate fluid volume and outlet areas, needs masking matrices call calcfluidvolumes call readinitfiles write ( * , * ) \"done readinitfiles\" write ( * , * ) \"done startup\" call createscals write ( * , * ) \"done create scals\" end subroutine startup","tags":"","loc":"proc/startup.html"},{"title":"checkinitvalues – uDALES","text":"public subroutine checkinitvalues() Uses modsurfdata modglobal modmpi modglobal proc~~checkinitvalues~~UsesGraph proc~checkinitvalues checkinitvalues module~modmpi modmpi proc~checkinitvalues->module~modmpi module~modglobal modglobal proc~checkinitvalues->module~modglobal module~modsurfdata modsurfdata proc~checkinitvalues->module~modsurfdata mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~checkinitvalues~~CallsGraph proc~checkinitvalues checkinitvalues mpi_bcast mpi_bcast proc~checkinitvalues->mpi_bcast mpi_finalize mpi_finalize proc~checkinitvalues->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~checkinitvalues~~CalledByGraph proc~checkinitvalues checkinitvalues proc~startup startup proc~startup->proc~checkinitvalues program~dalesurban DALESURBAN program~dalesurban->proc~startup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code checkinitvalues Source Code subroutine checkinitvalues !-----------------------------------------------------------------| !                                                                 | !      Thijs Heus   TU Delft  9/2/2006                            | !                                                                 | !     purpose.                                                    | !     --------                                                    | !                                                                 | !      checks whether crucial parameters are set correctly        | !                                                                 | !     interface.                                                  | !     ----------                                                  | !                                                                 | !     *checkinitvalues* is called from *program*.                 | !                                                                 | !-----------------------------------------------------------------| use modsurfdata , only : wtsurf , wqsurf , qts , ps use modglobal , only : imax , kmax , jtot , ysize , xsize , dxf , ib , ie ,& dtmax , runtime , startfile , lwarmstart , lstratstart ,& BCxm , BCxT , BCxq , BCxs , BCtopm , BCbotm ,& iinletgen , linoutflow , ltempeq , iwalltemp , iwallmom ,& ipoiss , POISS_FFT , POISS_CYC use modmpi , only : myid , nprocs , mpierr , comm3d , MPI_INTEGER , MPI_LOGICAL use modglobal , only : idriver implicit none real :: d ( 1 : imax - 1 ) logical :: inequi if ( mod ( jtot , nprocs ) /= 0 ) then if ( myid == 0 ) then write ( 0 , * ) 'STOP ERROR IN NUMBER OF PROCESSORS' write ( 0 , * ) 'nprocs must divide jtot!!! ' write ( 0 , * ) 'nprocs and jtot are: ' , nprocs , jtot end if call MPI_FINALIZE ( mpierr ) stop 1 end if if ( ipoiss == POISS_FFT ) then if ( mod ( imax , nprocs ) /= 0 ) then if ( myid == 0 ) then write ( 0 , * ) 'STOP ERROR IN NUMBER OF PROCESSORS' write ( 0 , * ) 'nprocs must divide imax!!! ' write ( 0 , * ) 'nprocs and imax are: ' , nprocs , imax end if call MPI_FINALIZE ( mpierr ) stop 1 end if end if if ( mod ( kmax , nprocs ) /= 0 ) then if ( myid == 0 ) then write ( 0 , * ) 'STOP ERROR IN NUMBER OF PROCESSORS' write ( 0 , * ) 'nprocs must divide kmax!!! ' write ( 0 , * ) 'nprocs and kmax are: ' , nprocs , kmax end if call MPI_FINALIZE ( mpierr ) stop 1 end if !Check Namoptions if ( runtime < 0 ) then write ( 0 , * ) 'ERROR: runtime out of range/not set' stop 1 end if if ( dtmax < 0 ) then write ( 0 , * ) 'ERROR: dtmax out of range/not set' stop 1 end if if ( ps < 0 ) then write ( 0 , * ) 'ERROR: psout of range/not set' stop 1 end if if ( xsize < 0 ) then write ( 0 , * ) 'ERROR: xsize out of range/not set' stop 1 end if if ( ysize < 0 ) then write ( 0 , * ) 'ERROR: ysize out of range/not set' stop 1 end if if (( lwarmstart ) . or . ( lstratstart )) then if ( startfile == '' ) then write ( 0 , * ) 'ERROR: no restartfile set' stop 1 end if end if ! Switch to ensure that neutral wall function is called when ltempeq=false and if iwalltemp==1 (constant flux and therefore wall temp is not resolved. if (( ltempeq . eqv . . false .) . or . ( iwalltemp == 1 )) then iwallmom = 3 BCbotm = 3 end if ! choosing inoutflow in x requires switches to be set ! tg3315 - these could be moved to init boundary if ( BCxm . eq . 2 ) then write ( * , * ) \"inoutflow conditions, setting appropriate switches (1)\" iinletgen = 1 BCxT = 3 !temperature is considered in inletgen & iolet BCxq = 3 !humidity is considered in iolet BCxs = 3 !scalars are considered in iolet BCtopm = 3 !velocity at top determined by topm linoutflow = . true . call MPI_BCAST ( iinletgen , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxT , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxq , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxs , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCtopm , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( linoutflow , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) else if ( BCxm . eq . 3 ) then write ( * , * ) \"inoutflow conditions, setting appropriate switches (2)\" iinletgen = 2 ! see modstartup for conditions that apply with inletgenerators ! move to modstartup BCxT = 3 !temperature is considered in inletgen & iolet BCxq = 3 !humidity is considered in iolet BCxs = 3 !scalars are considered in iolet BCtopm = 3 !velocity at top determined by topm linoutflow = . true . call MPI_BCAST ( iinletgen , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxT , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxq , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxs , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCtopm , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( linoutflow , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) else if ( BCxm . eq . 4 ) then write ( * , * ) \"inoutflow conditions, setting appropriate switches (0)\" iinletgen = 0 ! see modstartup for conditions that apply with inletgenerators ! move to modstartup BCxT = 3 !temperature is considered in inletgen & iolet BCxq = 3 !humidity is considered in iolet BCxs = 3 !scalars are considered in iolet BCtopm = 3 !velocity at top determined by topm linoutflow = . true . call MPI_BCAST ( iinletgen , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxT , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxq , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxs , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCtopm , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( linoutflow , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) else if ( BCxm . eq . 5 ) then write ( * , * ) \"inoutflow conditions and idriver, setting appropriate switches (0)\" iinletgen = 0 idriver = 2 BCxT = 3 !temperature is considered in inletgen & iolet BCxq = 3 !humidity is considered in iolet BCxs = 3 !scalars are considered in iolet BCtopm = 3 !velocity at top determined by topm linoutflow = . true . call MPI_BCAST ( iinletgen , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( idriver , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxT , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxq , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxs , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCtopm , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( linoutflow , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) end if ! check the Poisson solver setting w.r.t. x-grid d ( 1 : imax - 1 ) = dxf ( ib + 1 : ie ) - dxf ( ib : ie - 1 ) inequi = any ( abs ( d ) > dxf ( ib ) * 1e-5 ) if ((. not . inequi ) . and . ( ipoiss == POISS_CYC ) . and . (. not . linoutflow )) then write ( * , * ) \"WARNING: consider using FFT poisson solver for better performance!\" end if if (( ipoiss == POISS_FFT ) . and . ( inequi )) then write ( * , * ) \"ERROR: POISS_FFT requires equidistant grid. Aborting...\" call MPI_FINALIZE ( mpierr ) stop 1 end if end subroutine checkinitvalues","tags":"","loc":"proc/checkinitvalues.html"},{"title":"readinitfiles – uDALES","text":"public subroutine readinitfiles() Uses modfields modglobal modsubgriddata modsurfdata modboundary modmpi modthermodynamics modinletdata modinlet moddriver proc~~readinitfiles~~UsesGraph proc~readinitfiles readinitfiles module~moddriver moddriver proc~readinitfiles->module~moddriver module~modsurfdata modsurfdata proc~readinitfiles->module~modsurfdata module~modinlet modinlet proc~readinitfiles->module~modinlet module~modmpi modmpi proc~readinitfiles->module~modmpi module~modboundary modboundary proc~readinitfiles->module~modboundary module~modsubgriddata modsubgriddata proc~readinitfiles->module~modsubgriddata module~modinletdata modinletdata proc~readinitfiles->module~modinletdata module~modthermodynamics modthermodynamics proc~readinitfiles->module~modthermodynamics module~modfields modfields proc~readinitfiles->module~modfields module~modglobal modglobal proc~readinitfiles->module~modglobal module~moddriver->module~modinletdata module~modinlet->module~modinletdata mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~readinitfiles~~CallsGraph proc~readinitfiles readinitfiles proc~boundary boundary proc~readinitfiles->proc~boundary proc~randomnize randomnize proc~readinitfiles->proc~randomnize proc~drivergen drivergen proc~readinitfiles->proc~drivergen proc~calc_halflev calc_halflev proc~readinitfiles->proc~calc_halflev proc~readrestartfiles readrestartfiles proc~readinitfiles->proc~readrestartfiles proc~readdriverfile readdriverfile proc~readinitfiles->proc~readdriverfile proc~thermodynamics thermodynamics proc~readinitfiles->proc~thermodynamics proc~readinletfile readinletfile proc~readinitfiles->proc~readinletfile proc~slabsum slabsum proc~readinitfiles->proc~slabsum mpi_bcast mpi_bcast proc~readinitfiles->mpi_bcast proc~boundary->proc~drivergen proc~cyclicmj cyclicmj proc~boundary->proc~cyclicmj proc~iohi iohi proc~boundary->proc~iohi proc~iolet iolet proc~boundary->proc~iolet proc~cyclicqi cyclicqi proc~boundary->proc~cyclicqi proc~inletgen inletgen proc~boundary->proc~inletgen proc~cyclichi cyclichi proc~boundary->proc~cyclichi proc~iosi iosi proc~boundary->proc~iosi proc~inletgennotemp inletgennotemp proc~boundary->proc~inletgennotemp proc~fluxtopscal fluxtopscal proc~boundary->proc~fluxtopscal proc~cyclicsi cyclicsi proc~boundary->proc~cyclicsi proc~cyclicqj cyclicqj proc~boundary->proc~cyclicqj proc~valuetop valuetop proc~boundary->proc~valuetop proc~inlettop inlettop proc~boundary->proc~inlettop proc~cyclicmi cyclicmi proc~boundary->proc~cyclicmi proc~scalrec scalrec proc~boundary->proc~scalrec proc~fluxtop fluxtop proc~boundary->proc~fluxtop proc~valuetopscal valuetopscal proc~boundary->proc~valuetopscal proc~cyclicsj cyclicsj proc~boundary->proc~cyclicsj proc~cyclichj cyclichj proc~boundary->proc~cyclichj proc~ioqi ioqi proc~boundary->proc~ioqi proc~scalsirane scalSIRANE proc~boundary->proc~scalsirane proc~writedriverfile writedriverfile proc~drivergen->proc~writedriverfile proc~zinterpolate2d zinterpolate2d proc~readrestartfiles->proc~zinterpolate2d proc~zinterpolatew1d zinterpolatew1d proc~readrestartfiles->proc~zinterpolatew1d proc~zinterpolate1d zinterpolate1d proc~readrestartfiles->proc~zinterpolate1d proc~zinterpolatet1d zinterpolatet1d proc~readrestartfiles->proc~zinterpolatet1d proc~thermodynamics->proc~calc_halflev proc~calthv calthv proc~thermodynamics->proc~calthv proc~diagfld diagfld proc~thermodynamics->proc~diagfld proc~thermo thermo proc~thermodynamics->proc~thermo proc~yinterpolate yinterpolate proc~readinletfile->proc~yinterpolate proc~excjs excjs proc~readinletfile->proc~excjs mpi_allreduce mpi_allreduce proc~slabsum->mpi_allreduce proc~cyclicmj->proc~excjs proc~iolet->proc~slabsum proc~inletgen->proc~readinletfile proc~inletgen->proc~slabsum proc~enthalpythickness enthalpythickness proc~inletgen->proc~enthalpythickness trec trec proc~inletgen->trec wrec wrec proc~inletgen->wrec uinl uinl proc~inletgen->uinl urec urec proc~inletgen->urec ttav ttav proc~inletgen->ttav proc~writerestartfiles writerestartfiles proc~inletgen->proc~writerestartfiles proc~writeinletfile writeinletfile proc~inletgen->proc~writeinletfile proc~momentumthicknessexp momentumthicknessexp proc~inletgen->proc~momentumthicknessexp proc~blthicknesst blthicknesst proc~inletgen->proc~blthicknesst tinl tinl proc~inletgen->tinl proc~dispthicknessexp dispthicknessexp proc~inletgen->proc~dispthicknessexp utav utav proc~inletgen->utav proc~fromztop fromztop proc~diagfld->proc~fromztop proc~inletgennotemp->proc~readinletfile proc~inletgennotemp->proc~slabsum proc~inletgennotemp->wrec proc~inletgennotemp->uinl proc~inletgennotemp->urec proc~inletgennotemp->proc~writerestartfiles proc~inletgennotemp->proc~writeinletfile proc~inletgennotemp->proc~momentumthicknessexp proc~inletgennotemp->proc~blthicknesst proc~inletgennotemp->proc~dispthicknessexp proc~inletgennotemp->utav proc~cyclicqj->proc~excjs proc~slabsumi slabsumi proc~inlettop->proc~slabsumi mpi_sendrecv mpi_sendrecv proc~excjs->mpi_sendrecv proc~cyclichj->proc~excjs proc~slabsumi->mpi_allreduce proc~dispthicknessexp->utav Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readinitfiles~~CalledByGraph proc~readinitfiles readinitfiles proc~startup startup proc~startup->proc~readinitfiles program~dalesurban DALESURBAN program~dalesurban->proc~startup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code readinitfiles Source Code subroutine readinitfiles use modfields , only : u0 , v0 , w0 , um , vm , wm , thlm , thl0 , thl0h , qtm , qt0 , qt0h , & ql0 , ql0h , thv0h , sv0 , svm , e12m , e120 , & dudxls , dudyls , dvdxls , dvdyls , dthldxls , dthldyls , & dqtdxls , dqtdyls , dqtdtls , dpdx , dpdxl , dpdyl , & wfls , whls , ug , vg , pgx , pgy , uprof , vprof , thlprof , qtprof , e12prof , svprof , & v0av , u0av , qt0av , ql0av , thl0av , qt0av , sv0av , exnf , exnh , presf , presh , rhof , & thlpcar , uav , thvh , thvf , IIc , IIcs , IIu , IIus , IIv , IIvs , IIw , IIws use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , khc , kmax , dtmax , dt , runtime , timeleft , timee , ntimee , ntrun , btime , dt_lim , nsv ,& zf , zh , dzf , dzh , rv , rd , grav , cp , rlv , pref0 , om23_gs , jgb , jge , Uinf , Vinf , dy , & rslabs , e12min , dzh , dtheta , dqt , dsv , cexpnr , ifinput , lwarmstart , lstratstart , trestart , numol , & ladaptive , tnextrestart , jmax , linoutflow , lper2inout , iinletgen , lreadminl , & uflowrate , vflowrate , ltempeq , prandtlmoli , freestreamav , & tnextfielddump , tfielddump , tsample , tstatsdump , startfile , lprofforc , lchem , k1 , JNO2 ,& idriver , dtdriver , driverstore , tdriverstart , tdriverdump use modsubgriddata , only : ekm , ekh use modsurfdata , only : wtsurf , wqsurf , wsvsurf , & thls , thvs , ps , qts , svs , sv_top ! use modsurface,        only : surface,dthldz use modboundary , only : boundary , tqaver use modmpi , only : slabsum , myid , comm3d , mpierr , my_real , avexy_ibm use modthermodynamics , only : thermodynamics , calc_halflev use modinletdata , only : Uinl , Urec , Wrec , u0inletbc , v0inletbc , w0inletbc , ubulk , irecy , Utav , Ttav , & uminletbc , vminletbc , wminletbc , u0inletbcold , v0inletbcold , w0inletbcold , & storeu0inletbc , storev0inletbc , storew0inletbc , nstepread , nfile , Tinl , & Trec , tminletbc , t0inletbcold , t0inletbc , storet0inletbc , utaui , ttaui , iangle ,& u0driver , v0driver , w0driver , e120driver , tdriver , thl0driver , qt0driver , storetdriver ,& storeu0driver , storev0driver , storew0driver , storee120driver , storethl0driver , storeqt0driver ,& nstepreaddriver use modinlet , only : readinletfile use moddriver , only : readdriverfile , initdriver , drivergen integer i , j , k , n real , allocatable :: height (:), th0av (:) real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) :: thv0 real , dimension ( kb : ke ) :: uaverage ! volume averaged u-velocity real , dimension ( kb : ke ) :: vaverage ! volume averaged v-velocity real , dimension ( kb : ke ) :: uaverager ! recycle plane real , dimension ( kb : ke ) :: uaveragei ! inlet plane real , dimension ( kb : ke ) :: taverager ! recycle plane real , dimension ( kb : ke ) :: taveragei ! inlet plane real , dimension ( kb : ke + 1 ) :: waverage real , dimension ( kb : ke + 1 ) :: uprofrot real , dimension ( kb : ke + 1 ) :: vprofrot real tv , ran , ran1 , vbulk character ( 80 ) chmess allocate ( height ( kb : ke + kh )) allocate ( th0av ( kb : ke + kh )) if ( lstratstart ) then ! Switch ! Read restart files as in lwarmstart call readrestartfiles um = u0 vm = v0 wm = w0 thlm = thl0 !do this before or just not? qtm = qt0 svm = sv0 e12m = e120 ! Overwrite thlm, thl0, qtm, qt0 from prof.inp.xxx if ( myid == 0 ) then open ( ifinput , file = 'prof.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess write ( * , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do k = kb , ke read ( ifinput , * ) & height ( k ), & thlprof ( k ), & qtprof ( k ), & uprof ( k ), & vprof ( k ), & e12prof ( k ) end do close ( ifinput ) write ( * , * ) 'height    thl     qt      u      v     e12' do k = ke , kb , - 1 write ( * , '(f7.1,2f8.1,3f7.1)' ) & height ( k ), & thlprof ( k ), & qtprof ( k ), & uprof ( k ), & vprof ( k ), & e12prof ( k ) end do end if !myid=0 ! MPI broadcast thl and qt call MPI_BCAST ( thlprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( qtprof , kmax , MY_REAL , 0 , comm3d , mpierr ) do k = kb , ke do j = jb - 1 , je + 1 do i = ib - 1 , ie + 1 thl0 ( i , j , k ) = thlprof ( k ) thlm ( i , j , k ) = thlprof ( k ) qt0 ( i , j , k ) = qtprof ( k ) qtm ( i , j , k ) = qtprof ( k ) end do end do end do !ILS13 reintroduced thv !tg3315 this part may wrong, could need to use call calc_halflev ! exnf = (presf/pref0)**(rd/cp)  !exner functions not in restart files ! anymore.. or at least not read ! exnh = (presh/pref0)**(rd/cp) !   write(*,*) \"exnf\",enf !   write(*,*) \"exnh\",exnh do k = kb , ke + kh do j = jb , je do i = ib , ie !write(*,*) \"thl0h\",thl0h(i,j,k) thv0h ( i , j , k ) = ( thl0h ( i , j , k ) + rlv * ql0h ( i , j , k ) / ( cp )) & * ( 1 + ( rv / rd - 1 ) * qt0h ( i , j , k ) - rv / rd * ql0h ( i , j , k )) end do end do end do do j = j , je do i = ib , ie do k = kb , ke + kh thv0 ( i , j , k ) = ( thl0 ( i , j , k ) + rlv * ql0 ( i , j , k ) / ( cp )) & * ( 1 + ( rv / rd - 1 ) * qt0 ( i , j , k ) - rv / rd * ql0 ( i , j , k )) end do end do end do thvh = 0. ! call slabsum(thvh,kb,ke,thv0h,ib-ih,ie+ih,jb-jh,je+jh,kb-kh,ke+kh,ib,ie,jb,je,kb,ke) ! redefine halflevel thv using calculated thv call avexy_ibm ( thvh ( kb : ke + kh ), thv0h ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. false .) ! thvh = thvh/rslabs thvf = 0.0 call avexy_ibm ( thvf ( kb : ke + kh ), thv0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) ! call slabsum(thvf,kb,ke,thv0,ib-ih,ie+ih,jb-jh,je+jh,kb-kh,ke+kh,ib,ie,jb,je,kb,ke) ! thvf = thvf/rslabs else !if not lstratstart if (. not . lwarmstart ) then !******************************************************************** !    1.0 prepare initial fields from files 'prof.inp' and 'scalar.inp' !    ---------------------------------------------------------------- !-------------------------------------------------------------------- !    1.1 read fields !----------------------------------------------------------------- dt = dtmax / 10 0. timee = 0. if ( myid == 0 ) then open ( ifinput , file = 'prof.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess write ( * , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do k = kb , ke read ( ifinput , * ) & height ( k ), & thlprof ( k ), & qtprof ( k ), & uprof ( k ), & vprof ( k ), & e12prof ( k ) end do ! Apply rotation in horizontal !write (6, *) 'iangle = ', iangle !uprofrot = uprof*cos(iangle) - vprof*sin(iangle) !vprofrot = vprof*cos(iangle) + uprof*sin(iangle) !uprof = uprofrot !vprof = vprofrot close ( ifinput ) write ( * , * ) 'height    thl     qt      u      v     e12' do k = ke , kb , - 1 write ( * , '(f7.1,2f8.1,3f7.1)' ) & height ( k ), & thlprof ( k ), & qtprof ( k ), & uprof ( k ), & vprof ( k ), & e12prof ( k ) end do if ( minval ( e12prof ( kb : ke )) < e12min ) then write ( * , * ) 'e12 value is zero (or less) in prof.inp' do k = kb , ke e12prof ( k ) = max ( e12prof ( k ), e12min ) end do end if end if ! end if myid==0 ! MPI broadcast numbers reading call MPI_BCAST ( thlprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( qtprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( uprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( vprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( e12prof , kmax , MY_REAL , 0 , comm3d , mpierr ) do k = kb , ke do j = jb - 1 , je + 1 do i = ib - 1 , ie + 1 thl0 ( i , j , k ) = thlprof ( k ) thlm ( i , j , k ) = thlprof ( k ) qt0 ( i , j , k ) = qtprof ( k ) qtm ( i , j , k ) = qtprof ( k ) u0 ( i , j , k ) = uprof ( k ) um ( i , j , k ) = uprof ( k ) v0 ( i , j , k ) = vprof ( k ) vm ( i , j , k ) = vprof ( k ) w0 ( i , j , k ) = 0.0 wm ( i , j , k ) = 0.0 e120 ( i , j , k ) = e12prof ( k ) e12m ( i , j , k ) = e12prof ( k ) !        ekm (i,j,k) = 0.0 !        ekh (i,j,k) = 0.0 ekm ( i , j , k ) = numol ekh ( i , j , k ) = numol end do end do end do ekh (:, :, ke + 1 ) = ekh (:, :, ke ) ! also for start up ! ILS13 30.11.17, added, not sure if necessary ! ILS13 30.11.1, commented do j = jb - jh , je + jh do i = ib - ih , ie + ih thl0 ( i , j , ke + 1 ) = thl0 ( i , j , ke ) thl0 ( i , j , kb - 1 ) = thl0 ( i , j , kb ) end do end do !! add random fluctuations krand = min ( krand , ke ) do k = kb , krand call randomnize ( um , k , randu , irandom , ih , jh ) end do do k = kb , krand call randomnize ( vm , k , randu , irandom , ih , jh ) end do do k = kb , krand call randomnize ( wm , k , randu , irandom , ih , jh ) end do !       do k=kb+1,ke-1 !       do j=jb,je !       do i=ib+1,ie-1 !         call random_number(ran) !         ran1 = -1. +2.*ran !         wm(i,j,k)=wm(i,j,k)+ 0.1*Uinf*ran1 !       end do !       end do !       end do ! !       do k=kb+1,ke-1 !       do j=jb,je !       do i=ib+2,ie-1 !         call random_number(ran) !         ran1 = -1. +2.*ran !         um(i,j,k)=um(i,j,k)+ 0.1*Uinf*ran1 !       end do !       end do !       end do ! !       do k=kb+1,ke-1 !       do j=jb,je !       do i=ib+1,ie-1 !         call random_number(ran) !         ran1 = -1. +2.*ran !         vm(i,j,k)=vm(i,j,k)+ 0.1*Uinf*ran1 !       end do !       end do !       end do u0 = um v0 = vm w0 = wm uaverage = 0. ! call slabsum(uaverage, kb, ke, um, ib - 1, ie + 1, jb - 1, je + 1, kb - 1, ke + 1, ib, ie, jb, je, kb, ke) do k = kb , ke uaverage ( k ) = uprof ( k ) * dzf ( k ) end do ubulk = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! averaged u-velocity inflow profile vaverage = 0. ! call slabsum(vaverage, kb, ke, vm, ib - 1, ie + 1, jb - 1, je + 1, kb - 1, ke + 1, ib, ie, jb, je, kb, ke) do k = kb , ke vaverage ( k ) = vprof ( k ) * dzf ( k ) end do vbulk = sum ( vaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! averaged u-velocity inflow profile ! Set average inlet profile to initial inlet profile in case of inletgenerator mode if ( iinletgen == 1 ) then uaverage = 0. call slabsum ( uaverage , kb , ke , um , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ie , jb , je , kb , ke ) do k = kb , ke uaverage ( k ) = uprof ( k ) * dzf ( k ) end do ubulk = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! volume-averaged u-velocity write ( 6 , * ) 'Modstartup: ubulk=' , ubulk Utav ( ib : ie , kb : ke ) = um ( ib : ie , jb , kb : ke ) Uinl = um ( ib , jb , kb : ke ) ! set the initial time-averaged inlet profile equal to um Urec = um ( ib , jb , kb : ke ) ! set the initial time-averaged inlet profile equal to um Wrec ( kb : ke + 1 ) = wm ( ib , jb , kb : ke + 1 ) ! set the initial time-averaged inlet profile equal to mean w-profile u0inletbcold ( jb : je , kb : ke ) = um ( ib , jb : je , kb : ke ) v0inletbcold ( jb : je , kb : ke ) = vm ( ib - 1 , jb : je , kb : ke ) w0inletbcold ( jb : je , kb : ke + 1 ) = wm ( ib - 1 , jb : je , kb : ke + 1 ) uminletbc ( jb : je , kb : ke ) = um ( ib , jb : je , kb : ke ) vminletbc ( jb : je , kb : ke ) = vm ( ib - 1 , jb : je , kb : ke ) wminletbc ( jb : je , kb : ke ) = wm ( ib - 1 , jb : je , kb : ke ) u0inletbc ( jb : je , kb : ke ) = um ( ib , jb : je , kb : ke ) v0inletbc ( jb : je , kb : ke ) = vm ( ib - 1 , jb : je , kb : ke ) w0inletbc ( jb : je , kb : ke + 1 ) = wm ( ib - 1 , jb : je , kb : ke + 1 ) utaui = sqrt ( abs ( 2 * numol * Uinl ( kb ) / dzf ( kb ))) ! average streamwise friction at inlet (need for first time step) if ( ltempeq ) then Ttav ( ib : ie , kb : ke ) = thlm ( ib : ie , jb , kb : ke ) ! set the initial time-averaged inlet profile equal to thlm Tinl = thlm ( ib , jb , kb : ke ) ! set the initial time-averaged inlet profile equal to thlm Trec = thlm ( ib , jb , kb : ke ) ! set the initial time-averaged inlet profile equal to thlm t0inletbcold ( jb : je , kb : ke ) = thlm ( ib - 1 , jb : je , kb : ke ) t0inletbc ( jb : je , kb : ke ) = thl0 ( ib - 1 , jb : je , kb : ke ) tminletbc ( jb : je , kb : ke ) = thlm ( ib - 1 , jb : je , kb : ke ) ttaui = numol * prandtlmoli * 2. * ( Tinl ( kb ) - thls ) / ( dzf ( kb ) * utaui ) ! average friction temp. at inlet (need for first time step) end if ! add random perturbations if ( myid == 0 ) then call random_number ( ran ) ran1 = - 1. + 2. * ran write ( 6 , * ) 'random=' , ran , ran1 call random_number ( ran ) ran1 = - 1. + 2. * ran write ( 6 , * ) 'random=' , ran , ran1 call random_number ( ran ) ran1 = - 1. + 2. * ran write ( 6 , * ) 'random=' , ran , ran1 call random_number ( ran ) ran1 = - 1. + 2. * ran write ( 6 , * ) 'random=' , ran , ran1 call random_number ( ran ) ran1 = - 1. + 2. * ran write ( 6 , * ) 'random=' , ran , ran1 call random_number ( ran ) ran1 = - 1. + 2. * ran write ( 6 , * ) 'random=' , ran , ran1 end if do k = kb + 1 , kb + 48 do j = jb , je do i = ib + 1 , ie - 1 call random_number ( ran ) ran1 = - 1. + 2. * ran wm ( i , j , k ) = wm ( i , j , k ) + 0.1 * Uinf * ran1 end do end do end do !       do k=kb+1,ke-1 do k = kb + 1 , kb + 48 do j = jb , je do i = ib + 2 , ie - 1 call random_number ( ran ) ran1 = - 1. + 2. * ran um ( i , j , k ) = um ( i , j , k ) + 0.1 * Uinf * ran1 end do end do end do !       do k=kb+1,ke-1 do k = kb + 1 , kb + 48 do j = jb , je do i = ib + 1 , ie - 1 call random_number ( ran ) ran1 = - 1. + 2. * ran vm ( i , j , k ) = vm ( i , j , k ) + 0.1 * Uinf * ran1 end do end do end do u0 = um v0 = vm w0 = wm else if ( iinletgen == 2 ) then nfile = nfile + 1 call readinletfile u0inletbc (:, :) = storeu0inletbc (:, :, nstepread ) v0inletbc (:, :) = storev0inletbc (:, :, nstepread ) w0inletbc (:, :) = storew0inletbc (:, :, nstepread ) uminletbc (:, :) = storeu0inletbc (:, :, nstepread ) vminletbc (:, :) = storev0inletbc (:, :, nstepread ) wminletbc (:, :) = storew0inletbc (:, :, nstepread ) ! determine bulk velocity call slabsum ( uaverage , kb , ke , u0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ie , jb , je , kb , ke ) uaverage = uaverage / (( ie - ib + 1 ) * ( jge - jgb + 1 )) ! this gives the i-j-averaged velocity (only correct for equidistant grid?) do k = kb , ke uaverage ( k ) = uaverage ( k ) * dzf ( k ) end do ubulk = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! volume-averaged u-velocity write ( 6 , * ) 'Modstartup: ubulk=' , ubulk elseif ( idriver == 2 ) then ! idriver call readdriverfile ! if(myid==0) then ! write(*,*) 'Driver inlet velocity' ! do n=1,driverstore ! write (*,'(f9.2,e20.12)') storetdriver(n),     storeu0driver(1,32,n) ! end do ! endif ! call slabsum(uaverage,kb,ke,u0,ib-1,ie+1,jb-1,je+1,kb-1,ke+1,ib,ie,jb,je,kb,ke) ! uaverage = uaverage / ((ie-ib+1)*(jge-jgb+1))  ! this gives the i-j-averaged velocity (only correct for equidistant grid?) call avexy_ibm ( uaverage ( kb : ke ), u0 ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIu ( ib : ie , jb : je , kb : ke ), IIus ( kb : ke ),. false .) do k = kb , ke uaverage ( k ) = uaverage ( k ) * dzf ( k ) end do ubulk = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) !volume-averaged u-velocity if ( myid == 0 ) then write ( 6 , * ) 'Modstartup: ubulk=' , ubulk end if elseif ( idriver == 1 ) then call drivergen end if !--------------------------------------------------------------- !  1.2 randomnize fields !--------------------------------------------------------------- !     if (iinletgen /= 2 .and. iinletgen /= 1) then !       write(6,*) 'randomnizing temperature!' !       krand  = min(krand,ke) !        do k = kb,ke !edited tg3315 krand --> ke !          call randomnize(thlm,k,randthl,irandom,ih,jh) !          call randomnize(thl0,k,randthl,irandom,ih,jh) !        end do !       end if svprof = 0. if ( myid == 0 ) then if ( nsv > 0 ) then open ( ifinput , file = 'scalar.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do k = kb , ke read ( ifinput , * ) & height ( k ), & ( svprof ( k , n ), n = 1 , nsv ) end do open ( ifinput , file = 'scalar.inp.' // cexpnr ) write ( 6 , * ) 'height   sv(1) --------- sv(nsv) ' do k = ke , kb , - 1 write ( 6 , * ) & height ( k ), & ( svprof ( k , n ), n = 1 , nsv ) end do end if end if ! end if myid==0 call MPI_BCAST ( svprof , ( ke + kh - ( kb - kh )) * nsv , MY_REAL , 0 , comm3d , mpierr ) do k = kb , ke do j = jb - 1 , je + 1 do i = ib - 1 , ie + 1 do n = 1 , nsv sv0 ( i , j , k , n ) = svprof ( k , n ) svm ( i , j , k , n ) = svprof ( k , n ) end do end do end do end do if ( nsv > 0 ) then !tg3315 set these variables here for now and repeat for warmstart allocate ( sv_top ( 1 : nsv )) sv_top (:) = svprof ( ke , 1 : nsv ) call MPI_BCAST ( sv_top , nsv , MY_REAL , 0 , comm3d , mpierr ) write ( * , * ) 'svprof' , svprof write ( * , * ) 'sv_top' , sv_top end if !do n = 1,nsv !  do j = jb - jhc, je + jhc !    do i = ib - ihc, ie + ihc !      svm(i, j, ke + 1, n) = svm(i, j, ke) !      sv0(i, j, kb - 1, n) = sv0(i, j, kb) !    end do !  end do !end do !----------------------------------------------------------------- !    2.2 Initialize surface layer !----------------------------------------------------------------- !ILS13 reintroduced thv !tg3315 this part may wrong, could need to use call calc_halflev ! exnf = (presf/pref0)**(rd/cp)  !exner functions not in restart files ! anymore.. or at least not read ! exnh = (presh/pref0)**(rd/cp) call boundary ! tg3315 17.10.17 having this in startup was causing issues for running with lmoist ! turned of when pot. temp = temp. call thermodynamics ! turned off when pot. temp = temp. call boundary call thermodynamics ! turned off when pot. temp = temp. else !if lwarmstart write ( * , * ) \"doing warmstart\" call readrestartfiles um = u0 vm = v0 wm = w0 thlm = thl0 qtm = qt0 svm = sv0 e12m = e120 ekm (:, :, :) = numol ekh (:, :, :) = numol * prandtlmoli !tg3315 added because wttop using ekh in modboundary which is called in startup ekh (:, :, ke + 1 ) = ekh (:, :, ke ) ! also for start up if ( idriver == 1 ) then !driverstore = (timeleft - tdriverstart)/dtdriver + 1 !if(myid==0) then !  write(*,*) 'driverstore: ', driverstore !end if call drivergen tdriverdump = tdriverstart endif !ILS13 reintroduced thv call calc_halflev ! exnf = (presf/pref0)**(rd/cp)  !exner functions not in restart files ! anymore.. or at least not read ! exnh = (presh/pref0)**(rd/cp) !   write(*,*) \"exnf\",enf !   write(*,*) \"exnh\",exnh do j = jb , je do i = ib , ie do k = kb , ke + kh !write(*,*) \"thl0h\",thl0h(i,j,k) thv0h ( i , j , k ) = ( thl0h ( i , j , k ) + rlv * ql0h ( i , j , k ) / ( cp )) & * ( 1 + ( rv / rd - 1 ) * qt0h ( i , j , k ) - rv / rd * ql0h ( i , j , k )) end do end do end do do j = j , je do i = ib , ie do k = kb , ke + kh thv0 ( i , j , k ) = ( thl0 ( i , j , k ) + rlv * ql0 ( i , j , k ) / ( cp )) & * ( 1 + ( rv / rd - 1 ) * qt0 ( i , j , k ) - rv / rd * ql0 ( i , j , k )) end do end do end do thvh = 0. ! call slabsum(thvh,kb,ke,thv0h,ib-ih,ie+ih,jb-jh,je+jh,kb-kh,ke+kh,ib,ie,jb,je,kb,ke) ! redefine halflevel thv using calculated thv call avexy_ibm ( thvh ( kb : ke + kh ), thv0h ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. false .) ! thvh = thvh/rslabs thvf = 0.0 call avexy_ibm ( thvf ( kb : ke + kh ), thv0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) ! call slabsum(thvf,kb,ke,thv0,ib-ih,ie+ih,jb-jh,je+jh,kb-kh,ke+kh,ib,ie,jb,je,kb,ke) ! thvf = thvf/rslabs ! Set average inlet profile to initial inlet profile in case of inletgenerator mode uaverage = 0. uaveragei = 0. uaverager = 0. waverage = 0. taveragei = 0. taverager = 0. if ( iinletgen == 1 ) then call slabsum ( uaveragei , kb , ke , u0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ib , jb , je , kb , ke ) call slabsum ( uaverager , kb , ke , u0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , irecy , irecy , jb , je , kb , ke ) call slabsum ( waverage , kb , ke + 1 , w0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ie , jb , je , kb , ke + 1 ) call slabsum ( uaverage , kb , ke , u0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ie , jb , je , kb , ke ) uaverage = uaverage / (( ie - ib + 1 ) * ( jge - jgb + 1 )) ! this gives the i-j-averaged velocity (only correct for equidistant grid?) uaveragei = uaveragei / ( jge - jgb + 1 ) ! this gives the j-averaged u-velocity at the inlet uaverager = uaverager / ( jge - jgb + 1 ) ! this gives the j-averaged u-velocity at the recycle plane waverage = waverage / (( ie - ib + 1 ) * ( jge - jgb + 1 )) ! this gives the i-j-averaged w-velocity (only correct for equidistant grid?) if ( ltempeq ) then call slabsum ( taveragei , kb , ke , thl0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ie , jb , je , kb , ke ) call slabsum ( taverager , kb , ke , thl0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , irecy - 1 , irecy - 1 , jb , je , kb , ke ) taveragei = taveragei / (( ie - ib + 1 ) * ( jge - jgb + 1 )) ! this gives the j-averaged temperature at the inlet taverager = taverager / ( jge - jgb + 1 ) ! this gives the j-averaged temperature at the recycle plane end if if (. not . lreadminl ) then if ( myid == 0 ) then write ( 6 , * ) 'uaverage(kb)=' , uaverage ( kb ) write ( 6 , * ) 'uaverage(ke)=' , uaverage ( ke ) write ( 6 , * ) 'waverage(ke)=' , waverage ( ke ) write ( 6 , * ) 'waverage(ke-20)=' , waverage ( ke - 20 ) write ( 6 , * ) 'taveragei(kb)=' , taveragei ( kb ) write ( 6 , * ) 'taveragei(ke)=' , taveragei ( ke ) end if Utav = 0. do i = ib , ie Utav ( i , :) = uaverage end do Uinl = uaverage ! set the initial time-averaged inlet profile equal to mean u-profile read from means write ( 6 , * ) 'Uinl(kb+10)=' , Uinl ( kb + 10 ) utaui = sqrt ( abs ( 2 * numol * Uinl ( kb ) / dzf ( kb ))) ! average streamwise friction at inlet (need for first time step) Urec = uaverage ! set the initial time-averaged inlet profile equal to mean u-profile Wrec ( kb : ke + 1 ) = waverage ( kb : ke + 1 ) ! set the initial time-averaged inlet profile equal to mean w-profile Wrec ( kb ) = 0. ! set the initial time-averaged inlet profile equal to zero if ( ltempeq ) then Ttav = 0. do i = ib , ie Ttav ( i , :) = taveragei (:) end do Tinl = taveragei Trec = taveragei ttaui = numol * prandtlmoli * 2. * ( Tinl ( kb ) - thls ) / ( dzf ( kb ) * utaui ) ! friction temp. at inlet (need at first time step) end if else ! -> lreadminl -> Uinl, Urec, Wrec already read call slabsum ( uaverage , kb , ke , u0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ie , jb , je , kb , ke ) uaverage = uaverage / (( ie - ib + 1 ) * ( jge - jgb + 1 )) ! this gives the i-j-averaged velocity (only correct for equidistant grid?) end if ! determine bulk velocity do k = kb , ke uaverage ( k ) = uaverage ( k ) * dzf ( k ) end do ubulk = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! volume-averaged u-velocity write ( 6 , * ) 'Modstartup: ubulk=' , ubulk do k = kb , ke do j = jb , je uminletbc ( j , k ) = um ( ib , j , k ) vminletbc ( j , k ) = vm ( ib - 1 , j , k ) u0inletbcold ( j , k ) = um ( ib , j , k ) v0inletbcold ( j , k ) = vm ( ib - 1 , j , k ) u0inletbc ( j , k ) = um ( ib , j , k ) v0inletbc ( j , k ) = vm ( ib - 1 , j , k ) end do end do do k = kb , ke + 1 do j = jb , je wminletbc ( j , k ) = wm ( ib - 1 , j , k ) w0inletbcold ( j , k ) = wm ( ib - 1 , j , k ) w0inletbc ( j , k ) = wm ( ib - 1 , j , k ) end do end do if ( ltempeq ) then do k = kb , ke do j = jb , je tminletbc ( j , k ) = thlm ( ib - 1 , j , k ) t0inletbcold ( j , k ) = thlm ( ib - 1 , j , k ) t0inletbc ( j , k ) = thlm ( ib - 1 , j , k ) end do end do end if write ( 6 , * ) 'uminletbc(jb,kb),um(ib,jb,kb)=' , uminletbc ( jb , kb ), um ( ib , jb , kb ) write ( 6 , * ) 'uminletbc(jb+1,kb+10),um(ib,jb+1,kb+10)=' , uminletbc ( jb + 1 , kb + 10 ), um ( ib , jb + 1 , kb + 10 ) write ( 6 , * ) 'uminletbc(je,kb+10),um(ib,je,kb+10)=' , uminletbc ( je , kb + 10 ), um ( ib , je , kb + 10 ) else if ( iinletgen == 2 ) then nfile = nfile + 1 write ( 6 , * ) 'Loading inletfile' call readinletfile u0inletbc (:, :) = storeu0inletbc (:, :, nstepread ) v0inletbc (:, :) = storev0inletbc (:, :, nstepread ) w0inletbc (:, :) = storew0inletbc (:, :, nstepread ) uminletbc (:, :) = storeu0inletbc (:, :, nstepread ) vminletbc (:, :) = storev0inletbc (:, :, nstepread ) wminletbc (:, :) = storew0inletbc (:, :, nstepread ) if ( ltempeq ) then t0inletbc (:, :) = storet0inletbc (:, :, nstepread ) tminletbc (:, :) = storet0inletbc (:, :, nstepread ) end if ! determine bulk velocity call slabsum ( uaverage , kb , ke , u0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ie , jb , je , kb , ke ) uaverage = uaverage / (( ie - ib + 1 ) * ( jge - jgb + 1 )) ! this gives the i-j-averaged velocity (only correct for equidistant grid?) do k = kb , ke uaverage ( k ) = uaverage ( k ) * dzf ( k ) end do ubulk = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! volume-averaged u-velocity write ( 6 , * ) 'Modstartup: ubulk=' , ubulk elseif ( idriver == 2 ) then ! idriver call readdriverfile call drivergen !call slabsum(uaverage,kb,ke,u0,ib-1,ie+1,jb-1,je+1,kb-1,ke+1,ib,ie,jb,je,kb,ke) !uaverage = uaverage / ((ie-ib+1)*(jge-jgb+1))  ! this gives the i-j-averaged velocity (only correct for equidistant grid?) call avexy_ibm ( uaverage ( kb : ke ), u0 ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIu ( ib : ie , jb : je , kb : ke ), IIus ( kb : ke ),. false .) do k = kb , ke uaverage ( k ) = uaverage ( k ) * dzf ( k ) end do ubulk = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) !volume-averaged u-velocity if ( myid == 0 ) then write ( 6 , * ) 'Modstartup: ubulk=' , ubulk end if end if ! iinletgen/idriver if ( lper2inout ) then ! if the restart starts from a periodic simulation to in/outflow, lper2inout should be set to .true. if ( myid == 0 ) then write ( 6 , * ) 'per2inout=.true. -> reading inlet profile from prof.inp.XXX and scalar.inp.XXX' open ( ifinput , file = 'prof.inp.' // cexpnr ) !  read the inlet profile from prof.inp read ( ifinput , '(a80)' ) chmess write ( * , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do k = kb , ke read ( ifinput , * ) & height ( k ), & thlprof ( k ), & qtprof ( k ), & uprof ( k ), & vprof ( k ), & e12prof ( k ) end do svprof = 0. if ( nsv > 0 ) then open ( ifinput , file = 'scalar.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do k = kb , ke read ( ifinput , * ) & height ( k ), & ( svprof ( k , n ), n = 1 , nsv ) end do open ( ifinput , file = 'scalar.inp.' // cexpnr ) write ( 6 , * ) 'height   sv(1) --------- sv(nsv) ' do k = ke , kb , - 1 write ( 6 , * ) & height ( k ), & ( svprof ( k , n ), n = 1 , nsv ) end do end if end if ! end if myid==0 ! MPI broadcast numbers reading call MPI_BCAST ( thlprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( uprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( vprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( e12prof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( qtprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( svprof , ( ke + kh - ( kb - kh )) * nsv , MY_REAL , 0 , comm3d , mpierr ) else if ( linoutflow ) then ! restart of inoutflow simulation: reproduce inlet boundary condition from restartfile do j = jb - 1 , je + 1 do k = kb , ke + 1 uprof ( k ) = u0 ( ib , j , k ) vprof ( k ) = ( v0 ( ib - 1 , j , k ) + v0 ( ib , j , k )) / 2 thlprof ( k ) = ( thl0 ( ib - 1 , j , k ) + thl0 ( ib , j , k )) / 2 qtprof ( k ) = ( qt0 ( ib - 1 , j , k ) + qt0 ( ib , j , k )) / 2 e12prof ( k ) = ( e120 ( ib - 1 , j , k ) + e120 ( ib , j , k )) / 2 do n = 1 , nsv svprof ( k , n ) = ( sv0 ( ib - 1 , j , k , n ) + sv0 ( ib , j , k , n )) / 2 enddo enddo enddo ! outlet bulk velocity call slabsum ( uaverage , kb , ke , u0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ie , jb , je , kb , ke ) uaverage = uaverage / (( ie - ib + 1 ) * ( jge - jgb + 1 )) ! this gives the i-j-averaged velocity (only correct for equidistant grid?) ! determine bulk velocity do k = kb , ke uaverage ( k ) = uaverage ( k ) * dzf ( k ) end do ubulk = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! volume-averaged u-velocity write ( 6 , * ) 'Modstartup: ubulk=' , ubulk else ! else per2per... read svprof regardless... ! tg3315 read svprof (but do not use regardless of above...) svprof = 0. if ( myid == 0 ) then if ( nsv > 0 ) then open ( ifinput , file = 'scalar.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do k = kb , ke read ( ifinput , * ) & height ( k ), & ( svprof ( k , n ), n = 1 , nsv ) end do open ( ifinput , file = 'scalar.inp.' // cexpnr ) write ( 6 , * ) 'height   sv(1) --------- sv(nsv) ' do k = ke , kb , - 1 write ( 6 , * ) & height ( k ), & ( svprof ( k , n ), n = 1 , nsv ) end do end if end if ! end if myid==0 call MPI_BCAST ( svprof , ( ke + kh - ( kb - kh )) * nsv , MY_REAL , 0 , comm3d , mpierr ) if ( nsv > 0 ) then !tg3315 set these variables here for now and repeat for warmstart allocate ( sv_top ( 1 : nsv )) sv_top (:) = svprof ( ke , 1 : nsv ) call MPI_BCAST ( sv_top , nsv , MY_REAL , 0 , comm3d , mpierr ) end if end if ! end if lper2inout u0av = 0.0 v0av = 0.0 thl0av = 0.0 qt0av = 0.0 th0av = 0.0 sv0av = 0. ! call slabsum(u0av  ,kb,ke+kh,u0(:,:,kb:ke+kh)  ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( u0av ( kb : ke + kh ), u0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIu ( ib : ie , jb : je , kb : ke + kh ), IIus ( kb : ke + kh ),. false .) ! call slabsum(v0av  ,kb,ke+kh,v0(:,:,kb:ke+kh)  ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( v0av ( kb : ke + kh ), v0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIv ( ib : ie , jb : je , kb : ke + kh ), IIvs ( kb : ke + kh ),. false .) ! call slabsum(thl0av,kb,ke+kh,thl0(:,:,kb:ke+kh),ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( thl0av ( kb : ke + kh ), thl0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) ! call slabsum(qt0av,kb,ke+kh,qt0(:,:,kb:ke+kh),ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( qt0av ( kb : ke + kh ), qt0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) do n = 1 , nsv ! call slabsum(sv0av(kb,n),kb,ke+kh,sv0(ib-ih,jb-jh,kb,n),ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( sv0av ( kb : ke + khc , n ), sv0 ( ib : ie , jb : je , kb : ke + khc , n ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + khc ), IIcs ( kb : ke + khc ),. false .) end do ! CvH - only do this for fixed timestepping. In adaptive dt comes from restartfile if (. not . ladaptive ) dt = dtmax !  call boundary end if ! lwarmstart end if ! not lstratstart !----------------------------------------------------------------- !    2.1 read and initialise fields !----------------------------------------------------------------- if ( myid == 0 ) then open ( ifinput , file = 'lscale.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess write ( 6 , * ) ' height  u_geo  v_geo  pgx  pgy  subs     ' & , '   dqtdx      dqtdy        dqtdtls     thl_rad ' do k = kb , ke read ( ifinput , * ) & height ( k ), & ug ( k ), & vg ( k ), & pgx ( k ), & pgy ( k ), & wfls ( k ), & dqtdxls ( k ), & dqtdyls ( k ), & dqtdtls ( k ), & thlpcar ( k ) end do close ( ifinput ) do k = ke , kb , - 1 write ( 6 , '(3f7.1,5e12.4)' ) & height ( k ), & ug ( k ), & vg ( k ), & pgx ( k ), & pgy ( k ), & wfls ( k ), & dqtdxls ( k ), & dqtdyls ( k ), & dqtdtls ( k ), & thlpcar ( k ) end do end if ! end myid==0 ! MPI broadcast variables read in call MPI_BCAST ( ug , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( vg , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( pgx , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( pgy , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wfls , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dqtdxls , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dqtdyls , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dqtdtls , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( thlpcar , kmax , MY_REAL , 0 , comm3d , mpierr ) !----------------------------------------------------------------- !    2.3 make large-scale horizontal pressure gradient !----------------------------------------------------------------- !******include rho if rho = rho(z) /= 1.0 *********** if ( lprofforc ) then !tg3315 do k = kb , ke dpdxl ( k ) = - pgx ( k ) - dpdx !-om23_gs*ug(k)-pgx(k)-dpdx dpdyl ( k ) = - pgy ( k ) end do else do k = kb , ke !dpdxl(k) =  om23_gs*vg(k) !dpdyl(k) = -om23_gs*ug(k) !dpdxl(k) =  -ug(k) !dpdyl(k) =  -vg(k) dpdxl ( k ) = om23_gs * vg ( k ) - pgx ( k ) - dpdx !corriolis forcing and pressure gradient dpdyl ( k ) = - om23_gs * ug ( k ) - pgy ( k ) end do endif !----------------------------------------------------------------- !    2.4 large-scale subsidence, reintroduced ILS13 05.06.2014 !----------------------------------------------------------------- whls ( kb ) = 0.0 do k = kb + 1 , ke whls ( k ) = ( wfls ( k ) * dzf ( k - 1 ) + wfls ( k - 1 ) * dzf ( k )) / ( 2 * dzh ( k )) end do whls ( ke + 1 ) = ( wfls ( ke ) + dzf ( ke ) * ( wfls ( ke ) - wfls ( ke - 1 )) / dzh ( ke )) ! tg3315 31/07/18 removed a 0.5 !    idtmax = floor(dtmax/tres) btime = timee !    timeleft=ceiling(runtime/tres) timeleft = runtime dt_lim = timeleft !    write(6,*) 'real(dt)*tres= ',rdt, ' dtmax/100= ',dtmax/100 if (( lwarmstart ) . or . ( lstratstart )) then ! tg3315 to have cumulative number on restart files read ( startfile ( 6 : 13 ), '(i4)' ) ntrun ! ntrun = ichar(startfile(6:13)) else ntrun = 0 end if ntimee = nint ( timee / dtmax ) tnextrestart = btime + trestart tnextfielddump = btime + tfielddump deallocate ( height , th0av ) !    call boundary end subroutine readinitfiles","tags":"","loc":"proc/readinitfiles.html"},{"title":"readrestartfiles – uDALES","text":"public subroutine readrestartfiles() Uses modsurfdata modfields modglobal modmpi modsubgriddata modinlet modinletdata proc~~readrestartfiles~~UsesGraph proc~readrestartfiles readrestartfiles module~modsurfdata modsurfdata proc~readrestartfiles->module~modsurfdata module~modmpi modmpi proc~readrestartfiles->module~modmpi module~modinlet modinlet proc~readrestartfiles->module~modinlet module~modsubgriddata modsubgriddata proc~readrestartfiles->module~modsubgriddata module~modinletdata modinletdata proc~readrestartfiles->module~modinletdata module~modfields modfields proc~readrestartfiles->module~modfields module~modglobal modglobal proc~readrestartfiles->module~modglobal mpi mpi module~modmpi->mpi module~modinlet->module~modinletdata Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~readrestartfiles~~CallsGraph proc~readrestartfiles readrestartfiles proc~zinterpolate2d zinterpolate2d proc~readrestartfiles->proc~zinterpolate2d proc~zinterpolatet1d zinterpolatet1d proc~readrestartfiles->proc~zinterpolatet1d proc~zinterpolate1d zinterpolate1d proc~readrestartfiles->proc~zinterpolate1d proc~zinterpolatew1d zinterpolatew1d proc~readrestartfiles->proc~zinterpolatew1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readrestartfiles~~CalledByGraph proc~readrestartfiles readrestartfiles proc~readinitfiles readinitfiles proc~readinitfiles->proc~readrestartfiles proc~startup startup proc~startup->proc~readinitfiles program~dalesurban DALESURBAN program~dalesurban->proc~startup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code readrestartfiles Source Code subroutine readrestartfiles use modsurfdata , only : ustar , thlflux , qtflux , svflux , dudz , dvdz , dthldz , dqtdz , ps , thls , qts , thvs , oblav , & wtsurf use modfields , only : u0 , v0 , w0 , thl0 , qt0 , ql0 , ql0h , qtav , qlav , e120 , dthvdz , presf , presh , sv0 , mindist , wall , & uav , vav , wav , uuav , vvav , wwav , uvav , uwav , vwav , svav , thlav , thl2av , sv2av , pres0 , svm , & svprof , viscratioav , thluav , thlvav , thlwav , svuav , svvav , svwav , presav , & uusgsav , vvsgsav , wwsgsav , uwsgsav , thlusgsav , thlwsgsav , svusgsav , svwsgsav , tkesgsav , & strain2av , nusgsav use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , dtheta , dqt , dsv , startfile , timee , totavtime , runavtime , & iexpnr , ntimee , rk3step , ifinput , nsv , runtime , dt , cexpnr , lreadmean , lreadminl , & totinletav , lreadscal , ltempeq , dzf , numol , prandtlmoli use modmpi , only : cmyid , myid use modsubgriddata , only : ekm use modinlet , only : zinterpolate1d , zinterpolatet1d , zinterpolatew1d , zinterpolate2d use modinletdata , only : Uinl , Urec , Wrec , Utav , Tinl , Trec , linuf , linuh , & kbin , kein , lzinzsim , utaui , Ttav , ttaui real , dimension ( ib : ie , jb : je , kb : ke ) :: dummy3d real , dimension ( ib : ie , kbin : kein ) :: Utavin real , dimension ( ib : ie , kbin : kein ) :: Ttavin real , dimension ( kbin : kein ) :: Uinlin real , dimension ( kbin : kein ) :: Urecin real , dimension ( kbin : kein ) :: Tinlin real , dimension ( kbin : kein ) :: Trecin real , dimension ( kbin : kein + 1 ) :: Wrecin character ( 50 ) :: name , name2 , name4 real dummy integer i , j , k , n !******************************************************************** !    1.0 Read initfiles !----------------------------------------------------------------- name = startfile name ( 5 : 5 ) = 'd' name ( 15 : 17 ) = cmyid write ( 6 , * ) 'loading ' , name open ( unit = ifinput , file = name , form = 'unformatted' , status = 'old' ) read ( ifinput ) ((( mindist ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke ) read ( ifinput ) (((( wall ( i , j , k , n ), i = ib , ie ), j = jb , je ), k = kb , ke ), n = 1 , 5 ) read ( ifinput ) ((( u0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( v0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( w0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( pres0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( thl0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( e120 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( ekm ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( qt0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( ql0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( ql0h ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) timee , dt close ( ifinput ) write ( 6 , * ) 'finished loading ' , name if (( nsv > 0 ) . and . ( lreadscal )) then name ( 5 : 5 ) = 's' write ( 6 , * ) 'loading ' , name open ( unit = ifinput , file = name , form = 'unformatted' ) read ( ifinput ) (((( sv0 ( i , j , k , n ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ), n = 1 , nsv ) read ( ifinput ) timee close ( ifinput ) write ( 6 , * ) 'finished loading ' , name elseif (( nsv > 0 ) . and . (. not . lreadscal )) then sv0 = 0. svprof = 0. end if ! read mean variables if asked for by lreadmean name2 = 'means   .' name2 ( 6 : 8 ) = cmyid name2 ( 10 : 12 ) = cexpnr if ( lreadmean ) then write ( 6 , * ) 'Reading meansXXX.XXX, proc = ' , myid open ( unit = ifinput , file = name2 , form = 'unformatted' ) read ( ifinput ) totavtime , nsv read ( ifinput ) ((( uav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( vav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( wav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( thlav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( qtav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( qlav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( presav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) (((( svav ( i , j , k , n ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ), n = 1 , nsv ) read ( ifinput ) ((( viscratioav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( uuav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( vvav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( wwav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( thl2av ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) (((( sv2av ( i , j , k , n ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ), n = 1 , nsv ) read ( ifinput ) ((( uvav ( i , j , k ), i = ib , ie + ih ), j = jb , je + jh ), k = kb , ke ) read ( ifinput ) ((( uwav ( i , j , k ), i = ib , ie + ih ), j = jb , je ), k = kb , ke + kh ) read ( ifinput ) ((( vwav ( i , j , k ), i = ib , ie ), j = jb , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( thluav ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke ) read ( ifinput ) ((( thlvav ( i , j , k ), i = ib , ie ), j = jb , je + jh ), k = kb , ke ) read ( ifinput ) ((( thlwav ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke + kh ) read ( ifinput ) (((( svuav ( i , j , k , n ), i = ib , ie ), j = jb , je ), k = kb , ke ), n = 1 , nsv ) read ( ifinput ) (((( svvav ( i , j , k , n ), i = ib , ie ), j = jb , je + jh ), k = kb , ke ), n = 1 , nsv ) read ( ifinput ) (((( svwav ( i , j , k , n ), i = ib , ie ), j = jb , je ), k = kb , ke + kh ), n = 1 , nsv ) close ( ifinput ) write ( 6 , * ) 'Total averaging time so far: ' , totavtime ! read <x'y'>_SGS to file. name2 = 'SGS__   .' name2 ( 6 : 8 ) = cmyid name2 ( 10 : 12 ) = cexpnr open ( unit = ifinput , file = name2 , form = 'unformatted' ) read ( ifinput ) dummy , dummy read ( ifinput ) ((( uusgsav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( vvsgsav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( wwsgsav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( uwsgsav ( i , j , k ), i = ib , ie + ih ), j = jb , je ), k = kb , ke + kh ) read ( ifinput ) ((( dummy3d ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke ) ! this is dissresav, which will be computed using other mean quantities read ( ifinput ) ((( tkesgsav ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke ) read ( ifinput ) ((( dummy3d ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke ) ! this is disssgsav, which will be computed using other mean quantities read ( ifinput ) ((( strain2av ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke ) ! <SijSij> (NOT <Sij><Sij> !!) (average over time) read ( ifinput ) ((( nusgsav ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke ) ! <nu_sgs> (average over time) read ( ifinput ) ((( thlusgsav ( i , j , k ), i = ib , ie + ih ), j = jb , je ), k = kb , ke ) read ( ifinput ) ((( thlwsgsav ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke + kh ) read ( ifinput ) (((( svusgsav ( i , j , k , n ), i = ib , ie + ih ), j = jb , je ), k = kb , ke ), n = 1 , nsv ) read ( ifinput ) (((( svwsgsav ( i , j , k , n ), i = ib , ie ), j = jb , je ), k = kb , ke + kh ), n = 1 , nsv ) close ( ifinput ) end if ! read mean profiles for inlet generator if ( lreadminl ) then if (. not . lzinzsim ) then name4 = 'meaninlet.   ' name4 ( 11 : 13 ) = cexpnr open ( unit = ifinput , file = name4 , form = 'unformatted' ) read ( ifinput ) totinletav ! interval of time-average read ( ifinput ) ( Uinlin ( k ), k = kbin , kein ) read ( ifinput ) ( Urecin ( k ), k = kbin , kein ) read ( ifinput ) ( Wrecin ( k ), k = kbin , kein + 1 ) read ( ifinput ) (( Utavin ( i , k ), i = ib , ie ), k = kbin , kein ) close ( ifinput ) call zinterpolate1d ( Uinlin , Uinl ) ! interpolate inlet profile to zgrid call zinterpolate1d ( Urecin , Urec ) call zinterpolatew1d ( Wrecin , Wrec ) call zinterpolate2d ( Utavin , Utav ) if ( ltempeq ) then name4 = 'tempinlet.   ' name4 ( 11 : 13 ) = cexpnr open ( unit = ifinput , file = name4 , form = 'unformatted' ) read ( ifinput ) totinletav ! interval of time-average read ( ifinput ) ( Tinlin ( k ), k = kbin , kein ) read ( ifinput ) ( Trecin ( k ), k = kbin , kein ) read ( ifinput ) (( Ttavin ( i , k ), i = ib , ie ), k = kbin , kein ) close ( ifinput ) call zinterpolatet1d ( Tinlin , Tinl ) call zinterpolatet1d ( Trecin , Trec ) call zinterpolate2d ( Ttavin , Ttav ) end if ! ltempeq else !lzinzsim=.true. -> inlet grid equals sim grid name4 = 'meaninlet.   ' name4 ( 11 : 13 ) = cexpnr open ( unit = ifinput , file = name4 , form = 'unformatted' ) read ( ifinput ) totinletav ! interval of time-average read ( ifinput ) ( Uinl ( k ), k = kb , ke ) read ( ifinput ) ( Urec ( k ), k = kb , ke ) read ( ifinput ) ( Wrec ( k ), k = kb , ke + 1 ) read ( ifinput ) (( Utav ( i , k ), i = ib , ie ), k = kb , ke ) close ( ifinput ) if ( ltempeq ) then name4 = 'tempinlet.   ' name4 ( 11 : 13 ) = cexpnr open ( unit = ifinput , file = name4 , form = 'unformatted' ) read ( ifinput ) totinletav ! interval of time-average read ( ifinput ) ( Tinl ( k ), k = kb , ke ) read ( ifinput ) ( Trec ( k ), k = kb , ke ) read ( ifinput ) (( Ttav ( i , k ), i = ib , ie ), k = kb , ke ) close ( ifinput ) end if ! ltempeq end if ! lzinzsim utaui = sqrt ( abs ( 2 * numol * Uinl ( kb ) / dzf ( kb ))) ! average streamwise friction at inlet (need for first time step) if ( ltempeq ) then ttaui = numol * prandtlmoli * 2. * ( Tinl ( kb ) - thls ) / ( dzf ( kb ) * utaui ) end if end if !(lreadminl) end subroutine readrestartfiles","tags":"","loc":"proc/readrestartfiles.html"},{"title":"exitmodules – uDALES","text":"public subroutine exitmodules() Uses modfields modglobal modmpi modpois modsubgrid modthermodynamics modinlet proc~~exitmodules~~UsesGraph proc~exitmodules exitmodules module~modpois modpois proc~exitmodules->module~modpois module~modmpi modmpi proc~exitmodules->module~modmpi module~modsubgrid modsubgrid proc~exitmodules->module~modsubgrid module~modinlet modinlet proc~exitmodules->module~modinlet module~modthermodynamics modthermodynamics proc~exitmodules->module~modthermodynamics module~modfields modfields proc~exitmodules->module~modfields module~modglobal modglobal proc~exitmodules->module~modglobal mpi mpi module~modmpi->mpi module~modsubgriddata modsubgriddata module~modsubgrid->module~modsubgriddata module~modinletdata modinletdata module~modinlet->module~modinletdata Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~exitmodules~~CallsGraph proc~exitmodules exitmodules proc~exitsubgrid exitsubgrid proc~exitmodules->proc~exitsubgrid proc~exitpois exitpois proc~exitmodules->proc~exitpois proc~exitinlet exitinlet proc~exitmodules->proc~exitinlet proc~exitfields exitfields proc~exitmodules->proc~exitfields proc~exitmpi exitmpi proc~exitmodules->proc~exitmpi proc~exitglobal exitglobal proc~exitmodules->proc~exitglobal proc~exitthermodynamics exitthermodynamics proc~exitmodules->proc~exitthermodynamics mpi_wtime mpi_wtime proc~exitmpi->mpi_wtime mpi_comm_free mpi_comm_free proc~exitmpi->mpi_comm_free mpi_finalize mpi_finalize proc~exitmpi->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~exitmodules~~CalledByGraph proc~exitmodules exitmodules program~dalesurban DALESURBAN program~dalesurban->proc~exitmodules Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code exitmodules Source Code subroutine exitmodules use modfields , only : exitfields use modglobal , only : exitglobal use modmpi , only : exitmpi use modpois , only : exitpois use modsubgrid , only : exitsubgrid use modthermodynamics , only : exitthermodynamics use modinlet , only : exitinlet call exitthermodynamics call exitsubgrid call exitpois call exitfields call exitglobal call exitinlet call exitmpi end subroutine exitmodules","tags":"","loc":"proc/exitmodules.html"},{"title":"randomnize – uDALES","text":"public subroutine randomnize(field, klev, ampl, ir, ihl, jhl) Uses modmpi modglobal proc~~randomnize~~UsesGraph proc~randomnize randomnize module~modmpi modmpi proc~randomnize->module~modmpi module~modglobal modglobal proc~randomnize->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real :: field (ib-ihl:ie+ihl,jb-jhl:je+jhl,kb-kh:ke+kh) integer :: klev real :: ampl integer(kind=selected_int_kind(6)) :: ir integer :: ihl integer :: jhl Called by proc~~randomnize~~CalledByGraph proc~randomnize randomnize proc~readinitfiles readinitfiles proc~readinitfiles->proc~randomnize proc~startup startup proc~startup->proc~readinitfiles program~dalesurban DALESURBAN program~dalesurban->proc~startup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code randomnize Source Code subroutine randomnize ( field , klev , ampl , ir , ihl , jhl ) use modmpi , only : myid , nprocs use modglobal , only : ib , ie , imax , jmax , jb , je , kb , ke , kh integer ( KIND = selected_int_kind ( 6 )) :: imm , ia , ic , ir integer ihl , jhl integer i , j , klev integer m , mfac real ran , ampl real field ( ib - ihl : ie + ihl , jb - jhl : je + jhl , kb - kh : ke + kh ) parameter ( imm = 134456 , ia = 8121 , ic = 28411 ) if ( myid > 0 ) then mfac = myid * jmax * imax do m = 1 , mfac ir = mod (( ir ) * ia + ic , imm ) end do end if do j = jb , je do i = ib , ie ir = mod (( ir ) * ia + ic , imm ) ran = real ( ir ) / real ( imm ) field ( i , j , klev ) = field ( i , j , klev ) + ( ran - 0.5 ) * 2.0 * ampl end do end do if ( nprocs - 1 - myid > 0 ) then mfac = ( nprocs - 1 - myid ) * imax * jmax do m = 1 , mfac ir = mod (( ir ) * ia + ic , imm ) end do end if return end subroutine randomnize","tags":"","loc":"proc/randomnize.html"},{"title":"createmasks – uDALES","text":"public subroutine createmasks() Uses modglobal modfields modmpi proc~~createmasks~~UsesGraph proc~createmasks createmasks module~modmpi modmpi proc~createmasks->module~modmpi module~modfields modfields proc~createmasks->module~modfields module~modglobal modglobal proc~createmasks->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~createmasks~~CallsGraph proc~createmasks createmasks mpi_allreduce mpi_allreduce proc~createmasks->mpi_allreduce mpi_bcast mpi_bcast proc~createmasks->mpi_bcast Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~createmasks~~CalledByGraph proc~createmasks createmasks proc~startup startup proc~startup->proc~createmasks program~dalesurban DALESURBAN program~dalesurban->proc~startup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code createmasks Source Code subroutine createmasks use modglobal , only : ib , ie , ih , ihc , jb , je , jh , jhc , kb , ke , kh , khc , rslabs , jmax , nblocks ,& ifinput , cexpnr , libm , jtot , block use modfields , only : IIc , IIu , IIv , IIw , IIuw , IIvw , IIuv , IIct , IIwt , IIut , IIuwt , IIvt ,& IIcs , IIus , IIuws , IIvws , IIuvs , IIvs , IIws , & um , u0 , vm , v0 , wm , w0 use modmpi , only : myid , comm3d , mpierr , MPI_INTEGER , MPI_DOUBLE_PRECISION , MY_REAL , nprocs , & cmyid , MPI_REAL8 , MPI_REAL4 , MPI_SUM , excjs ! use initfac, only:block integer k , n , il , iu , jl , ju , kl , ku integer :: IIcl ( kb : ke + khc ), IIul ( kb : ke + khc ), IIvl ( kb : ke + khc ), IIwl ( kb : ke + khc ), IIuwl ( kb : ke + khc ), IIvwl ( kb : ke + khc ), IIuvl ( kb : ke + khc ) integer :: IIcd ( ib : ie , kb : ke ) integer :: IIwd ( ib : ie , kb : ke ) integer :: IIuwd ( ib : ie , kb : ke ) integer :: IIud ( ib : ie , kb : ke ) integer :: IIvd ( ib : ie , kb : ke ) character ( 80 ) chmess , name2 ! II*l needn't be defined up to ke_khc, but for now would require large scale changes in modstatsdump so if works leave as is ! tg3315 04/07/18 if (. not . libm ) then IIc (:, :, :) = 1 IIu (:, :, :) = 1 IIv (:, :, :) = 1 IIw (:, :, :) = 1 IIuw (:, :, :) = 1 IIvw (:, :, :) = 1 IIuv (:, :, :) = 1 IIcs (:) = nint ( rslabs ) IIus (:) = nint ( rslabs ) IIvs (:) = nint ( rslabs ) IIws (:) = nint ( rslabs ) IIuws (:) = nint ( rslabs ) IIvws (:) = nint ( rslabs ) IIuvs (:) = nint ( rslabs ) IIct (:, :) = jtot IIut (:, :) = jtot IIvt (:, :) = jtot IIwt (:, :) = jtot IIuwt (:, :) = jtot return end if allocate ( block ( 1 : nblocks , 1 : 11 )) if ( myid == 0 ) then if ( nblocks > 0 ) then open ( ifinput , file = 'blocks.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do n = 1 , nblocks read ( ifinput , * ) & block ( n , 1 ), & block ( n , 2 ), & block ( n , 3 ), & block ( n , 4 ), & block ( n , 5 ), & block ( n , 6 ), & block ( n , 7 ), & block ( n , 8 ), & block ( n , 9 ), & block ( n , 10 ), & block ( n , 11 ) end do close ( ifinput ) do n = 1 , nblocks write ( 6 , * ) & n , & block ( n , 1 ), & block ( n , 2 ), & block ( n , 3 ), & block ( n , 4 ), & block ( n , 5 ), & block ( n , 6 ) end do end if !nblocks>0 end if !myid call MPI_BCAST ( block , 11 * nblocks , MPI_INTEGER , 0 , comm3d , mpierr ) ! Create masking matrices IIc = 1 ; IIu = 1 ; IIv = 1 ; IIct = 1 ; IIw = 1 ; IIuw = 1 ; IIvw = 1 ; IIuv = 1 ; IIwt = 1 ; IIut = 1 ; IIvt = 1 ; IIuwt = 1 ; IIcs = 1 ; IIus = 1 ; IIvs = 1 ; IIws = 1 ; IIuws = 1 ; IIvws = 1 ; IIuvs = 1 do n = 1 , nblocks il = block ( n , 1 ) iu = block ( n , 2 ) !kl = block(n, 5) kl = kb ! tg3315 changed as buildings for lEB must start at kb+1 not kb with no block below ku = block ( n , 6 ) jl = block ( n , 3 ) - myid * jmax ju = block ( n , 4 ) - myid * jmax if ( ju < jb - 1 . or . jl > je ) then cycle else if ( ju >= je ) then !tg3315 04/07/18 to avoid ju+1 when is last cell... if ( jl < jb ) jl = jb ju = je ! Masking matrices !tg3315 IIc ( il : iu , jl : ju , kl : ku ) = 0 IIu ( il : iu + 1 , jl : ju , kl : ku ) = 0 IIv ( il : iu , jl : ju , kl : ku ) = 0 IIw ( il : iu , jl : ju , kl : ku + 1 ) = 0 IIuw ( il : iu + 1 , jl : ju , kl : ku + 1 ) = 0 IIvw ( il : iu , jl : ju , kl : ku + 1 ) = 0 IIuv ( il : iu + 1 , jl : ju , kl : ku ) = 0 else if ( ju == jb - 1 ) then ! if end of block is in cell before proc IIv ( il : iu , jb , kl : ku ) = 0 IIvw ( il : iu , jb , kl : ku + 1 ) = 0 IIuv ( il : iu + 1 , jb , kl : ku ) = 0 else ! ju is in this proc... if ( jl < jb ) jl = jb ! Masking matrices !tg3315 IIc ( il : iu , jl : ju , kl : ku ) = 0 IIu ( il : iu + 1 , jl : ju , kl : ku ) = 0 IIv ( il : iu , jl : ju + 1 , kl : ku ) = 0 IIw ( il : iu , jl : ju , kl : ku + 1 ) = 0 IIuw ( il : iu + 1 , jl : ju , kl : ku + 1 ) = 0 IIvw ( il : iu , jl : ju + 1 , kl : ku + 1 ) = 0 IIuv ( il : iu + 1 , jl : ju + 1 , kl : ku ) = 0 end if ! ensure that ghost cells know where blocks are !tg3315 this is not necessary ! if (jl<jb+jh)  IIc(il:iu,je+jh,kl:ku) = 0 ! if (jl<jb+jhc) IIc(il:iu,je+jhc,kl:ku) = 0 ! if (ju>je-jh)  IIc(il:iu,jb-jh,kl:ku) = 0 ! if (ju>je-jhc) IIc(il:iu,jb-jhc,kl:ku) = 0 ! if (il<ib+ih)  IIc(ie+ih,jl:ju,kl:ku) = 0 ! if (il<ib+ihc) IIc(ie+ihc,jl:ju,kl:ku) = 0 ! if (iu>ie-ih)  IIc(ib-ih,jl:ju,kl:ku) = 0 ! if (iu>ie-ihc) IIc(ib-ihc,jl:ju,kl:ku) = 0 end if end do IIw (:, :, kb ) = 0 ; IIuw (:, :, kb ) = 0 ; IIvw (:, :, kb ) = 0 ! for correct ghost cells from adjacent processors !tg3315 ?unsure if this is correct ! tg3315 22/11/17 does not work because II is an integer and needs real numbers... !tg3315 not necessary !call excjs( IIc  , ib,ie,jb,je,kb,ke+khc,ihc,jhc) !call excjs( IIu  , ib,ie,jb,je,kb,ke+khc,ihc,jhc) !call excjs( IIv  , ib,ie,jb,je,kb,ke+khc,ihc,jhc) !call excjs( IIw  , ib,ie,jb,je,kb,ke+khc,ihc,jhc) do k = kb , ke + khc IIcl ( k ) = sum ( IIc ( ib : ie , jb : je , k )) IIul ( k ) = sum ( IIu ( ib : ie , jb : je , k )) IIvl ( k ) = sum ( IIv ( ib : ie , jb : je , k )) IIwl ( k ) = sum ( IIw ( ib : ie , jb : je , k )) IIuwl ( k ) = sum ( IIuw ( ib : ie , jb : je , k )) IIvwl ( k ) = sum ( IIvw ( ib : ie , jb : je , k )) IIuvl ( k ) = sum ( IIuv ( ib : ie , jb : je , k )) enddo call MPI_ALLREDUCE ( IIcl , IIcs , ke + khc - kb + 1 , MPI_INTEGER , & MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIul , IIus , ke + khc - kb + 1 , MPI_INTEGER , & MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIvl , IIvs , ke + khc - kb + 1 , MPI_INTEGER , & MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIwl , IIws , ke + khc - kb + 1 , MPI_INTEGER , & MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIuwl , IIuws , ke + khc - kb + 1 , MPI_INTEGER , & MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIvwl , IIvws , ke + khc - kb + 1 , MPI_INTEGER , & MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIuvl , IIuvs , ke + khc - kb + 1 , MPI_INTEGER , & MPI_SUM , comm3d , mpierr ) IIcd ( ib : ie , kb : ke ) = sum ( IIc ( ib : ie , jb : je , kb : ke ), DIM = 2 ) IIwd ( ib : ie , kb : ke ) = sum ( IIw ( ib : ie , jb : je , kb : ke ), DIM = 2 ) IIuwd ( ib : ie , kb : ke ) = sum ( IIuw ( ib : ie , jb : je , kb : ke ), DIM = 2 ) IIud ( ib : ie , kb : ke ) = sum ( IIu ( ib : ie , jb : je , kb : ke ), DIM = 2 ) IIvd ( ib : ie , kb : ke ) = sum ( IIv ( ib : ie , jb : je , kb : ke ), DIM = 2 ) call MPI_ALLREDUCE ( IIwd ( ib : ie , kb : ke ), IIwt ( ib : ie , kb : ke ), ( ke - kb + 1 ) * ( ie - ib + 1 ), MPI_INTEGER , MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIcd ( ib : ie , kb : ke ), IIct ( ib : ie , kb : ke ), ( ke - kb + 1 ) * ( ie - ib + 1 ), MPI_INTEGER , MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIuwd ( ib : ie , kb : ke ), IIuwt ( ib : ie , kb : ke ), ( ke - kb + 1 ) * ( ie - ib + 1 ), MPI_INTEGER , MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIud ( ib : ie , kb : ke ), IIut ( ib : ie , kb : ke ), ( ke - kb + 1 ) * ( ie - ib + 1 ), MPI_INTEGER , MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIvd ( ib : ie , kb : ke ), IIvt ( ib : ie , kb : ke ), ( ke - kb + 1 ) * ( ie - ib + 1 ), MPI_INTEGER , MPI_SUM , comm3d , mpierr ) ! masking matrix for switch if entire slab is blocks !if (IIcs(kb) == 0) then !  IIbl = 0 !else !  IIbl = 1 !end if !where (IIcs == 0) !IIcs = nint(rslabs) !endwhere !where (IIus == 0) !IIus = nint(rslabs) !endwhere !where (IIvs == 0) !IIvs = nint(rslabs) !endwhere !where (IIws == 0) !IIws = nint(rslabs) !endwhere !where (IIuws == 0) !IIuws = nint(rslabs) !endwhere !where (IIvws == 0) !IIvws = nint(rslabs) !endwhere ! use masking matrices to set 0 in blocks from start? tg3315 13/12/17 ! um(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) = IIu(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh)*um(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) ! vm(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) = IIv(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh)*vm(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) ! wm(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) = IIw(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh)*wm(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) ! u0 = um ! v0 = vm ! w0 = wm end subroutine createmasks","tags":"","loc":"proc/createmasks.html"},{"title":"genstats – uDALES","text":"public subroutine genstats(tsamplep, tstatsdumpp, umint, vmint, wmint) Uses modfields modglobal modmpi proc~~genstats~~UsesGraph proc~genstats genstats module~modmpi modmpi proc~genstats->module~modmpi module~modfields modfields proc~genstats->module~modfields module~modglobal modglobal proc~genstats->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real :: tsamplep real :: tstatsdumpp real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) :: umint real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) :: vmint real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) :: wmint Calls proc~~genstats~~CallsGraph proc~genstats genstats proc~tkestats tkestats proc~genstats->proc~tkestats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code genstats Source Code subroutine genstats ( tsamplep , tstatsdumpp , umint , vmint , wmint ) use modfields , only : um , up , vm , wm , thlm , uav , vav , wav , uuav , vvav , wwav , uvav , vwav , uwav , thlav , thlwav , thlthlav , & upupav , vpvpav , wpwpav , upvpav , upwpav , vpwpav , thlpwpav use modglobal , only : ib , ie , ih , jb , je , dy , jh , ke , kb , kh , rk3step , timee , cexpnr , tsample , tstatsdump ,& ltempeq , dxf , dzf , dzhi use modmpi , only : myid , cmyid , my_real , mpi_sum , mpierr , comm3d implicit none real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) :: umint real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) :: vmint real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) :: wmint real :: tstatsdumppi , tsamplep , tstatsdumpp integer :: km tstatsdumppi = 1. / tstatsdumpp !  if (lydump) then if (. not . rk3step == 3 ) return !      if (tsamplep > tsample) then !> Interpolate velocity fields to cell centers !        do k=kb-kh,ke !          do j=jb-jh,je+jh !            do i=ib-ih,ie+ih !              umint(i,j,k) = 0.5*(um(i,j,k)+um(i+1,j,k)) !              vmint(i,j,k) = 0.5*(vm(i,j,k)+vm(i,j+1,k)) !              wmint(i,j,k) = 0.5*(wm(i,j,k)+wm(i,j,k+1)) !            enddo !          enddo !        enddo do k = kb , ke do j = jb , je do i = ib , ie uav ( i , j , k ) = ( uav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + umint ( i , j , k ) * tsamplep ) * tstatsdumppi vav ( i , j , k ) = ( vav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + vmint ( i , j , k ) * tsamplep ) * tstatsdumppi wav ( i , j , k ) = ( wav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + wmint ( i , j , k ) * tsamplep ) * tstatsdumppi uuav ( i , j , k ) = ( uuav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + ( umint ( i , j , k ) ** 2 ) * tsamplep ) * tstatsdumppi vvav ( i , j , k ) = ( vvav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + ( vmint ( i , j , k ) ** 2 ) * tsamplep ) * tstatsdumppi wwav ( i , j , k ) = ( wwav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + ( wmint ( i , j , k ) ** 2 ) * tsamplep ) * tstatsdumppi uvav ( i , j , k ) = ( uvav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + umint ( i , j , k ) * vmint ( i , j , k ) * tsamplep ) * tstatsdumppi vwav ( i , j , k ) = ( vwav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + vmint ( i , j , k ) * wmint ( i , j , k ) * tsamplep ) * tstatsdumppi uwav ( i , j , k ) = ( uwav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + umint ( i , j , k ) * wmint ( i , j , k ) * tsamplep ) * tstatsdumppi if ( ltempeq ) then thlav ( i , j , k ) = ( thlav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + thlm ( i , j , k ) * tsamplep ) * tstatsdumppi thlwav ( i , j , k ) = ( thlwav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + thlm ( i , j , k ) * wmint ( i , j , k ) * tsamplep ) * tstatsdumppi thlthlav ( i , j , k ) = ( thlthlav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + ( thlm ( i , j , k ) ** 2 ) * tsamplep ) * tstatsdumppi end if end do end do end do upupav = uuav - uav ** 2 ! overline(u'u') = overline(uu) - U&#94;2 vpvpav = vvav - vav ** 2 ! overline(v'v') = overline(vv) - V&#94;2 wpwpav = wwav - wav ** 2 ! overline(w'w') = overline(ww) - W&#94;2 upvpav = uvav - uav * vav ! overline(u'v') = overline(uv) - U*V upwpav = uwav - uav * wav ! overline(u'w') = overline(uw) - U*W vpwpav = vwav - vav * wav ! overline(v'w') = overline(vw) - V*W ! thlw and svw: ib:ie jb:je kb:ke+1  (located on w-faces) !tg3315 BUT thlwav is on cell centre... do k = kb , ke + 1 km = k - 1 do j = jb , je do i = ib , ie thlpwpav ( i , j , k ) = thlwav ( i , j , k ) - & 0.5 * wav ( i , j , k ) * & ! no interpolation ( thlav ( i , j , km ) * dzf ( k ) + thlav ( i , j , k ) * dzf ( km )) * dzhi ( k ) ! interpolate thl to w-faces !              qlpwpav(i,j,k) = thlwav(i,j,k) - & !                                0.5 * wav(i,j,k) * & ! no interpolation !                               (qlav(i,j,km)*dzf(k) + qlav(i,j,k)*dzf(km))*dzhi(k) ! interpolate thl to w-faces !              qtpwpav(i,j,k) = qtwav(i,j,k) - & !                                0.5 * wav(i,j,k) * & ! no interpolation !                                (qtav(i,j,km)*dzf(k) + qtav(i,j,k)*dzf(km))*dzhi(k) ! interpolate thl to w-faces ! !              do n=1,nsv !                svpwpav(i,j,k,n) = svwav(i,j,k,n) - & !                                   0.5 * wav(i,j,k) * & ! no interpolation !                                   (svav(i,j,km,n)*dzf(k) + svav(i,j,k,n)*dzf(km))*dzhi(k) ! interpolate svav to w-faces !              end do end do end do end do !> generate time averaged stats for TKE budget and call subroutine final field values if ( ltkedump ) then call tkestats ( tsamplep , tstatsdumpp ) end if !        tsample = dt !     else !timestatsdumpp < tsample !       tsamplep = tsamplep + dt !      end if !    end if !  end if end subroutine genstats","tags":"","loc":"proc/genstats.html"},{"title":"tkestats – uDALES","text":"public subroutine tkestats(tsamplep, tstatsdumpp) Uses modfields modglobal modstat_nc modsurfdata modsubgriddata proc~~tkestats~~UsesGraph proc~tkestats tkestats module~modsurfdata modsurfdata proc~tkestats->module~modsurfdata module~modsubgriddata modsubgriddata proc~tkestats->module~modsubgriddata module~modstat_nc modstat_nc proc~tkestats->module~modstat_nc module~modfields modfields proc~tkestats->module~modfields module~modglobal modglobal proc~tkestats->module~modglobal module~modmpi modmpi module~modstat_nc->module~modmpi netcdf netcdf module~modstat_nc->netcdf mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real :: tsamplep real :: tstatsdumpp Called by proc~~tkestats~~CalledByGraph proc~tkestats tkestats proc~genstats genstats proc~genstats->proc~tkestats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code tkestats Source Code subroutine tkestats ( tsamplep , tstatsdumpp ) ! change of variable names not yet translated across to here ! tg3315 30/11/17 use modfields , only : u0 , v0 , w0 , thlm , uyt , vyt , wyt , thlyt , pres0 ,& tvmx , tvmy , tvmz , strain2av , tsgsmx1 , tsgsmx2 , tsgsmy1 , tsgsmy2 ,& tsgsmz1 , tsgsmz2 , pres0 use modglobal , only : ib , ie , ih , jb , je , jgb , jge , dy , jh , ke , kb , kh , rk3step , cexpnr , tsample , tstatsdump , dzf , zh , dxf , dzf , numol ,& dzfi , dxfi , dyi , dy2i , dxfiq , dxhiq , dyiq , dzfi5 , dzh , dzf , dzhi , dzhiq , dxf , dxhi use modstat_nc , only : writestat_nc use modsurfdata , only : thls use modsubgriddata , only : ekm implicit none real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) :: tekm ! turbulent viscosity !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: emom !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: eomm !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: eopm !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: epom !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: emmo !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: eomp !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: epmo !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: emop !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: empo !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: tkesgs !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: nusgs !  real :: dummy integer i , j , k , im , ip , jm , jp , km , kp real tstatsdumppi , tsamplep , tstatsdumpp , strain2 , tkesgs , nusgs ,& emom , eomm , eopm , epom , emmo , eomp , epmo , emop , empo , dummy tekm (:,:,:) = ekm (:,:,:) - numol tstatsdumppi = 1. / tstatsdumpp !--------------------------------------- ! Viscous transport TKE !--------------------------------------- !> Time averaged viscous transport in x,y and z to be used to calculate the total viscous transport for TKE ! Tvmx at u-locations (ib:ih+ih:jb:je,kb:ke) ! This is similar to routine diffu time u_i do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie ip = i + 1 im = i - 1 dummy = u0 ( i , j , k ) * ( & ( numol * ( u0 ( i + 1 , j , k ) - u0 ( i , j , k )) * dxfi ( i ) & - numol * ( u0 ( i , j , k ) - u0 ( i - 1 , j , k )) * dxfi ( i - 1 ) ) * 2. * dxhi ( i ) & + & ( numol * ( ( u0 ( i , jp , k ) - u0 ( i , j , k )) * dyi & + ( v0 ( i , jp , k ) - v0 ( i - 1 , jp , k )) * dxhi ( i )) & - numol * ( ( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi & + ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dxhi ( i )) & ) * dyi & + & ( numol * ( ( u0 ( i , j , kp ) - u0 ( i , j , k )) * dzhi ( kp ) & + ( w0 ( i , j , kp ) - w0 ( i - 1 , j , kp )) * dxhi ( i )) & - numol * ( ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) & + ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dxhi ( i )) & ) * dzfi ( k ) ) tvmx ( i , j , k ) = ( tvmx ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * tsamplep ) * tstatsdumppi ! update average tvmx ! Tvmv at v-locations (ib:ih:jb:je+1,kb:ke) ! This is similar to routine diffv time v dummy = v0 ( i , j , k ) * ( & ( numol * ( ( v0 ( i + 1 , j , k ) - v0 ( i , j , k )) * dxhi ( i + 1 ) & + ( u0 ( i + 1 , j , k ) - u0 ( i + 1 , jm , k )) * dyi ) & - numol * ( ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dxhi ( i ) & + ( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi ) & ) * dxfi ( i ) & ! = d/dx( Km*(dv/dx + du/dy) ) + & ( numol * ( v0 ( i , jp , k ) - v0 ( i , j , k )) & - numol * ( v0 ( i , j , k ) - v0 ( i , jm , k )) ) * 2. * dy2i & ! = d/dy( 2*Km*(dv/dy) ) + & ( numol * ( ( v0 ( i , j , kp ) - v0 ( i , j , k )) * dzhi ( kp ) & + ( w0 ( i , j , kp ) - w0 ( i , jm , kp )) * dyi ) & - numol * ( ( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) & + ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi ) & ) * dzfi ( k ) ) ! = d/dz( Km*(dv/dz + dw/dy) ) tvmy ( i , j , k ) = ( tvmy ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * tsamplep ) * tstatsdumppi ! update average tvmy ! Tvmz at w-locations (ib:ih:jb:je,kb:ke+kh) ! This is similar to routine diffw time w dummy = w0 ( i , j , k ) * ( & ( numol * ( ( w0 ( i + 1 , j , k ) - w0 ( i , j , k )) * dxhi ( i + 1 ) & + ( u0 ( i + 1 , j , k ) - u0 ( i + 1 , j , km )) * dzhi ( k ) ) & - numol * ( ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dxhi ( i ) & + ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) ) & ) * dxfi ( i ) & + & ( numol * ( ( w0 ( i , jp , k ) - w0 ( i , j , k )) * dyi & + ( v0 ( i , jp , k ) - v0 ( i , jp , km )) * dzhi ( k ) ) & - numol * ( ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi & + ( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) ) & ) * dyi & + & ( numol * ( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) & - numol * ( w0 ( i , j , k ) - w0 ( i , j , km )) * dzfi ( km ) ) * 2. & * dzhi ( k ) ) tvmz ( i , j , k ) = ( tvmz ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * tsamplep ) * tstatsdumppi ! update average uwsgsav ! Compute stresses and fluxes at c.c. , also used in total viscous transport strain2 = ( & (( u0 ( ip , j , k ) - u0 ( i , j , k )) * dxfi ( i ) ) ** 2 + & (( v0 ( i , jp , k ) - v0 ( i , j , k )) * dyi ) ** 2 + & (( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) ) ** 2 ) strain2 = strain2 + 0.125 * ( & (( w0 ( i , j , kp ) - w0 ( im , j , kp )) * dxhi ( i ) + & ( u0 ( i , j , kp ) - u0 ( i , j , k )) * dzhi ( kp ) ) ** 2 + & (( w0 ( i , j , k ) - w0 ( im , j , k )) * dxhi ( i ) + & ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) ) ** 2 + & (( w0 ( ip , j , k ) - w0 ( i , j , k )) * dxhi ( ip ) + & ( u0 ( ip , j , k ) - u0 ( ip , j , km )) * dzhi ( k ) ) ** 2 + & (( w0 ( ip , j , kp ) - w0 ( i , j , kp )) * dxhi ( ip ) + & ( u0 ( ip , j , kp ) - u0 ( ip , j , k )) * dzhi ( kp ) ) ** 2 ) strain2 = strain2 + 0.125 * ( & (( u0 ( i , jp , k ) - u0 ( i , j , k )) * dyi + & ( v0 ( i , jp , k ) - v0 ( im , jp , k )) * dxhi ( i ) ) ** 2 + & (( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi + & ( v0 ( i , j , k ) - v0 ( im , j , k )) * dxhi ( i ) ) ** 2 + & (( u0 ( ip , j , k ) - u0 ( ip , jm , k )) * dyi + & ( v0 ( ip , j , k ) - v0 ( i , j , k )) * dxhi ( ip ) ) ** 2 + & (( u0 ( ip , jp , k ) - u0 ( ip , j , k )) * dyi + & ( v0 ( ip , jp , k ) - v0 ( i , jp , k )) * dxhi ( ip ) ) ** 2 ) strain2 = strain2 + 0.125 * ( & (( v0 ( i , j , kp ) - v0 ( i , j , k )) * dzhi ( kp ) + & ( w0 ( i , j , kp ) - w0 ( i , jm , kp )) * dyi ) ** 2 + & (( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) + & ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi ) ** 2 + & (( v0 ( i , jp , k ) - v0 ( i , jp , km )) * dzhi ( k ) + & ( w0 ( i , jp , k ) - w0 ( i , j , k )) * dyi ) ** 2 + & (( v0 ( i , jp , kp ) - v0 ( i , jp , k )) * dzhi ( kp ) + & ( w0 ( i , jp , kp ) - w0 ( i , j , kp )) * dyi ) ** 2 ) strain2av ( i , j , k ) = ( strain2av ( i , j , k ) * ( tstatsdumpp - tsamplep ) + strain2 * tsamplep ) * tstatsdumppi ! update average strain2av !-------------------------------------------------- !> SGS TKE !-------------------------------------------------- ! x-direction emom = ( dzf ( km ) * ( tekm ( i , j , k ) * dxf ( i - 1 ) + tekm ( i - 1 , j , k ) * dxf ( i ) ) + & ! dx is non-equidistant dzf ( k ) * ( tekm ( i , j , km ) * dxf ( i - 1 ) + tekm ( i - 1 , j , km ) * dxf ( i ) ) ) * dxhi ( i ) * dzhiq ( k ) emop = ( dzf ( kp ) * ( tekm ( i , j , k ) * dxf ( i - 1 ) + tekm ( i - 1 , j , k ) * dxf ( i ) ) + & ! dx is non-equidistant dzf ( k ) * ( tekm ( i , j , kp ) * dxf ( i - 1 ) + tekm ( i - 1 , j , kp ) * dxf ( i ) ) ) * dxhi ( i ) * dzhiq ( kp ) empo = 0.25 * ( ( tekm ( i , j , k ) + tekm ( i , jp , k )) * dxf ( i - 1 ) + ( tekm ( i - 1 , j , k ) + tekm ( i - 1 , jp , k )) * dxf ( i ) ) * dxhi ( i ) ! dx is non-equidistant emmo = 0.25 * ( ( tekm ( i , j , k ) + tekm ( i , jm , k )) * dxf ( i - 1 ) + ( tekm ( i - 1 , jm , k ) + tekm ( i - 1 , j , k )) * dxf ( i ) ) * dxhi ( i ) ! dx is non-equidistant !        dummy =  u0(i,j,k)*(                           & dummy = ( & ( tekm ( i , j , k ) * ( u0 ( i + 1 , j , k ) - u0 ( i , j , k )) * dxfi ( i ) & - tekm ( i - 1 , j , k ) * ( u0 ( i , j , k ) - u0 ( i - 1 , j , k )) * dxfi ( i - 1 ) ) * 2. * dxhi ( i ) & + & ( empo * ( ( u0 ( i , jp , k ) - u0 ( i , j , k )) * dyi & + ( v0 ( i , jp , k ) - v0 ( i - 1 , jp , k )) * dxhi ( i )) & - emmo * ( ( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi & + ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dxhi ( i )) & ) * dyi & + & ( emop * ( ( u0 ( i , j , kp ) - u0 ( i , j , k )) * dzhi ( kp ) & + ( w0 ( i , j , kp ) - w0 ( i - 1 , j , kp )) * dxhi ( i )) & - emom * ( ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) & + ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dxhi ( i )) & ) * dzfi ( k ) ) tsgsmx1 ( i , j , k ) = ( tsgsmx1 ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * u0 ( i , j , k ) * tsamplep ) * tstatsdumppi ! update average tsgsmx1 tsgsmx2 ( i , j , k ) = ( tsgsmx2 ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * tsamplep ) * tstatsdumppi ! update average tsgsmx2 ! y-direction eomm = ( dzf ( km ) * ( tekm ( i , j , k ) + tekm ( i , jm , k ) ) + & dzf ( k ) * ( tekm ( i , j , km ) + tekm ( i , jm , km ) ) ) * dzhiq ( k ) eomp = ( dzf ( kp ) * ( tekm ( i , j , k ) + tekm ( i , jm , k ) ) + & dzf ( k ) * ( tekm ( i , j , kp ) + tekm ( i , jm , kp ) ) ) * dzhiq ( kp ) emmo = 0.25 * ( ( tekm ( i , j , k ) + tekm ( i , jm , k )) * dxf ( i - 1 ) + ( tekm ( i - 1 , jm , k ) + tekm ( i - 1 , j , k )) * dxf ( i ) ) * dxhi ( i ) ! dx is non-equidistant epmo = 0.25 * ( ( tekm ( i , j , k ) + tekm ( i , jm , k )) * dxf ( i + 1 ) + ( tekm ( i + 1 , jm , k ) + tekm ( i + 1 , j , k )) * dxf ( i ) ) * dxhi ( i + 1 ) ! dx is non-equidistant !       dummy = v0(i,j,k) * (                            & dummy = ( & ( epmo * ( ( v0 ( i + 1 , j , k ) - v0 ( i , j , k )) * dxhi ( i + 1 ) & + ( u0 ( i + 1 , j , k ) - u0 ( i + 1 , jm , k )) * dyi ) & - emmo * ( ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dxhi ( i ) & + ( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi ) & ) * dxfi ( i ) & ! = d/dx( Km*(dv/dx + du/dy) ) + & ( tekm ( i , j , k ) * ( v0 ( i , jp , k ) - v0 ( i , j , k )) & - tekm ( i , jm , k ) * ( v0 ( i , j , k ) - v0 ( i , jm , k )) ) * 2. * dy2i & ! = d/dy( 2*Km*(dv/dy) ) + & ( eomp * ( ( v0 ( i , j , kp ) - v0 ( i , j , k )) * dzhi ( kp ) & + ( w0 ( i , j , kp ) - w0 ( i , jm , kp )) * dyi ) & - eomm * ( ( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) & + ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi ) & ) * dzfi ( k ) ) ! = d/dz( Km*(dv/dz + dw/dy) ) tsgsmy1 ( i , j , k ) = ( tsgsmy1 ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * v0 ( i , j , k ) * tsamplep ) * tstatsdumppi ! update average tsgsmy1  = <v*d/dxj(2*nu*S2j)> tsgsmy2 ( i , j , k ) = ( tsgsmy2 ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * tsamplep ) * tstatsdumppi ! update average tsgsmy2  = <d/dxj(2*nu*S2j)> ! z-direction emom = ( dzf ( km ) * ( tekm ( i , j , k ) * dxf ( i - 1 ) + tekm ( i - 1 , j , k ) * dxf ( i ) ) * dxhi ( i ) + & dzf ( k ) * ( tekm ( i , j , km ) * dxf ( i - 1 ) + tekm ( i - 1 , j , km ) * dxf ( i ) ) * dxhi ( i ) ) * dzhiq ( k ) eomm = ( dzf ( km ) * ( tekm ( i , j , k ) + tekm ( i , jm , k ) ) + & dzf ( k ) * ( tekm ( i , j , km ) + tekm ( i , jm , km ) ) ) * dzhiq ( k ) eopm = ( dzf ( km ) * ( tekm ( i , j , k ) + tekm ( i , jp , k ) ) + & dzf ( k ) * ( tekm ( i , j , km ) + tekm ( i , jp , km ) ) ) * dzhiq ( k ) epom = ( dzf ( km ) * ( tekm ( i , j , k ) * dxf ( i + 1 ) + tekm ( i + 1 , j , k ) * dxf ( i ) ) * dxhi ( i + 1 ) + & dzf ( k ) * ( tekm ( i , j , km ) * dxf ( i + 1 ) + tekm ( i + 1 , j , km ) * dxf ( i ) ) * dxhi ( i + 1 ) ) * dzhiq ( k ) !        dummy = w0(i,j,k) * (                                         & dummy = ( & ( epom * ( ( w0 ( i + 1 , j , k ) - w0 ( i , j , k )) * dxhi ( i + 1 ) & + ( u0 ( i + 1 , j , k ) - u0 ( i + 1 , j , km )) * dzhi ( k ) ) & - emom * ( ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dxhi ( i ) & + ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) ) & ) * dxfi ( i ) & + & ( eopm * ( ( w0 ( i , jp , k ) - w0 ( i , j , k )) * dyi & + ( v0 ( i , jp , k ) - v0 ( i , jp , km )) * dzhi ( k ) ) & - eomm * ( ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi & + ( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) ) & ) * dyi & + & ( tekm ( i , j , k ) * ( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) & - tekm ( i , j , km ) * ( w0 ( i , j , k ) - w0 ( i , j , km )) * dzfi ( km ) ) * 2. & * dzhi ( k )) tsgsmz1 ( i , j , k ) = ( tsgsmz1 ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * w0 ( i , j , k ) * tsamplep ) * tstatsdumppi ! update average tsgsmz1 = <w*d/dxj(2*nu*S3j)> tsgsmz2 ( i , j , k ) = ( tsgsmz2 ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * tsamplep ) * tstatsdumppi ! update average tsgsmz2 = <d/dxj(2*nu*S3j)> end do end do end do end subroutine tkestats","tags":"","loc":"proc/tkestats.html"},{"title":"forces – uDALES","text":"public subroutine forces() Uses modglobal modfields modibmdata modsurfdata modmpi proc~~forces~~UsesGraph proc~forces forces module~modibmdata modibmdata proc~forces->module~modibmdata module~modsurfdata modsurfdata proc~forces->module~modsurfdata module~modmpi modmpi proc~forces->module~modmpi module~modfields modfields proc~forces->module~modfields module~modglobal modglobal proc~forces->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~forces~~CalledByGraph proc~forces forces program~dalesurban DALESURBAN program~dalesurban->proc~forces Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code forces Source Code subroutine forces !-----------------------------------------------------------------| !                                                                 | !      Hans Cuijpers   I.M.A.U.                                   | !      Pier Siebesma   K.N.M.I.     06/01/1995                    | !                                                                 | !     purpose.                                                    | !     --------                                                    | !                                                                 | !      Calculates all other terms in the N-S equation,            | !      except for the diffusion and advection terms.              | !                                                                 | !**   interface.                                                  | !     ----------                                                  | !                                                                 | !     *forces* is called from *program*.                          | !                                                                 | !-----------------------------------------------------------------| !  use modglobal, only : i1,j1,kmax,dzh,dzf,grav use modglobal , only : ib , ie , jb , je , kb , ke , kh , dzhi , dzf , grav , lbuoyancy use modfields , only : u0 , v0 , w0 , up , vp , wp , thv0h , dpdxl , dpdyl , thlp , thlpcar , thvh use modibmdata , only : nxwallsnorm , xwallsnorm use modsurfdata , only : thvs use modmpi , only : myid implicit none real thvsi integer i , j , k , n , jm , jp , km , kp if ( lbuoyancy ) then !ILS13 replace thvsi by thvh ! thvsi = 1./thvsi !write(*,*) 'thvh',thvh do k = kb + 1 , ke do j = jb , je do i = ib , ie up ( i , j , k ) = up ( i , j , k ) - dpdxl ( k ) vp ( i , j , k ) = vp ( i , j , k ) - dpdyl ( k ) wp ( i , j , k ) = wp ( i , j , k ) + grav * ( thv0h ( i , j , k ) - thvh ( k )) / thvh ( k ) end do end do end do else do k = kb + 1 , ke do j = jb , je do i = ib , ie up ( i , j , k ) = up ( i , j , k ) - dpdxl ( k ) vp ( i , j , k ) = vp ( i , j , k ) - dpdyl ( k ) ! IS+HJ      wp(i,j,k) = wp(i,j,k) end do end do end do end if !     ---------------------------------------------- !     add radiative heating to potential temperature !     ---------------------------------------------- do k = kb , ke do j = jb , je do i = ib , ie thlp ( i , j , k ) = thlp ( i , j , k ) + thlpcar ( k ) end do end do end do !     -------------------------------------------- !     special treatment for lowest full level: k=1 !     -------------------------------------------- do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie up ( i , j , kb ) = up ( i , j , kb ) - dpdxl ( kb ) vp ( i , j , kb ) = vp ( i , j , kb ) - dpdyl ( kb ) wp ( i , j , kb ) = 0.0 end do end do !     ----------------------------------------------end i,j-loop return end subroutine forces","tags":"","loc":"proc/forces.html"},{"title":"detfreestream – uDALES","text":"public subroutine detfreestream(freestream) Uses modglobal modfields modmpi proc~~detfreestream~~UsesGraph proc~detfreestream detfreestream module~modmpi modmpi proc~detfreestream->module~modmpi module~modfields modfields proc~detfreestream->module~modfields module~modglobal modglobal proc~detfreestream->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(out) :: freestream Calls proc~~detfreestream~~CallsGraph proc~detfreestream detfreestream mpi_allreduce mpi_allreduce proc~detfreestream->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~detfreestream~~CalledByGraph proc~detfreestream detfreestream proc~fixuinf1 fixuinf1 proc~fixuinf1->proc~detfreestream proc~fixuinf2 fixuinf2 proc~fixuinf2->proc~detfreestream program~dalesurban DALESURBAN program~dalesurban->proc~fixuinf1 program~dalesurban->proc~fixuinf2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code detfreestream Source Code subroutine detfreestream ( freestream ) use modglobal , only : ib , ie , jb , je , kb , ke , kh , dxf , xh , dt ,& Uinf , lvinf , dy use modfields , only : u0 , dpdxl , dgdt , dpdx , v0 use modmpi , only : myid , comm3d , mpierr , mpi_sum , my_real , nprocs implicit none real , intent ( out ) :: freestream real utop , vtop , dum integer i , j if ( lvinf ) then vtop = 0. do j = jb , je do i = ib , ie vtop = vtop + 0.5 * ( v0 ( i , j , ke ) + u0 ( i , j + 1 , ke )) * dy end do end do vtop = vtop / ( ( je - jb + 1 ) * ( xh ( ie + 1 ) - xh ( ib ) ) ) call MPI_ALLREDUCE ( vtop , dum , 1 , MY_REAL , MPI_SUM , comm3d , mpierr ) freestream = dum / nprocs else utop = 0. do j = jb , je do i = ib , ie !dum=0.5*(u0(i,j,ke)+u0(i+1,j,ke))*dxf(i) !utop = utop + dum utop = utop + 0.5 * ( u0 ( i , j , ke ) + u0 ( i + 1 , j , ke )) * dxf ( i ) end do end do utop = utop / ( ( je - jb + 1 ) * ( xh ( ie + 1 ) - xh ( ib ) ) ) call MPI_ALLREDUCE ( utop , dum , 1 , MY_REAL , MPI_SUM , comm3d , mpierr ) freestream = dum / nprocs !write(*,*) \"myid,utop,dum,freestream\",myid,utop,dum,freestream end if end subroutine detfreestream","tags":"","loc":"proc/detfreestream.html"},{"title":"detfreestrtmp – uDALES","text":"public subroutine detfreestrtmp(freestrtmp) Uses modglobal modfields modmpi proc~~detfreestrtmp~~UsesGraph proc~detfreestrtmp detfreestrtmp module~modmpi modmpi proc~detfreestrtmp->module~modmpi module~modfields modfields proc~detfreestrtmp->module~modfields module~modglobal modglobal proc~detfreestrtmp->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(out) :: freestrtmp Calls proc~~detfreestrtmp~~CallsGraph proc~detfreestrtmp detfreestrtmp mpi_allreduce mpi_allreduce proc~detfreestrtmp->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code detfreestrtmp Source Code subroutine detfreestrtmp ( freestrtmp ) use modglobal , only : ib , ie , jb , je , kb , ke , kh , dxf , xh , dt ,& Uinf use modfields , only : thl0 , dpdxl , dgdt , dpdx use modmpi , only : myid , comm3d , mpierr , mpi_sum , my_real , nprocs implicit none real , intent ( out ) :: freestrtmp real ttop integer i , j ttop = 0. do j = jb , je do i = ib , ie ttop = ttop + thl0 ( i , j , ke ) * dxf ( i ) end do end do ttop = ttop / ( ( je - jb + 1 ) * ( xh ( ie + 1 ) - xh ( ib ) ) ) call MPI_ALLREDUCE ( ttop , freestrtmp , 1 , MY_REAL , MPI_SUM , comm3d , mpierr ) freestrtmp = freestrtmp / nprocs end subroutine detfreestrtmp","tags":"","loc":"proc/detfreestrtmp.html"},{"title":"fixuinf2 – uDALES","text":"public subroutine fixuinf2() Uses modglobal modsurfdata modfields modmpi proc~~fixuinf2~~UsesGraph proc~fixuinf2 fixuinf2 module~modmpi modmpi proc~fixuinf2->module~modmpi module~modfields modfields proc~fixuinf2->module~modfields module~modglobal modglobal proc~fixuinf2->module~modglobal module~modsurfdata modsurfdata proc~fixuinf2->module~modsurfdata mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~fixuinf2~~CallsGraph proc~fixuinf2 fixuinf2 proc~detfreestream detfreestream proc~fixuinf2->proc~detfreestream mpi_allreduce mpi_allreduce proc~detfreestream->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~fixuinf2~~CalledByGraph proc~fixuinf2 fixuinf2 program~dalesurban DALESURBAN program~dalesurban->proc~fixuinf2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code fixuinf2 Source Code subroutine fixuinf2 use modglobal , only : ib , ie , jb , je , kb , ke , kh , dxf , xh , dt ,& Uinf , ifixuinf , tscale , timee , rk3step , inletav ,& freestreamav , freestrtmpav , ltempeq use modsurfdata , only : thl_top use modfields , only : u0 , thl0 , dpdxl , dgdt , dpdx , thlsrcdt use modmpi , only : myid , comm3d , mpierr , mpi_sum , my_real , nprocs implicit none real utop , freestream , freestrtmp , rk3coef integer i , j utop = 0. if (( ifixuinf == 2 ) . and . ( rk3step == 3 )) then call detfreestream ( freestream ) freestreamav = freestream * dt / inletav + ( 1. - dt / inletav ) * freestreamav ! Write some statistics to monitoring file ! if (myid==0) then !   open(unit=11,file='freestr.txt',position='append') !   write(11,3002) timee,freestream,freestreamav !   3002      format (13(6e14.6)) !   close(11) ! endif !    dgdt =  (1./tscale) * (freestream - Uinf) !    dgdt =  (1./dt) * (freestreamav - Uinf) dgdt = ( 1. / tscale ) * ( freestreamav - Uinf ) ! plus sign because dpdx is SUBTRACTED from Navier-Stokes eqs !    dgdt =  (1./inletav) * (freestreamav - Uinf) !    if (ltempeq) then  !tg3315 commented !      call detfreestrtmp(freestrtmp) !      freestrtmpav=  freestrtmp*dt/inletav + (1.-dt/inletav)*freestrtmpav !      thlsrcdt = -(1./tscale) * (freestrtmpav - thl_top)   ! minus sign because thlsr is ADDED to Navier-Stokes eqs. !      if (myid==0) then !        open(unit=11,file='theta_top.txt',position='append') !        write(11,3009) timee,freestrtmp,freestrtmpav !3009    format (13(6e20.12)) !        close(11) !      endif !    end if end if end subroutine fixuinf2","tags":"","loc":"proc/fixuinf2.html"},{"title":"fixuinf1 – uDALES","text":"public subroutine fixuinf1() Uses modglobal modfields modmpi proc~~fixuinf1~~UsesGraph proc~fixuinf1 fixuinf1 module~modmpi modmpi proc~fixuinf1->module~modmpi module~modfields modfields proc~fixuinf1->module~modfields module~modglobal modglobal proc~fixuinf1->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~fixuinf1~~CallsGraph proc~fixuinf1 fixuinf1 proc~detfreestream detfreestream proc~fixuinf1->proc~detfreestream mpi_allreduce mpi_allreduce proc~detfreestream->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~fixuinf1~~CalledByGraph proc~fixuinf1 fixuinf1 program~dalesurban DALESURBAN program~dalesurban->proc~fixuinf1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code fixuinf1 Source Code subroutine fixuinf1 use modglobal , only : ib , ie , jb , je , kb , ke , kh , dxf , xh , dt ,& Uinf , Vinf , ifixuinf , tscale , timee , rk3step , inletav ,& freestreamav , lvinf use modfields , only : u0 , dpdxl , dgdt , dpdx , up , vp use modmpi , only : myid , comm3d , mpierr , mpi_sum , my_real , nprocs implicit none real utop , freestream , rk3coef integer i , j , k utop = 0. if (( ifixuinf == 1 ) . and . ( rk3step == 3 )) then ! rk3coef = dt / (4. - dble(rk3step)) ! do j =jb,je !   do i =ib,ie !     utop = utop + 0.5*(u0(i,j,ke)+u0(i+1,j,ke))*dxf(i) !   end do ! end do ! utop = utop / ( (je-jb+1)*(xh(ie+1)-xh(ib) ) ) ! call MPI_ALLREDUCE(utop,    freestream,1,MY_REAL,MPI_SUM,comm3d,mpierr) ! freestream = freestream / nprocs ! Write some statistics to monitoring file ! if (myid==0 .and. rk3step==3) then ! ! dpdxl(:) = dpdx + (1./rk3coef) * (freestream - Uinf) ! dpdxl(:) = dpdx + (1./dt) * (freestream - Uinf) call detfreestream ( freestream ) ! write(*,*) \"freestream\",freestream if ( lvinf ) then do k = kb , ke do i = ib , ie do j = jb , je vp ( i , j , k ) = vp ( i , j , k ) - ( 1. / dt ) * ( freestream - Vinf ) enddo enddo enddo else do k = kb , ke do j = jb , je do i = ib , ie up ( i , j , k ) = up ( i , j , k ) - ( 1. / dt ) * ( freestream - Uinf ) enddo enddo enddo endif ! if (myid==0) then !   write(*,*), \"freestream\", freestream !   write(*,*), \"Uinf\", Uinf !   open(unit=11,file='freestr.txt',position='append') !   write(11,3003) timee,freestream !   3003    format (13(6e20.12)) !   close(11) !   open(unit=11,file='dpdx___.txt',position='append') !   write(11,3002) timee,dpdxl(kb),dpdxl(kb)-dpdx !   3002    format (13(6e20.12)) !   close(11) ! endif end if end subroutine fixuinf1","tags":"","loc":"proc/fixuinf1.html"},{"title":"fixthetainf – uDALES","text":"public subroutine fixthetainf() Uses modglobal modfields modmpi modsurfdata proc~~fixthetainf~~UsesGraph proc~fixthetainf fixthetainf module~modmpi modmpi proc~fixthetainf->module~modmpi module~modfields modfields proc~fixthetainf->module~modfields module~modglobal modglobal proc~fixthetainf->module~modglobal module~modsurfdata modsurfdata proc~fixthetainf->module~modsurfdata mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~fixthetainf~~CalledByGraph proc~fixthetainf fixthetainf program~dalesurban DALESURBAN program~dalesurban->proc~fixthetainf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code fixthetainf Source Code subroutine fixthetainf use modglobal , only : ib , ie , jb , je , kb , ke , kh , dxf , xh , dt ,& Uinf , ifixuinf , tscale , timee , rk3step , inletav ,& freestreamav , thlsrc , ltempeq use modfields , only : thl0 use modmpi , only : myid , comm3d , mpierr , mpi_sum , my_real , nprocs use modsurfdata , only : thl_top implicit none real ttop , freestreamtheta , rk3coef integer i , j ttop = 0. ! if (ifixuinf==1 .and. rk3step==3 .and. ltempeq) then !tg3315 commented !   rk3coef = dt / (4. - dble(rk3step)) !   do j =jb,je !     do i =ib,ie !       ttop = ttop + thl0(i,j,ke)*dxf(i) !     end do !   end do !   ttop = ttop / ( (je-jb+1)*(xh(ie+1)-xh(ib) ) ) !   call MPI_ALLREDUCE(ttop,    freestreamtheta,1,MY_REAL,MPI_SUM,comm3d,mpierr) !   freestreamtheta = freestreamtheta / nprocs !   thlsrc = -(1./dt) * (freestreamtheta - thl_top) !     if (myid==0) then !       open(unit=11,file='theta_top.txt',position='append') !       write(11,3003) timee,freestreamtheta !       3003    format (13(6e20.12)) !       close(11) !       open(unit=11,file='thlsrc.txt',position='append') !       write(11,3002) timee,thlsrc !       3002    format (13(6e20.12)) !       close(11) !     endif ! end if end subroutine fixthetainf","tags":"","loc":"proc/fixthetainf.html"},{"title":"masscorr – uDALES","text":"public subroutine masscorr() Uses modglobal modfields modmpi proc~~masscorr~~UsesGraph proc~masscorr masscorr module~modmpi modmpi proc~masscorr->module~modmpi module~modfields modfields proc~masscorr->module~modfields module~modglobal modglobal proc~masscorr->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~masscorr~~CallsGraph proc~masscorr masscorr mpi_bcast mpi_bcast proc~masscorr->mpi_bcast Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~masscorr~~CalledByGraph proc~masscorr masscorr program~dalesurban DALESURBAN program~dalesurban->proc~masscorr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code masscorr Source Code subroutine masscorr !> correct the velocities to get prescribed flow rate use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , dzf , dxf , dy , dt , rk3step ,& uflowrate , vflowrate , linoutflow ,& luoutflowr , lvoutflowr , luvolflowr , lvvolflowr use modfields , only : um , up , vm , vp , uout , uouttot , udef , vout , vouttot , vdef ,& uoutarea , voutarea , fluidvol , IIu , IIv use modmpi , only : myid , comm3d , mpierr , nprocs , MY_REAL , sumy_ibm real , dimension ( ib : ie , kb : ke ) :: uvol real , dimension ( ib : ie , kb : ke ) :: uvolold real , dimension ( ib : ie , kb : ke ) :: vvol real , dimension ( ib : ie , kb : ke ) :: vvolold real , dimension ( kb : ke ) :: uoutold real , dimension ( kb : ke ) :: voutold real rk3coef , rk3coefi ,& uoutflow , voutflow ,& uflowrateold , vflowrateold integer i , j , k if ((. not . linoutflow ) . and . ( luoutflowr )) then rk3coef = dt / ( 4. - dble ( rk3step )) rk3coefi = 1 / rk3coef udef = 0. uout = 0. uoutflow = 0. uoutold = 0. ! integrate u fixed at outlet ie along y call sumy_ibm ( uout , up ( ie , jb : je , kb : ke ) * dy , ie , ie , jb , je , kb , ke , IIu ( ie , jb : je , kb : ke )) ! u tendency at previous time step call sumy_ibm ( uoutold , um ( ie , jb : je , kb : ke ) * dy , ie , ie , jb , je , kb , ke , IIu ( ie , jb : je , kb : ke )) ! u at previous time step ! integrate u in z do k = kb , ke uout ( k ) = rk3coef * uout ( k ) * dzf ( k ) uoutold ( k ) = uoutold ( k ) * dzf ( k ) end do uoutflow = sum ( uout ( kb : ke )) uflowrateold = sum ( uoutold ( kb : ke )) ! average over outflow area uoutflow = uoutflow / uoutarea uflowrateold = uflowrateold / uoutarea ! flow correction to match outflow rate udef = uflowrate - ( uoutflow + uflowrateold ) do k = kb , ke do j = jb , je do i = ib , ie up ( i , j , k ) = up ( i , j , k ) + udef * rk3coefi end do end do end do ! bss116 calculate uouttot which is used in modboundary. ! this really should be in the routine directly! uouttot = sum ( uout ( kb : ke )) ! mass flow rate at outlet elseif ((. not . linoutflow ) . and . ( luvolflowr )) then rk3coef = dt / ( 4. - dble ( rk3step )) rk3coefi = 1 / rk3coef udef = 0. uout = 0. uoutflow = 0. uoutold = 0. uvol = 0. uvolold = 0. ! integrate u in y call sumy_ibm ( uvol , up ( ib : ie , jb : je , kb : ke ) * dy , ib , ie , jb , je , kb , ke , IIu ( ib : ie , jb : je , kb : ke )) ! u tendency at previous time step call sumy_ibm ( uvolold , um ( ib : ie , jb : je , kb : ke ) * dy , ib , ie , jb , je , kb , ke , IIu ( ib : ie , jb : je , kb : ke )) ! u at previous time step ! integrate u in x do k = kb , ke uout ( k ) = sum ( uvol ( ib : ie , k ) * dxf ( ib : ie )) uoutold ( k ) = sum ( uvolold ( ib : ie , k ) * dxf ( ib : ie )) end do ! integrate u in z do k = kb , ke uout ( k ) = rk3coef * uout ( k ) * dzf ( k ) uoutold ( k ) = uoutold ( k ) * dzf ( k ) end do uoutflow = sum ( uout ( kb : ke )) uflowrateold = sum ( uoutold ( kb : ke )) ! average over fluid volume uoutflow = uoutflow / fluidvol uflowrateold = uflowrateold / fluidvol ! flow correction to match outflow rate udef = uflowrate - ( uoutflow + uflowrateold ) do k = kb , ke do j = jb , je do i = ib , ie up ( i , j , k ) = up ( i , j , k ) + udef * rk3coefi end do end do end do end if if ((. not . linoutflow ) . and . ( lvoutflowr )) then rk3coef = dt / ( 4. - dble ( rk3step )) rk3coefi = 1 / rk3coef vdef = 0. vout = 0. voutflow = 0. voutold = 0. ! integrate v fixed at outlet je along x if ( myid == nprocs - 1 ) then do k = kb , ke vout ( k ) = sum ( vp ( ib : ie , je , k ) * IIv ( ib : ie , je , k ) * dxf ( ib : ie )) ! v tendency at previous time step voutold ( k ) = sum ( vm ( ib : ie , je , k ) * IIv ( ib : ie , je , k ) * dxf ( ib : ie )) ! v at previous time step end do end if call MPI_BCAST ( vout , ke - kb + 1 , MY_REAL , nprocs - 1 , comm3d , mpierr ) call MPI_BCAST ( voutold , ke - kb + 1 , MY_REAL , nprocs - 1 , comm3d , mpierr ) ! integrate v in z do k = kb , ke vout ( k ) = rk3coef * vout ( k ) * dzf ( k ) voutold ( k ) = voutold ( k ) * dzf ( k ) end do voutflow = sum ( vout ( kb : ke )) vflowrateold = sum ( voutold ( kb : ke )) ! average over outflow area voutflow = voutflow / voutarea vflowrateold = vflowrateold / voutarea ! flow correction to match outflow rate vdef = vflowrate - ( voutflow + vflowrateold ) do k = kb , ke do j = jb , je do i = ib , ie vp ( i , j , k ) = vp ( i , j , k ) + vdef * rk3coefi end do end do end do elseif ((. not . linoutflow ) . and . ( lvvolflowr )) then rk3coef = dt / ( 4. - dble ( rk3step )) rk3coefi = 1 / rk3coef vdef = 0. vout = 0. voutflow = 0. voutold = 0. vvol = 0. vvolold = 0. ! integrate v in y call sumy_ibm ( vvol , vp ( ib : ie , jb : je , kb : ke ) * dy , ib , ie , jb , je , kb , ke , IIv ( ib : ie , jb : je , kb : ke )) ! v tendency at previous time step call sumy_ibm ( vvolold , vm ( ib : ie , jb : je , kb : ke ) * dy , ib , ie , jb , je , kb , ke , IIv ( ib : ie , jb : je , kb : ke )) ! v at previous time step ! integrate v in x do k = kb , ke vout ( k ) = sum ( vvol ( ib : ie , k ) * dxf ( ib : ie )) voutold ( k ) = sum ( vvolold ( ib : ie , k ) * dxf ( ib : ie )) end do ! integrate v in z do k = kb , ke vout ( k ) = rk3coef * vout ( k ) * dzf ( k ) voutold ( k ) = voutold ( k ) * dzf ( k ) end do voutflow = sum ( vout ( kb : ke )) vflowrateold = sum ( voutold ( kb : ke )) ! average over fluid volume voutflow = voutflow / fluidvol vflowrateold = vflowrateold / fluidvol ! flow correction to match outflow rate vdef = vflowrate - ( voutflow + vflowrateold ) do k = kb , ke do j = jb , je do i = ib , ie vp ( i , j , k ) = vp ( i , j , k ) + vdef * rk3coefi end do end do end do end if end subroutine masscorr","tags":"","loc":"proc/masscorr.html"},{"title":"uoutletarea – uDALES","text":"public subroutine uoutletarea(area) Uses modglobal modfields modmpi proc~~uoutletarea~~UsesGraph proc~uoutletarea uoutletarea module~modmpi modmpi proc~uoutletarea->module~modmpi module~modfields modfields proc~uoutletarea->module~modfields module~modglobal modglobal proc~uoutletarea->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(out) :: area Called by proc~~uoutletarea~~CalledByGraph proc~uoutletarea uoutletarea proc~calcfluidvolumes calcfluidvolumes proc~calcfluidvolumes->proc~uoutletarea proc~startup startup proc~startup->proc~calcfluidvolumes program~dalesurban DALESURBAN program~dalesurban->proc~startup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code uoutletarea Source Code subroutine uoutletarea ( area ) ! calculates outlet area of domain for u-velocity excluding blocks use modglobal , only : ib , ie , jb , je , kb , ke , dy , dzf use modfields , only : IIc use modmpi , only : sumy_ibm implicit none real , intent ( out ) :: area real , dimension ( kb : ke ) :: sumy integer k sumy = 0. ! integrate fluid area at outflow plane in y call sumy_ibm ( sumy , IIc ( ie , jb : je , kb : ke ) * dy , ie , ie , jb , je , kb , ke , IIc ( ie , jb : je , kb : ke )) ! integrate fluid area at outflow plane in z do k = kb , ke sumy ( k ) = sumy ( k ) * dzf ( k ) end do area = sum ( sumy ( kb : ke )) end subroutine uoutletarea","tags":"","loc":"proc/uoutletarea.html"},{"title":"voutletarea – uDALES","text":"public subroutine voutletarea(area) Uses modglobal modfields modmpi proc~~voutletarea~~UsesGraph proc~voutletarea voutletarea module~modmpi modmpi proc~voutletarea->module~modmpi module~modfields modfields proc~voutletarea->module~modfields module~modglobal modglobal proc~voutletarea->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(out) :: area Calls proc~~voutletarea~~CallsGraph proc~voutletarea voutletarea mpi_bcast mpi_bcast proc~voutletarea->mpi_bcast Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~voutletarea~~CalledByGraph proc~voutletarea voutletarea proc~calcfluidvolumes calcfluidvolumes proc~calcfluidvolumes->proc~voutletarea proc~startup startup proc~startup->proc~calcfluidvolumes program~dalesurban DALESURBAN program~dalesurban->proc~startup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code voutletarea Source Code subroutine voutletarea ( area ) ! calculates outlet area of domain for v-velocity excluding blocks use modglobal , only : ib , ie , jb , je , kb , ke , dxf , dzf use modfields , only : IIc use modmpi , only : myid , comm3d , mpierr , nprocs , MY_REAL implicit none real , intent ( out ) :: area real , dimension ( kb : ke ) :: sumx integer k sumx = 0. ! integrate fluid area at outflow plane in x if ( myid == nprocs - 1 ) then do k = kb , ke sumx ( k ) = sum ( IIc ( ib : ie , je , k ) * dxf ( ib : ie )) end do end if call MPI_BCAST ( sumx , ke - kb + 1 , MY_REAL , nprocs - 1 , comm3d , mpierr ) ! integrate fluid area at outflow plane in z do k = kb , ke sumx ( k ) = sumx ( k ) * dzf ( k ) end do area = sum ( sumx ( kb : ke )) end subroutine voutletarea","tags":"","loc":"proc/voutletarea.html"},{"title":"fluidvolume – uDALES","text":"public subroutine fluidvolume(volume) Uses modglobal modfields modmpi proc~~fluidvolume~~UsesGraph proc~fluidvolume fluidvolume module~modmpi modmpi proc~fluidvolume->module~modmpi module~modfields modfields proc~fluidvolume->module~modfields module~modglobal modglobal proc~fluidvolume->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real, intent(out) :: volume Called by proc~~fluidvolume~~CalledByGraph proc~fluidvolume fluidvolume proc~calcfluidvolumes calcfluidvolumes proc~calcfluidvolumes->proc~fluidvolume proc~startup startup proc~startup->proc~calcfluidvolumes program~dalesurban DALESURBAN program~dalesurban->proc~startup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code fluidvolume Source Code subroutine fluidvolume ( volume ) ! calculates fluid volume of domain excluding blocks use modglobal , only : ib , ie , jb , je , kb , ke , dy , dxf , dzf use modfields , only : IIc use modmpi , only : sumy_ibm implicit none real , intent ( out ) :: volume real , dimension ( ib : ie , kb : ke ) :: sumy real , dimension ( kb : ke ) :: sumxy integer k sumy = 0. sumxy = 0. ! integrate fluid volume in y call sumy_ibm ( sumy , IIc ( ib : ie , jb : je , kb : ke ) * dy , ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke )) ! integrate fluid area in x do k = kb , ke sumxy ( k ) = sum ( sumy ( ib : ie , k ) * dxf ( ib : ie )) end do ! integrate fluid area in z volume = sum ( sumxy ( kb : ke ) * dzf ( kb : ke )) end subroutine fluidvolume","tags":"","loc":"proc/fluidvolume.html"},{"title":"calcfluidvolumes – uDALES","text":"public subroutine calcfluidvolumes() Uses modfields proc~~calcfluidvolumes~~UsesGraph proc~calcfluidvolumes calcfluidvolumes module~modfields modfields proc~calcfluidvolumes->module~modfields Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~calcfluidvolumes~~CallsGraph proc~calcfluidvolumes calcfluidvolumes proc~uoutletarea uoutletarea proc~calcfluidvolumes->proc~uoutletarea proc~fluidvolume fluidvolume proc~calcfluidvolumes->proc~fluidvolume proc~voutletarea voutletarea proc~calcfluidvolumes->proc~voutletarea mpi_bcast mpi_bcast proc~voutletarea->mpi_bcast Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~calcfluidvolumes~~CalledByGraph proc~calcfluidvolumes calcfluidvolumes proc~startup startup proc~startup->proc~calcfluidvolumes program~dalesurban DALESURBAN program~dalesurban->proc~startup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code calcfluidvolumes Source Code subroutine calcfluidvolumes !> calculates fluid volume and outlet areas, excluding blocks !> and saves it to variables from modfields use modfields , only : uoutarea , voutarea , fluidvol implicit none real :: volume ! calculate outlet area call uoutletarea ( volume ) uoutarea = volume ! calculate outlet area call voutletarea ( volume ) voutarea = volume ! calculate fluid volume call fluidvolume ( volume ) fluidvol = volume end subroutine calcfluidvolumes","tags":"","loc":"proc/calcfluidvolumes.html"},{"title":"coriolis – uDALES","text":"public subroutine coriolis() Uses modglobal modfields modmpi proc~~coriolis~~UsesGraph proc~coriolis coriolis module~modmpi modmpi proc~coriolis->module~modmpi module~modfields modfields proc~coriolis->module~modfields module~modglobal modglobal proc~coriolis->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~coriolis~~CalledByGraph proc~coriolis coriolis program~dalesurban DALESURBAN program~dalesurban->proc~coriolis Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code coriolis Source Code subroutine coriolis !-----------------------------------------------------------------| !                                                                 | !      Thijs Heus TU Delft                                        | !                                                                 | !     purpose.                                                    | !     --------                                                    | !                                                                 | !      Calculates the Coriolis force.                             | !                                                                 | !**   interface.                                                  | !     ----------                                                  | !                                                                 | !     *coriolis* is called from *program*.                        | !                                                                 | !-----------------------------------------------------------------| ! use modglobal, only : i1,j1,kmax,dzh,dzf,om22,om23 use modglobal , only : ib , ie , jb , je , kb , ke , kh , dzh , dzf , om22 , om23 , lcoriol , lprofforc , timee use modfields , only : u0 , v0 , w0 , up , vp , wp , ug , vg use modmpi , only : myid implicit none integer i , j , k , jm , jp , km , kp real , dimension ( kb : ke + kh ) :: ugg real om23g if ( lcoriol ) then ! if (myid==0) then !   write(*,*) \"up before coriol\",up(3,3,ke) ! end if do k = kb + 1 , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie up ( i , j , k ) = up ( i , j , k ) & + (( v0 ( i , j , k ) + v0 ( i , jp , k ) + v0 ( i - 1 , j , k ) + v0 ( i - 1 , jp , k )) * om23 * 0.25 ) & - (( w0 ( i , j , k ) + w0 ( i , j , kp ) + w0 ( i - 1 , j , kp ) + w0 ( i - 1 , j , k )) * om22 * 0.25 ) vp ( i , j , k ) = vp ( i , j , k ) & - (( u0 ( i , j , k ) + u0 ( i , jm , k ) + u0 ( i + 1 , jm , k ) + u0 ( i + 1 , j , k )) * om23 * 0.25 ) wp ( i , j , k ) = wp ( i , j , k ) + (( ( dzf ( km ) * ( u0 ( i , j , k ) + u0 ( i + 1 , j , k ) ) & + dzf ( k ) * ( u0 ( i , j , km ) + u0 ( i + 1 , j , km )) ) / dzh ( k ) ) & * om22 * 0.25 ) end do end do ! -------------------------------------------end i&j-loop end do ! -------------------------------------------end k-loop ! -------------------------------------------- ! special treatment for lowest full level: k=1 ! -------------------------------------------- do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie up ( i , j , kb ) = up ( i , j , kb ) & + ( v0 ( i , j , kb ) + v0 ( i , jp , kb ) + v0 ( i - 1 , j , kb ) + v0 ( i - 1 , jp , kb )) * om23 * 0.25 & - ( w0 ( i , j , kb ) + w0 ( i , j , kb + 1 ) + w0 ( i - 1 , j , kb + 1 ) + w0 ( i - 1 , j , kb )) * om22 * 0.25 vp ( i , j , kb ) = vp ( i , j , kb ) & - ( u0 ( i , j , kb ) + u0 ( i , jm , kb ) + u0 ( i + 1 , jm , kb ) + u0 ( i + 1 , j , kb )) * om23 * 0.25 wp ( i , j , kb ) = 0.0 end do end do ! ----------------------------------------------end i,j-loop ! if (myid==0) then !   write(*,*) \"up after coriol\",up(3,3,ke) ! end if elseif ( lprofforc ) then ugg (:) = ug (:) om23g = om23 do k = kb + 1 , ke do j = jb , je do i = ib , ie up ( i , j , k ) = up ( i , j , k ) + om23g * ( ugg ( k ) - u0 ( i , j , k )) enddo enddo enddo ! -------------------------------------------- ! special treatment for lowest full level: k=1 ! -------------------------------------------- do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie up ( i , j , kb ) = up ( i , j , kb ) + om23g * ( ugg ( kb ) - u0 ( i , j , kb )) enddo enddo ! if (myid==0) then !   write(*,*) \"up after profforc\",up(3,3,ke) ! end if endif !lcoriol and lprofforc return end subroutine coriolis","tags":"","loc":"proc/coriolis.html"},{"title":"lstend – uDALES","text":"public subroutine lstend() Uses modglobal modfields modmpi proc~~lstend~~UsesGraph proc~lstend lstend module~modmpi modmpi proc~lstend->module~modmpi module~modfields modfields proc~lstend->module~modfields module~modglobal modglobal proc~lstend->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~lstend~~CalledByGraph proc~lstend lstend program~dalesurban DALESURBAN program~dalesurban->proc~lstend Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code lstend Source Code subroutine lstend !-----------------------------------------------------------------| !                                                                 | !*** *lstend*  calculates large-scale tendencies                  | !                                                                 | !      Pier Siebesma   K.N.M.I.     06/01/1995                    | !                                                                 | !     purpose.                                                    | !     --------                                                    | !                                                                 | !     calculates and adds large-scale tendencies due to           | !     large scale advection and subsidence.                       | !                                                                 | !**   interface.                                                  | !     ----------                                                  | !                                                                 | !             *lstend* is called from *program*.                  | !                                                                 | !-----------------------------------------------------------------| use modglobal , only : ib , ie , jb , je , kb , ke , kh , dzh , nsv , lmomsubs use modfields , only : up , vp , thlp , qtp , svp ,& whls , u0av , v0av , thl0av , qt0av , sv0av ,& dudxls , dudyls , dvdxls , dvdyls , dthldxls , dthldyls , dqtdxls , dqtdyls , dqtdtls use modmpi , only : myid implicit none integer k , n real subs_thl , subs_qt , subs_u , subs_v , subs_sv ! if (ltimedep) then !   ! call ls ! end if ! if (myid==0) then !   write(*,*) \"up before lstend\",up(3,3,ke) ! end if ! 1. DETERMINE LARGE SCALE TENDENCIES !    -------------------------------- ! 1.1 lowest model level above surface : only downward component subs_u = 0. subs_v = 0. subs_thl = 0. subs_qt = 0. subs_sv = 0. k = kb if ( whls ( k + 1 ). lt . 0 ) then !neglect effect of mean ascending on tendencies at the lowest full level subs_thl = whls ( k + 1 ) * ( thl0av ( k + 1 ) - thl0av ( k )) / dzh ( k + 1 ) ! tg3315 ils13 bss116 31/07/18 Dales 4.0 multiplies these by 0.5. To reduce subsidence towards the ground? Have removed subs_qt = whls ( k + 1 ) * ( qt0av ( k + 1 ) - qt0av ( k ) ) / dzh ( k + 1 ) if ( lmomsubs ) then subs_u = whls ( k + 1 ) * ( u0av ( k + 1 ) - u0av ( k ) ) / dzh ( k + 1 ) subs_v = whls ( k + 1 ) * ( v0av ( k + 1 ) - v0av ( k ) ) / dzh ( k + 1 ) endif do n = 1 , nsv subs_sv = whls ( k + 1 ) * ( sv0av ( k + 1 , n ) - sv0av ( k , n ) ) / dzh ( k + 1 ) ! svp(2:i1,2:j1,1,n) = svp(2:i1,2:j1,1,n)-subs_sv svp ( ib : ie , jb : je , kb , n ) = svp ( ib : ie , jb : je , kb , n ) - subs_sv enddo endif thlp ( ib : ie , jb : je , k ) = thlp ( ib : ie , jb : je , k ) - u0av ( k ) * dthldxls ( k ) - v0av ( k ) * dthldyls ( k ) - subs_thl qtp ( ib : ie , jb : je , k ) = qtp ( ib : ie , jb : je , k ) - u0av ( k ) * dqtdxls ( k ) - v0av ( k ) * dqtdyls ( k ) - subs_qt + dqtdtls ( k ) up ( ib : ie , jb : je , k ) = up ( ib : ie , jb : je , k ) - u0av ( k ) * dudxls ( k ) - v0av ( k ) * dudyls ( k ) - subs_u vp ( ib : ie , jb : je , k ) = vp ( ib : ie , jb : je , k ) - u0av ( k ) * dvdxls ( k ) - v0av ( k ) * dvdyls ( k ) - subs_v ! 1.2 other model levels twostream do k = kb + 1 , ke if ( whls ( k + 1 ). lt . 0 ) then !downwind scheme for subsidence subs_thl = whls ( k + 1 ) * ( thl0av ( k + 1 ) - thl0av ( k )) / dzh ( k + 1 ) subs_qt = whls ( k + 1 ) * ( qt0av ( k + 1 ) - qt0av ( k )) / dzh ( k + 1 ) do n = 1 , nsv subs_sv = whls ( k + 1 ) * ( sv0av ( k + 1 , n ) - sv0av ( k , n )) / dzh ( k + 1 ) svp ( ib : ie , jb : je , k , n ) = svp ( ib : ie , jb : je , k , n ) - subs_sv enddo if ( lmomsubs ) then subs_u = whls ( k + 1 ) * ( u0av ( k + 1 ) - u0av ( k )) / dzh ( k + 1 ) subs_v = whls ( k + 1 ) * ( v0av ( k + 1 ) - v0av ( k )) / dzh ( k + 1 ) endif else !downwind scheme for mean upward motions subs_thl = whls ( k ) * ( thl0av ( k ) - thl0av ( k - 1 )) / dzh ( k ) subs_qt = whls ( k ) * ( qt0av ( k ) - qt0av ( k - 1 )) / dzh ( k ) do n = 1 , nsv subs_sv = whls ( k ) * ( sv0av ( k , n ) - sv0av ( k - 1 , n )) / dzh ( k ) svp ( ib : ie , jb : je , k , n ) = svp ( ib : ie , jb : je , k , n ) - subs_sv enddo if ( lmomsubs ) then subs_u = whls ( k ) * ( u0av ( k ) - u0av ( k - 1 )) / dzh ( k ) subs_v = whls ( k ) * ( v0av ( k ) - v0av ( k - 1 )) / dzh ( k ) endif endif thlp ( ib : ie , jb : je , k ) = thlp ( ib : ie , jb : je , k ) - u0av ( k ) * dthldxls ( k ) - v0av ( k ) * dthldyls ( k ) - subs_thl qtp ( ib : ie , jb : je , k ) = qtp ( ib : ie , jb : je , k ) - u0av ( k ) * dqtdxls ( k ) - v0av ( k ) * dqtdyls ( k ) - subs_qt + dqtdtls ( k ) up ( ib : ie , jb : je , k ) = up ( ib : ie , jb : je , k ) - u0av ( k ) * dudxls ( k ) - v0av ( k ) * dudyls ( k ) - subs_u vp ( ib : ie , jb : je , k ) = vp ( ib : ie , jb : je , k ) - u0av ( k ) * dvdxls ( k ) - v0av ( k ) * dvdyls ( k ) - subs_v enddo return end subroutine lstend","tags":"","loc":"proc/lstend.html"},{"title":"nudge – uDALES","text":"public subroutine nudge() Uses modglobal modfields modmpi proc~~nudge~~UsesGraph proc~nudge nudge module~modmpi modmpi proc~nudge->module~modmpi module~modfields modfields proc~nudge->module~modfields module~modglobal modglobal proc~nudge->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~nudge~~CalledByGraph proc~nudge nudge program~dalesurban DALESURBAN program~dalesurban->proc~nudge Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code nudge Source Code subroutine nudge use modglobal , only : kb , ke , lmoist , ltempeq , lnudge , tnudge , nnudge , numol , nsv use modfields , only : thlp , qtp , svp , sv0av , thl0av , qt0av use modmpi , only : myid implicit none integer :: k real :: numoli numoli = 1 / numol if ( lnudge . eqv . . false .) return if ( nsv > 0 ) then do k = ke - nnudge , ke svp (:,:, k , 1 ) = svp (:,:, k , 1 ) - ( sv0av ( k , 1 ) - 0. ) / ( tnudge / 2 + ( ke - k ) * tnudge / nnudge ) end do end if if ( ltempeq ) then do k = ke - nnudge , ke thlp (:,:, k ) = thlp (:,:, k ) - ( thl0av ( k ) - 288 ) / ( tnudge / 2 + ( ke - k ) * tnudge / nnudge ) end do end if !ltempeq if ( lmoist ) then do k = ke - nnudge , ke qtp (:,:, k ) = qtp (:,:, k ) - ( qt0av ( k ) - 0. ) / ( tnudge / 2 + ( ke - k ) * tnudge / nnudge ) end do end if !lmoist end subroutine nudge","tags":"","loc":"proc/nudge.html"},{"title":"initmpi – uDALES","text":"public subroutine initmpi() Arguments None Calls proc~~initmpi~~CallsGraph proc~initmpi initmpi mpi_cart_shift mpi_cart_shift proc~initmpi->mpi_cart_shift mpi_cart_create mpi_cart_create proc~initmpi->mpi_cart_create mpi_dims_create mpi_dims_create proc~initmpi->mpi_dims_create mpi_wtime mpi_wtime proc~initmpi->mpi_wtime mpi_comm_size mpi_comm_size proc~initmpi->mpi_comm_size mpi_init mpi_init proc~initmpi->mpi_init mpi_comm_rank mpi_comm_rank proc~initmpi->mpi_comm_rank Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~initmpi~~CalledByGraph proc~initmpi initmpi program~dalesurban DALESURBAN program~dalesurban->proc~initmpi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code initmpi Source Code subroutine initmpi implicit none integer dims ( 1 ) logical periods ( 1 ) integer periods2 ( 1 ) call MPI_INIT ( mpierr ) MY_REAL = MPI_DOUBLE_PRECISION !MPI_REAL8 should be the same.. call MPI_COMM_RANK ( MPI_COMM_WORLD , myid , mpierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , nprocs , mpierr ) ! Specify the # procs in each direction. ! specifying a 0 means that MPI will try to find a useful # procs in ! the corresponding  direction, ! specifying 1 means only 1 processor in this direction, meaning that ! we have in fact a grid of (at most) 2 dimensions left. This is used ! when we want the array index range in 1 particular direction to be ! present on all processors in the grid dims ( 1 ) = 0 ! directions 1 and 2 are chosen periodic periods ( 1 ) = . true . ! Soares 20080115 periods2 ( 1 ) = 1 ! find suitable # procs in each direction call MPI_DIMS_CREATE ( nprocs , 1 , dims , mpierr ) ! create the Cartesian communicator, denoted by the integer comm3d ! BUG - Thijs, Harm !call MPI_CART_CREATE(MPI_COMM_WORLD, 1, dims, periods,.false., & !                    comm3d, ierr ) call MPI_CART_CREATE ( MPI_COMM_WORLD , 1 , dims , periods ,. true ., & comm3d , mpierr ) ! Soares 20080115 !     call MPI_CART_CREATE(MPI_COMM_WORLD, 1, dims, periods2,1, & !                         comm3d, mpierr ) ! Get my processor number in this communicator call MPI_COMM_RANK ( comm3d , myid , mpierr ) ! when applying boundary conditions, we need to know which processors ! are neighbours in all 3 directions ! these are determined with the aid of the MPI routine MPI_CART_SHIFT, call MPI_CART_SHIFT ( comm3d , 0 , 1 , nbrbottom , nbrtop , mpierr ) ! determine some useful MPI datatypes for sending/receiving data write ( cmyid , '(i3.3)' ) myid if ( myid == 0 ) then CPU_program0 = MPI_Wtime () end if write ( * , * ) 'nprocs = ' , nprocs end subroutine initmpi","tags":"","loc":"proc/initmpi.html"},{"title":"exitmpi – uDALES","text":"public subroutine exitmpi() Arguments None Calls proc~~exitmpi~~CallsGraph proc~exitmpi exitmpi mpi_wtime mpi_wtime proc~exitmpi->mpi_wtime mpi_comm_free mpi_comm_free proc~exitmpi->mpi_comm_free mpi_finalize mpi_finalize proc~exitmpi->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~exitmpi~~CalledByGraph proc~exitmpi exitmpi proc~exitmodules exitmodules proc~exitmodules->proc~exitmpi program~dalesurban DALESURBAN program~dalesurban->proc~exitmodules Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code exitmpi Source Code subroutine exitmpi implicit none if ( myid == 0 ) then CPU_program = MPI_Wtime () - CPU_program0 write ( 6 , * ) 'TOTAL CPU time = ' , CPU_program end if call MPI_Comm_free ( comm3d , mpierr ) call MPI_FINALIZE ( mpierr ) end subroutine exitmpi","tags":"","loc":"proc/exitmpi.html"},{"title":"barrou – uDALES","text":"public subroutine barrou() Arguments None Calls proc~~barrou~~CallsGraph proc~barrou barrou mpi_barrier mpi_barrier proc~barrou->mpi_barrier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~barrou~~CalledByGraph proc~barrou barrou proc~all_all_j2 ALL_ALL_j2 proc~all_all_j2->proc~barrou proc~poisr poisr proc~poisr->proc~barrou proc~poisr->proc~all_all_j2 proc~poisson poisson proc~poisson->proc~poisr program~dalesurban DALESURBAN program~dalesurban->proc~poisson Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code barrou Source Code subroutine barrou () implicit none call MPI_BARRIER ( comm3d , mpierr ) return end subroutine barrou","tags":"","loc":"proc/barrou.html"},{"title":"excj – uDALES","text":"public subroutine excj(a, sx, ex, sy, ey, sz, ez) Arguments Type Intent Optional Attributes Name real :: a (sx:ex,sy:ey,sz:ez) integer :: sx integer :: ex integer :: sy integer :: ey integer :: sz integer :: ez Calls proc~~excj~~CallsGraph proc~excj excj mpi_sendrecv mpi_sendrecv proc~excj->mpi_sendrecv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~excj~~CalledByGraph proc~excj excj proc~bcp bcp proc~bcp->proc~excj proc~tderive tderive proc~tderive->proc~bcp proc~poisson poisson proc~poisson->proc~tderive program~dalesurban DALESURBAN program~dalesurban->proc~poisson Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code excj Source Code subroutine excj ( a , sx , ex , sy , ey , sz , ez ) implicit none integer sx , ex , sy , ey , sz , ez real a ( sx : ex , sy : ey , sz : ez ) integer iiget , status ( MPI_STATUS_SIZE ) integer ii , i , k real , allocatable , dimension (:) :: buffj1 , buffj2 , buffj3 , buffj4 iiget = ( ex - sx + 1 ) * ( ez - sz + 1 ) allocate ( buffj1 ( iiget ),& buffj2 ( iiget ),& buffj3 ( iiget ),& buffj4 ( iiget )) if ( nbrtop /= MPI_PROC_NULL ) then do k = sz , ez do i = sx , ex ii = i - sx + 1 + ( k - sz ) * ( ex - sx + 1 ) buffj1 ( ii ) = a ( i , ey - 1 , k ) enddo enddo endif call MPI_SENDRECV ( buffj1 , ii , MY_REAL , nbrtop , 4 , & buffj2 , iiget , MY_REAL , nbrbottom , 4 , & comm3d , status , mpierr ) if ( nbrbottom /= MPI_PROC_NULL ) then do k = sz , ez do i = sx , ex ii = i - sx + 1 + ( k - sz ) * ( ex - sx + 1 ) a ( i , sy , k ) = buffj2 ( ii ) enddo enddo endif !   call barrou() if ( nbrbottom /= MPI_PROC_NULL ) then do k = sz , ez do i = sx , ex ii = i - sx + 1 + ( k - sz ) * ( ex - sx + 1 ) buffj3 ( ii ) = a ( i , sy + 1 , k ) enddo enddo endif call MPI_SENDRECV ( buffj3 , ii , MY_REAL , nbrbottom , 5 , & buffj4 , iiget , MY_REAL , nbrtop , 5 , & comm3d , status , mpierr ) if ( nbrtop /= MPI_PROC_NULL ) then do k = sz , ez do i = sx , ex ii = i - sx + 1 + ( k - sz ) * ( ex - sx + 1 ) a ( i , ey , k ) = buffj4 ( ii ) enddo enddo endif !   call barrou() deallocate ( buffj1 , buffj2 , buffj3 , buffj4 ) return end subroutine excj","tags":"","loc":"proc/excj.html"},{"title":"excjs – uDALES","text":"public subroutine excjs(a, sx, ex, sy, ey, sz, ez, ih, jh) Arguments Type Intent Optional Attributes Name real :: a (sx-ih:ex+ih,sy-jh:ey+jh,sz:ez) integer :: sx integer :: ex integer :: sy integer :: ey integer :: sz integer :: ez integer :: ih integer :: jh Calls proc~~excjs~~CallsGraph proc~excjs excjs mpi_sendrecv mpi_sendrecv proc~excjs->mpi_sendrecv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~excjs~~CalledByGraph proc~excjs excjs proc~bcpup bcpup proc~bcpup->proc~excjs proc~cyclicmj cyclicmj proc~cyclicmj->proc~excjs proc~tkestatsdump tkestatsdump proc~tkestatsdump->proc~excjs proc~closurebc closurebc proc~closurebc->proc~excjs proc~readinletfile readinletfile proc~readinletfile->proc~excjs proc~cyclicqj cyclicqj proc~cyclicqj->proc~excjs proc~cyclichj cyclichj proc~cyclichj->proc~excjs proc~boundary boundary proc~boundary->proc~cyclicmj proc~boundary->proc~cyclicqj proc~boundary->proc~cyclichj proc~inletgennotemp inletgennotemp proc~boundary->proc~inletgennotemp proc~inletgen inletgen proc~boundary->proc~inletgen proc~fillps fillps proc~fillps->proc~bcpup proc~closure closure proc~closure->proc~closurebc proc~inletgennotemp->proc~readinletfile proc~statsdump statsdump proc~statsdump->proc~tkestatsdump proc~inletgen->proc~readinletfile proc~readinitfiles readinitfiles proc~readinitfiles->proc~readinletfile proc~readinitfiles->proc~boundary proc~startup startup proc~startup->proc~readinitfiles proc~subgrid subgrid proc~subgrid->proc~closure proc~poisson poisson proc~poisson->proc~fillps program~dalesurban DALESURBAN program~dalesurban->proc~boundary program~dalesurban->proc~statsdump program~dalesurban->proc~startup program~dalesurban->proc~subgrid program~dalesurban->proc~poisson Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code excjs Source Code subroutine excjs ( a , sx , ex , sy , ey , sz , ez , ih , jh ) implicit none integer sx , ex , sy , ey , sz , ez , ih , jh real a ( sx - ih : ex + ih , sy - jh : ey + jh , sz : ez ) integer status ( MPI_STATUS_SIZE ), iiget integer ii , i , j , k real , allocatable , dimension (:) :: buffj1 , buffj2 , buffj3 , buffj4 iiget = jh * ( ex - sx + 1 + 2 * ih ) * ( ez - sz + 1 ) allocate ( buffj1 ( iiget ),& buffj2 ( iiget ),& buffj3 ( iiget ),& buffj4 ( iiget )) if ( nbrtop /= MPI_PROC_NULL ) then ii = 0 do j = 1 , jh do k = sz , ez do i = sx - ih , ex + ih ii = ii + 1 buffj1 ( ii ) = a ( i , ey - j + 1 , k ) ! tg3315 buffj1 is je-jhc ghost cells on myid enddo enddo enddo endif call MPI_SENDRECV ( buffj1 , ii , MY_REAL , nbrtop , 4 , & buffj2 , iiget , MY_REAL , nbrbottom , 4 , & comm3d , status , mpierr ) ! tg3315 sends this to nbrtop and pulls buffj2 from nbrbottom! send and receive process that is good for executing chain shifts. if ( nbrbottom /= MPI_PROC_NULL ) then ii = 0 do j = 1 , jh do k = sz , ez do i = sx - ih , ex + ih ii = ii + 1 a ( i , sy - j , k ) = buffj2 ( ii ) ! set the previous ghost cells to buffj2 (last cells of nbrbottom I think) enddo enddo enddo endif !   call barrou() ! repeats this process for other way round if ( nbrbottom /= MPI_PROC_NULL ) then ii = 0 do j = 1 , jh do k = sz , ez do i = sx - ih , ex + ih ii = ii + 1 buffj3 ( ii ) = a ( i , sy + j - 1 , k ) enddo enddo enddo endif call MPI_SENDRECV ( buffj3 , ii , MY_REAL , nbrbottom , 5 , & buffj4 , iiget , MY_REAL , nbrtop , 5 , & comm3d , status , mpierr ) if ( nbrtop /= MPI_PROC_NULL ) then ii = 0 do j = 1 , jh do k = sz , ez do i = sx - ih , ex + ih ii = ii + 1 a ( i , ey + j , k ) = buffj4 ( ii ) enddo enddo enddo endif !   call barrou() deallocate ( buffj1 , buffj2 , buffj3 , buffj4 ) return end subroutine excjs","tags":"","loc":"proc/excjs.html"},{"title":"slabsum – uDALES","text":"public subroutine slabsum(aver, ks, kf, var, ib, ie, jb, je, kb, ke, ibs, ies, jbs, jes, kbs, kes) Arguments Type Intent Optional Attributes Name real :: aver (ks:kf) integer :: ks integer :: kf real :: var (ib:ie,jb:je,kb:ke) integer :: ib integer :: ie integer :: jb integer :: je integer :: kb integer :: ke integer :: ibs integer :: ies integer :: jbs integer :: jes integer :: kbs integer :: kes Calls proc~~slabsum~~CallsGraph proc~slabsum slabsum mpi_allreduce mpi_allreduce proc~slabsum->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~slabsum~~CalledByGraph proc~slabsum slabsum proc~inletgennotemp inletgennotemp proc~inletgennotemp->proc~slabsum proc~inletgen inletgen proc~inletgen->proc~slabsum proc~readinitfiles readinitfiles proc~readinitfiles->proc~slabsum proc~boundary boundary proc~readinitfiles->proc~boundary proc~iolet iolet proc~iolet->proc~slabsum proc~startup startup proc~startup->proc~readinitfiles proc~boundary->proc~inletgennotemp proc~boundary->proc~inletgen proc~boundary->proc~iolet program~dalesurban DALESURBAN program~dalesurban->proc~startup program~dalesurban->proc~boundary Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code slabsum Source Code subroutine slabsum ( aver , ks , kf , var , ib , ie , jb , je , kb , ke , ibs , ies , jbs , jes , kbs , kes ) implicit none integer :: ks , kf integer :: ib , ie , jb , je , kb , ke , ibs , ies , jbs , jes , kbs , kes real :: aver ( ks : kf ) real :: var ( ib : ie , jb : je , kb : ke ) real :: averl ( ks : kf ) real :: avers ( ks : kf ) integer :: k averl = 0. avers = 0. do k = kbs , kes averl ( k ) = sum ( var ( ibs : ies , jbs : jes , k )) enddo call MPI_ALLREDUCE ( averl , avers , kf - ks + 1 , MY_REAL , & MPI_SUM , comm3d , mpierr ) aver = aver + avers return end subroutine slabsum","tags":"","loc":"proc/slabsum.html"},{"title":"avexy_ibm – uDALES","text":"public subroutine avexy_ibm(aver, var, ib, ie, jb, je, kb, ke, ih, jh, kh, II, IIs, lnan) Arguments Type Intent Optional Attributes Name real :: aver (kb:ke+kh) real :: var (ib:ie,jb:je,kb:ke+kh) integer :: ib integer :: ie integer :: jb integer :: je integer :: kb integer :: ke integer :: ih integer :: jh integer :: kh integer :: II (ib:ie,jb:je,kb:ke+kh) integer :: IIs (kb:ke+kh) logical :: lnan Calls proc~~avexy_ibm~~CallsGraph proc~avexy_ibm avexy_ibm mpi_allreduce mpi_allreduce proc~avexy_ibm->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code avexy_ibm Source Code subroutine avexy_ibm ( aver , var , ib , ie , jb , je , kb , ke , ih , jh , kh , II , IIs , lnan ) implicit none integer :: ib , ie , jb , je , kb , ke , ih , jh , kh real :: aver ( kb : ke + kh ) real :: var ( ib : ie , jb : je , kb : ke + kh ) integer :: II ( ib : ie , jb : je , kb : ke + kh ) integer :: IIs ( kb : ke + kh ) integer :: IId ( kb : ke + kh ) real :: averl ( kb : ke + kh ) real :: avers ( kb : ke + kh ) integer :: k logical :: lnan averl = 0. avers = 0. do k = kb , ke + kh averl ( k ) = sum ( var ( ib : ie , jb : je , k ) * II ( ib : ie , jb : je , k )) enddo IId = IIs ! tg3315 22.03.19 - if not calculating stats and all blocks on lowest layer... ! should not be necessary but value at kb is used in modthermo so reasonable value must ! be assigned. Potentially should leave as before and only account for in modthermo... if ((. not . lnan ) . and . ( IId ( kb ) == 0 )) then averl ( kb ) = sum ( var ( ib : ie , jb : je , kb )) IId ( kb ) = IId ( ke ) end if call MPI_ALLREDUCE ( averl , avers , ke + kh - kb + 1 , MY_REAL , & MPI_SUM , comm3d , mpierr ) where ( IId == 0 ) aver = - 99 9. elsewhere aver = avers / IId endwhere return end subroutine avexy_ibm","tags":"","loc":"proc/avexy_ibm.html"},{"title":"slabsumi – uDALES","text":"public subroutine slabsumi(aver, iis, iif, var, ib, ie, jb, je, kb, ke, ibs, ies, jbs, jes, kbs, kes) Arguments Type Intent Optional Attributes Name real :: aver (iis:iif) integer :: iis integer :: iif real :: var (ib:ie,jb:je,kb:ke) integer :: ib integer :: ie integer :: jb integer :: je integer :: kb integer :: ke integer :: ibs integer :: ies integer :: jbs integer :: jes integer :: kbs integer :: kes Calls proc~~slabsumi~~CallsGraph proc~slabsumi slabsumi mpi_allreduce mpi_allreduce proc~slabsumi->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~slabsumi~~CalledByGraph proc~slabsumi slabsumi proc~inlettop inlettop proc~inlettop->proc~slabsumi proc~boundary boundary proc~boundary->proc~inlettop proc~readinitfiles readinitfiles proc~readinitfiles->proc~boundary program~dalesurban DALESURBAN program~dalesurban->proc~boundary proc~startup startup program~dalesurban->proc~startup proc~startup->proc~readinitfiles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code slabsumi Source Code subroutine slabsumi ( aver , iis , iif , var , ib , ie , jb , je , kb , ke , ibs , ies , jbs , jes , kbs , kes ) implicit none integer :: iis , iif integer :: ib , ie , jb , je , kb , ke , ibs , ies , jbs , jes , kbs , kes real :: aver ( iis : iif ) real :: var ( ib : ie , jb : je , kb : ke ) real :: averl ( iis : iif ) real :: avers ( iis : iif ) integer :: i averl = 0. avers = 0. do i = ibs , ies averl ( i ) = sum ( var ( i , jbs : jes , kbs : kes )) enddo call MPI_ALLREDUCE ( averl , avers , iif - iis + 1 , MY_REAL , & MPI_SUM , comm3d , mpierr ) aver = aver + avers return end subroutine slabsumi","tags":"","loc":"proc/slabsumi.html"},{"title":"avey_ibm – uDALES","text":"public subroutine avey_ibm(aver, var, ib, ie, jb, je, kb, ke, II, IIt) Arguments Type Intent Optional Attributes Name real :: aver (ib:ie,kb:ke) real :: var (ib:ie,jb:je,kb:ke) integer :: ib integer :: ie integer :: jb integer :: je integer :: kb integer :: ke integer :: II (ib:ie,jb:je,kb:ke) integer :: IIt (ib:ie,kb:ke) Contents Source Code avey_ibm Source Code subroutine avey_ibm ( aver , var , ib , ie , jb , je , kb , ke , II , IIt ) implicit none integer :: ib , ie , jb , je , kb , ke real :: aver ( ib : ie , kb : ke ) real :: avero ( ib : ie , kb : ke ) real :: var ( ib : ie , jb : je , kb : ke ) integer :: II ( ib : ie , jb : je , kb : ke ) integer :: IIt ( ib : ie , kb : ke ) logical :: lytdump , lnan avero = 0. aver = 0. avero = sum ( var ( ib : ie , jb : je , kb : ke ) * II ( ib : ie , jb : je , kb : ke ), DIM = 2 ) call MPI_ALLREDUCE ( avero ( ib : ie , kb : ke ), aver ( ib : ie , kb : ke ), ( ke - kb + 1 ) * ( ie - ib + 1 ), MY_REAL , MPI_SUM , comm3d , mpierr ) where ( IIt == 0 ) aver = - 99 9. elsewhere aver = aver / IIt endwhere end subroutine avey_ibm","tags":"","loc":"proc/avey_ibm.html"},{"title":"sumy_ibm – uDALES","text":"public subroutine sumy_ibm(sumy, var, ib, ie, jb, je, kb, ke, II) Arguments Type Intent Optional Attributes Name real :: sumy (ib:ie,kb:ke) real :: var (ib:ie,jb:je,kb:ke) integer :: ib integer :: ie integer :: jb integer :: je integer :: kb integer :: ke integer :: II (ib:ie,jb:je,kb:ke) Contents Source Code sumy_ibm Source Code subroutine sumy_ibm ( sumy , var , ib , ie , jb , je , kb , ke , II ) ! This routine sums up a variable over the y direction, ! only including the fluid cells. implicit none integer :: ib , ie , jb , je , kb , ke real :: sumy ( ib : ie , kb : ke ) real :: sumproc ( ib : ie , kb : ke ) real :: var ( ib : ie , jb : je , kb : ke ) integer :: II ( ib : ie , jb : je , kb : ke ) sumproc = 0. sumy = 0. sumproc = sum ( var ( ib : ie , jb : je , kb : ke ) * II ( ib : ie , jb : je , kb : ke ), DIM = 2 ) call MPI_ALLREDUCE ( sumproc ( ib : ie , kb : ke ), sumy ( ib : ie , kb : ke ), ( ke - kb + 1 ) * ( ie - ib + 1 ), MY_REAL , MPI_SUM , comm3d , mpierr ) end subroutine sumy_ibm","tags":"","loc":"proc/sumy_ibm.html"},{"title":"initchecksim – uDALES","text":"public subroutine initchecksim() Uses modglobal modmpi proc~~initchecksim~~UsesGraph proc~initchecksim initchecksim module~modmpi modmpi proc~initchecksim->module~modmpi module~modglobal modglobal proc~initchecksim->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~initchecksim~~CallsGraph proc~initchecksim initchecksim mpi_bcast mpi_bcast proc~initchecksim->mpi_bcast Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~initchecksim~~CalledByGraph proc~initchecksim initchecksim program~dalesurban DALESURBAN program~dalesurban->proc~initchecksim Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code initchecksim Source Code subroutine initchecksim use modglobal , only : ifnamopt , fname_options , dtmax , ladaptive , btime use modmpi , only : myid , my_real , comm3d , mpierr implicit none integer :: ierr namelist / NAMCHECKSIM / & tcheck if ( myid == 0 ) then open ( ifnamopt , file = fname_options , status = 'old' , iostat = ierr ) read ( ifnamopt , NAMCHECKSIM , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions NAMCHECKSIM' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif write ( 6 , NAMCHECKSIM ) close ( ifnamopt ) if ((. not . ladaptive ) . and . ( tcheck < dtmax )) then tcheck = dtmax end if end if call MPI_BCAST ( tcheck , 1 , MY_REAL , 0 , comm3d , mpierr ) !    itcheck = floor(tcheck/tres) tnext = tcheck + btime end subroutine initchecksim","tags":"","loc":"proc/initchecksim.html"},{"title":"checksim – uDALES","text":"public subroutine checksim() Uses modglobal modmpi proc~~checksim~~UsesGraph proc~checksim checksim module~modmpi modmpi proc~checksim->module~modmpi module~modglobal modglobal proc~checksim->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~checksim~~CallsGraph proc~checksim checksim proc~calcdiffnr calcdiffnr proc~checksim->proc~calcdiffnr proc~chkdiv chkdiv proc~checksim->proc~chkdiv proc~calccourant calccourant proc~checksim->proc~calccourant mpi_allreduce mpi_allreduce proc~calcdiffnr->mpi_allreduce proc~chkdiv->mpi_allreduce proc~calccourant->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~checksim~~CalledByGraph proc~checksim checksim program~dalesurban DALESURBAN program~dalesurban->proc~checksim Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code checksim Source Code subroutine checksim use modglobal , only : timee , rk3step , dt_lim , dt use modmpi , only : myid implicit none character ( 20 ) :: timeday if ( timee == 0.0 ) return if ( rk3step /= 3 ) return dtmn = dtmn + dt ; ndt = ndt + 1. if ( timee < tnext ) return tnext = tnext + tcheck dtmn = dtmn / ndt if ( myid == 0 ) then call date_and_time ( time = timeday ) write ( * , * ) '=================================================================' write ( * , '(3A,F9.2,A,F12.9)' ) 'Time of Day: ' , timeday ( 1 : 10 ), '    Time of Simulation: ' , timee , '    dt: ' , dtmn end if call calccourant call calcdiffnr call chkdiv dtmn = 0. ndt = 0. end subroutine checksim","tags":"","loc":"proc/checksim.html"},{"title":"calccourant – uDALES","text":"private subroutine calccourant() Uses modglobal modfields modmpi proc~~calccourant~~UsesGraph proc~calccourant calccourant module~modmpi modmpi proc~calccourant->module~modmpi module~modfields modfields proc~calccourant->module~modfields module~modglobal modglobal proc~calccourant->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~calccourant~~CallsGraph proc~calccourant calccourant mpi_allreduce mpi_allreduce proc~calccourant->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~calccourant~~CalledByGraph proc~calccourant calccourant proc~checksim checksim proc~checksim->proc~calccourant program~dalesurban DALESURBAN program~dalesurban->proc~checksim Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code calccourant Source Code subroutine calccourant use modglobal , only : ib , ie , jb , je , kb , ke , kh , dxhi , dyi , dzhi , dt , timee use modfields , only : um , vm , wm use modmpi , only : myid , comm3d , mpierr , mpi_max , my_real implicit none real :: courtotl , courtot integer :: i , j , k courtotl = 0.0 courtot = 0.0 do k = kb , ke do j = jb , je do i = ib , ie courtotl = max ( courtotl ,( um ( i , j , k ) * dxhi ( i ) + vm ( i , j , k ) * dyi + wm ( i , j , k ) * dzhi ( k )) * dtmn ) end do end do end do call MPI_ALLREDUCE ( courtotl , courtot , 1 , MY_REAL , MPI_MAX , comm3d , mpierr ) if ( myid == 0 ) then write ( * , '(A,ES10.2)' ) 'Courant numbers (x,y,z,tot):' , courtot end if return end subroutine calccourant","tags":"","loc":"proc/calccourant.html"},{"title":"calcdiffnr – uDALES","text":"private subroutine calcdiffnr() Uses modglobal modsubgriddata modmpi proc~~calcdiffnr~~UsesGraph proc~calcdiffnr calcdiffnr module~modmpi modmpi proc~calcdiffnr->module~modmpi module~modsubgriddata modsubgriddata proc~calcdiffnr->module~modsubgriddata module~modglobal modglobal proc~calcdiffnr->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~calcdiffnr~~CallsGraph proc~calcdiffnr calcdiffnr mpi_allreduce mpi_allreduce proc~calcdiffnr->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~calcdiffnr~~CalledByGraph proc~calcdiffnr calcdiffnr proc~checksim checksim proc~checksim->proc~calcdiffnr program~dalesurban DALESURBAN program~dalesurban->proc~checksim Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code calcdiffnr Source Code subroutine calcdiffnr use modglobal , only : ib , ie , jb , je , kb , ke , kh , dxh2i , dy2i , dzh , dt , timee use modsubgriddata , only : ekm , ekh use modmpi , only : myid , comm3d , mpierr , mpi_max , my_real implicit none real diffnrtotl , diffnrtot integer :: i , j , k diffnrtotl = 0. diffnrtot = 0. do k = kb , ke do j = jb , je do i = ib , ie !      diffnrtotl = max(diffnrtotl,  ekm(i,j,k)*(1/dzh(k)**2 + dxh2i(i) + dy2i)*dtmn )  ! or should I interpolate ekm to the correct position? diffnrtotl = max ( diffnrtotl , ekm ( i , j , k ) * ( 1 / dzh ( k ) ** 2 + dxh2i ( i ) + dy2i ) * dtmn , & ekh ( i , j , k ) * ( 1 / dzh ( k ) ** 2 + dxh2i ( i ) + dy2i ) * dtmn ) ! or should I interpolate ekm to the correct position? end do end do end do call MPI_ALLREDUCE ( diffnrtotl , diffnrtot , 1 , MY_REAL , MPI_MAX , comm3d , mpierr ) if ( myid == 0 ) then write ( 6 , '(A,ES10.2)' ) 'Diffusion number:' , diffnrtot end if return end subroutine calcdiffnr","tags":"","loc":"proc/calcdiffnr.html"},{"title":"calcreyn – uDALES","text":"private subroutine calcreyn() Uses modglobal modfields modmpi modsubgriddata proc~~calcreyn~~UsesGraph proc~calcreyn calcreyn module~modmpi modmpi proc~calcreyn->module~modmpi module~modfields modfields proc~calcreyn->module~modfields module~modsubgriddata modsubgriddata proc~calcreyn->module~modsubgriddata module~modglobal modglobal proc~calcreyn->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~calcreyn~~CallsGraph proc~calcreyn calcreyn mpi_allreduce mpi_allreduce proc~calcreyn->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code calcreyn Source Code subroutine calcreyn use modglobal , only : ib , ie , jb , je , ke , kb , dy , dxh , dzh use modfields , only : u0 , v0 , w0 use modmpi , only : myid , comm3d , mpi_sum , mpi_max , my_real , mpierr use modsubgriddata , only : ekm , ekh implicit none real reyntotl , reyntot integer :: i , j , k reyntotl = 0. reyntot = 0. do k = kb , ke do j = jb , je do i = ib , ie reyntotl = max ( reyntotl , u0 ( i , j , k ) * dxh ( i ) / ekm ( i , j , k ), v0 ( i , j , k ) * dy / ekm ( i , j , k ), & w0 ( i , j , k ) * dzh ( k ) / ekm ( i , j , k )) ! or should I interpolate ekm to the correct position? end do end do end do call MPI_ALLREDUCE ( reyntotl , reyntot , 1 , MY_REAL , MPI_MAX , comm3d , mpierr ) if ( myid == 0 ) then write ( 6 , '(A,ES10.2)' ) 'Cell Reynolds number:' , reyntot end if end subroutine calcreyn","tags":"","loc":"proc/calcreyn.html"},{"title":"chkdiv – uDALES","text":"private subroutine chkdiv() Uses modglobal modfields modmpi proc~~chkdiv~~UsesGraph proc~chkdiv chkdiv module~modmpi modmpi proc~chkdiv->module~modmpi module~modfields modfields proc~chkdiv->module~modfields module~modglobal modglobal proc~chkdiv->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~chkdiv~~CallsGraph proc~chkdiv chkdiv mpi_allreduce mpi_allreduce proc~chkdiv->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~chkdiv~~CalledByGraph proc~chkdiv chkdiv proc~checksim checksim proc~checksim->proc~chkdiv program~dalesurban DALESURBAN program~dalesurban->proc~checksim Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code chkdiv Source Code subroutine chkdiv use modglobal , only : ib , ie , jb , je , ke , kb , dxf , dxfi , dy , dzf use modfields , only : u0 , v0 , w0 !,divergentie use modmpi , only : myid , comm3d , mpi_sum , mpi_max , my_real , mpierr implicit none real div , divmax , divtot real divmaxl , divtotl integer i , j , k divmax = 0. divtot = 0. divmaxl = 0. divtotl = 0. do k = kb , ke do j = jb , je do i = ib , ie div = & ( u0 ( i + 1 , j , k ) - u0 ( i , j , k ) ) * dxfi ( i ) + & ( v0 ( i , j + 1 , k ) - v0 ( i , j , k ) ) / dy + & ( w0 ( i , j , k + 1 ) - w0 ( i , j , k ) ) / dzf ( k ) !      divergentie(i,j,k)=div divmaxl = max ( divmaxl , abs ( div )) divtotl = divtotl + div * dxf ( i ) * dy * dzf ( k ) end do end do end do call MPI_ALLREDUCE ( divtotl , divtot , 1 , MY_REAL , & MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( divmaxl , divmax , 1 , MY_REAL , & MPI_MAX , comm3d , mpierr ) if ( myid == 0 ) then write ( 6 , '(A,2ES11.2)' ) 'divmax, divtot = ' , divmax , divtot end if return end subroutine chkdiv","tags":"","loc":"proc/chkdiv.html"},{"title":"initfields – uDALES","text":"public subroutine initfields() Uses modglobal proc~~initfields~~UsesGraph proc~initfields initfields module~modglobal modglobal proc~initfields->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~initfields~~CalledByGraph proc~initfields initfields proc~startup startup proc~startup->proc~initfields program~dalesurban DALESURBAN program~dalesurban->proc~startup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code initfields Source Code subroutine initfields use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , nsv , jtot , imax , jmax , kmax ,& ihc , jhc , khc !, iadv_kappa,iadv_sv ! Allocation of prognostic variables implicit none allocate ( worksave ( 2 * imax * jmax * kmax )) allocate ( um ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( vm ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( wm ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( thlm ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( e12m ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qtm ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( u0 ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( v0 ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( w0 ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( pres0 ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( thl0 ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( thl0h ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qt0h ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( e120 ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qt0 ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( ql0 ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( up ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( vp ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( wp ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( thlp ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( e12p ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( qtp ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( svm ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb - khc : ke + khc , nsv )) allocate ( sv0 ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb - khc : ke + khc , nsv )) allocate ( svp ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc , nsv )) allocate ( svpp ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc , 1 )) ! Allocation of diagnostic variables allocate ( mindist ( ib : ie , jb : je , kb : ke )) allocate ( thv0h ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( whls ( kb : ke + kh )) allocate ( presf ( kb : ke + kh )) allocate ( presh ( kb : ke + kh )) allocate ( exnf ( kb : ke + kh )) allocate ( exnh ( kb : ke + kh )) allocate ( thvf ( kb : ke + kh )) allocate ( thvh ( kb : ke + kh )) allocate ( rhof ( kb : ke + kh )) allocate ( qt0av ( kb : ke + kh )) allocate ( ql0av ( kb : ke + kh )) allocate ( thl0av ( kb : ke + kh )) allocate ( u0av ( kb : ke + kh )) allocate ( v0av ( kb : ke + kh )) allocate ( ug ( kb : ke + kh )) allocate ( vg ( kb : ke + kh )) allocate ( pgx ( kb : ke + kh )) allocate ( pgy ( kb : ke + kh )) allocate ( dpdxl ( kb : ke + kh )) allocate ( dpdyl ( kb : ke + kh )) allocate ( dthldxls ( kb : ke + kh )) allocate ( dthldyls ( kb : ke + kh )) allocate ( dqtdxls ( kb : ke + kh )) allocate ( dqtdyls ( kb : ke + kh )) allocate ( dqtdtls ( kb : ke + kh )) allocate ( dudxls ( kb : ke + kh )) allocate ( dudyls ( kb : ke + kh )) allocate ( dvdxls ( kb : ke + kh )) allocate ( dvdyls ( kb : ke + kh )) allocate ( wfls ( kb : ke + kh )) allocate ( ql0h ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( dthvdz ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( thlprof ( kb : ke + kh )) allocate ( qtprof ( kb : ke + kh )) allocate ( qlprof ( kb : ke + kh )) allocate ( uprof ( kb : ke + kh )) allocate ( vprof ( kb : ke + kh )) allocate ( e12prof ( kb : ke + kh )) allocate ( sv0av ( kb : ke + khc , nsv )) allocate ( svprof ( kb : ke + kh , nsv )) allocate ( thlpcar ( kb : ke + kh )) allocate ( uout ( kb : ke )) ! height average outlet velocity (used in convective outflow BC) allocate ( vout ( kb : ke )) allocate ( wout ( ib : ie )) ! j -averaged top velocity allocate ( friction ( ib : ie )) ! line-averaged (along j) skin friction allocate ( momthick ( ib : ie )) ! line-averaged (along j) momentum thickness allocate ( displthick ( ib : ie )) ! line-averaged (along j) displacement thickness allocate ( SW_up_TOA ( ib - ih : ie + ih , jb - jh : je + jh )) allocate ( SW_dn_TOA ( ib - ih : ie + ih , jb - jh : je + jh )) allocate ( LW_up_TOA ( ib - ih : ie + ih , jb - jh : je + jh )) allocate ( LW_dn_TOA ( ib - ih : ie + ih , jb - jh : je + jh )) ! allocate averaged variables allocate ( uav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( vav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( wav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( thlav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qtav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qlav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( presav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( svav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh , 1 : nsv )) allocate ( viscratioav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( IIc ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc )) allocate ( IIu ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc )) allocate ( IIv ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc )) allocate ( IIw ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc )) allocate ( IIuw ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc )) allocate ( IIvw ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc )) allocate ( IIuv ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc )) allocate ( IIct ( ib : ie , kb : ke )) allocate ( IIwt ( ib : ie , kb : ke )) allocate ( IIuwt ( ib : ie , kb : ke )) allocate ( IIut ( ib : ie , kb : ke )) allocate ( IIvt ( ib : ie , kb : ke )) allocate ( IIcs ( kb : ke + khc )) allocate ( IIus ( kb : ke + khc )) allocate ( IIvs ( kb : ke + khc )) allocate ( IIws ( kb : ke + khc )) allocate ( IIuws ( kb : ke + khc )) allocate ( IIvws ( kb : ke + khc )) allocate ( IIuvs ( kb : ke + khc )) allocate ( uyt ( ib : ie , kb : ke )) allocate ( uytik ( ib : ie , kb : ke )) allocate ( vyt ( ib : ie , kb : ke )) allocate ( wyt ( ib : ie , kb : ke )) allocate ( wytik ( ib : ie , kb : ke )) allocate ( thlyt ( ib : ie , kb : ke )) allocate ( qtyt ( ib : ie , kb : ke )) allocate ( thlytk ( ib : ie , kb : ke )) allocate ( sca1yt ( ib : ie , kb : ke )) allocate ( sca2yt ( ib : ie , kb : ke )) allocate ( sca3yt ( ib : ie , kb : ke )) allocate ( usgsyt ( ib : ie , kb : ke )) allocate ( thlsgsyt ( ib : ie , kb : ke )) allocate ( qtsgsyt ( ib : ie , kb : ke )) allocate ( wsgsyt ( ib : ie , kb : ke )) allocate ( sv1sgsyt ( ib : ie , kb : ke )) allocate ( sv2sgsyt ( ib : ie , kb : ke )) allocate ( sv3sgsyt ( ib : ie , kb : ke )) allocate ( uxyt ( kb : ke + kh )) allocate ( vxyt ( kb : ke + kh )) allocate ( wxyt ( kb : ke + kh )) allocate ( thlxyt ( kb : ke + kh )) allocate ( qtxyt ( kb : ke + kh )) allocate ( pxyt ( kb : ke + kh )) allocate ( usgsxyt ( kb : ke + kh )) allocate ( thlsgsxyt ( kb : ke + kh )) allocate ( vsgsxyt ( kb : ke + kh )) allocate ( uwtik ( ib : ie , jb : je , kb : ke + kh )) allocate ( wthltk ( ib : ie , jb : je , kb : ke + kh )) allocate ( wqttk ( ib : ie , jb : je , kb : ke + kh )) allocate ( thlthlt ( ib : ie , jb : je , kb : ke + kh )) allocate ( qtqtt ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv1sv1t ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv2sv2t ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv3sv3t ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv4sv4t ( ib : ie , jb : je , kb : ke + kh )) ! allocate(sv1max(ib:ie,jb:je,kb:ke+kh)) ! allocate(sv2max(ib:ie,jb:je,kb:ke+kh)) ! allocate(sv3max(ib:ie,jb:je,kb:ke+kh)) ! allocate(sv4max(ib:ie,jb:je,kb:ke+kh)) allocate ( PSSt ( ib : ie , jb : je , kb : ke + kh )) allocate ( uutc ( ib : ie , jb : je , kb : ke + kh )) allocate ( vvtc ( ib : ie , jb : je , kb : ke + kh )) allocate ( wwtc ( ib : ie , jb : je , kb : ke + kh )) allocate ( vwtjk ( ib : ie , jb : je , kb : ke + kh )) allocate ( uvtij ( ib : ie , jb : je , kb : ke + kh )) allocate ( utik ( ib : ie , jb : je , kb : ke + kh )) allocate ( wtik ( ib : ie , jb : je , kb : ke + kh )) allocate ( vtjk ( ib : ie , jb : je , kb : ke + kh )) allocate ( wtjk ( ib : ie , jb : je , kb : ke + kh )) allocate ( utij ( ib : ie , jb : je , kb : ke + kh )) allocate ( vtij ( ib : ie , jb : je , kb : ke + kh )) allocate ( wmt ( ib : ie , jb : je , kb : ke + kh )) allocate ( thltk ( ib : ie , jb : je , kb : ke + kh )) allocate ( qttk ( ib : ie , jb : je , kb : ke + kh )) allocate ( thlt ( ib : ie , jb : je , kb : ke + kh )) allocate ( utc ( ib : ie , jb : je , kb : ke + kh )) allocate ( vtc ( ib : ie , jb : je , kb : ke + kh )) allocate ( wtc ( ib : ie , jb : je , kb : ke + kh )) allocate ( umt ( ib : ie , jb : je , kb : ke + kh )) allocate ( vmt ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv1t ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv2t ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv3t ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv4t ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv1tk ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv2tk ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv3tk ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv4tk ( ib : ie , jb : je , kb : ke + kh )) allocate ( wsv1tk ( ib : ie , jb : je , kb : ke + kh )) allocate ( wsv2tk ( ib : ie , jb : je , kb : ke + kh )) allocate ( wsv3tk ( ib : ie , jb : je , kb : ke + kh )) allocate ( wsv4tk ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv1sgst ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv2sgst ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv3sgst ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv4sgst ( ib : ie , jb : je , kb : ke + kh )) allocate ( qtt ( ib : ie , jb : je , kb : ke + kh )) allocate ( pt ( ib : ie , jb : je , kb : ke + kh )) allocate ( slice ( ib : ie , jb : je )) allocate ( slice2 ( ib : ie , jb : je )) allocate ( slice3 ( ib : ie , jb : je )) allocate ( slice4 ( ib : ie , jb : je )) allocate ( slice5 ( ib : ie , jb : je )) allocate ( slice6 ( ib : ie , jb : je )) allocate ( slice7 ( ib : ie , jb : je )) allocate ( slice8 ( ib : ie , jb : je )) allocate ( scar ( ib : ie , jb : jtot )) allocate ( scarl ( ib : ie , jb : je )) allocate ( thl2av ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( ql2av ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qt2av ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( sv2av ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh , 1 : nsv )) allocate ( umint ( ib : ie , jb : je , kb : ke )) allocate ( vmint ( ib : ie , jb : je , kb : ke )) allocate ( wmint ( ib : ie , jb : je , kb : ke )) allocate ( uuav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( vvav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( wwav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( uvav ( ib : ie + ih , jb : je + jh , kb : ke )) allocate ( uwav ( ib : ie + ih , jb : je , kb : ke + kh )) allocate ( vwav ( ib : ie , jb : je + jh , kb : ke + kh )) allocate ( thluav ( ib : ie + ih , jb : je , kb : ke )) allocate ( thlvav ( ib : ie , jb : je + jh , kb : ke )) allocate ( thlwav ( ib : ie , jb : je , kb : ke + kh )) allocate ( thlthlav ( ib : ie , jb : je , kb : ke + kh )) allocate ( qluav ( ib : ie + ih , jb : je , kb : ke )) allocate ( qlvav ( ib : ie , jb : je + jh , kb : ke )) allocate ( qlwav ( ib : ie , jb : je , kb : ke + kh )) allocate ( qtuav ( ib : ie + ih , jb : je , kb : ke )) allocate ( qtvav ( ib : ie , jb : je + jh , kb : ke )) allocate ( qtwav ( ib : ie , jb : je , kb : ke + kh )) allocate ( svuav ( ib : ie + ih , jb : je , kb : ke , 1 : nsv )) allocate ( svvav ( ib : ie , jb : je + jh , kb : ke , 1 : nsv )) allocate ( svwav ( ib : ie , jb : je , kb : ke + kh , 1 : nsv )) ! <x'x> ( = <xx> -<x><x> ) allocate ( upupav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( vpvpav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( wpwpav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( upvpav ( ib : ie + ih , jb : je + jh , kb : ke )) allocate ( upwpav ( ib : ie + ih , jb : je , kb : ke + kh )) allocate ( vpwpav ( ib : ie , jb : je + jh , kb : ke + kh )) allocate ( thlpthlpav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( thlpupav ( ib : ie + ih , jb : je , kb : ke )) allocate ( thlpvpav ( ib : ie , jb : je + jh , kb : ke )) allocate ( thlpwpav ( ib : ie , jb : je , kb : ke + kh )) allocate ( qlpqlpav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qlpupav ( ib : ie + ih , jb : je , kb : ke )) allocate ( qlpvpav ( ib : ie , jb : je + jh , kb : ke )) allocate ( qlpwpav ( ib : ie , jb : je , kb : ke + kh )) allocate ( qtpqtpav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qtpupav ( ib : ie + ih , jb : je , kb : ke )) allocate ( qtpvpav ( ib : ie , jb : je + jh , kb : ke )) allocate ( qtpwpav ( ib : ie , jb : je , kb : ke + kh )) allocate ( svpsvpav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh , 1 : nsv )) allocate ( svpupav ( ib : ie + ih , jb : je , kb : ke , 1 : nsv )) allocate ( svpvpav ( ib : ie , jb : je + jh , kb : ke , 1 : nsv )) allocate ( svpwpav ( ib : ie , jb : je , kb : ke + kh , 1 : nsv )) ! Subgrid allocate ( uusgsav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( vvsgsav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( wwsgsav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( uwsgsav ( ib : ie + ih , jb : je , kb : ke + kh )) allocate ( thlusgsav ( ib : ie + ih , jb : je , kb : ke )) allocate ( thlwsgsav ( ib : ie , jb : je , kb : ke + kh )) allocate ( qlusgsav ( ib : ie + ih , jb : je , kb : ke )) allocate ( qlwsgsav ( ib : ie , jb : je , kb : ke + kh )) allocate ( qtusgsav ( ib : ie + ih , jb : je , kb : ke )) allocate ( qtwsgsav ( ib : ie , jb : je , kb : ke + kh )) allocate ( tkesgsav ( ib : ie , jb : je , kb : ke )) allocate ( svusgsav ( ib : ie + ih , jb : je , kb : ke , 1 : nsv )) allocate ( svwsgsav ( ib : ie , jb : je , kb : ke + kh , 1 : nsv )) allocate ( nusgsav ( ib : ie , jb : je , kb : ke )) ! resolved dissipation allocate ( strain2av ( ib : ie , jb : je , kb : ke )) allocate ( disssgsav ( ib : ie , jb : je , kb : ke )) ! TKE budget terms allocate ( tvmx ( ib : ie + 1 , jb : je , kb : ke )) allocate ( tvmy ( ib : ie , jb - 1 : je + 1 , kb : ke )) allocate ( tvmz ( ib : ie , jb : je , kb : ke + 1 )) allocate ( tpm ( ib : ie , jb : je , kb : ke )) allocate ( ttmx ( ib : ie + 1 , jb : je , kb : ke )) allocate ( ttmy ( ib : ie , jb - 1 : je + 1 , kb : ke )) allocate ( ttmz ( ib : ie , jb : je , kb : ke + 1 )) allocate ( tsgsmx1 ( ib : ie + 1 , jb : je , kb : ke )) allocate ( tsgsmy1 ( ib : ie , jb - 1 : je + 1 , kb : ke )) allocate ( tsgsmz1 ( ib : ie , jb : je , kb : ke + 1 )) allocate ( tsgsmx2 ( ib : ie + 1 , jb : je , kb : ke )) allocate ( tsgsmy2 ( ib : ie , jb - 1 : je + 1 , kb : ke )) allocate ( tsgsmz2 ( ib : ie , jb : je , kb : ke + 1 )) allocate ( t_pav ( ib : ie , jb : je , kb : ke )) allocate ( t_vav ( ib : ie , jb : je , kb : ke )) allocate ( t_tav ( ib : ie , jb : je , kb : ke )) allocate ( t_sgsav ( ib : ie , jb : je , kb : ke )) allocate ( p_tav ( ib : ie , jb : je , kb : ke )) allocate ( p_bav ( ib : ie , jb : je , kb : ke )) allocate ( d_sgsav ( ib : ie , jb : je , kb : ke )) allocate ( tkeadv ( ib : ie , jb : je , kb : ke )) allocate ( t_p ( kb : ke )) allocate ( t_v ( kb : ke )) allocate ( t_t ( kb : ke )) allocate ( t_sgs ( kb : ke )) allocate ( p_t ( kb : ke )) allocate ( p_b ( kb : ke )) allocate ( d_sgs ( kb : ke )) allocate ( adv ( kb : ke )) ! allocate wall shear-stress terms (immersed boundaries) allocate ( shear ( ib - 1 : ie + 1 , jb - 1 : je + 1 , kb - 1 : ke + 1 , 0 : 12 )) ! halo is set to 1 !     allocate(shear(ib:ie,jb-1:je+1,kb:ke,12) allocate ( momfluxb ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) !  write(*,*) \"allocate momfluxb, indeces:\",ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh allocate ( tfluxb ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qfluxb ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( cth ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) momfluxb = 0. ; tfluxb = 0. ; qfluxb = 0. ; cth = 0. allocate ( wall ( ib : ie , jb : je , kb : ke , 5 )) ! um = 0. ; u0 = 0. ; up = 0. vm = 0. ; v0 = 0. ; vp = 0. wm = 0. ; w0 = 0. ; wp = 0. pres0 = 0. ; thlm = 0. ; thl0 = 0. ; thlp = 0. qtm = 0. ; qt0 = 0. ; qtp = 0. e12m = 0. ; e120 = 0. ; e12p = 0. svm = 0. ; sv0 = 0. ; svp = 0. ; svpp = 0. ql0 = 0. ; qt0h = 0. ; thv0h = 0. ; thl0h = 0. ; mindist = 1.0e10 ; presf = 0. ; presh = 0. ; exnf = 1. ; exnh = 0. ; thvf = 0. ; thvh = 0. ; rhof = 0. ! OG !Exner function should be called in startup and just be initialised here qt0av = 0. ; ql0av = 0. ; thl0av = 0. ; u0av = 0. ; v0av = 0. ; sv0av = 0. thlprof = 0. ; qtprof = 0. ; qlprof = 0. ; uprof = 0. ; vprof = 0. ; e12prof = 0. ; svprof = 0. ug = 0. ; vg = 0. ; pgx = 0. ; pgy = 0. ; dpdxl = 0. ; dpdyl = 0. ; wfls = 0. ; whls = 0. ; thlpcar = 0. ; uout = 0. ; vout = 0. ; wout = 0. ; udef = 0. ; vdef = 0. ; uouttot = 0. ; wouttot = 0. ; vouttot = 0. dthldxls = 0. ; dthldyls = 0. ; dqtdxls = 0. ; dqtdyls = 0. ; dudxls = 0. ; dudyls = 0. ; dvdxls = 0. ; dvdyls = 0. dthvdz = 0. SW_up_TOA = 0. ; SW_dn_TOA = 0. ; LW_up_TOA = 0. ; LW_dn_TOA = 0. uyt = 0. ; uytik = 0. ; vyt = 0. ; wyt = 0. ; wytik = 0. ; thlyt = 0. ; qtyt = 0. ; thlytk = 0. ; sca1yt = 0. ; sca2yt = 0. ; sca3yt = 0. ; thlsgsyt = 0. ; wsgsyt = 0. ; qtsgsyt = 0. ; sv1sgsyt = 0. ; sv2sgsyt = 0. ; sv3sgsyt = 0. usgsyt = 0. uxyt = 0. ; vxyt = 0. ; wxyt = 0. ; thlxyt = 0. ; qtxyt = 0. ; pxyt = 0. ; usgsxyt = 0. ; vsgsxyt = 0. ; thlsgsxyt = 0. ; uwtik = 0. ; wthltk = 0. ; wqttk = 0. ; thlthlt = 0. ; qtqtt = 0. ; sv1sv1t = 0. ; sv2sv2t = 0. ; sv3sv3t = 0. ; sv4sv4t = 0. ; uutc = 0. ; vvtc = 0. ; wwtc = 0. ; vwtjk = 0. ; uvtij = 0. ; utik = 0. ; wtik = 0. ; wtjk = 0. ; vtjk = 0. ; utij = 0. ; vtij = 0. ; wmt = 0. ; thltk = 0. ; qttk = 0. ; thlt = 0. ; slice = 0. ; slice2 = 0. ; slice3 = 0. ; slice4 = 0. ; slice5 = 0. ; utc = 0. ; vtc = 0. ; wtc = 0. slice6 = 0. ; slice7 = 0. ; slice8 = 0. ; umt = 0. ; vmt = 0. ; sv1t = 0. ; sv2t = 0. ; sv3t = 0. ; sv4t = 0. ; sv1tk = 0. ; sv2tk = 0. ; sv3tk = 0. ; sv4tk = 0. wsv1tk = 0. ; wsv2tk = 0. ; wsv3tk = 0. ; wsv4tk = 0. ; sv1sgst = 0. ; sv2sgst = 0. ; sv3sgst = 0. ; sv4sgst = 0. ; qtt = 0. ; pt = 0. PSSt = 0. !sv1max = 0.; sv2max = 0.; sv3max = 0.; sv4max = 0. scar = 0. ; scarl = 0. IIc = 1 ; IIu = 1 ; IIv = 1 ; IIct = 1 ; IIw = 1 ; IIuw = 1 ; IIvw = 1 ; IIuwt = 1 ; IIut = 1 ; IIvt = 1 ; IIwt = 1 ; IIcs = 1 ; IIus = 1 ; IIvs = 1 ; IIws = 1 ; IIuws = 1 ; IIvws = 1 ; IIuw = 1 ; IIuvs = 1 uav = 0. ; vav = 0. ; wav = 0. ; thlav = 0. ; qtav = 0. ; svav = 0. ; viscratioav = 0. ; uuav = 0. ; vvav = 0. wwav = 0. ; uvav = 0. ; uwav = 0. ; vwav = 0. ; sv2av = 0. ; thl2av = 0. ; ql2av = 0. ; qt2av = 0. ; presav = 0. thluav = 0. ; thlvav = 0. ; thlwav = 0. ; thlthlav = 0. ; svuav = 0. ; svvav = 0. ; svwav = 0. shear = 0. upupav = 0. ; vpvpav = 0. ; wpwpav = 0. ; thlpthlpav = 0. ; qlpqlpav = 0. ; qtpqtpav = 0. ; svpsvpav = 0. ; upvpav = 0. ; upwpav = 0. ; vpwpav = 0. thlpupav = 0. ; thlpvpav = 0. ; thlpwpav = 0. ; qlpupav = 0. ; qlpvpav = 0. ; qlpwpav = 0. ; qtpwpav = 0. ; qtpvpav = 0. ; qtpupav = 0. ; svpupav = 0. ; svpvpav = 0. ; svpwpav = 0. umint = 0. ; vmint = 0. ; wmint = 0. ! SGS uusgsav = 0. ; vvsgsav = 0. ; wwsgsav = 0. ; uwsgsav = 0. ; thlusgsav = 0. ; thlwsgsav = 0. ; qlusgsav = 0. ; qlwsgsav = 0. ; qtwsgsav = 0. ; qtusgsav = 0. ; svusgsav = 0. ; svwsgsav = 0. ; tkesgsav = 0. ; nusgsav = 0. ! Resolved dissipation strain2av = 0. ! Subgrid dissipation disssgsav = 0. ! TKE budget t_vav = 0. ; tvmx = 0. ; tvmy = 0. ; tvmz = 0. ; tpm = 0. ; ttmx = 0. ; ttmy = 0. ; ttmz = 0. ; t_sgsav = 0. ; p_tav = 0. tsgsmx1 = 0. ; tsgsmy1 = 0. ; tsgsmz1 = 0. ; tsgsmx2 = 0. ; tsgsmy2 = 0. ; tsgsmz2 = 0. t_pav = 0. ; t_tav = 0. ; p_bav = 0. ; d_sgsav = 0. ; tkeadv = 0. ; t_p = 0. ; t_v = 0. ; t_t = 0. ; t_sgs = 0. ; p_t = 0. ; p_b = 0. ; d_sgs = 0. ; adv = 0. ! domain fluid volume and area calculations uoutarea = 0. ; voutarea = 0. ; fluidvol = 0. end subroutine initfields","tags":"","loc":"proc/initfields.html"},{"title":"exitfields – uDALES","text":"public subroutine exitfields() Arguments None Called by proc~~exitfields~~CalledByGraph proc~exitfields exitfields proc~exitmodules exitmodules proc~exitmodules->proc~exitfields program~dalesurban DALESURBAN program~dalesurban->proc~exitmodules Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code exitfields Source Code subroutine exitfields implicit none deallocate ( um , vm , wm , thlm , e12m , qtm , u0 , v0 , w0 , pres0 , thl0 , thl0h , qt0h , e120 , qt0 ) deallocate ( up , vp , wp , thlp , e12p , qtp ) deallocate ( svm , sv0 , svp , svpp ) deallocate ( ql0 , ql0h , thv0h , dthvdz , whls , presf , presh , exnf , exnh , thvf , thvh , rhof , qt0av , ql0av , thl0av , u0av , v0av ) deallocate ( ug , vg , pgx , pgy , dpdxl , dpdyl , dthldxls , dthldyls , dqtdxls , dqtdyls , dqtdtls , dudxls , dudyls , dvdxls , dvdyls , wfls ) deallocate ( thlprof , qtprof , uprof , vprof , e12prof , sv0av , svprof ) deallocate ( thlpcar ) deallocate ( momfluxb , tfluxb , qfluxb , cth ) deallocate ( SW_up_TOA , SW_dn_TOA , LW_up_TOA , LW_dn_TOA ) end subroutine exitfields","tags":"","loc":"proc/exitfields.html"},{"title":"matinv3 – uDALES","text":"public pure function matinv3(A) result(B) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (3,3) Return Value real\n  (3,3) Contents None","tags":"","loc":"proc/matinv3.html"},{"title":"matinv4 – uDALES","text":"public pure function matinv4(A) result(B) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (4,4) Return Value real\n  (4,4) Called by proc~~matinv4~~CalledByGraph proc~matinv4 matinv4 proc~eb EB proc~eb->proc~matinv4 proc~initeb initEB proc~initeb->proc~matinv4 program~dalesurban DALESURBAN program~dalesurban->proc~eb program~dalesurban->proc~initeb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/matinv4.html"},{"title":"gaussji – uDALES","text":"public function gaussji(c, d, n) result(a) Arguments Type Intent Optional Attributes Name real, intent(in) :: c (n,n) real, intent(in) :: d (n,n) integer :: n Return Value real\n  (n,n) Called by proc~~gaussji~~CalledByGraph proc~gaussji gaussji proc~eb EB proc~eb->proc~gaussji proc~initeb initEB proc~initeb->proc~gaussji program~dalesurban DALESURBAN program~dalesurban->proc~eb program~dalesurban->proc~initeb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code gaussji Source Code function gaussji ( c , d , n ) result ( a ) !Linear equation solution by Gauss-Jordan elimination, used to find inverse of matrix c. !possibly slow for large \"c\" (LAPACK better?) !c needs to be square and have dimension n !c(1:n,1:n) is an input matrix stored in an array of physical dimensions n by n. !d(1:n,1:n) is an input matrix containing the n by n identity matrix. !On  output, a(1:n,1:n) (and b(1:n,1:n)) are the inverse of c !Parameter: NMAX is  the  largest  anticipated  value  of n. INTEGER :: n real , intent ( in ) :: c ( n , n ) !WILL BE OVERWRITTEN!! real , intent ( in ) :: d ( n , n ) real :: a ( n , n ), b ( n , n ) INTEGER , PARAMETER :: NMAX = 50 INTEGER :: m , i , icol , irow , j , k , l , ll , indxc ( NMAX ), indxr ( NMAX ), ipiv ( NMAX ) !The integer arrays ipiv, indxr, and indxc are  used for bookkeeping  on the pivoting. REAL :: big , dum , pivinv a = c b = d m = n do j = 1 , n ipiv ( j ) = 0 end do do i = 1 , n !This  is  the  main  loop  over  the  columns  to  be  reduced. big = 0. do j = 1 , n !This  is  the  outer  loop  of  the  search  for  a  pivot  element. if ( ipiv ( j ) . ne . 1 ) then do k = 1 , n if ( ipiv ( k ) . eq . 0 ) then if ( abs ( a ( j , k )) . ge . big ) then big = abs ( a ( j , k )) irow = j icol = k endif !else if (ipiv(k).gt.1) then !pause 'singular matrix in gaussj' end if end do end if end do ipiv ( icol ) = ipiv ( icol ) + 1 !We  now  have  the  pivot  element,  so  we  interchange  rows,  if  needed,  to  put  the  pivot !element  on  the  diagonal.  The  columns  are  not  physically  interchanged,  only  relabeled: !indxc(i), the column of the ith pivot element, is the ith column that is reduced, while !indxr(i) is  the  row in  which  that  pivot  element  was  originally  located.  If !indxr(i) /= indxc(i) there  is  an  implied  column  interchange.  With  this  form  of  bookkeeping,  the !solution b's  will  end  up  in  the  correct  order,  and  the  inverse  matrix  will  be  scrambled by  columns if ( irow . ne . icol ) then do l = 1 , n dum = a ( irow , l ) a ( irow , l ) = a ( icol , l ) a ( icol , l ) = dum end do do l = 1 , m dum = b ( irow , l ) b ( irow , l ) = b ( icol , l ) b ( icol , l ) = dum enddo endif !We are now ready to divide the pivot row by the pivot element, located at irow and icol. indxr ( i ) = irow indxc ( i ) = icol !if (a(icol,icol).eq.0.) pause 'singular matrix in gaussj' pivinv = 1. / a ( icol , icol ) a ( icol , icol ) = 1. do l = 1 , n a ( icol , l ) = a ( icol , l ) * pivinv end do do l = 1 , m b ( icol , l ) = b ( icol , l ) * pivinv end do do ll = 1 , n !Next,  we  reduce  the  rows, except for the  pivot  one, of course. if ( ll . ne . icol ) then dum = a ( ll , icol ) a ( ll , icol ) = 0. do l = 1 , n a ( ll , l ) = a ( ll , l ) - a ( icol , l ) * dum end do do l = 1 , m b ( ll , l ) = b ( ll , l ) - b ( icol , l ) * dum end do end if end do end do !This is the end of the main loop over columns of the reduction. do l = n , 1 , - 1 !It  only  remains  to  unscramble  the  solution  in  view !of  the  column  interchanges.  We  do  this  by  in- !terchanging pairs of columns in the reverse order !that the permutation was built  up. if ( indxr ( l ) . ne . indxc ( l )) then do k = 1 , n dum = a ( k , indxr ( l )) a ( k , indxr ( l )) = a ( k , indxc ( l )) a ( k , indxc ( l )) = dum end do end if end do return !And  we  are  done. END function gaussji","tags":"","loc":"proc/gaussji.html"},{"title":"intqH – uDALES","text":"public subroutine intqH() Uses modglobal initfac modmpi proc~~intqh~~UsesGraph proc~intqh intqH module~modmpi modmpi proc~intqh->module~modmpi module~initfac initfac proc~intqh->module~initfac module~modglobal modglobal proc~intqh->module~modglobal mpi mpi module~modmpi->mpi module~initfac->module~modmpi module~initfac->module~modglobal netcdf netcdf module~initfac->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~intqh~~CalledByGraph proc~intqh intqH proc~eb EB proc~eb->proc~intqh program~dalesurban DALESURBAN program~dalesurban->proc~eb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code intqH Source Code subroutine intqH !time integration of heat and latent heat from facets use modglobal , only : nfcts , dt , rk3step , lEB use initfac , only : faccth , fachfsum , fachf , fachfi , facef , facefi , facefsum use modmpi , only : nprocs , myid , comm3d , mpierr , mpi_sum , my_real real :: dummy integer :: n if (. not . lEB ) return if ( rk3step . eq . 3 ) then !sum over all processors since a facet can be split onto more than one processor fachfsum = 0. facefsum = 0. call MPI_ALLREDUCE ( fachf ( 1 : nfcts ), fachfsum ( 1 : nfcts ), nfcts , MY_REAL , MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( facef ( 1 : nfcts ), facefsum ( 1 : nfcts ), nfcts , MY_REAL , MPI_SUM , comm3d , mpierr ) if ( myid == 0 ) then !time summation of total facet heatlux (will be divided by dtEB in EB to get time mean flux) do n = 1 , nfcts fachfi ( n ) = fachfi ( n ) + dt * fachfsum ( n ) !sum up the fluxes over time facefi ( n ) = facefi ( n ) + dt * facefsum ( n ) end do end if end if fachf = 0. fachfsum = 0. facefsum = 0. facef = 0. end subroutine intqH","tags":"","loc":"proc/intqh.html"},{"title":"initEB – uDALES","text":"public subroutine initEB() Uses modglobal initfac modmpi modstat_nc proc~~initeb~~UsesGraph proc~initeb initEB module~modmpi modmpi proc~initeb->module~modmpi module~initfac initfac proc~initeb->module~initfac module~modstat_nc modstat_nc proc~initeb->module~modstat_nc module~modglobal modglobal proc~initeb->module~modglobal mpi mpi module~modmpi->mpi module~initfac->module~modmpi module~initfac->module~modglobal netcdf netcdf module~initfac->netcdf module~modstat_nc->module~modmpi module~modstat_nc->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~initeb~~CallsGraph proc~initeb initEB proc~matinv4 matinv4 proc~initeb->proc~matinv4 proc~define_nc define_nc proc~initeb->proc~define_nc proc~gaussji gaussji proc~initeb->proc~gaussji proc~open_nc open_nc proc~initeb->proc~open_nc proc~writestat_dims_nc writestat_dims_nc proc~initeb->proc~writestat_dims_nc nf90_put_att nf90_put_att proc~define_nc->nf90_put_att nf90_redef nf90_redef proc~define_nc->nf90_redef nf90_def_var nf90_def_var proc~define_nc->nf90_def_var nf90_inq_varid nf90_inq_varid proc~define_nc->nf90_inq_varid nf90_inq_dimid nf90_inq_dimid proc~define_nc->nf90_inq_dimid nf90_enddef nf90_enddef proc~define_nc->nf90_enddef proc~nchandle_error nchandle_error proc~define_nc->proc~nchandle_error proc~open_nc->nf90_put_att nf90_def_dim nf90_def_dim proc~open_nc->nf90_def_dim nf90_inquire_dimension nf90_inquire_dimension proc~open_nc->nf90_inquire_dimension proc~open_nc->nf90_def_var proc~open_nc->nf90_inq_varid nf90_inquire nf90_inquire proc~open_nc->nf90_inquire nf90_open nf90_open proc~open_nc->nf90_open proc~open_nc->nf90_inq_dimid nf90_create nf90_create proc~open_nc->nf90_create nf90_get_var nf90_get_var proc~open_nc->nf90_get_var proc~open_nc->nf90_enddef nf90_sync nf90_sync proc~open_nc->nf90_sync nf90_put_var nf90_put_var proc~writestat_dims_nc->nf90_put_var proc~writestat_dims_nc->nf90_inquire_dimension proc~writestat_dims_nc->nf90_inq_varid nf90_strerror nf90_strerror proc~nchandle_error->nf90_strerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~initeb~~CalledByGraph proc~initeb initEB program~dalesurban DALESURBAN program~dalesurban->proc~initeb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code initEB Source Code subroutine initEB !initialise everything necessary to calculate the energy balance use modglobal , only : AM , BM , CM , DM , EM , FM , GM , HM , IDM , inAM , bb , w , dumv , Tdash , bldT , nfcts , nwalllayers use initfac , only : facdi , faccp , faclami , fackappa , netsw , facem , fachf , facef , fachfi , facT , facLWin , facain , facefi , facwsoil , facf , facets , facTdash , facqsat , facf , fachurel use modmpi , only : myid , comm3d , mpierr , MPI_INTEGER , MPI_DOUBLE_PRECISION , MY_REAL , nprocs , cmyid , MPI_REAL8 , MPI_REAL4 , MPI_SUM use modstat_nc , only : open_nc , define_nc , ncinfo , writestat_dims_nc integer :: i , j , k , l , m , n real :: dum allocate ( AM ( 1 : nwalllayers + 1 , 1 : nwalllayers + 1 )) allocate ( inAM ( 1 : nwalllayers + 1 , 1 : nwalllayers + 1 )) allocate ( CM ( 1 : nwalllayers + 1 , 1 : nwalllayers + 1 )) allocate ( bb ( 1 : nwalllayers + 1 )) allocate ( BM ( 1 : nwalllayers + 1 , 1 : nwalllayers + 1 )) allocate ( DM ( 1 : nwalllayers + 1 , 1 : nwalllayers + 1 )) allocate ( EM ( 1 : nwalllayers + 1 , 1 : nwalllayers + 1 )) allocate ( FM ( 1 : nwalllayers + 1 , 1 : nwalllayers + 1 )) allocate ( GM ( 1 : nwalllayers + 1 , 1 : nwalllayers + 1 )) allocate ( HM ( 1 : nwalllayers + 1 , 1 : nwalllayers + 1 )) allocate ( IDM ( 1 : nwalllayers + 1 , 1 : nwalllayers + 1 )) allocate ( w ( 1 : nwalllayers + 1 )) allocate ( dumv ( 1 : nwalllayers + 1 )) allocate ( Tdash ( 1 : nwalllayers + 1 )) write ( * , * ) \"nwalllayers\" , nwalllayers BM = 0. ; DM = 0. ; EM = 0. ; FM = 0. ; GM = 0. ; HM = 0. ; w = 0. ; dumv = 0. ; Tdash = 0. ; AM = 0. ; inAM = 0. ; CM = 0. ; IDM = 0. ; bb = 0. do j = 1 , nwalllayers + 1 IDM ( j , j ) = 1.0 end do !Fortran is column major, i.e. left dimensions should be iterated first ! e.g.  (1,1)->(2,1)->(3,1)->(1,2)->... since they are next to each other on memory !first index moves \"up and down\" second \"left and right\" (as always) m = 1 ; !position along columns do j = 2 , nwalllayers + 1 AM ( j , m ) = 0.5 AM ( j , m + 1 ) = 0.5 m = m + 1 end do AM ( 1 , 1 ) = 1.0 if ( nwalllayers == 3 ) then inAM = matinv4 ( AM ) !!alternatively !inAM=matinv3(AM) !!or else inAM = gaussji ( AM , IDM , nwalllayers + 1 ) end if ! write facet temperatures to facT.xxx.nc, and energies to facEB.xxx.nc if ( lwriteEBfiles ) then Tname ( 6 : 8 ) = cexpnr EBname ( 7 : 9 ) = cexpnr allocate ( ncstatT ( nstatT , 4 )) call ncinfo ( tncstatT ( 1 ,:), 't' , 'Time' , 's' , 'time' ) call ncinfo ( ncstatT ( 1 ,:), 'T' , 'Temperature' , 'K' , 'flt' ) call ncinfo ( ncstatT ( 2 ,:), 'dTdz' , 'Temperature gradient' , 'K/m' , 'flt' ) allocate ( ncstatEB ( nstatEB , 4 )) call ncinfo ( tncstatEB ( 1 ,:), 't' , 'Time' , 's' , 'time' ) call ncinfo ( ncstatEB ( 1 ,:), 'netsw' , 'Shortwave radiation' , 'W' , 'ft' ) call ncinfo ( ncstatEB ( 2 ,:), 'LWin' , 'Longwave radiation' , 'W' , 'ft' ) call ncinfo ( ncstatEB ( 3 ,:), 'hf' , 'Sensible heat flux' , 'W' , 'ft' ) call ncinfo ( ncstatEB ( 4 ,:), 'ef' , 'Latent heat flux' , 'W' , 'ft' ) call ncinfo ( ncstatEB ( 5 ,:), 'WGR' , 'Moisture?' , 'W' , 'ft' ) if ( myid == 0 ) then call open_nc ( Tname , ncidT , nrecT , nfcts = nfcts , nlyrs = nwalllayers + 1 ) call open_nc ( EBname , ncidEB , nrecEB , nfcts = nfcts ) if ( nrecT == 0 ) then call define_nc ( ncidT , 1 , tncstatT ) call writestat_dims_nc ( ncidT ) end if if ( nrecT == 0 ) then call define_nc ( ncidEB , 1 , tncstatEB ) call writestat_dims_nc ( ncidEB ) end if call define_nc ( ncidT , nstatT , ncstatT ) call define_nc ( ncidEB , nstatEB , ncstatEB ) endif !myid==0 end if end subroutine initEB","tags":"","loc":"proc/initeb.html"},{"title":"calclw – uDALES","text":"public subroutine calclw() Uses modglobal initfac proc~~calclw~~UsesGraph proc~calclw calclw module~initfac initfac proc~calclw->module~initfac module~modglobal modglobal proc~calclw->module~modglobal module~initfac->module~modglobal module~modmpi modmpi module~initfac->module~modmpi netcdf netcdf module~initfac->netcdf mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~calclw~~CalledByGraph proc~calclw calclw proc~eb EB proc~eb->proc~calclw program~dalesurban DALESURBAN program~dalesurban->proc~eb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code calclw Source Code subroutine calclw !calculate the longwave exchange between facets use modglobal , only : nfcts , boltz , skyLW use initfac , only : facem , vf , svf , faca , facT , facLWin , facets integer :: n , m real :: ltemp = 0. do n = 1 , nfcts if ( facets ( n , 2 ) < - 100 ) then !it's a bounding wall, no need to update incoming longwave cycle else ltemp = 0. do m = 1 , nfcts !for n, sum over all other m facets ltemp = ltemp + vf ( m , n ) * faca ( m ) / faca ( n ) * facem ( m ) * boltz * facT ( m , 1 ) ** 4 ![W/m2] end do facLWin ( n ) = ( ltemp + svf ( n ) * skyLW ) * facem ( n ) end if end do end subroutine calclw","tags":"","loc":"proc/calclw.html"},{"title":"updateGR – uDALES","text":"public subroutine updateGR() Uses modglobal initfac proc~~updategr~~UsesGraph proc~updategr updateGR module~initfac initfac proc~updategr->module~initfac module~modglobal modglobal proc~updategr->module~modglobal module~initfac->module~modglobal module~modmpi modmpi module~initfac->module~modmpi netcdf netcdf module~initfac->netcdf mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~updategr~~CallsGraph proc~updategr updateGR proc~qsat qsat proc~updategr->proc~qsat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~updategr~~CalledByGraph proc~updategr updateGR proc~eb EB proc~eb->proc~updategr program~dalesurban DALESURBAN program~dalesurban->proc~eb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code updateGR Source Code subroutine updateGR !updates soil and vegetation resistance to evaporation !updates soil moisture ! ! based on ERA40 surface scheme ! van den Hurk 2000 ! plants ! E = max(0,vegetation% * rhoa * (qa-qsat(TGR)) * 1/(rc+ra)) !no dew!! ! rc=rsmin/LAI*f1(K)*f2(WGS)*f3(D)*f4(T) ! ra,qa,qsat ! f3(D) is 1 for small plants ! bare soil ! E = max(0,(1-vegetation%) * rhoa * (qa-qsat(TGR)*hu) * (1/(rs+ra)) use modglobal , only : nfcts , rlv , rlvi , rhoa , cp , wfc , wwilt , wsoil , rsmin , GRLAI , tEB , rsmax , lconstW use initfac , only : netSW , faccth , fachurel , faclGR , facwsoil , facf , facef , facT , facefi , facqsat , facdi , facain , qsat integer :: n real :: vfraction = 0.8 !fraction of GR covered in vegetation, should be made into a proper model parameter (-> modglobal) real :: dum do n = 1 , nfcts if ( faclGR ( n )) then !facefi is actually the accumulated moisture flux, has to be converted to energy flux to calculate temperature !yet actually the moisture flux is needed for water budget, i.e. currently many operations cancel each other e.g. X*Lv/Lv !facefi is the sum over all gridcells of a facet, thus has to be averaged by dividing by number of cells in that facet !units of facefi are kgW/kgA*m/s facefi ( n ) = facefi ( n ) / tEB / facain ( n ) * rhoa * rlv !mean heat flux since last EB calculation (time average) if (. not . lconstW ) then !remove water from soil facwsoil ( n ) = max ( facwsoil ( n ) + facefi ( n ) * tEB * rlvi * facdi ( n , 1 ), 0. ) !ils13, careful this assumes water only being present in the first layer!!! end if !update canopy resistance used in wf_gr fachurel ( n ) = max ( min ( 1.0 , 0.5 * ( 1.0 - cos ( 3.14159 * facwsoil ( n ) / wfc ))), 0. ) !relative humidity above soil facf ( n , 1 ) = 1. / min ( 1.0 , ( 0.004 * netSW ( n ) + 0.05 ) / ( 0.81 * ( 0.004 * netSW ( n ) + 1 ))) !f1 facf ( n , 2 ) = 1. / min ( max ( 0.001 , ( facwsoil ( n ) - wwilt ) / ( wfc - wwilt )), 1.0 ) !f2 !f3 drops out because it is for high vegetation only facf ( n , 3 ) = 1. / max (( 1 - 0.0016 * ( 298 - facT ( n , 1 )) ** 2 ), 0.001 ) !f4 !store resistance for plants facf ( n , 4 ) = min ( rsmin / GRLAI * facf ( n , 1 ) * facf ( n , 2 ) * facf ( n , 3 ), rsmax ) !store resistance for soil facf ( n , 5 ) = min ( rsmin * facf ( n , 2 ), rsmax ) dum = facT ( n , 1 ) facqsat ( n ) = qsat ( dum ) end if end do end subroutine updateGR","tags":"","loc":"proc/updategr.html"},{"title":"EB – uDALES","text":"public subroutine EB() Uses modglobal initfac modmpi modstat_nc proc~~eb~~UsesGraph proc~eb EB module~modmpi modmpi proc~eb->module~modmpi module~initfac initfac proc~eb->module~initfac module~modstat_nc modstat_nc proc~eb->module~modstat_nc module~modglobal modglobal proc~eb->module~modglobal mpi mpi module~modmpi->mpi module~initfac->module~modmpi module~initfac->module~modglobal netcdf netcdf module~initfac->netcdf module~modstat_nc->module~modmpi module~modstat_nc->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~eb~~CallsGraph proc~eb EB proc~calclw calclw proc~eb->proc~calclw proc~writestat_2d_nc writestat_2D_nc proc~eb->proc~writestat_2d_nc proc~writestat_1d_nc writestat_1D_nc proc~eb->proc~writestat_1d_nc proc~matinv4 matinv4 proc~eb->proc~matinv4 proc~gaussji gaussji proc~eb->proc~gaussji interface~writestat_nc writestat_nc proc~eb->interface~writestat_nc proc~intqh intqH proc~eb->proc~intqh proc~updategr updateGR proc~eb->proc~updategr mpi_bcast mpi_bcast proc~eb->mpi_bcast nf90_put_var nf90_put_var proc~writestat_2d_nc->nf90_put_var nf90_inq_varid nf90_inq_varid proc~writestat_2d_nc->nf90_inq_varid nf90_sync nf90_sync proc~writestat_2d_nc->nf90_sync proc~writestat_1d_nc->nf90_put_var proc~writestat_1d_nc->nf90_inq_varid proc~writestat_1d_nc->nf90_sync interface~writestat_nc->proc~writestat_2d_nc interface~writestat_nc->proc~writestat_1d_nc proc~writestat_time_nc writestat_time_nc interface~writestat_nc->proc~writestat_time_nc proc~writestat_3d_nc writestat_3D_nc interface~writestat_nc->proc~writestat_3d_nc proc~writestat_3d_short_nc writestat_3D_short_nc interface~writestat_nc->proc~writestat_3d_short_nc proc~qsat qsat proc~updategr->proc~qsat proc~writestat_time_nc->nf90_put_var proc~writestat_time_nc->nf90_inq_varid proc~writestat_time_nc->nf90_sync proc~writestat_3d_nc->nf90_put_var proc~writestat_3d_nc->nf90_inq_varid proc~writestat_3d_nc->nf90_sync proc~writestat_3d_short_nc->nf90_put_var proc~writestat_3d_short_nc->nf90_inq_varid proc~writestat_3d_short_nc->nf90_sync Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~eb~~CalledByGraph proc~eb EB program~dalesurban DALESURBAN program~dalesurban->proc~eb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code EB Source Code subroutine EB !calculates the energy balance for every facet use modglobal , only : nfcts , boltz , tEB , AM , BM , CM , DM , EM , FM , GM , HM , inAM , bb , w , dumv , Tdash , timee , tnextEB , rk3step , rhoa , cp , lEB , ntrun , lwriteEBfiles , nwalllayers use initfac , only : faclami , netsw , facem , fachf , facef , fachfi , facT , facLWin , facain , facefi , facf , facets , facTdash , facqsat , facwsoil , facf , fachurel , facd , facdi , fackappa use modmpi , only : myid , comm3d , mpierr , MPI_INTEGER , MPI_DOUBLE_PRECISION , MY_REAL , nprocs , cmyid , MPI_REAL8 , MPI_REAL4 , MPI_SUM use modstat_nc , only : writestat_nc , writestat_1D_nc , writestat_2D_nc real :: ca = 0. , cb = 0. , cc = 0. , cd = 0. , ce = 0. , cf = 0. real :: ab = 0. integer :: l , n , m , i , j character ( 19 ) name if (. not . ( lEB )) return !calculate latent heat flux from vegetation and soil call intqH !calculate energy balance, update facet temperature and soil moisture if (( rk3step . eq . 3 ) . and . ( timee . ge . tnextEB )) then if ( myid . eq . 0 ) then tEB = timee - tEB !time since last calculation of energy balance write ( * , * ) \"doing EB, time since last EB:\" , tEB !calculate time mean, facet area mean latent heat flux and update green roof !ILS13 02.05.18 ABOUT updateGR: convert latent heatflux E properly should be done before temperature calculatation. BUT the rest of updateGR should be done after! !update green roof call updateGR !get longwave fluxes for all facets call calclw !get time mean, facet area mean sensible heat flux do n = 1 , nfcts fachfi ( n ) = fachfi ( n ) / tEB / facain ( n ) * rhoa * cp !mean heat flux since last EB calculation (time average) !since fachf is the sum over all cells making up a facet we need to divide by the number of cells, assuming a given density to convert to W/m2 end do !solve the system: !see Suter 2018 !A * T'= bb + B * T,   where T' = dT/dz !C * d/dtT + D d/dtT'= e * T' ! !-> T(n+1)=(F-G*dt)&#94;-1*(F*T+w*dt) !where F=(C + D*A&#94;-1*B), G=(E*A&#94;-1*B), w=(E*A&#94;-1*bb) do n = 1 , nfcts if ( facets ( n , 2 ) < - 100 ) then !it's a bounding wall, no reason to do energy balance cycle else !calculate wallflux and update surface temperature !! define time dependent fluxes ab = faclami ( n , 1 ) * boltz * facem ( n ) * ( facT ( n , 1 ) ** 3 ) ! ab*T is the Stefan-Boltzman law bb ( 1 ) = - faclami ( n , 1 ) * ( netsw ( n ) + facLWin ( n ) + fachfi ( n ) + facefi ( n )) !net surface flux !!define the matrices to solve wall heat flux !! CREATE MATRICES BASED ON WALL PROPERTIES i = 1 ; m = 0 ; !position along columns, placeholder for layerindex since only 3 layers implemented (initfac.f90) do j = 1 , nwalllayers m = min ( j , 3 ) !!CARE!!! ONLY 3 LAYERS ARE CURRENTLY BEING READ FROM INPUT FILES. PROPERTIES OF LAYER 3 ARE USED FOR SUBSEQUENT LAYERS!!! ca = facdi ( n , m ) BM ( j + 1 , i ) =- ca BM ( j + 1 , i + 1 ) = ca EM ( j , i ) =- fackappa ( n , m ) EM ( j , i + 1 ) = fackappa ( n , m + 1 ) cb = facd ( n , m ) / 2 CM ( j , i ) = cb CM ( j , i + 1 ) = cb ca = cb ** 2 * 0.33333333 DM ( j , i ) = ca DM ( j , i + 1 ) =- ca i = i + 1 end do CM ( nwalllayers + 1 , nwalllayers + 1 ) = 1.0 BM ( 1 , 1 ) = ab w = matmul ( EM , matmul ( inAM , bb )) * tEB !easier than loop and sum HM = matmul ( inAM , BM ) FM = CM + matmul ( DM , HM ) GM = matmul ( EM , HM ) HM = FM - GM * tEB if ( nwalllayers == 3 ) then GM = matinv4 ( HM ) else GM = gaussji ( HM , IDM , nwalllayers + 1 ) end if !instead of inverting matrix HM and multiplying by GM (=HM&#94;-1) it would be waster to do a  left matrix division HM\\x is faster than (HM&#94;-1)*x dumv = matmul ( GM , ( matmul ( FM , facT ( n ,:)) + w )) facT ( n , :) = dumv !calculate Temperature gradient dT/dz=>Tdash so we can output it !ground heat flux = lambda dT/dz w = matmul ( BM , dumv ) facTdash ( n , :) = matmul ( inAM , ( bb + w )) end if end do if ( lwriteEBfiles ) then if ( myid == 0 ) then allocate ( varsT ( nfcts , nwalllayers + 1 , nstatT )) varsT (:,:, 1 ) = facT ( 1 : nfcts , 1 : nwalllayers + 1 ) varsT (:,:, 2 ) = facTdash ( 1 : nfcts , 1 : nwalllayers + 1 ) call writestat_nc ( ncidT , 1 , tncstatT ,( / timee / ), nrecT ,. true .) call writestat_2D_nc ( ncidT , nstatT , ncstatT , varsT , nrecT , nfcts , nwalllayers + 1 ) deallocate ( varsT ) allocate ( varsEB ( nfcts , nstatEB )) varsEB (:, 1 ) = netsw ( 1 : nfcts ) varsEB (:, 2 ) = facLWin ( 1 : nfcts ) varsEB (:, 3 ) = fachfi ( 1 : nfcts ) varsEB (:, 4 ) = facefi ( 1 : nfcts ) varsEB (:, 5 ) = facwsoil ( 1 : nfcts ) call writestat_nc ( ncidEB , 1 , tncstatEB ,( / timee / ), nrecEB ,. true .) call writestat_1D_nc ( ncidEB , nstatEB , ncstatEB , varsEB , nrecEB , nfcts ) deallocate ( varsEB ) endif !myid !            if (lwriteEBfiles) then !               name = 'tEB____________.txt' !               open (unit=11, file=name, position='append') !               write (11, '(1(F10.4,:,\",\"))') tEB !               close (11) !               name = 'dummy__________.csv' !               write (name(6:15), '(F10.4)') timee !               write (name(1:5), '(A5)') 'netsw' !               open (unit=11, file=name, position='append') !               write (11, '(249(F10.4,:,\",\"))') netsw(1:nfcts) !               close (11) !               write (name(1:5), '(A5)') 'LWin_' !               open (unit=11, file=name, position='append') !               write (11, '(249(F10.4,:,\",\"))') facLWin(1:nfcts) !               close (11) !               write (name(1:5), '(A5)') 'hf___' !               open (unit=11, file=name, position='append') !               write (11, '(249(F10.4,:,\",\"))') fachfi(1:nfcts) !               close (11) !               write (name(1:5), '(A5)') 'ef___' !               open (unit=11, file=name, position='append') !               write (11, '(249(F10.4,:,\",\"))') facefi(1:nfcts) !               close (11) !               write (name(1:5), '(A5)') 'WGR__' !               open (unit=11, file=name, position='append') !               write (11, '(249(F10.4,:,\",\"))') facwsoil(1:nfcts) !               close (11) !               write (name(1:5), '(A5)') 'facT1' !               open (unit=11, file=name, position='append') !               write (11, '(249(F10.4,:,\",\"))') facT(1:nfcts, 1) !               close (11) !               write (name(1:5), '(A5)') 'facT2' !               open (unit=11, file=name, position='append') !               write (11, '(249(F10.4,:,\",\"))') facT(1:nfcts, 2) !               close (11) !               write (name(1:5), '(A5)') 'facT3' !               open (unit=11, file=name, position='append') !               write (11, '(249(F10.4,:,\",\"))') facT(1:nfcts, 3) !               close (11) !               write (name(1:5), '(A5)') 'faTd1' !               open (unit=11, file=name, position='append') !               write (11, '(249(F10.4,:,\",\"))') facTdash(1:nfcts, 1) !               write (name(1:5), '(A5)') 'faTd2' !               open (unit=11, file=name, position='append') !               write (11, '(249(F10.4,:,\",\"))') facTdash(1:nfcts, 2) !               write (name(1:5), '(A5)') 'faTd3' !               open (unit=11, file=name, position='append') !               write (11, '(249(F10.4,:,\",\"))') facTdash(1:nfcts, 3) !               close (11) !               write (name(1:5), '(A5)') 'faTd4' !               open (unit=11, file=name, position='append') !               write (11, '(249(F10.4,:,\",\"))') facTdash(1:nfcts, 4) !               close (11) end if tEB = timee !set time of last calculation of energy balance to current time tnextEB = NINT (( timee + dtEB )) * 1.0 !rounded to nearest integer  (e.g. if current time is 10.013s and dtEb=10s, then the next energy balance will be calculated at t>=20s) write ( * , * ) \"time, time next EB\" , timee , tnextEB do n = 1 , nfcts fachfi ( n ) = 0. facefi ( n ) = 0. end do end if !myid==0 write ( * , * ) \"bcasting facT\" call MPI_BCAST ( facT ( 0 : nfcts , 1 : nwalllayers + 1 ), ( nwalllayers + 1 ) * ( nfcts + 1 ), MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( tnextEB , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facqsat ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facf ( 0 : nfcts , 1 : 5 ), ( nfcts + 1 ) * 5 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( fachurel ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facwsoil ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) end if !time>tnextEB end subroutine EB","tags":"","loc":"proc/eb.html"},{"title":"initdriver – uDALES","text":"public subroutine initdriver() Uses modglobal modfields modmpi proc~~initdriver~~UsesGraph proc~initdriver initdriver module~modmpi modmpi proc~initdriver->module~modmpi module~modfields modfields proc~initdriver->module~modfields module~modglobal modglobal proc~initdriver->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~initdriver~~CalledByGraph proc~initdriver initdriver proc~startup startup proc~startup->proc~initdriver program~dalesurban DALESURBAN program~dalesurban->proc~startup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code initdriver Source Code subroutine initdriver use modglobal , only : ih , ib , ie , jh , jb , je , kb , ke , kh , jhc , khc , idriver , iplane , xf , lstoreplane , nstore , Uinf , ltempeq , lmoist , pi , zf , zh , driverstore , tdriverstart , tdriverdump , timeleft , dtdriver , nsv , timee use modfields , only : um use modmpi , only : myid , nprocs implicit none real :: pfi , epsi integer :: k if ( idriver == 1 ) then if ( tdriverstart < timee ) then write ( 0 , * ) 'ERROR: tdriverstart must be greater than the elapsed time at the start of the simulation' stop 1 end if tdriverdump = tdriverstart endif if ( idriver == 1 ) then allocate ( storetdriver ( 1 : driverstore )) allocate ( storeu0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storeumdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storev0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storevmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storew0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storewmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) !allocate(storee120driver(jb-jh:je+jh,kb-kh:ke+kh,1:driverstore)) !allocate(storee12mdriver(jb-jh:je+jh,kb-kh:ke+kh,1:driverstore)) if ( ltempeq ) then allocate ( storethl0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storethlmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) end if if ( lmoist ) then allocate ( storeqt0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storeqtmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) end if if ( nsv > 0 ) then allocate ( storesv0driver ( jb - jhc : je + jhc , kb - khc : ke + khc , 1 : nsv , 1 : driverstore )) allocate ( storesvmdriver ( jb - jhc : je + jhc , kb - khc : ke + khc , 1 : nsv , 1 : driverstore )) end if irecydriver = iplane !+ib        ! index of recycle plane from driver simulation equals iplane (read from namoptions) else if ( idriver == 2 ) then allocate ( storetdriver ( 1 : driverstore )) allocate ( storeu0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storeumdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storev0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storevmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storew0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storewmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) !allocate(storee120driver(jb-jh:je+jh,kb-kh:ke+kh,1:driverstore)) !allocate(storee12mdriver(jb-jh:je+jh,kb-kh:ke+kh,1:driverstore)) allocate ( u0driver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( v0driver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( w0driver ( jb - jh : je + jh , kb - kh : ke + kh )) !allocate(e120driver(jb-jh:je+jh,kb-kh:ke+kh)) allocate ( umdriver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( vmdriver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( wmdriver ( jb - jh : je + jh , kb - kh : ke + kh )) !allocate(e12mdriver(jb-jh:je+jh,kb-kh:ke+kh)) if ( ltempeq ) then allocate ( storethl0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storethlmdriver ( jb - jh : je + kh , kb - kh : ke + kh , 1 : driverstore )) allocate ( thl0driver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( thlmdriver ( jb - jh : je + jh , kb - kh : ke + kh )) end if if ( lmoist ) then allocate ( storeqt0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storeqtmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( qt0driver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qtmdriver ( jb - jh : je + jh , kb - kh : ke + kh )) end if if ( nsv > 0 ) then allocate ( storesv0driver ( jb - jhc : je + jhc , kb - khc : ke + khc , 1 : nsv , 1 : driverstore )) allocate ( storesvmdriver ( jb - jhc : je + jhc , kb - khc : ke + khc , 1 : nsv , 1 : driverstore )) allocate ( sv0driver ( jb - jhc : je + jhc , kb - khc : ke + khc , 1 : nsv )) allocate ( svmdriver ( jb - jhc : je + jhc , kb - khc : ke + khc , 1 : nsv )) end if irecydriver = iplane !+ib else return end if end subroutine initdriver","tags":"","loc":"proc/initdriver.html"},{"title":"drivergen – uDALES","text":"public subroutine drivergen() Uses modglobal modfields modsave modmpi proc~~drivergen~~UsesGraph proc~drivergen drivergen module~modmpi modmpi proc~drivergen->module~modmpi module~modsave modsave proc~drivergen->module~modsave module~modfields modfields proc~drivergen->module~modfields module~modglobal modglobal proc~drivergen->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~drivergen~~CallsGraph proc~drivergen drivergen proc~writedriverfile writedriverfile proc~drivergen->proc~writedriverfile Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~drivergen~~CalledByGraph proc~drivergen drivergen proc~readinitfiles readinitfiles proc~readinitfiles->proc~drivergen proc~boundary boundary proc~readinitfiles->proc~boundary proc~boundary->proc~drivergen proc~startup startup proc~startup->proc~readinitfiles program~dalesurban DALESURBAN program~dalesurban->proc~boundary program~dalesurban->proc~startup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code drivergen Source Code subroutine drivergen use modglobal , only : ib , ie , jb , je , jgb , jge , kb , ke , zf , zh , dzf , dzhi , timee , btime , totavtime , rk3step ,& dt , numol , iplane , lles , idriver , inletav , runavtime , Uinf , lwallfunc , linletRA ,& totinletav , lstoreplane , nstore , driverstore , prandtlmoli , numol , grav , lbuoyancy ,& lfixinlet , lfixutauin , tdriverstart , dtdriver , tdriverdump , ltempeq , lmoist , nsv use modfields , only : u0 , v0 , w0 , e120 , thl0 , qt0 , wm , uprof use modsave , only : writerestartfiles use modmpi , only : slabsum , myid implicit none real :: inlrec ! time of last inlet record real :: elapsrec ! time elapsed in this inlet record real :: dtint ! dt for linear interpolation REAL * 8 , PARAMETER :: eps = 1 d - 3 integer i , j , k , kk , kdamp , x if ( idriver == 1 ) then ! if (.not. (rk3step==3)) return if (. not . ( timee >= tdriverstart )) return if (. not . ( timee >= tdriverdump )) return if ( nstepreaddriver >= driverstore ) return if ( nstepreaddriver == 0 ) then ! tdriverdump = timee tdriverdump = tdriverstart ! tdriverstart = timee   !Update tdriverstart to the actual recorded value if (( myid == 0 ) . and . ( rk3step == 3 )) then write ( 6 , * ) '==================================================================' write ( 6 , * ) '*** Starting to write data for driver simulation ***' write ( 6 , * ) 'Driver recording variables:' write ( 6 , '(A,F9.2,A,I4,A,F12.9)' ) ' Starting time: ' , tdriverdump , ' Stored time steps: ' , driverstore , '     Inlet record intervals: ' , dtdriver write ( 6 , * ) '==================================================================' end if end if if ( rk3step == 3 ) then nstepreaddriver = nstepreaddriver + 1 tdriverdump = tdriverdump + dtdriver ! storetinlet(nstepreaddriver) = timee - tdriverstart call writedriverfile end if elseif ( idriver == 2 ) then ! if (.not. rk3step==1) return if ( timee > maxval ( storetdriver )) then if ( myid == 0 ) then write ( 0 , '(A,F9.2,A,F9.2)' ) 'timee: ' , timee , '     Final inlet driver time:' , maxval ( storetdriver ) write ( 0 , '(A,I4,A,I4)' ) 'Inlet driver step: ' , nstepreaddriver , '     Total inlet driver steps:' , driverstore end if stop 'Time in simulation has exceeded the inlet information - no more inlet data available!' end if x = minloc ( abs ( storetdriver - timee ), 1 ) elapsrec = storetdriver ( x ) - timee if ( myid == 0 ) then ! if(rk3step==1) then ! write(6,*) '============ Inlet interpolating =============' ! write(6,*) 'Inlet interpolation time = ', elapsrec ! write(6,'(A,F9.4)') 'Inlet driver time stamp (x)  = ', storetdriver(x) ! write(6,'(A,F9.4)') 'Inlet driver time stamp (x+1) = ', storetdriver(x+1) ! write(6,'(A,F9.4)') 'Inlet driver time stamp (x-1) = ', storetdriver(x-1) ! write(6,'(A,E20.12)') 'Reading driver velocity: storeu0driver(je,ke,x) = ', storeu0driver(je,ke,x) ! write(6,*) 'Inlet step = ',nstepreaddriver ! end if end if if ( abs ( elapsrec ) < eps ) then if (( myid == 0 ) . and . ( rk3step == 1 )) then write ( * , '(A,I5,A,F10.3,A)' ) '======= Inputs loaded from driver tstep ' , x , ' (at ' , storetdriver ( x ), 's) =======' end if u0driver (:,:) = storeu0driver (:,:, x ) v0driver (:,:) = storev0driver (:,:, x ) w0driver (:,:) = storew0driver (:,:, x ) !e120driver(:,:) = storee120driver(:,:,x) if ( ltempeq ) then thl0driver (:,:) = storethl0driver (:,:, x ) end if if ( lmoist ) then qt0driver (:,:) = storeqt0driver (:,:, x ) end if if ( nsv > 0 ) then sv0driver (:,:,:) = storesv0driver (:,:,:, x ) end if nstepreaddriver = x elseif (( elapsrec > 0. ) . and . ( x == 1 )) then if (( myid == 0 ) . and . ( rk3step == 1 )) then write ( * , '(A,F10.3,A)' ) '======= Inputs loaded from the proceeding driver tstep 1 (at ' , storetdriver ( x ), 's) =======' end if u0driver (:,:) = storeu0driver (:,:, x ) v0driver (:,:) = storev0driver (:,:, x ) w0driver (:,:) = storew0driver (:,:, x ) ! e120driver(:,:) = storee120driver(:,:,x) if ( ltempeq ) then thl0driver (:,:) = storethl0driver (:,:, x ) end if if ( lmoist ) then qt0driver (:,:) = storeqt0driver (:,:, x ) end if if ( nsv > 0 ) then sv0driver (:,:,:) = storesv0driver (:,:,:, x ) end if nstepreaddriver = x elseif ( elapsrec < 0. ) then if (( myid == 0 ) . and . ( rk3step == 1 )) then write ( * , '(A,I5,A,F10.3,A,I5,A,F10.3,A)' ) '======= Inputs interpolated from driver tsteps ' , x , ' (' , storetdriver ( x ), ' s) and ' , x + 1 , ' (' , storetdriver ( x + 1 ), ' s) =======' end if dtint = ( timee - storetdriver ( x )) / ( storetdriver ( x + 1 ) - storetdriver ( x )) ! if(myid==0) then ! write(6,'(A,I4)') 'x: ', x ! write(6,'(A,F9.4)') 'dtint: ', dtint ! write(6,'(A,E20.12)') 'storeu0driver(1,32,x): ', storeu0driver(1,32,x) ! write(6,'(A,E20.12)') 'storeu0driver(1,32,x+1): ', storeu0driver(1,32,x+1) ! write(6,'(A,E20.12)') 'u0driver(1,32): ',  storeu0driver(1,32,x) + (storeu0driver(1,32,x+1)-storeu0driver(1,32,x))*dtint ! end if u0driver (:,:) = storeu0driver (:,:, x ) + ( storeu0driver (:,:, x + 1 ) - storeu0driver (:,:, x )) * dtint v0driver (:,:) = storev0driver (:,:, x ) + ( storev0driver (:,:, x + 1 ) - storev0driver (:,:, x )) * dtint w0driver (:,:) = storew0driver (:,:, x ) + ( storew0driver (:,:, x + 1 ) - storew0driver (:,:, x )) * dtint ! e120driver(:,:) = storee120driver(:,:,x) + (storee120driver(:,:,x+1)-storee120driver(:,:,x))*dtint if ( ltempeq ) then thl0driver (:,:) = storethl0driver (:,:, x ) + ( storethl0driver (:,:, x + 1 ) - storethl0driver (:,:, x )) * dtint end if if ( lmoist ) then qt0driver (:,:) = storeqt0driver (:,:, x ) + ( storeqt0driver (:,:, x + 1 ) - storeqt0driver (:,:, x )) * dtint end if if ( nsv > 0 ) then sv0driver (:,:,:) = storesv0driver (:,:,:, x ) + ( storesv0driver (:,:,:, x + 1 ) - storesv0driver (:,:,:, x )) * dtint end if nstepreaddriver = x elseif ( elapsrec > 0. ) then if (( myid == 0 ) . and . ( rk3step == 1 )) then write ( * , '(A,I5,A,F10.3,A,I5,A,F10.3,A)' ) '======= Inputs interpolated from driver tsteps ' , x , ' (' , storetdriver ( x ), ' s) and ' , x - 1 , ' (' , storetdriver ( x - 1 ), ' s) =======' end if dtint = ( timee - storetdriver ( x - 1 )) / ( storetdriver ( x ) - storetdriver ( x - 1 )) u0driver (:,:) = storeu0driver (:,:, x - 1 ) + ( storeu0driver (:,:, x ) - storeu0driver (:,:, x - 1 )) * dtint v0driver (:,:) = storev0driver (:,:, x - 1 ) + ( storev0driver (:,:, x ) - storev0driver (:,:, x - 1 )) * dtint w0driver (:,:) = storew0driver (:,:, x - 1 ) + ( storew0driver (:,:, x ) - storew0driver (:,:, x - 1 )) * dtint ! e120driver(:,:) = storee120driver(:,:,x-1) + (storee120driver(:,:,x)-storee120driver(:,:,x-1))*dtint if ( ltempeq ) then thl0driver (:,:) = storethl0driver (:,:, x - 1 ) + ( storethl0driver (:,:, x ) - storethl0driver (:,:, x - 1 )) * dtint end if if ( lmoist ) then qt0driver (:,:) = storeqt0driver (:,:, x - 1 ) + ( storeqt0driver (:,:, x ) - storeqt0driver (:,:, x - 1 )) * dtint end if if ( nsv > 0 ) then sv0driver (:,:,:) = storesv0driver (:,:,:, x - 1 ) + ( storesv0driver (:,:,:, x ) - storesv0driver (:,:,:, x - 1 )) * dtint end if nstepreaddriver = x end if ! if(myid==0) then ! write(6,'(A,F9.4)') 'Simulation time: ', timee ! write(6,'(A,F9.4)') 'dtint: ', dtint ! write(6,*) 'Velocities interpolated:' ! write(6,'(A,e20.12)') 'storeu0driver(je,ke,x-1): ', storeu0driver(je,ke,x-1) ! write(6,'(A,e20.12)') 'storeu0driver(je,ke,x): ', storeu0driver(je,ke,x) ! write(6,'(A,e20.12)') 'storeu0driver(je,ke,x+1): ', storeu0driver(je,ke,x+1) ! write(6,'(A,e20.12)') 'Interpolated inlet velocity (jb,20): ', u0driver(jb,20) ! write(6,*) 'Temperatures interpolated:' ! write(6,'(A,e20.12)') 'storethl0driver(je,20,x-1): ', storethl0driver(jb,20,x-1) ! write(6,'(A,e20.12)') 'storethl0driver(je,20,x): ', storethl0driver(jb,20,x) ! write(6,'(A,e20.12)') 'storethl0driver(je,20,x+1): ', storethl0driver(jb,20,x+1) ! write(6,'(A,e20.12)') 'Interpolated inlet temperature (jb,20): ', thl0driver(jb,20) ! end if ! umdriver = u0driver   ! MAYBE ITS BETTER TO WRITE THE M VARIABLES TO FILE TOO AND JUST READ THEM - THOUGH CURRENTLY THIS IS NOT DONE FOR RESTART FILES?? ae1212 ! vmdriver = v0driver   ! EDIT READ AND WRITE INLET FILES (AND CHECK MODBOUNDARY & MODSURFACE) TO INCLUDE M VARIABLES ! wmdriver = w0driver ! thlmdriver = thl0driver ! qtmdriver = qt0driver if ( rk3step == 1 ) then umdriver = u0driver vmdriver = v0driver wmdriver = w0driver !e12mdriver = e120driver if ( ltempeq ) then thlmdriver = thl0driver end if if ( lmoist ) then qtmdriver = qt0driver end if if ( nsv > 0 ) then svmdriver = sv0driver end if end if else return end if ! idrivergen end subroutine drivergen","tags":"","loc":"proc/drivergen.html"},{"title":"writedriverfile – uDALES","text":"public subroutine writedriverfile() Uses modglobal modfields modmpi modinletdata proc~~writedriverfile~~UsesGraph proc~writedriverfile writedriverfile module~modmpi modmpi proc~writedriverfile->module~modmpi module~modinletdata modinletdata proc~writedriverfile->module~modinletdata module~modfields modfields proc~writedriverfile->module~modfields module~modglobal modglobal proc~writedriverfile->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~writedriverfile~~CalledByGraph proc~writedriverfile writedriverfile proc~drivergen drivergen proc~drivergen->proc~writedriverfile proc~readinitfiles readinitfiles proc~readinitfiles->proc~drivergen proc~boundary boundary proc~readinitfiles->proc~boundary proc~boundary->proc~drivergen proc~startup startup proc~startup->proc~readinitfiles program~dalesurban DALESURBAN program~dalesurban->proc~boundary program~dalesurban->proc~startup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code writedriverfile Source Code subroutine writedriverfile use modglobal , only : timee , tdriverstart , ib , ie , ih , jb , je , jh , kb , ke , kh , cexpnr , ifoutput , nstore , ltempeq , lmoist , driverstore , nsv use modfields , only : u0 , v0 , w0 , e120 , thl0 , qt0 , um , sv0 use modmpi , only : cmyid , myid use modinletdata , only : storetdriver , storeu0driver , storev0driver , storew0driver , storethl0driver , storeqt0driver ,& storesv0driver , nfile , nstepreaddriver implicit none integer :: fileid , IOS integer :: i , j , k , n integer :: filesizet , filesizev , filesizetest1 , filesizetest2 , filesizes character ( 15 ) :: name logical :: lexist real , allocatable :: arraysizetest (:,:) allocate ( arraysizetest ( jb - jh : je + jh , kb - kh : ke + kh )) inquire ( iolength = filesizet )( timee - tdriverstart ) ! inquire(iolength=filesizetest1)(timee) ! inquire(iolength=filesizetest2)u0(1,1,1) inquire ( iolength = filesizev ) u0 ( irecydriver ,:,:) inquire ( iolength = filesizes ) sv0 ( irecydriver ,:,:,:) !! ! if((myid==0) .and. (nstepreaddriver==1)) then ! write(6,*) 'inquire iolength ', filesizet ! write(6,*) 'inquire iolength test', filesizetest1 ! write(6,*) 'inquire iolength test u', filesizetest2 ! end if ! inquire(iolength=filesizetest1)arraysizetest(:,:) ! filesizetest2 = (je-jb+2*jh)*(ke-kb+2*kh) ! if((myid==0) .and. (nstepreaddriver==1)) then ! write(6,*) 'je,jb,jh,ke,kb,kh', je,jb,jh,ke,kb,kh ! write(6,*) 'inquire iolength test 1 ', filesizetest1 ! write(6,*) 'inquire iolength test 2', filesizetest2 ! write(6,*) 'inquire iolength', filesizev ! end if if ( myid == 0 ) then write ( 6 , * ) '============ Writing driver files ============' write ( * , * ) 'Driver timestep: ' , nstepreaddriver end if if ( myid == 0 ) then name = 'tdriver_   .' name ( 9 : 11 ) = cmyid name ( 13 : 15 ) = cexpnr ! name(15:18)= '.txt' inquire ( file = name , exist = lexist ) if ( lexist ) then ! write(6,*) 'Writing Time stamp to file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , access = 'direct' , recl = filesizet , action = 'write' ) else ! write(6,*) 'Creating Time stamp driver file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'replace' , access = 'direct' , recl = filesizet , action = 'write' , IOSTAT = IOS ) ! if (IOS > 0) then ! write(6,*) 'IOS = ',IOS ! endif end if ! write(*,*) 'filesizet', filesizet ! write(ifoutput)  ( storetdriver (n),  n=1,nstore) ! write(6,'(A,F9.2)') 'Writing time stamp to file: ', timee-tdriverstart write ( 11 , rec = nstepreaddriver ) ( timee - tdriverstart ) close ( unit = 11 ) write ( * , * ) 'Driver time:' , timee - tdriverstart end if name = 'udriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cmyid name ( 13 : 15 ) = cexpnr ! name(15:18)= '.txt' inquire ( file = name , exist = lexist ) if ( lexist ) then ! write(6,*) 'Writing Inlet u-velocity to file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , access = 'direct' , recl = filesizev , action = 'write' ) else ! write(6,*) 'Creating Inlet u-velocity inlet file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'replace' , access = 'direct' , recl = filesizev , action = 'write' ) end if ! write(ifoutput)  (((storeu0driver (j,k,n),j=jb,je),k=kb,ke),  n=1,nstore) ! Nested implied do-loop !if(myid==0) then !write(6,'(A,e20.12)') 'Writing u0 to file. u0(irecydriver,je,ke)', u0(irecydriver,je,ke) !write(6,'(A,e20.12)') 'u0(irecydriver,jb,kb)', u0(irecydriver,jb,kb) !write(6,'(A,e20.12)') 'Writing thl0 to file. thl0(irecydriver-1,je,ke)', thl0(irecydriver-1,je,ke) !write(6,'(A,e20.12)') 'thl0(irecydriver-1,jb,kb)', thl0(irecydriver-1,jb,kb) ! write(6,*) 'irecydriver, je, ke, ib, jb, kb', irecydriver, je, ke, ib, jb, kb !end if write ( 11 , rec = nstepreaddriver ) ( u0 ( irecydriver ,:,:)) close ( unit = 11 ) name = 'vdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cmyid name ( 13 : 15 ) = cexpnr ! name(15:18)= '.txt' inquire ( file = name , exist = lexist ) if ( lexist ) then ! write(6,*) 'Writing Inlet v-velocity to file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'write' , access = 'direct' , recl = filesizev ) else ! write(6,*) 'Creating v-velocity inlet file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'replace' , access = 'direct' , recl = filesizev , action = 'write' ) end if ! write(ifoutput)  (((storev0driver (j,k,n),j=jb,je),k=kb,ke),  n=1,nstore) ! '(F8.4)' write ( 11 , rec = nstepreaddriver ) ( v0 ( irecydriver ,:,:)) !tg3315 removed irecydriver-1 close ( unit = 11 ) name = 'wdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cmyid name ( 13 : 15 ) = cexpnr ! name(15:18)= '.txt' inquire ( file = name , exist = lexist ) if ( lexist ) then ! write(6,*) 'Writing Inlet w-velocity to file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'write' , access = 'direct' , recl = filesizev ) else ! write(6,*) 'Creating w-velocity inlet file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'replace' , access = 'direct' , recl = filesizev , action = 'write' ) end if ! write(ifoutput)  (((storew0driver (j,k,n),j=jb,je),k=kb,ke+1),n=1,nstore) write ( 11 , rec = nstepreaddriver ) ( w0 ( irecydriver ,:,:)) !tg3315 removed irecydriver-1 close ( unit = 11 ) ! name = 'edriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile ! name(9:11)= cmyid ! name(13:15)= cexpnr ! name(15:18)= '.txt' ! inquire(file=name,exist=lexist) ! if (lexist) then ! write(6,*) 'Writing Inlet w-velocity to file: ', name ! open(unit=11,file=name,form='unformatted',status='old',action='write',access='direct',recl=filesizev) ! else ! write(6,*) 'Creating w-velocity inlet file: ', name ! open(unit=11,file=name,form='unformatted',status='replace',access='direct',recl=filesizev,action='write') ! end if ! write(ifoutput)  (((storew0driver (j,k,n),j=jb,je),k=kb,ke+1),n=1,nstore) ! write(11,rec=nstepreaddriver)  (e120(irecydriver,:,:)) !tg3315 removed irecydriver-1 ! close (unit=11) if ( ltempeq ) then name = 'hdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cmyid name ( 13 : 15 ) = cexpnr ! name(15:18)= '.txt' inquire ( file = name , exist = lexist ) if ( lexist ) then ! write(6,*) 'Writing Inlet temperature to file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'write' , access = 'direct' , recl = filesizev ) else ! write(6,*) 'Creating temperature inlet file: ', name ! write(6,*) 'Creating w-velocity inlet file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'replace' , access = 'direct' , recl = filesizev , action = 'write' ) end if ! write(ifoutput)  (((storew0driver (j,k,n),j=jb,je),k=kb,ke+1),n=1,nstore) write ( 11 , rec = nstepreaddriver ) ( thl0 ( irecydriver ,:,:)) !tg3315 removed irecydriver-1 close ( unit = 11 ) end if if ( lmoist ) then name = 'qdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cmyid name ( 13 : 15 ) = cexpnr ! name(15:18)= '.txt' inquire ( file = name , exist = lexist ) if ( lexist ) then ! write(6,*) 'Writing Inlet temperature to file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'write' , access = 'direct' , recl = filesizev ) else ! write(6,*) 'Creating temperature inlet file: ', name ! write(6,*) 'Creating w-velocity inlet file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'replace' , access = 'direct' , recl = filesizev , action = 'write' ) end if ! write(ifoutput)  (((storew0driver (j,k,n),j=jb,je),k=kb,ke+1),n=1,nstore) write ( 11 , rec = nstepreaddriver ) ( qt0 ( irecydriver ,:,:)) !tg3315 removed irecydriver-1 close ( unit = 11 ) end if if ( nsv > 0 ) then name = 'sdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cmyid name ( 13 : 15 ) = cexpnr ! name(15:18)= '.txt' inquire ( file = name , exist = lexist ) if ( lexist ) then ! write(6,*) 'Writing Inlet temperature to file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'write' , access = 'direct' , recl = filesizes ) else ! write(6,*) 'Creating temperature inlet file: ', name ! write(6,*) 'Creating w-velocity inlet file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'replace' , access = 'direct' , recl = filesizes , action = 'write' ) end if ! write(ifoutput)  (((storew0driver (j,k,n),j=jb,je),k=kb,ke+1),n=1,nstore) write ( 11 , rec = nstepreaddriver ) ( sv0 ( irecydriver ,:,:,:)) !tg3315 removed irecydriver-1 close ( unit = 11 ) end if end subroutine writedriverfile","tags":"","loc":"proc/writedriverfile.html"},{"title":"readdriverfile – uDALES","text":"public subroutine readdriverfile() Uses modfields modglobal modmpi modinletdata proc~~readdriverfile~~UsesGraph proc~readdriverfile readdriverfile module~modmpi modmpi proc~readdriverfile->module~modmpi module~modinletdata modinletdata proc~readdriverfile->module~modinletdata module~modfields modfields proc~readdriverfile->module~modfields module~modglobal modglobal proc~readdriverfile->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~readdriverfile~~CalledByGraph proc~readdriverfile readdriverfile proc~readinitfiles readinitfiles proc~readinitfiles->proc~readdriverfile proc~startup startup proc~startup->proc~readinitfiles program~dalesurban DALESURBAN program~dalesurban->proc~startup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code readdriverfile Source Code subroutine readdriverfile use modfields , only : u0 , sv0 use modglobal , only : ib , jb , je , jmax , kb , ke , kh , jhc , khc , cexpnr , ifinput , driverstore , ltempeq , lmoist , zh , jgb , jge , jh , driverjobnr , nsv , timee , tdriverstart use modmpi , only : cmyid , myid , nprocs , slabsum , excjs use modinletdata , only : storetdriver , storeu0driver , storev0driver , storew0driver , storethl0driver , storeqt0driver , storesv0driver , nfile implicit none integer :: filen , filee integer :: fileid , IOS , filesize , filesizes integer :: j , k , m , n , js , jf , jfdum , jsdum character ( 24 ) :: name if ( myid == 0 ) then write ( * , * ) '========================================================================' write ( * , * ) '*** Reading precursor driver simulation ***' end if name = 'tdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = '000' ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr inquire ( file = name , size = filesize ) if ( myid == 0 ) then write ( 6 , * ) 'Reading time stamps: ' , name write ( 6 , * ) 'driverstore: ' , driverstore write ( 6 , * ) 'File size of time in bytes (/8) = ' , filesize endif ! driverstore = driverstore/4. ! write(6,*) 'driverstore: ', driverstore inquire ( iolength = filesize )( timee - tdriverstart ) open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize , IOSTAT = IOS ) if ( myid == 0 ) then if ( IOS > 0 ) then write ( 6 , * ) 'IOS = ' , IOS endif endif do n = 1 , driverstore read ( 11 , rec = n , IOSTAT = IOS ) storetdriver ( n ) if ( myid == 0 ) then if ( IOS > 0 ) then write ( 6 , * ) 'IOS = ' , IOS elseif ( IOS < 0 ) then write ( 6 , * ) 'n =' , n end if write ( 6 , '(A,e20.12)' ) ' Reading t:' , storetdriver ( n ) end if end do storetdriver = storetdriver + timee !tg3315 added in case using a warmstart... close ( unit = 11 ) ! write(*,*) 'storetdriver', storetdriver ! end if name = 'udriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cmyid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr write ( 6 , * ) 'Reading Driver u-velocity: ' , name ! inquire(file=name,recl=filesize) inquire ( iolength = filesize ) u0 ( ib ,:,:) write ( 6 , * ) 'record length ' , filesize open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize ) do n = 1 , driverstore read ( 11 , rec = n ) (( storeu0driver ( j , k , n ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) ! if(myid==0) then ! write(6, '(A,e20.12)') 'Reading u(irecydriver, jb, kb)', storeu0driver(jb,kb,n) ! endif end do ! if(myid==0) then ! do k=ke,kb,-1 !   write(6, '(A,e20.12)') 'Reading u(ib,1,:)', storeu0driver(jb,k,1) ! end do ! end if close ( unit = 11 ) name = 'vdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cmyid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr write ( 6 , * ) 'Reading Driver v-velocity: ' , name ! inquire(file=name,recl=filesize) ! inquire(iolength=filesize)u0(ib,:,:) open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize ) do n = 1 , driverstore read ( 11 , rec = n ) (( storev0driver ( j , k , n ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) end do close ( unit = 11 ) name = 'wdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cmyid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr write ( 6 , * ) 'Reading Driver w-velocity: ' , name ! inquire(file=name,recl=filesize) ! inquire(iolength=filesize)u0(ib,:,:) open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize ) do n = 1 , driverstore read ( 11 , rec = n ) (( storew0driver ( j , k , n ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) end do close ( unit = 11 ) !name = 'edriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile ! name(9:11)= cmyid ! write (name(18:20)  ,'(i3.3)') filen ! write (name(13:15)   ,'(i3.3)') driverjobnr ! write(6,*) 'Reading Driver turbulent kinetic energy: ', name ! inquire(file=name,recl=filesize) ! inquire(iolength=filesize)u0(ib,:,:) ! open(unit=11,file=name,form='unformatted',status='old',action='read',access='direct',recl=filesize) ! do n = 1,driverstore ! read(11,rec=n)  ((storee120driver (j,k,n),j=jb-jh,je+jh),k=kb-kh,ke+kh) ! enddo ! close (unit=11) if ( ltempeq ) then name = 'hdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cmyid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr write ( 6 , * ) 'Reading Driver temperature: ' , name ! inquire(file=name,recl=filesize) open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize ) do n = 1 , driverstore read ( 11 , rec = n ) (( storethl0driver ( j , k , n ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) end do !if(myid==0) then !  do k=ke,kb,-1 !    write(6, '(A,e20.12)') 'Reading thl0(ib,1,:)', storethl0driver(jb,k,1) !  end do !end if close ( unit = 11 ) end if if ( lmoist ) then name = 'qdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cmyid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr write ( 6 , * ) 'Reading Driver moisture: ' , name ! inquire(file=name,recl=filesize) open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize ) do n = 1 , driverstore read ( 11 , rec = n ) (( storeqt0driver ( j , k , n ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) end do close ( unit = 11 ) end if if ( nsv > 0 ) then name = 'sdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cmyid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr write ( 6 , * ) 'Reading Driver scalar: ' , name ! inquire(file=name,recl=filesize) inquire ( iolength = filesizes ) sv0 ( ib ,:,:,:) open ( unit = 12 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesizes ) do n = 1 , driverstore read ( 12 , rec = n ) ((( storesv0driver ( j , k , m , n ), j = jb - jhc , je + jhc ), k = kb - khc , ke + khc ), m = 1 , nsv ) end do close ( unit = 12 ) end if end subroutine readdriverfile","tags":"","loc":"proc/readdriverfile.html"},{"title":"exitdriver – uDALES","text":"public subroutine exitdriver() Uses modglobal proc~~exitdriver~~UsesGraph proc~exitdriver exitdriver module~modglobal modglobal proc~exitdriver->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Contents Source Code exitdriver Source Code subroutine exitdriver use modglobal , only : idriver , lstoreplane , ltempeq , lmoist , nsv if ( idriver == 1 ) then if ( lstoreplane ) then deallocate ( storetdriver , storeu0driver , storev0driver , storew0driver ) !,storee120driver) if ( ltempeq ) then deallocate ( storethl0driver ) end if if ( lmoist ) then deallocate ( storeqt0driver ) end if if ( nsv > 0 ) then deallocate ( storesv0driver ) end if end if else if ( idriver == 2 ) then deallocate ( storetdriver , storeu0driver , storev0driver , storew0driver , u0driver , v0driver , w0driver ) !,e120driver,storee120driver) if ( ltempeq ) then deallocate ( storethl0driver , thl0driver ) end if if ( lmoist ) then deallocate ( storeqt0driver , qt0driver ) end if if ( nsv > 0 ) then deallocate ( storesv0driver , sv0driver ) end if end if end subroutine exitdriver","tags":"","loc":"proc/exitdriver.html"},{"title":"modstatsdump – uDALES","text":"Uses modglobal modmpi module~~modstatsdump~~UsesGraph module~modstatsdump modstatsdump module~modmpi modmpi module~modstatsdump->module~modmpi module~modglobal modglobal module~modstatsdump->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~modstatsdump~~UsedByGraph module~modstatsdump modstatsdump program~dalesurban DALESURBAN program~dalesurban->module~modstatsdump Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ncidy ncidyt ncidtke ncidxy ncidslice ncidxyt nrecy nrecyt nrectke nrecxy nrecslice nrecxyt nstatyt nstaty nstattke nstatxy nstatslice nstatxyt ncidt nrect nstatt yname ytname tkename xyname xytname tname slicename tncstaty tncstatyt tncstattke tncstatxy tncstatslice tncstatxyt tncstatt klow khigh i j k tsamplep tstatsdumpp tsample tstatsdump Subroutines initstatsdump statsdump tkestatsdump exitstatsdump Variables Type Visibility Attributes Name Initial integer, private :: ncidy integer, private :: ncidyt integer, private :: ncidtke integer, private :: ncidxy integer, private :: ncidslice integer, private :: ncidxyt integer, private :: nrecy = 0 integer, private :: nrecyt = 0 integer, private :: nrectke = 0 integer, private :: nrecxy = 0 integer, private :: nrecslice = 0 integer, private :: nrecxyt = 0 integer, private :: nstatyt = 34 integer, private :: nstaty = 14 integer, private :: nstattke = 8 integer, private :: nstatxy = 15 integer, private :: nstatslice = 8 integer, private :: nstatxyt = 23 integer, private :: ncidt integer, private :: nrect = 0 integer, private :: nstatt = 32 character(len=80), private :: yname = 'ydump.xxx.nc' character(len=80), private :: ytname = 'ytdump.xxx.nc' character(len=80), private :: tkename = 'tkedump.xxx.nc' character(len=80), private :: xyname = 'xydump.xxx.nc' character(len=80), private :: xytname = 'xytdump.xxx.nc' character(len=80), private :: tname = 'tdump.xxx.xxx.nc' character(len=80), private :: slicename = 'slicedump.xxx.xxx.nc' character(len=80), private, dimension(1,4) :: tncstaty character(len=80), private, dimension(1,4) :: tncstatyt character(len=80), private, dimension(1,4) :: tncstattke character(len=80), private, dimension(1,4) :: tncstatxy character(len=80), private, dimension(1,4) :: tncstatslice character(len=80), private, dimension(1,4) :: tncstatxyt character(len=80), private, dimension(1,4) :: tncstatt integer, private :: klow integer, private :: khigh integer, private :: i integer, private :: j integer, private :: k real, private :: tsamplep real, private :: tstatsdumpp real, private :: tsample real, private :: tstatsdump Subroutines public subroutine initstatsdump () Arguments None public subroutine statsdump () Arguments None private subroutine tkestatsdump () Arguments None public subroutine exitstatsdump () Arguments None","tags":"","loc":"module/modstatsdump.html"},{"title":"modinletdata – uDALES","text":"Used by module~~modinletdata~~UsedByGraph module~modinletdata modinletdata proc~enthalpythickness enthalpythickness proc~enthalpythickness->module~modinletdata proc~iohi iohi proc~iohi->module~modinletdata proc~iolet iolet proc~iolet->module~modinletdata proc~tstep_integrate tstep_integrate proc~tstep_integrate->module~modinletdata proc~readinitfiles readinitfiles proc~readinitfiles->module~modinletdata module~moddriver moddriver proc~readinitfiles->module~moddriver module~modinlet modinlet proc~readinitfiles->module~modinlet proc~bcpup bcpup proc~bcpup->module~modinletdata module~moddriver->module~modinletdata proc~iosi iosi proc~iosi->module~modinletdata proc~momentumthicknessexp momentumthicknessexp proc~momentumthicknessexp->module~modinletdata proc~inlettop inlettop proc~inlettop->module~modinletdata proc~closure closure proc~closure->module~modinletdata proc~readrestartfiles readrestartfiles proc~readrestartfiles->module~modinletdata proc~readrestartfiles->module~modinlet proc~readdriverfile readdriverfile proc~readdriverfile->module~modinletdata proc~scalrec scalrec proc~scalrec->module~modinletdata proc~boundary boundary proc~boundary->module~modinletdata proc~boundary->module~moddriver proc~boundary->module~modinlet module~modinlet->module~modinletdata proc~ioqi ioqi proc~ioqi->module~modinletdata proc~writerestartfiles writerestartfiles proc~writerestartfiles->module~modinletdata proc~startup startup proc~startup->module~modinletdata proc~startup->module~moddriver proc~startup->module~modinlet proc~initboundary initboundary proc~initboundary->module~modinletdata proc~writedriverfile writedriverfile proc~writedriverfile->module~modinletdata proc~scalsirane scalSIRANE proc~scalsirane->module~modinletdata proc~exitmodules exitmodules proc~exitmodules->module~modinlet Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables storeu0inletbc storev0inletbc storew0inletbc storet0inletbc u0rot v0rot Utav QLtav QTtav Ttav uaver taver u0inletbc v0inletbc w0inletbc t0inletbc u0inletbcold v0inletbcold w0inletbcold t0inletbcold uminletbc vminletbc wminletbc tminletbc Uinl QLinl QTinl Winl Tinl Urec QLrec QTrec Wrec Trec zirf ziif zirh ziih zorf zoif zorh zoih zotr zoti displ displold upupavinl vpvpavinl wpwpavinl upwpavinl thlpthlpavinl thlpupavinl thlpwpavinl qlpqlpavinl qlpupavinl qlpwpavinl qtpqtpavinl qtpupavinl qtpwpavinl zfin zhin dzfin dzhin heavif heavih heavit loclowif locupif loclowih locupih loclowof locupof loclowoh locupoh loclowot locupot linlf linuf linlh linuh di di_test dti_test dr dti dtr thetai thetar thetati thetatr utaui utaur ttaui ttaur lmoi lmor q0 deltat ubulk totalu totaluold ddispdx ddispdxold wtop xfm xf2m dtin elapstep totalreadu iangle iangledeg jgbin jgein jgtotinl jbin jein jtotin jbdum jedum jtotdum filenumstart filenumend filestoread procinlo procinup jend jgend jbeg jgbeg yh yf yhin yfin yhdum yfdum ylocupf yloclowf ylocuph yloclowh dyin irecy nfile nstepread rk3stepin kbin kein nprocsinl inlfactor lzinzsim storeu0driver storev0driver storew0driver storethl0driver storee120driver storeqt0driver storesv0driver storetdriver u0driver v0driver w0driver e120driver tdriver thl0driver qt0driver sv0driver storeumdriver umdriver storevmdriver vmdriver storewmdriver wmdriver storee12mdriver e12mdriver storethlmdriver thlmdriver storeqtmdriver qtmdriver storesvmdriver svmdriver irecydriver nstepreaddriver Variables Type Visibility Attributes Name Initial real, public, allocatable :: storeu0inletbc (:,:,:) real, public, allocatable :: storev0inletbc (:,:,:) real, public, allocatable :: storew0inletbc (:,:,:) real, public, allocatable :: storet0inletbc (:,:,:) real, public, allocatable :: u0rot (:,:,:) real, public, allocatable :: v0rot (:,:,:) real, public, allocatable :: Utav (:,:) real, public, allocatable :: QLtav (:,:) real, public, allocatable :: QTtav (:,:) real, public, allocatable :: Ttav (:,:) real, public, allocatable :: uaver (:,:) real, public, allocatable :: taver (:,:) real, public, allocatable :: u0inletbc (:,:) real, public, allocatable :: v0inletbc (:,:) real, public, allocatable :: w0inletbc (:,:) real, public, allocatable :: t0inletbc (:,:) real, public, allocatable :: u0inletbcold (:,:) real, public, allocatable :: v0inletbcold (:,:) real, public, allocatable :: w0inletbcold (:,:) real, public, allocatable :: t0inletbcold (:,:) real, public, allocatable :: uminletbc (:,:) real, public, allocatable :: vminletbc (:,:) real, public, allocatable :: wminletbc (:,:) real, public, allocatable :: tminletbc (:,:) real, public, allocatable :: Uinl (:) real, public, allocatable :: QLinl (:) real, public, allocatable :: QTinl (:) real, public, allocatable :: Winl (:) real, public, allocatable :: Tinl (:) real, public, allocatable :: Urec (:) real, public, allocatable :: QLrec (:) real, public, allocatable :: QTrec (:) real, public, allocatable :: Wrec (:) real, public, allocatable :: Trec (:) real, public, allocatable :: zirf (:) real, public, allocatable :: ziif (:) real, public, allocatable :: zirh (:) real, public, allocatable :: ziih (:) real, public, allocatable :: zorf (:) real, public, allocatable :: zoif (:) real, public, allocatable :: zorh (:) real, public, allocatable :: zoih (:) real, public, allocatable :: zotr (:) real, public, allocatable :: zoti (:) real, public, allocatable :: displ (:) real, public, allocatable :: displold (:) real, public, allocatable :: upupavinl (:) real, public, allocatable :: vpvpavinl (:) real, public, allocatable :: wpwpavinl (:) real, public, allocatable :: upwpavinl (:) real, public, allocatable :: thlpthlpavinl (:) real, public, allocatable :: thlpupavinl (:) real, public, allocatable :: thlpwpavinl (:) real, public, allocatable :: qlpqlpavinl (:) real, public, allocatable :: qlpupavinl (:) real, public, allocatable :: qlpwpavinl (:) real, public, allocatable :: qtpqtpavinl (:) real, public, allocatable :: qtpupavinl (:) real, public, allocatable :: qtpwpavinl (:) real, public, allocatable :: zfin (:) real, public, allocatable :: zhin (:) real, public, allocatable :: dzfin (:) real, public, allocatable :: dzhin (:) real, public, allocatable :: heavif (:) real, public, allocatable :: heavih (:) real, public, allocatable :: heavit (:) integer, public, allocatable :: loclowif (:) integer, public, allocatable :: locupif (:) integer, public, allocatable :: loclowih (:) integer, public, allocatable :: locupih (:) integer, public, allocatable :: loclowof (:) integer, public, allocatable :: locupof (:) integer, public, allocatable :: loclowoh (:) integer, public, allocatable :: locupoh (:) integer, public, allocatable :: loclowot (:) integer, public, allocatable :: locupot (:) integer, public, allocatable :: linlf (:) integer, public, allocatable :: linuf (:) integer, public, allocatable :: linlh (:) integer, public, allocatable :: linuh (:) real, public :: di = 0.09 real, public :: di_test real, public :: dti_test real, public :: dr real, public :: dti real, public :: dtr real, public :: thetai real, public :: thetar real, public :: thetati real, public :: thetatr real, public :: utaui real, public :: utaur real, public :: ttaui real, public :: ttaur real, public :: lmoi real, public :: lmor real, public :: q0 real, public :: deltat = 0. real, public :: ubulk = 0. real, public :: totalu = 0. real, public :: totaluold = 0. real, public :: ddispdx = 0. real, public :: ddispdxold = 0. real, public :: wtop = 0. real, public :: xfm real, public :: xf2m real, public :: dtin real, public :: elapstep = 0. real, public :: totalreadu real, public :: iangle real, public :: iangledeg = 0. integer, public :: jgbin integer, public :: jgein integer, public :: jgtotinl integer, public :: jbin integer, public :: jein integer, public :: jtotin integer, public :: jbdum integer, public :: jedum integer, public :: jtotdum integer, public :: filenumstart integer, public :: filenumend integer, public :: filestoread integer, public :: procinlo integer, public :: procinup integer, public :: jend integer, public :: jgend integer, public :: jbeg integer, public :: jgbeg real, public, allocatable :: yh (:) real, public, allocatable :: yf (:) real, public, allocatable :: yhin (:) real, public, allocatable :: yfin (:) real, public, allocatable :: yhdum (:) real, public, allocatable :: yfdum (:) integer, public, allocatable :: ylocupf (:) integer, public, allocatable :: yloclowf (:) integer, public, allocatable :: ylocuph (:) integer, public, allocatable :: yloclowh (:) real, public :: dyin integer, public :: irecy integer, public :: nfile = 0 integer, public :: nstepread = 1 integer, public :: rk3stepin = 1 integer, public :: kbin integer, public :: kein integer, public :: nprocsinl integer, public :: inlfactor logical, public :: lzinzsim = .true. real, public, allocatable :: storeu0driver (:,:,:) real, public, allocatable :: storev0driver (:,:,:) real, public, allocatable :: storew0driver (:,:,:) real, public, allocatable :: storethl0driver (:,:,:) real, public, allocatable :: storee120driver (:,:,:) real, public, allocatable :: storeqt0driver (:,:,:) real, public, allocatable :: storesv0driver (:,:,:,:) real, public, allocatable :: storetdriver (:) real, public, allocatable :: u0driver (:,:) real, public, allocatable :: v0driver (:,:) real, public, allocatable :: w0driver (:,:) real, public, allocatable :: e120driver (:,:) real, public, allocatable :: tdriver (:) real, public, allocatable :: thl0driver (:,:) real, public, allocatable :: qt0driver (:,:) real, public, allocatable :: sv0driver (:,:,:) real, public, allocatable :: storeumdriver (:,:,:) real, public, allocatable :: umdriver (:,:) real, public, allocatable :: storevmdriver (:,:,:) real, public, allocatable :: vmdriver (:,:) real, public, allocatable :: storewmdriver (:,:,:) real, public, allocatable :: wmdriver (:,:) real, public, allocatable :: storee12mdriver (:,:,:) real, public, allocatable :: e12mdriver (:,:) real, public, allocatable :: storethlmdriver (:,:,:) real, public, allocatable :: thlmdriver (:,:) real, public, allocatable :: storeqtmdriver (:,:,:) real, public, allocatable :: qtmdriver (:,:) real, public, allocatable :: storesvmdriver (:,:,:,:) real, public, allocatable :: svmdriver (:,:,:) integer, public :: irecydriver integer, public :: nstepreaddriver = 0","tags":"","loc":"module/modinletdata.html"},{"title":"modglobal – uDALES","text":"Used by module~~modglobal~~UsedByGraph module~modglobal modglobal proc~zwallscalar zwallscalar proc~zwallscalar->module~modglobal module~initfac initfac proc~zwallscalar->module~initfac proc~readzincoord readzincoord proc~readzincoord->module~modglobal proc~fixthetainf fixthetainf proc~fixthetainf->module~modglobal proc~poisson poisson proc~poisson->module~modglobal proc~iolet iolet proc~iolet->module~modglobal proc~grwdamp grwdamp proc~grwdamp->module~modglobal proc~drivergen drivergen proc~drivergen->module~modglobal proc~advecc_upw advecc_upw proc~advecc_upw->module~modglobal proc~calcreyn calcreyn proc~calcreyn->module~modglobal proc~createwalls createwalls proc~createwalls->module~modglobal proc~createwalls->module~initfac proc~diffv diffv proc~diffv->module~modglobal proc~inletgen inletgen proc~inletgen->module~modglobal module~modeb modEB module~modeb->module~modglobal proc~nearwall nearwall proc~nearwall->module~modglobal proc~nearwall->module~initfac proc~genstats genstats proc~genstats->module~modglobal proc~exitfielddump exitfielddump proc~exitfielddump->module~modglobal proc~advecc_2nd advecc_2nd proc~advecc_2nd->module~modglobal proc~advecc_2nd->module~initfac proc~writestat_dims_nc writestat_dims_nc proc~writestat_dims_nc->module~modglobal proc~inletgennotemp inletgennotemp proc~inletgennotemp->module~modglobal proc~fluxtopscal fluxtopscal proc~fluxtopscal->module~modglobal proc~createmasks createmasks proc~createmasks->module~modglobal proc~cyclicqj cyclicqj proc~cyclicqj->module~modglobal proc~initpois initpois proc~initpois->module~modglobal proc~inlettop inlettop proc~inlettop->module~modglobal proc~closure closure proc~closure->module~modglobal proc~initfields initfields proc~initfields->module~modglobal proc~scalrec scalrec proc~scalrec->module~modglobal proc~fluxtop fluxtop proc~fluxtop->module~modglobal proc~valuetopscal valuetopscal proc~valuetopscal->module~modglobal proc~boundary boundary proc~boundary->module~modglobal proc~chem chem proc~chem->module~modglobal proc~coriolis coriolis proc~coriolis->module~modglobal proc~fixuinf1 fixuinf1 proc~fixuinf1->module~modglobal proc~subgridnamelist subgridnamelist proc~subgridnamelist->module~modglobal proc~zinterpolatet zinterpolatet proc~zinterpolatet->module~modglobal proc~blthicknesst blthicknesst proc~blthicknesst->module~modglobal proc~dispthicknessmo dispthicknessmo proc~dispthicknessmo->module~modglobal proc~scalsirane scalSIRANE proc~scalsirane->module~modglobal proc~enthalpythickness enthalpythickness proc~enthalpythickness->module~modglobal proc~diffu diffu proc~diffu->module~modglobal proc~calclw calclw proc~calclw->module~modglobal proc~calclw->module~initfac proc~cyclicmj cyclicmj proc~cyclicmj->module~modglobal proc~exitdriver exitdriver proc~exitdriver->module~modglobal proc~sources sources proc~sources->module~modglobal module~initfac->module~modglobal proc~writeinletfile writeinletfile proc~writeinletfile->module~modglobal proc~readinitfiles readinitfiles proc~readinitfiles->module~modglobal proc~yinterpolate yinterpolate proc~yinterpolate->module~modglobal proc~diffe diffe proc~diffe->module~modglobal proc~bcpup bcpup proc~bcpup->module~modglobal proc~uoutletarea uoutletarea proc~uoutletarea->module~modglobal proc~checkinitvalues checkinitvalues proc~checkinitvalues->module~modglobal proc~initthermodynamics initthermodynamics proc~initthermodynamics->module~modglobal proc~tkestats tkestats proc~tkestats->module~modglobal proc~diagfld diagfld proc~diagfld->module~modglobal proc~initstatsdump initstatsdump proc~initstatsdump->module~modglobal proc~momentumthicknessexp momentumthicknessexp proc~momentumthicknessexp->module~modglobal proc~dispthickness dispthickness proc~dispthickness->module~modglobal proc~momentumthickness momentumthickness proc~momentumthickness->module~modglobal proc~advection advection proc~advection->module~modglobal proc~blthicknessmo blthicknessmo proc~blthicknessmo->module~modglobal proc~cyclicmi cyclicmi proc~cyclicmi->module~modglobal proc~initchecksim initchecksim proc~initchecksim->module~modglobal proc~advecw_2nd advecw_2nd proc~advecw_2nd->module~modglobal proc~voutletarea voutletarea proc~voutletarea->module~modglobal proc~wfuno wfuno proc~wfuno->module~modglobal proc~wfuno->module~initfac proc~advecu_2nd advecu_2nd proc~advecu_2nd->module~modglobal proc~ibmnorm ibmnorm proc~ibmnorm->module~modglobal proc~ibmnorm->module~initfac proc~detfreestream detfreestream proc~detfreestream->module~modglobal proc~calccourant calccourant proc~calccourant->module~modglobal proc~eb EB proc~eb->module~modglobal proc~eb->module~initfac proc~initfielddump initfielddump proc~initfielddump->module~modglobal proc~writedriverfile writedriverfile proc~writedriverfile->module~modglobal proc~createscals createscals proc~createscals->module~modglobal proc~createscals->module~initfac proc~zinterpolate2d zinterpolate2d proc~zinterpolate2d->module~modglobal proc~iohi iohi proc~iohi->module~modglobal proc~fromztop fromztop proc~fromztop->module~modglobal proc~rlim rlim proc~rlim->module~modglobal proc~exitstatsdump exitstatsdump proc~exitstatsdump->module~modglobal proc~thermodynamics thermodynamics proc~thermodynamics->module~modglobal proc~forces forces proc~forces->module~modglobal proc~tqaver tqaver proc~tqaver->module~modglobal proc~diffw diffw proc~diffw->module~modglobal proc~initeb initEB proc~initeb->module~modglobal proc~initeb->module~initfac proc~ywallfunplus ywallfunplus proc~ywallfunplus->module~modglobal proc~ywallfunplus->module~initfac proc~calthv calthv proc~calthv->module~modglobal proc~nudge nudge proc~nudge->module~modglobal proc~momentumthicknessmo momentumthicknessmo proc~momentumthicknessmo->module~modglobal proc~tkestatsdump tkestatsdump proc~tkestatsdump->module~modglobal proc~all_all_j2 ALL_ALL_j2 proc~all_all_j2->module~modglobal proc~updategr updateGR proc~updategr->module~modglobal proc~updategr->module~initfac proc~tderive tderive proc~tderive->module~modglobal proc~ywallscalarmin ywallscalarmin proc~ywallscalarmin->module~modglobal proc~ywallscalarmin->module~initfac proc~readinletfile readinletfile proc~readinletfile->module~modglobal proc~cyclicsi cyclicsi proc~cyclicsi->module~modglobal program~dalesurban DALESURBAN program~dalesurban->module~modglobal program~dalesurban->module~modeb program~dalesurban->module~initfac module~modstatsdump modstatsdump program~dalesurban->module~modstatsdump module~modchecksim modchecksim program~dalesurban->module~modchecksim module~modfielddump modfielddump program~dalesurban->module~modfielddump proc~advecc_kappa advecc_kappa proc~advecc_kappa->module~modglobal proc~fillps fillps proc~fillps->module~modglobal proc~zinterpolate1d zinterpolate1d proc~zinterpolate1d->module~modglobal proc~poisr poisr proc~poisr->module~modglobal proc~exitmodules exitmodules proc~exitmodules->module~modglobal proc~readrestartfiles readrestartfiles proc~readrestartfiles->module~modglobal module~modstatsdump->module~modglobal proc~zinterpolatew zinterpolatew proc~zinterpolatew->module~modglobal proc~bottom bottom proc~bottom->module~modglobal proc~ibmwallfun ibmwallfun proc~ibmwallfun->module~modglobal proc~scalsource scalsource proc~scalsource->module~modglobal proc~scalsource->module~initfac proc~yinterpolateh yinterpolateh proc~yinterpolateh->module~modglobal proc~cyclichj cyclichj proc~cyclichj->module~modglobal proc~ioqi ioqi proc~ioqi->module~modglobal proc~blthickness blthickness proc~blthickness->module~modglobal proc~startup startup proc~startup->module~modglobal module~modstatistics modstatistics module~modstatistics->module~modglobal proc~masscorr masscorr proc~masscorr->module~modglobal proc~initboundary initboundary proc~initboundary->module~modglobal proc~initsubgrid initsubgrid proc~initsubgrid->module~modglobal proc~advecv_2nd advecv_2nd proc~advecv_2nd->module~modglobal proc~dispthicknessexp dispthicknessexp proc~dispthicknessexp->module~modglobal proc~lstend lstend proc~lstend->module~modglobal proc~detfreestrtmp detfreestrtmp proc~detfreestrtmp->module~modglobal proc~bcp bcp proc~bcp->module~modglobal proc~fluidvolume fluidvolume proc~fluidvolume->module~modglobal proc~initstat_nc initstat_nc proc~initstat_nc->module~modglobal proc~fixuinf2 fixuinf2 proc~fixuinf2->module~modglobal module~modchecksim->module~modglobal proc~xwallscalar xwallscalar proc~xwallscalar->module~modglobal proc~xwallscalar->module~initfac proc~calc_halflev calc_halflev proc~calc_halflev->module~modglobal proc~cyclicqi cyclicqi proc~cyclicqi->module~modglobal proc~closurebc closurebc proc~closurebc->module~modglobal proc~subgrid subgrid proc~subgrid->module~modglobal proc~solmpj solmpj proc~solmpj->module~modglobal proc~statsdump statsdump proc~statsdump->module~modglobal proc~statsdump->module~modstatistics proc~tstep_integrate tstep_integrate proc~tstep_integrate->module~modglobal proc~diffc diffc proc~diffc->module~modglobal proc~calcdiffnr calcdiffnr proc~calcdiffnr->module~modglobal proc~readfacetfiles readfacetfiles proc~readfacetfiles->module~modglobal proc~cyclichi cyclichi proc~cyclichi->module~modglobal proc~zwallfun zwallfun proc~zwallfun->module~modglobal proc~zwallfun->module~initfac proc~zinterpolatew1d zinterpolatew1d proc~zinterpolatew1d->module~modglobal proc~iosi iosi proc~iosi->module~modglobal proc~fielddump fielddump proc~fielddump->module~modglobal proc~thermo thermo proc~thermo->module~modglobal proc~initdriver initdriver proc~initdriver->module~modglobal proc~chkdiv chkdiv proc~chkdiv->module~modglobal proc~checksim checksim proc~checksim->module~modglobal proc~ywallfunmin ywallfunmin proc~ywallfunmin->module~modglobal proc~ywallfunmin->module~initfac proc~valuetop valuetop proc~valuetop->module~modglobal proc~zinterpolate zinterpolate proc~zinterpolate->module~modglobal proc~tstep_update tstep_update proc~tstep_update->module~modglobal proc~randomnize randomnize proc~randomnize->module~modglobal proc~wfmneutral wfmneutral proc~wfmneutral->module~modglobal proc~wfmneutral->module~initfac proc~intqh intqH proc~intqh->module~modglobal proc~intqh->module~initfac proc~readdriverfile readdriverfile proc~readdriverfile->module~modglobal proc~ywallscalarplus ywallscalarplus proc~ywallscalarplus->module~modglobal proc~ywallscalarplus->module~initfac proc~cyclicsj cyclicsj proc~cyclicsj->module~modglobal proc~all_all_j ALL_ALL_j proc~all_all_j->module~modglobal proc~wfgr wfGR proc~wfgr->module~modglobal proc~wfgr->module~initfac proc~xwallfun xwallfun proc~xwallfun->module~modglobal proc~xwallfun->module~initfac proc~initinlet initinlet proc~initinlet->module~modglobal proc~open_nc open_nc proc~open_nc->module~modglobal proc~writerestartfiles writerestartfiles proc~writerestartfiles->module~modglobal proc~writerestartfiles->module~initfac module~modfielddump->module~modglobal proc~zinterpolatet1d zinterpolatet1d proc~zinterpolatet1d->module~modglobal proc~exitinlet exitinlet proc~exitinlet->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables poisrcheck imax jtot jmax jsen kmax isen ib ie jb je jgb jge offset kb ke nsv nvar fieldvars ih jh kh ihc jhc khc nblocks block nfcts iplane nstore fname_options longint lwarmstart lstratstart lfielddump lreadscal BCxm BCxT BCxq BCxs BCym BCyT BCyq BCys BCtopm BCtopT BCtopq BCtops BCbotm BCbotT BCbotq BCbots iinletgen idriver linoutflow lzerogradtop lzerogradtopscal lbuoyancy ltempeq lscalrec lSIRANEinout ltempinout lmoistinout lper2inout libm lwalldist lles linletRA lfixinlet lfixutauin lscasrc lscasrcl lydump lytdump lxydump lxytdump lscasrcr ltkedump lslicedump ltdump lreadminl lwallfunc luoutflowr lvoutflowr luvolflowr lvvolflowr lstoreplane lstorexy lreadmean lstat lEB lwriteEBfiles lconstW ifixuinf lvinf freestreamav freestrtmpav ifinput ifoutput ifnamopt pi grav rd rv cp rlv rlvi ep ep2 rcp cpr rlvocp mair rhoa wfc wwilt wgrmax rsmin rsmax GRLAI wsoil bldT skyLW gres grqs grdqdt numol numoli prandtlmol prandtlmoli iwallmom iwalltemp iwallmoist iwallscal rhow pref0 tmelt es0 at bt ekmin e12min fkar eps1 epscloud boltz lprofforc lcoriol igrw_damp geodamptime uflowrate vflowrate Uinf Vinf inletav totinletav om22 om23 om22_gs om23_gs xlat xlon xSa ySa zSa xS yS zS SS sigS lnudge tnudge nnudge lchem k1 JNO2 POISS_FFT POISS_CYC ipoiss iadv_upw iadv_cd2 iadv_kappa iadv_mom iadv_tke iadv_thl iadv_qt iadv_sv lmoist xday xtime runtime dtmax trestart tfielddump tsample tstatsdump tnextrestart tscale tnextfielddump startfile totavtime dtEB tEB tnextEB thres dqt dtheta dsv dt timee btime runavtime ntimee ntrun timeleft ladaptive tdriverstart tdriverdump dtdriver driverstore driverjobnr courant diffnr dt_lim rk3step iexpnr cexpnr thlsrc dy dy2 dz dyi dyiq dyi5 dy2i nwalllayers AM BM CM DM EM FM GM HM inAM IDM bb w dumv Tdash rslabs dzf dzfc dzfci dzf2 dzh zh zf dzfi dzfiq dzfi5 dzhi dzhci dzhiq dzh2i zhi zfi dxf dxfc dxfci dxf2 dxfi dxfiq dxfi5 dxh dxhi dxhci dxhiq dxh2i xh xf xsize ysize delta lmomsubs author version Subroutines initglobal exitglobal Variables Type Visibility Attributes Name Initial integer, public :: poisrcheck = 0 integer, public :: imax = 64 integer, public :: jtot = 64 integer, public :: jmax integer, public :: jsen integer, public :: kmax = 96 integer, public :: isen integer, public :: ib integer, public :: ie integer, public :: jb integer, public :: je integer, public :: jgb integer, public :: jge integer, public :: offset integer, public :: kb integer, public :: ke integer, public :: nsv = 0 integer, public :: nvar = 0 character(len=50), public :: fieldvars = '' integer, public :: ih = 3 integer, public :: jh = 3 integer, public :: kh = 1 integer, public :: ihc = 2 integer, public :: jhc = 2 integer, public :: khc = 2 integer, public :: nblocks = 0 integer, public, allocatable :: block (:,:) integer, public :: nfcts = -1 integer, public :: iplane integer, public :: nstore = 1002 character(len=90), public :: fname_options = 'namoptions' integer, public, parameter :: longint = 8 logical, public :: lwarmstart = .false. logical, public :: lstratstart = .false. logical, public :: lfielddump = .false. logical, public :: lreadscal = .false. integer, public :: BCxm = 1 integer, public :: BCxT = 1 integer, public :: BCxq = 1 integer, public :: BCxs = 1 integer, public :: BCym = 1 integer, public :: BCyT = 1 integer, public :: BCyq = 1 integer, public :: BCys = 1 integer, public :: BCtopm = 1 integer, public :: BCtopT = 1 integer, public :: BCtopq = 1 integer, public :: BCtops = 1 integer, public :: BCbotm = 2 integer, public :: BCbotT = 1 integer, public :: BCbotq = 1 integer, public :: BCbots = 1 integer, public :: iinletgen = 0 integer, public :: idriver = 0 logical, public :: linoutflow = .false. logical, public :: lzerogradtop = .false. logical, public :: lzerogradtopscal = .false. logical, public :: lbuoyancy = .false. logical, public :: ltempeq = .false. logical, public :: lscalrec = .false. logical, public :: lSIRANEinout = .false. logical, public :: ltempinout = .false. logical, public :: lmoistinout = .false. logical, public :: lper2inout = .false. logical, public :: libm = .true. logical, public :: lwalldist = .false. logical, public :: lles = .true. logical, public :: linletRA = .false. logical, public :: lfixinlet = .false. logical, public :: lfixutauin = .false. logical, public :: lscasrc = .false. logical, public :: lscasrcl = .false. logical, public :: lydump = .false. logical, public :: lytdump = .false. logical, public :: lxydump = .false. logical, public :: lxytdump = .false. logical, public :: lscasrcr = .false. logical, public :: ltkedump = .false. logical, public :: lslicedump = .false. logical, public :: ltdump = .false. logical, public :: lreadminl = .false. logical, public :: lwallfunc = .true. logical, public :: luoutflowr = .false. logical, public :: lvoutflowr = .false. logical, public :: luvolflowr = .false. logical, public :: lvvolflowr = .false. logical, public :: lstoreplane = .false. logical, public :: lstorexy = .false. logical, public :: lreadmean = .false. logical, public :: lstat = .false. logical, public :: lEB = .false. logical, public :: lwriteEBfiles = .false. logical, public :: lconstW = .false. integer, public :: ifixuinf = 0 logical, public :: lvinf = .false. real, public :: freestreamav = 0. real, public :: freestrtmpav = 0. integer, public, parameter :: ifinput = 1 integer, public, parameter :: ifoutput = 2 integer, public, parameter :: ifnamopt = 3 real, public, parameter :: pi = 3.141592653589793116 real, public, parameter :: grav = 9.81 real, public, parameter :: rd = 287.04 real, public, parameter :: rv = 461.5 real, public, parameter :: cp = 1004. real, public, parameter :: rlv = 2.26e6 real, public, parameter :: rlvi = 1/rlv real, public, parameter :: ep = rd/rv real, public, parameter :: ep2 = rv/rd-1. real, public, parameter :: rcp = rd/cp real, public, parameter :: cpr = cp/rd real, public, parameter :: rlvocp = rlv/cp real, public, parameter :: mair = 28.967 real, public, parameter :: rhoa = 1.2 real, public :: wfc = 313. real, public :: wwilt = 171. real, public :: wgrmax = 450. real, public :: rsmin = 110. real, public :: rsmax = 5000. real, public :: GRLAI = 2. real, public :: wsoil = 0. real, public :: bldT = 0. real, public :: skyLW = 0. real, public :: gres = 0. real, public :: grqs = 0. real, public :: grdqdt = 0. real, public, parameter :: numol = 1.5e-5 real, public, parameter :: numoli = 1./numol real, public, parameter :: prandtlmol = 0.71 real, public, parameter :: prandtlmoli = 1./prandtlmol integer, public :: iwallmom = 2 integer, public :: iwalltemp = 1 integer, public :: iwallmoist = 1 integer, public :: iwallscal = 1 real, public, parameter :: rhow = 0.998e3 real, public, parameter :: pref0 = 1.e5 real, public, parameter :: tmelt = 273.16 real, public, parameter :: es0 = 610.78 real, public, parameter :: at = 17.27 real, public, parameter :: bt = 35.86 real, public, parameter :: ekmin = 1.e-12 real, public, parameter :: e12min = 5.e-5 real, public, parameter :: fkar = 0.41 real, public, parameter :: eps1 = 1.e-10 real, public, parameter :: epscloud = 1.e-5 real, public, parameter :: boltz = 5.67e-8 logical, public :: lprofforc = .false. logical, public :: lcoriol = .false. integer, public :: igrw_damp = 2 real, public :: geodamptime = 7200. real, public :: uflowrate = 1. real, public :: vflowrate = 1. real, public :: Uinf = 0. real, public :: Vinf = 0. real, public :: inletav = 0. real, public :: totinletav = 0. real, public :: om22 real, public :: om23 real, public :: om22_gs real, public :: om23_gs real, public :: xlat = 52. real, public :: xlon = 0. real, public, allocatable :: xSa (:) real, public, allocatable :: ySa (:) real, public, allocatable :: zSa (:) real, public :: xS = 0. real, public :: yS = 0. real, public :: zS = 0. real, public :: SS = 0. real, public :: sigS = 0. logical, public :: lnudge = .false. real, public :: tnudge = 50. integer, public :: nnudge = 10 logical, public :: lchem = .false. real, public :: k1 = 0. real, public :: JNO2 = 0. integer, public, parameter :: POISS_FFT = 0 integer, public, parameter :: POISS_CYC = 1 integer, public :: ipoiss = POISS_CYC integer, public, parameter :: iadv_upw = 1 integer, public, parameter :: iadv_cd2 = 2 integer, public, parameter :: iadv_kappa = 7 integer, public :: iadv_mom = 2 integer, public :: iadv_tke = -1 integer, public :: iadv_thl = -1 integer, public :: iadv_qt = -1 integer, public :: iadv_sv (100) = -1 logical, public :: lmoist = .false. real, public :: xday = 1. real, public :: xtime = 0. real, public :: runtime = 300. real, public :: dtmax = 20. real, public :: trestart = 10000. real, public :: tfielddump = 10000. real, public :: tsample = 5. real, public :: tstatsdump = 10000. real, public :: tnextrestart real, public :: tscale real, public :: tnextfielddump character(len=90), public :: startfile = '' real, public :: totavtime = 0. real, public :: dtEB = 10. real, public :: tEB = 0. real, public :: tnextEB = 0. real, public :: thres = 5.e-3 real, public :: dqt real, public :: dtheta real, public, allocatable :: dsv (:) real, public :: dt real, public :: timee real, public :: btime real, public :: runavtime integer, public :: ntimee integer, public :: ntrun real, public :: timeleft logical, public :: ladaptive = .false. real, public :: tdriverstart = 0. real, public :: tdriverdump real, public :: dtdriver = 0.1 integer, public :: driverstore integer, public :: driverjobnr real, public :: courant = -1. real, public :: diffnr = 0.25 real, public :: dt_lim integer, public :: rk3step = 0 integer, public :: iexpnr = 0 character(len=3), public :: cexpnr real, public :: thlsrc = 0. real, public :: dy real, public :: dy2 real, public :: dz real, public :: dyi real, public :: dyiq real, public :: dyi5 real, public :: dy2i integer, public :: nwalllayers = 3 real, public, allocatable :: AM (:,:) real, public, allocatable :: BM (:,:) real, public, allocatable :: CM (:,:) real, public, allocatable :: DM (:,:) real, public, allocatable :: EM (:,:) real, public, allocatable :: FM (:,:) real, public, allocatable :: GM (:,:) real, public, allocatable :: HM (:,:) real, public, allocatable :: inAM (:,:) real, public, allocatable :: IDM (:,:) real, public, allocatable :: bb (:) real, public, allocatable :: w (:) real, public, allocatable :: dumv (:) real, public, allocatable :: Tdash (:) real, public :: rslabs real, public, allocatable :: dzf (:) real, public, allocatable :: dzfc (:) real, public, allocatable :: dzfci (:) real, public, allocatable :: dzf2 (:) real, public, allocatable :: dzh (:) real, public, allocatable :: zh (:) real, public, allocatable :: zf (:) real, public, allocatable :: dzfi (:) real, public, allocatable :: dzfiq (:) real, public, allocatable :: dzfi5 (:) real, public, allocatable :: dzhi (:) real, public, allocatable :: dzhci (:) real, public, allocatable :: dzhiq (:) real, public, allocatable :: dzh2i (:) real, public, allocatable :: zhi (:) real, public, allocatable :: zfi (:) real, public, allocatable :: dxf (:) real, public, allocatable :: dxfc (:) real, public, allocatable :: dxfci (:) real, public, allocatable :: dxf2 (:) real, public, allocatable :: dxfi (:) real, public, allocatable :: dxfiq (:) real, public, allocatable :: dxfi5 (:) real, public, allocatable :: dxh (:) real, public, allocatable :: dxhi (:) real, public, allocatable :: dxhci (:) real, public, allocatable :: dxhiq (:) real, public, allocatable :: dxh2i (:) real, public, allocatable :: xh (:) real, public, allocatable :: xf (:) real, public :: xsize = -1. real, public :: ysize = -1. real, public, allocatable :: delta (:,:) logical, public :: lmomsubs = .false. character(len=80), public :: author = '' character(len=80), public :: version = 'DALES U' Subroutines public subroutine initglobal () Arguments None public subroutine exitglobal () Arguments None","tags":"","loc":"module/modglobal.html"},{"title":"modibm – uDALES","text":"Uses modibmdata module~~modibm~~UsesGraph module~modibm modibm module~modibmdata modibmdata module~modibm->module~modibmdata Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~modibm~~UsedByGraph module~modibm modibm proc~advecu_2nd advecu_2nd proc~advecu_2nd->module~modibm proc~advecc_2nd advecc_2nd proc~advecc_2nd->module~modibm program~dalesurban DALESURBAN program~dalesurban->module~modibm Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines createwalls ibmwallfun xwallfun xwallscalar ywallfunplus ywallscalarplus ywallfunmin ywallscalarmin zwallfun zwallscalar ibmnorm nearwall bottom Subroutines public subroutine createwalls () Arguments None public subroutine ibmwallfun () Arguments None public subroutine xwallfun () Arguments None public subroutine xwallscalar (hi, hj, hk, putin, putout, bcvaluem, bcvaluep, n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: hi integer, intent(in) :: hj integer, intent(in) :: hk real, intent(in) :: putin (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(inout) :: putout (ib-hi:ie+hi,jb-hj:je+hj,kb:ke+hk) real, intent(in) :: bcvaluem real, intent(in) :: bcvaluep integer, intent(in) :: n public subroutine ywallfunplus () Arguments None public subroutine ywallscalarplus (hi, hj, hk, putin, putout, bcvaluep, n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: hi integer, intent(in) :: hj integer, intent(in) :: hk real, intent(in) :: putin (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(inout) :: putout (ib-hi:ie+hi,jb-hj:je+hj,kb:ke+hk) real, intent(in) :: bcvaluep integer, intent(in) :: n public subroutine ywallfunmin () Arguments None public subroutine ywallscalarmin (hi, hj, hk, putin, putout, bcvaluem, n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: hi integer, intent(in) :: hj integer, intent(in) :: hk real, intent(in) :: putin (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(inout) :: putout (ib-hi:ie+hi,jb-hj:je+hj,kb:ke+hk) real, intent(in) :: bcvaluem integer, intent(in) :: n public subroutine zwallfun () Arguments None public subroutine zwallscalar (hi, hj, hk, putin, putout, bcvalue, n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: hi integer, intent(in) :: hj integer, intent(in) :: hk real, intent(in) :: putin (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(inout) :: putout (ib-hi:ie+hi,jb-hj:je+hj,kb:ke+hk) real, intent(in) :: bcvalue integer, intent(in) :: n public subroutine ibmnorm () Arguments None public subroutine nearwall () Arguments None public subroutine bottom () Arguments None","tags":"","loc":"module/modibm.html"},{"title":"modstat_nc – uDALES","text":"Uses netcdf modmpi module~~modstat_nc~~UsesGraph module~modstat_nc modstat_nc module~modmpi modmpi module~modstat_nc->module~modmpi netcdf netcdf module~modstat_nc->netcdf mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~modstat_nc~~UsedByGraph module~modstat_nc modstat_nc proc~exitfielddump exitfielddump proc~exitfielddump->module~modstat_nc proc~tkestats tkestats proc~tkestats->module~modstat_nc proc~fielddump fielddump proc~fielddump->module~modstat_nc proc~exitstatsdump exitstatsdump proc~exitstatsdump->module~modstat_nc proc~initstatsdump initstatsdump proc~initstatsdump->module~modstat_nc proc~initfielddump initfielddump proc~initfielddump->module~modstat_nc proc~eb EB proc~eb->module~modstat_nc proc~statsdump statsdump proc~statsdump->module~modstat_nc proc~initeb initEB proc~initeb->module~modstat_nc program~dalesurban DALESURBAN program~dalesurban->module~modstat_nc Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables timeID ztID zmID xtID xmID ytID ymID ztsID fctID lyrID nc_fillvalue Interfaces writestat_nc Subroutines initstat_nc open_nc define_nc redefine_nc exitstat_nc writestat_dims_nc writestat_time_nc writestat_1D_nc writestat_2D_nc writestat_3D_nc writestat_3D_short_nc ncinfo nchandle_error Variables Type Visibility Attributes Name Initial integer, public, save :: timeID = 0 integer, public, save :: ztID = 0 integer, public, save :: zmID = 0 integer, public, save :: xtID = 0 integer, public, save :: xmID = 0 integer, public, save :: ytID = 0 integer, public, save :: ymID = 0 integer, public, save :: ztsID = 0 integer, public, save :: fctID = 0 integer, public, save :: lyrID = 0 real(kind=4), public :: nc_fillvalue = -999. Interfaces public interface writestat_nc public subroutine writestat_time_nc (ncid, nvar, ncname, vars, nrec, lraise) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname real, intent(in), dimension(nvar) :: vars integer, intent(inout) :: nrec logical, intent(in) :: lraise public subroutine writestat_1D_nc (ncid, nvar, ncname, vars, nrec, dim1) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname real, intent(in), dimension(dim1,nvar) :: vars integer, intent(in) :: nrec integer, intent(in) :: dim1 public subroutine writestat_2D_nc (ncid, nvar, ncname, vars, nrec, dim1, dim2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname real, intent(in), dimension(:,:,:) :: vars integer, intent(in) :: nrec integer, intent(in) :: dim1 integer, intent(in) :: dim2 public subroutine writestat_3D_nc (ncid, nvar, ncname, vars, nrec, dim1, dim2, dim3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname real, intent(in), dimension(dim1,dim2,dim3,nvar) :: vars integer, intent(in) :: nrec integer, intent(in) :: dim1 integer, intent(in) :: dim2 integer, intent(in) :: dim3 public subroutine writestat_3D_short_nc (ncid, nvar, ncname, vars, nrec, dim1, dim2, dim3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname integer(kind=selected_int_kind(4)), intent(in), dimension(dim1,dim2,dim3,nvar) :: vars integer, intent(in) :: nrec integer, intent(in) :: dim1 integer, intent(in) :: dim2 integer, intent(in) :: dim3 Subroutines public subroutine initstat_nc () Arguments None public subroutine open_nc (fname, ncid, nrec, n1, n2, n3, ns, nfcts, nlyrs) Arguments Type Intent Optional Attributes Name character(len=40), intent(in) :: fname integer, intent(out) :: ncid integer, intent(out) :: nrec integer, intent(in), optional :: n1 integer, intent(in), optional :: n2 integer, intent(in), optional :: n3 integer, intent(in), optional :: ns integer, intent(in), optional :: nfcts integer, intent(in), optional :: nlyrs public subroutine define_nc (ncID, nVar, sx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncID integer, intent(in) :: nVar character(len=*), intent(in) :: sx (nVar,4) public subroutine redefine_nc (ncid) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid public subroutine exitstat_nc (ncid) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid public subroutine writestat_dims_nc (ncid) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid public subroutine writestat_time_nc (ncid, nvar, ncname, vars, nrec, lraise) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname real, intent(in), dimension(nvar) :: vars integer, intent(inout) :: nrec logical, intent(in) :: lraise public subroutine writestat_1D_nc (ncid, nvar, ncname, vars, nrec, dim1) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname real, intent(in), dimension(dim1,nvar) :: vars integer, intent(in) :: nrec integer, intent(in) :: dim1 public subroutine writestat_2D_nc (ncid, nvar, ncname, vars, nrec, dim1, dim2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname real, intent(in), dimension(:,:,:) :: vars integer, intent(in) :: nrec integer, intent(in) :: dim1 integer, intent(in) :: dim2 public subroutine writestat_3D_nc (ncid, nvar, ncname, vars, nrec, dim1, dim2, dim3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname real, intent(in), dimension(dim1,dim2,dim3,nvar) :: vars integer, intent(in) :: nrec integer, intent(in) :: dim1 integer, intent(in) :: dim2 integer, intent(in) :: dim3 public subroutine writestat_3D_short_nc (ncid, nvar, ncname, vars, nrec, dim1, dim2, dim3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname integer(kind=selected_int_kind(4)), intent(in), dimension(dim1,dim2,dim3,nvar) :: vars integer, intent(in) :: nrec integer, intent(in) :: dim1 integer, intent(in) :: dim2 integer, intent(in) :: dim3 public subroutine ncinfo (out, in1, in2, in3, in4) Arguments Type Intent Optional Attributes Name character(len=*), intent(out), dimension(4) :: out character(len=*), intent(in) :: in1 character(len=*), intent(in) :: in2 character(len=*), intent(in) :: in3 character(len=*), intent(in) :: in4 public subroutine nchandle_error (status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: status","tags":"","loc":"module/modstat_nc.html"},{"title":"modsurfdata – uDALES","text":"Used by module~~modsurfdata~~UsedByGraph module~modsurfdata modsurfdata proc~enthalpythickness enthalpythickness proc~enthalpythickness->module~modsurfdata proc~diffu diffu proc~diffu->module~modsurfdata proc~fixthetainf fixthetainf proc~fixthetainf->module~modsurfdata proc~fixuinf2 fixuinf2 proc~fixuinf2->module~modsurfdata proc~fromztop fromztop proc~fromztop->module~modsurfdata proc~calc_halflev calc_halflev proc~calc_halflev->module~modsurfdata proc~sources sources proc~sources->module~modsurfdata proc~subgrid subgrid proc~subgrid->module~modsurfdata proc~createwalls createwalls proc~createwalls->module~modsurfdata proc~diffv diffv proc~diffv->module~modsurfdata proc~forces forces proc~forces->module~modsurfdata proc~statsdump statsdump proc~statsdump->module~modsurfdata proc~inletgen inletgen proc~inletgen->module~modsurfdata proc~readinitfiles readinitfiles proc~readinitfiles->module~modsurfdata proc~calthv calthv proc~calthv->module~modsurfdata proc~checkinitvalues checkinitvalues proc~checkinitvalues->module~modsurfdata proc~tkestatsdump tkestatsdump proc~tkestatsdump->module~modsurfdata proc~tkestats tkestats proc~tkestats->module~modsurfdata proc~diagfld diagfld proc~diagfld->module~modsurfdata proc~fielddump fielddump proc~fielddump->module~modsurfdata proc~thermo thermo proc~thermo->module~modsurfdata proc~closure closure proc~closure->module~modsurfdata proc~readrestartfiles readrestartfiles proc~readrestartfiles->module~modsurfdata proc~bottom bottom proc~bottom->module~modsurfdata proc~boundary boundary proc~boundary->module~modsurfdata proc~writerestartfiles writerestartfiles proc~writerestartfiles->module~modsurfdata proc~startup startup proc~startup->module~modsurfdata proc~zinterpolatet1d zinterpolatet1d proc~zinterpolatet1d->module~modsurfdata proc~zinterpolatet zinterpolatet proc~zinterpolatet->module~modsurfdata proc~dispthicknessmo dispthicknessmo proc~dispthicknessmo->module~modsurfdata Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables tskin qskin ps lmostlocal obl oblav Cm Cs ustar thlflux qtflux svflux dudz dvdz dqtdz dthldz thls thl_top qts qt_top thvs svs sv_top z0 z0h Cmav Csav horvel wtsurf wttop wqtop wqsurf wsvsurf wsvtop wsvsurfdum wsvtopdum Variables Type Visibility Attributes Name Initial real, public, allocatable :: tskin (:,:) real, public, allocatable :: qskin (:,:) real, public :: ps = -1 logical, public :: lmostlocal = .false. real, public, allocatable :: obl (:,:) real, public :: oblav = 0.001 real, public, allocatable :: Cm (:,:) real, public, allocatable :: Cs (:,:) real, public, allocatable :: ustar (:,:) real, public, allocatable :: thlflux (:,:) real, public, allocatable :: qtflux (:,:) real, public, allocatable :: svflux (:,:,:) real, public, allocatable :: dudz (:,:) real, public, allocatable :: dvdz (:,:) real, public, allocatable :: dqtdz (:,:) real, public, allocatable :: dthldz (:,:) real, public :: thls = -1. real, public :: thl_top = -1. real, public :: qts = -1. real, public :: qt_top = -1. real, public :: thvs = -1. real, public, allocatable :: svs (:) real, public, allocatable :: sv_top (:) real, public :: z0 = -1. real, public :: z0h = -1. real, public :: Cmav real, public :: Csav real, public :: horvel real, public :: wtsurf = -1. real, public :: wttop = 0. real, public :: wqtop = 0. real, public :: wqsurf = -1. real, public, allocatable :: wsvsurf (:) real, public, allocatable :: wsvtop (:) real, public :: wsvsurfdum (1:99) = 0. real, public :: wsvtopdum (1:99) = 0.","tags":"","loc":"module/modsurfdata.html"},{"title":"initfac – uDALES","text":"Uses modglobal modmpi netcdf module~~initfac~~UsesGraph module~initfac initfac module~modmpi modmpi module~initfac->module~modmpi netcdf netcdf module~initfac->netcdf module~modglobal modglobal module~initfac->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~initfac~~UsedByGraph module~initfac initfac proc~calclw calclw proc~calclw->module~initfac proc~zwallscalar zwallscalar proc~zwallscalar->module~initfac proc~xwallscalar xwallscalar proc~xwallscalar->module~initfac proc~createwalls createwalls proc~createwalls->module~initfac proc~initeb initEB proc~initeb->module~initfac proc~nearwall nearwall proc~nearwall->module~initfac proc~ywallfunplus ywallfunplus proc~ywallfunplus->module~initfac proc~zwallfun zwallfun proc~zwallfun->module~initfac proc~advecc_2nd advecc_2nd proc~advecc_2nd->module~initfac proc~updategr updateGR proc~updategr->module~initfac proc~ywallscalarmin ywallscalarmin proc~ywallscalarmin->module~initfac program~dalesurban DALESURBAN program~dalesurban->module~initfac proc~ywallfunmin ywallfunmin proc~ywallfunmin->module~initfac proc~wfmneutral wfmneutral proc~wfmneutral->module~initfac proc~wfuno wfuno proc~wfuno->module~initfac proc~intqh intqH proc~intqh->module~initfac proc~ywallscalarplus ywallscalarplus proc~ywallscalarplus->module~initfac proc~scalsource scalsource proc~scalsource->module~initfac proc~wfgr wfGR proc~wfgr->module~initfac proc~ibmnorm ibmnorm proc~ibmnorm->module~initfac proc~xwallfun xwallfun proc~xwallfun->module~initfac proc~writerestartfiles writerestartfiles proc~writerestartfiles->module~initfac proc~eb EB proc~eb->module~initfac proc~createscals createscals proc~createscals->module~initfac Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables faclGR facz0 facz0h facalb facem facdi facd faccp faclami fackappa faca facain facets walltypes vf svf netsw facLWin Tfacinit facT facTdash facef facefi facefsum fachf fachfi fachfsum facf fachurel facwsoil faccth facqsat typeloc nwalltypes chmess nwallprops Functions qsat dqsatdT Subroutines readfacetfiles Variables Type Visibility Attributes Name Initial logical, public, allocatable :: faclGR (:) real, public, allocatable :: facz0 (:) real, public, allocatable :: facz0h (:) real, public, allocatable :: facalb (:) real, public, allocatable :: facem (:) real, public, allocatable :: facdi (:,:) real, public, allocatable :: facd (:,:) real, public, allocatable :: faccp (:,:) real, public, allocatable :: faclami (:,:) real, public, allocatable :: fackappa (:,:) real, public, allocatable :: faca (:) integer, public, allocatable :: facain (:) integer, public, allocatable :: facets (:,:) real, public, allocatable :: walltypes (:,:) real, public, allocatable :: vf (:,:) real, public, allocatable :: svf (:) real, public, allocatable :: netsw (:) real, public, allocatable :: facLWin (:) real, public, allocatable :: Tfacinit (:) real, public, allocatable :: facT (:,:) real, public, allocatable :: facTdash (:,:) real, public, allocatable :: facef (:) real, public, allocatable :: facefi (:) real, public, allocatable :: facefsum (:) real, public, allocatable :: fachf (:) real, public, allocatable :: fachfi (:) real, public, allocatable :: fachfsum (:) real, public, allocatable :: facf (:,:) real, public, allocatable :: fachurel (:) real, public, allocatable :: facwsoil (:) real, public, allocatable :: faccth (:) real, public, allocatable :: facqsat (:) integer, public, allocatable :: typeloc (:) integer, public :: nwalltypes = 0 character(len=80), public :: chmess integer, public :: nwallprops Functions public function qsat (T) Arguments Type Intent Optional Attributes Name real, intent(in) :: T Return Value real public function dqsatdT (T) Arguments Type Intent Optional Attributes Name real, intent(in) :: T Return Value real Subroutines public subroutine readfacetfiles () Arguments None","tags":"","loc":"module/initfac.html"},{"title":"modinlet – uDALES","text":"Uses modinletdata module~~modinlet~~UsesGraph module~modinlet modinlet module~modinletdata modinletdata module~modinlet->module~modinletdata Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~modinlet~~UsedByGraph module~modinlet modinlet proc~boundary boundary proc~boundary->module~modinlet proc~exitmodules exitmodules proc~exitmodules->module~modinlet proc~startup startup proc~startup->module~modinlet proc~readrestartfiles readrestartfiles proc~readrestartfiles->module~modinlet proc~readinitfiles readinitfiles proc~readinitfiles->module~modinlet Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines initinlet inletgen inletgennotemp momentumthicknessexp momentumthickness momentumthicknessmo enthalpythickness dispthicknessexp dispthickness dispthicknessmo blthicknesst blthickness blthicknessmo wallawinlet writeinletfile readinletfile zinterpolate zinterpolate1d zinterpolate2d zinterpolatew zinterpolatew1d zinterpolatet zinterpolatet1d yinterpolate yinterpolateh readzincoord exitinlet Subroutines public subroutine initinlet () Arguments None public subroutine inletgen () Arguments None public subroutine inletgennotemp () Arguments None public subroutine momentumthicknessexp (output, uinput) Arguments Type Intent Optional Attributes Name real, intent(out) :: output real, intent(in), dimension(kb:ke) :: uinput public subroutine momentumthickness (output, ustar, blth) Arguments Type Intent Optional Attributes Name real, intent(out) :: output real, intent(in) :: ustar real, intent(in) :: blth public subroutine momentumthicknessmo (output, ustar, blth, lmo) Arguments Type Intent Optional Attributes Name real, intent(out) :: output real, intent(in) :: ustar real, intent(in) :: blth real, intent(in) :: lmo public subroutine enthalpythickness (output, tinput, uinput) Arguments Type Intent Optional Attributes Name real, intent(out) :: output real, intent(in), dimension(kb:ke) :: tinput real, intent(in), dimension(kb:ke) :: uinput public subroutine dispthicknessexp (output) Arguments Type Intent Optional Attributes Name real, intent(out), dimension(ib:ie) :: output public subroutine dispthickness (output) Arguments Type Intent Optional Attributes Name real, intent(out), dimension(ib:ie) :: output public subroutine dispthicknessmo (output) Arguments Type Intent Optional Attributes Name real, intent(out), dimension(ib:ie) :: output public subroutine blthicknesst (output, uinput, criterion) Arguments Type Intent Optional Attributes Name real, intent(out) :: output real, intent(in), dimension(kb:ke) :: uinput real, intent(in) :: criterion public subroutine blthickness (output, ustar) Arguments Type Intent Optional Attributes Name real, intent(out) :: output real, intent(in) :: ustar public subroutine blthicknessmo (output, ustar, lmo) Arguments Type Intent Optional Attributes Name real, intent(inout) :: output real, intent(in) :: ustar real, intent(in) :: lmo public subroutine wallawinlet (utan, dx, visc, tau) Arguments Type Intent Optional Attributes Name real, intent(in) :: utan real, intent(in) :: dx real, intent(in) :: visc real, intent(out) :: tau public subroutine writeinletfile () Arguments None public subroutine readinletfile () Arguments None public subroutine zinterpolate (input, output) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(jb:je,kbin:kein,1:nstore) :: input real, intent(inout), dimension(jb:je,kb:ke,1:nstore) :: output public subroutine zinterpolate1d (input, output) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(kbin:kein) :: input real, intent(inout), dimension(kb:ke) :: output public subroutine zinterpolate2d (input, output) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(ib:ie,kbin:kein) :: input real, intent(inout), dimension(ib:ie,kb:ke) :: output public subroutine zinterpolatew (input, output) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(jb:je,kbin:kein+1,1:nstore) :: input real, intent(inout), dimension(jb:je,kb:ke+1,1:nstore) :: output public subroutine zinterpolatew1d (input, output) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(kbin:kein+1) :: input real, intent(inout), dimension(kb:ke+1) :: output public subroutine zinterpolatet (input, output) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(jb:je,kbin:kein,1:nstore) :: input real, intent(inout), dimension(jb:je,kb:ke,1:nstore) :: output public subroutine zinterpolatet1d (input, output) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(kbin:kein) :: input real, intent(inout), dimension(kb:ke) :: output public subroutine yinterpolate (input, output, ks, kf) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(jbdum:jedum,ks:kf,1:nstore) :: input real, intent(inout), dimension(jb   :je   ,ks:kf,1:nstore) :: output integer, intent(in) :: ks integer, intent(in) :: kf public subroutine yinterpolateh (input, output, ks, kf) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(jbdum:jedum,ks:kf,1:nstore) :: input real, intent(inout), dimension(jb   :je   ,ks:kf,1:nstore) :: output integer, intent(in) :: ks integer, intent(in) :: kf public subroutine readzincoord () Arguments None public subroutine exitinlet () Arguments None","tags":"","loc":"module/modinlet.html"},{"title":"modboundary – uDALES","text":"Used by module~~modboundary~~UsedByGraph module~modboundary modboundary proc~fillps fillps proc~fillps->module~modboundary proc~closure closure proc~closure->module~modboundary proc~startup startup proc~startup->module~modboundary proc~tderive tderive proc~tderive->module~modboundary proc~readinitfiles readinitfiles proc~readinitfiles->module~modboundary program~dalesurban DALESURBAN program~dalesurban->module~modboundary Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ksp tsc rnu0 Subroutines initboundary boundary closurebc iosi scalrec scalSIRANE cyclichi cyclicqi cyclicsi ioqi iohi cyclichj cyclicqj cyclicsj cyclicmi cyclicmj iolet bcpup bcp grwdamp fluxtop valuetop fluxtopscal valuetopscal inlettop tqaver Variables Type Visibility Attributes Name Initial integer, public :: ksp = -1 real, private, allocatable :: tsc (:) real, private :: rnu0 = 2.75e-3 Subroutines public subroutine initboundary () Arguments None public subroutine boundary () Arguments None public subroutine closurebc () Arguments None private subroutine iosi () Arguments None private subroutine scalrec () Arguments None private subroutine scalSIRANE () Arguments None private subroutine cyclichi () Arguments None private subroutine cyclicqi () Arguments None private subroutine cyclicsi () Arguments None private subroutine ioqi () Arguments None private subroutine iohi () Arguments None private subroutine cyclichj () Arguments None private subroutine cyclicqj () Arguments None private subroutine cyclicsj () Arguments None private subroutine cyclicmi () Arguments None private subroutine cyclicmj () Arguments None private subroutine iolet () Arguments None public subroutine bcpup (pup, pvp, pwp, rk3coef) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(ib - ih:ie + ih, jb - jh:je + jh, kb:ke + kh) :: pup real, intent(inout), dimension(ib - ih:ie + ih, jb - jh:je + jh, kb:ke + kh) :: pvp real, intent(inout), dimension(ib - ih:ie + ih, jb - jh:je + jh, kb:ke + kh) :: pwp real, intent(in) :: rk3coef public subroutine bcp (p) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(ib - ih:ie + ih, jb - jh:je + jh, kb - kh:ke + kh) :: p public subroutine grwdamp () Arguments None private subroutine fluxtop (field, ek, flux) Arguments Type Intent Optional Attributes Name real, intent(inout) :: field (ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) real, intent(in) :: ek (ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) real, intent(in) :: flux private subroutine valuetop (field, val) Arguments Type Intent Optional Attributes Name real, intent(inout) :: field (ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) real, intent(in) :: val private subroutine fluxtopscal (flux) Arguments Type Intent Optional Attributes Name real, intent(in) :: flux (1:nsv) private subroutine valuetopscal (val) Arguments Type Intent Optional Attributes Name real, intent(in) :: val (1:nsv) private subroutine inlettop () Arguments None public subroutine tqaver () Arguments None","tags":"","loc":"module/modboundary.html"},{"title":"modsave – uDALES","text":"Used by module~~modsave~~UsedByGraph module~modsave modsave proc~inletgennotemp inletgennotemp proc~inletgennotemp->module~modsave proc~inletgen inletgen proc~inletgen->module~modsave program~dalesurban DALESURBAN program~dalesurban->module~modsave proc~drivergen drivergen proc~drivergen->module~modsave Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines writerestartfiles Subroutines public subroutine writerestartfiles () Arguments None","tags":"","loc":"module/modsave.html"},{"title":"modsubgriddata – uDALES","text":"Used by module~~modsubgriddata~~UsedByGraph module~modsubgriddata modsubgriddata proc~zwallscalar zwallscalar proc~zwallscalar->module~modsubgriddata proc~cyclicmj cyclicmj proc~cyclicmj->module~modsubgriddata proc~xwallscalar xwallscalar proc~xwallscalar->module~modsubgriddata proc~closurebc closurebc proc~closurebc->module~modsubgriddata proc~calcreyn calcreyn proc~calcreyn->module~modsubgriddata proc~calcdiffnr calcdiffnr proc~calcdiffnr->module~modsubgriddata proc~tstep_integrate tstep_integrate proc~tstep_integrate->module~modsubgriddata proc~readinitfiles readinitfiles proc~readinitfiles->module~modsubgriddata proc~nearwall nearwall proc~nearwall->module~modsubgriddata proc~ywallfunplus ywallfunplus proc~ywallfunplus->module~modsubgriddata proc~tkestats tkestats proc~tkestats->module~modsubgriddata proc~fluxtopscal fluxtopscal proc~fluxtopscal->module~modsubgriddata proc~ywallscalarmin ywallscalarmin proc~ywallscalarmin->module~modsubgriddata proc~advection advection proc~advection->module~modsubgriddata proc~cyclicmi cyclicmi proc~cyclicmi->module~modsubgriddata proc~tstep_update tstep_update proc~tstep_update->module~modsubgriddata proc~readrestartfiles readrestartfiles proc~readrestartfiles->module~modsubgriddata proc~wfmneutral wfmneutral proc~wfmneutral->module~modsubgriddata proc~wfuno wfuno proc~wfuno->module~modsubgriddata proc~ywallscalarplus ywallscalarplus proc~ywallscalarplus->module~modsubgriddata proc~bottom bottom proc~bottom->module~modsubgriddata proc~wfgr wfGR proc~wfgr->module~modsubgriddata proc~boundary boundary proc~boundary->module~modsubgriddata module~modsubgrid modsubgrid module~modsubgrid->module~modsubgriddata proc~writerestartfiles writerestartfiles proc~writerestartfiles->module~modsubgriddata proc~tkestatsdump tkestatsdump proc~tkestatsdump->module~modsubgrid proc~exitmodules exitmodules proc~exitmodules->module~modsubgrid proc~startup startup proc~startup->module~modsubgrid proc~statsdump statsdump proc~statsdump->module~modsubgrid program~dalesurban DALESURBAN program~dalesurban->module~modsubgrid Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ldelta lmason lsmagorinsky lvreman lbuoycorr loneeqn cf Rigc Prandtl prandtli cm cn ch1 ch2 ce1 ce2 cs nmason alpha_kolm beta_kolm dampmin c_vreman ekm ekh sbdiss sbshr sbbuo zlt csz damp Variables Type Visibility Attributes Name Initial logical, public :: ldelta = .false. logical, public :: lmason = .false. logical, public :: lsmagorinsky = .false. logical, public :: lvreman = .false. logical, public :: lbuoycorr = .false. logical, public :: loneeqn = .false. real, public :: cf = 2.5 real, public :: Rigc = 0.25 real, public :: Prandtl = 0.333 real, public :: prandtli real, public :: cm = 0.12 real, public :: cn = 0.76 real, public :: ch1 = 1. real, public :: ch2 = 2. real, public :: ce1 = 0.19 real, public :: ce2 = 0.51 real, public :: cs = -1. real, public :: nmason = 2. real, public :: alpha_kolm = 1.5 real, public :: beta_kolm = 1. real, public :: dampmin = 1e-10 real, public :: c_vreman = 0.07 real, public, allocatable :: ekm (:,:,:) real, public, allocatable :: ekh (:,:,:) real, public, allocatable :: sbdiss (:,:,:) real, public, allocatable :: sbshr (:,:,:) real, public, allocatable :: sbbuo (:,:,:) real, public, allocatable :: zlt (:,:,:) real, public, allocatable :: csz (:,:) real, public, allocatable :: damp (:,:,:)","tags":"","loc":"module/modsubgriddata.html"},{"title":"modpois – uDALES","text":"Used by module~~modpois~~UsedByGraph module~modpois modpois proc~startup startup proc~startup->module~modpois program~dalesurban DALESURBAN program~dalesurban->module~modpois proc~exitmodules exitmodules proc~exitmodules->module~modpois Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables p Subroutines initpois poisson exitpois fillps tderive ALL_ALL_j ALL_ALL_j2 poisr solmpj Variables Type Visibility Attributes Name Initial real, public, allocatable :: p (:,:,:) Subroutines public subroutine initpois () Arguments None public subroutine poisson () Arguments None public subroutine exitpois () Arguments None private subroutine fillps () Arguments None private subroutine tderive () Arguments None private subroutine ALL_ALL_j (p, ptrans, iaction) Arguments Type Intent Optional Attributes Name real :: p (0:imax+1,0:jmax+1,0:kmax+1) real :: ptrans (1:isen,1:jtot,1:kmax) integer :: iaction private subroutine ALL_ALL_j2 (p, ptrans, iaction, ksen) Arguments Type Intent Optional Attributes Name real :: p (0:imax+1,0:jmax+1,0:kmax+1) real :: ptrans (1:imax,1:jtot,1:ksen) integer :: iaction integer :: ksen private subroutine poisr (rhs, dx, dxh, dy, dz, dzh, ibc1, ibc2, kbc1, kbc2, ksen) Arguments Type Intent Optional Attributes Name real :: rhs (0:imax+1,0:jmax+1,0:kmax+1) real :: dx (0:IMAX+1) real :: dxh (1:IMAX+1) real :: dy real :: dz (0:kmax+1) real :: dzh (1:kmax+1) integer :: ibc1 integer :: ibc2 integer :: kbc1 integer :: kbc2 integer :: ksen private subroutine solmpj (p1) Arguments Type Intent Optional Attributes Name real :: p1 (0:imax+1,0:jmax+1,0:kmax+1)","tags":"","loc":"module/modpois.html"},{"title":"modthermodynamics – uDALES","text":"Used by module~~modthermodynamics~~UsedByGraph module~modthermodynamics modthermodynamics proc~startup startup proc~startup->module~modthermodynamics proc~readinitfiles readinitfiles proc~readinitfiles->module~modthermodynamics program~dalesurban DALESURBAN program~dalesurban->module~modthermodynamics proc~exitmodules exitmodules proc~exitmodules->module~modthermodynamics Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables lqlnr th0av chi_half thv0 Subroutines initthermodynamics thermodynamics exitthermodynamics calthv diagfld fromztop thermo calc_halflev Variables Type Visibility Attributes Name Initial logical, public :: lqlnr = .false. real, public, allocatable :: th0av (:) real, public :: chi_half = 0.5 real, public, allocatable :: thv0 (:,:,:) Subroutines public subroutine initthermodynamics () Arguments None public subroutine thermodynamics () Arguments None public subroutine exitthermodynamics () Arguments None public subroutine calthv () Arguments None public subroutine diagfld () Arguments None public subroutine fromztop () Arguments None public subroutine thermo (thl, qt, ql, pressure, exner) Arguments Type Intent Optional Attributes Name real, intent(in) :: thl (ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) real, intent(in) :: qt (ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) real, intent(out) :: ql (ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) real, intent(in) :: pressure (kb:ke+kh) real, intent(in) :: exner (kb:ke+kh) public subroutine calc_halflev () Arguments None","tags":"","loc":"module/modthermodynamics.html"},{"title":"modfielddump – uDALES","text":"Uses modglobal modfields module~~modfielddump~~UsesGraph module~modfielddump modfielddump module~modfields modfields module~modfielddump->module~modfields module~modglobal modglobal module~modfielddump->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~modfielddump~~UsedByGraph module~modfielddump modfielddump program~dalesurban DALESURBAN program~dalesurban->module~modfielddump Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ncid nrec pfields fname tncname klow khigh n nvar ldiracc lbinary Derived Types domainptr Subroutines initfielddump fielddump exitfielddump Variables Type Visibility Attributes Name Initial integer, private :: ncid integer, private :: nrec = 0 type( domainptr ), private, dimension(30) :: pfields character(len=80), private :: fname = 'fielddump.xxx.xxx.nc' character(len=80), private, dimension(1,4) :: tncname integer, private :: klow integer, private :: khigh integer, private :: n integer, private :: nvar logical, private :: ldiracc = .false. logical, private :: lbinary = .false. Derived Types type, private :: domainptr Components Type Visibility Attributes Name Initial real, public, pointer :: point (:,:,:) Subroutines public subroutine initfielddump () Arguments None public subroutine fielddump () Arguments None public subroutine exitfielddump () Arguments None","tags":"","loc":"module/modfielddump.html"},{"title":"modchem – uDALES","text":"Used by module~~modchem~~UsedByGraph module~modchem modchem proc~tstep_integrate tstep_integrate proc~tstep_integrate->module~modchem Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines chem Subroutines public subroutine chem () Arguments None","tags":"","loc":"module/modchem.html"},{"title":"modsubgrid – uDALES","text":"Uses modsubgriddata module~~modsubgrid~~UsesGraph module~modsubgrid modsubgrid module~modsubgriddata modsubgriddata module~modsubgrid->module~modsubgriddata Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~modsubgrid~~UsedByGraph module~modsubgrid modsubgrid proc~tkestatsdump tkestatsdump proc~tkestatsdump->module~modsubgrid proc~exitmodules exitmodules proc~exitmodules->module~modsubgrid proc~startup startup proc~startup->module~modsubgrid proc~statsdump statsdump proc~statsdump->module~modsubgrid program~dalesurban DALESURBAN program~dalesurban->module~modsubgrid Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines initsubgrid subgridnamelist subgrid exitsubgrid closure sources diffc diffe diffu diffv diffw Subroutines public subroutine initsubgrid () Arguments None public subroutine subgridnamelist () Arguments None public subroutine subgrid () Arguments None public subroutine exitsubgrid () Arguments None public subroutine closure () Arguments None public subroutine sources () Arguments None public subroutine diffc (hi, hj, hk, putin, putout) Arguments Type Intent Optional Attributes Name integer, intent(in) :: hi integer, intent(in) :: hj integer, intent(in) :: hk real, intent(in) :: putin (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(inout) :: putout (ib-hi:ie+hi,jb-hj:je+hj,kb:ke+hk) public subroutine diffe (putout) Arguments Type Intent Optional Attributes Name real, intent(inout) :: putout (ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) public subroutine diffu (putout) Arguments Type Intent Optional Attributes Name real, intent(inout) :: putout (ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) public subroutine diffv (putout) Arguments Type Intent Optional Attributes Name real, intent(inout) :: putout (ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) public subroutine diffw (putout) Arguments Type Intent Optional Attributes Name real, intent(inout) :: putout (ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh)","tags":"","loc":"module/modsubgrid.html"},{"title":"modstartup – uDALES","text":"Used by module~~modstartup~~UsedByGraph module~modstartup modstartup program~dalesurban DALESURBAN program~dalesurban->module~modstartup Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables irandom krand randu randthl randqt Subroutines startup checkinitvalues readinitfiles readrestartfiles exitmodules randomnize createmasks Variables Type Visibility Attributes Name Initial integer(kind=selected_int_kind(6)), public :: irandom = 0 integer, public :: krand = huge(0) real, public :: randu = 0.0 real, public :: randthl = 0.0 real, public :: randqt = 0.0 Subroutines public subroutine startup () Arguments None public subroutine checkinitvalues () Arguments None public subroutine readinitfiles () Arguments None public subroutine readrestartfiles () Arguments None public subroutine exitmodules () Arguments None public subroutine randomnize (field, klev, ampl, ir, ihl, jhl) Arguments Type Intent Optional Attributes Name real :: field (ib-ihl:ie+ihl,jb-jhl:je+jhl,kb-kh:ke+kh) integer :: klev real :: ampl integer(kind=selected_int_kind(6)) :: ir integer :: ihl integer :: jhl public subroutine createmasks () Arguments None","tags":"","loc":"module/modstartup.html"},{"title":"modstatistics – uDALES","text":"Uses modglobal modmpi module~~modstatistics~~UsesGraph module~modstatistics modstatistics module~modmpi modmpi module~modstatistics->module~modmpi module~modglobal modglobal module~modstatistics->module~modglobal mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~modstatistics~~UsedByGraph module~modstatistics modstatistics proc~statsdump statsdump proc~statsdump->module~modstatistics Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables klow khigh i j k Subroutines genstats tkestats Variables Type Visibility Attributes Name Initial integer, private :: klow integer, private :: khigh integer, private :: i integer, private :: j integer, private :: k Subroutines public subroutine genstats (tsamplep, tstatsdumpp, umint, vmint, wmint) Arguments Type Intent Optional Attributes Name real :: tsamplep real :: tstatsdumpp real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) :: umint real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) :: vmint real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) :: wmint public subroutine tkestats (tsamplep, tstatsdumpp) Arguments Type Intent Optional Attributes Name real :: tsamplep real :: tstatsdumpp","tags":"","loc":"module/modstatistics.html"},{"title":"modibmdata – uDALES","text":"Used by module~~modibmdata~~UsedByGraph module~modibmdata modibmdata proc~wfgr wfGR proc~wfgr->module~modibmdata module~modibm modibm module~modibm->module~modibmdata proc~advecc_kappa advecc_kappa proc~advecc_kappa->module~modibmdata proc~writerestartfiles writerestartfiles proc~writerestartfiles->module~modibmdata proc~advecc_2nd advecc_2nd proc~advecc_2nd->module~modibmdata proc~advecc_2nd->module~modibm proc~startup startup proc~startup->module~modibmdata proc~wfmneutral wfmneutral proc~wfmneutral->module~modibmdata proc~wfuno wfuno proc~wfuno->module~modibmdata proc~forces forces proc~forces->module~modibmdata proc~nearwall nearwall proc~nearwall->module~modibmdata proc~advecu_2nd advecu_2nd proc~advecu_2nd->module~modibm program~dalesurban DALESURBAN program~dalesurban->module~modibm Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables xwallsglobal ywallsglobal zwallsglobal xwallsshear ywallsp ywallsm zwallsshear xwallsnorm ywallsnorm zwallsnorm nxwall ixwall nywall iyminwall nyminwall iywall nypluswall iypluswall ibmxforce ibmxforcevol ibmxforcevolp sumctm bcTfluxA bcqfluxA bctfxm bctfxp bctfym bctfyp bctfz bcqfxm bcqfxp bcqfym bcqfyp bcqfz nxwallsnorm nywallsnorm nzwallsnorm nxwallsshear nywallsp nywallsm nzwallsshear offset Variables Type Visibility Attributes Name Initial integer, public, allocatable :: xwallsglobal (:,:) integer, public, allocatable :: ywallsglobal (:,:) integer, public, allocatable :: zwallsglobal (:,:) integer, public, allocatable :: xwallsshear (:,:) integer, public, allocatable :: ywallsp (:,:) integer, public, allocatable :: ywallsm (:,:) integer, public, allocatable :: zwallsshear (:,:) integer, public, allocatable :: xwallsnorm (:,:) integer, public, allocatable :: ywallsnorm (:,:) integer, public, allocatable :: zwallsnorm (:,:) integer, public :: nxwall integer, public, allocatable :: ixwall (:) integer, public :: nywall integer, public, allocatable :: iyminwall (:,:) integer, public :: nyminwall integer, public, allocatable :: iywall (:) integer, public :: nypluswall integer, public, allocatable :: iypluswall (:,:) real, public, allocatable :: ibmxforce (:,:) real, public, allocatable :: ibmxforcevol (:,:) real, public, allocatable :: ibmxforcevolp (:,:) real, public :: sumctm = 0. real, public :: bcTfluxA = 0. real, public :: bcqfluxA = 0. real, public :: bctfxm = 0. real, public :: bctfxp = 0. real, public :: bctfym = 0. real, public :: bctfyp = 0. real, public :: bctfz = 0. real, public :: bcqfxm = 0. real, public :: bcqfxp = 0. real, public :: bcqfym = 0. real, public :: bcqfyp = 0. real, public :: bcqfz = 0. integer, public :: nxwallsnorm integer, public :: nywallsnorm integer, public :: nzwallsnorm integer, public :: nxwallsshear integer, public :: nywallsp integer, public :: nywallsm integer, public :: nzwallsshear integer, public :: offset = 1","tags":"","loc":"module/modibmdata.html"},{"title":"modforces – uDALES","text":"Used by module~~modforces~~UsedByGraph module~modforces modforces proc~startup startup proc~startup->module~modforces program~dalesurban DALESURBAN program~dalesurban->module~modforces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines forces detfreestream detfreestrtmp fixuinf2 fixuinf1 fixthetainf masscorr uoutletarea voutletarea fluidvolume calcfluidvolumes coriolis lstend nudge Subroutines public subroutine forces () Arguments None public subroutine detfreestream (freestream) Arguments Type Intent Optional Attributes Name real, intent(out) :: freestream public subroutine detfreestrtmp (freestrtmp) Arguments Type Intent Optional Attributes Name real, intent(out) :: freestrtmp public subroutine fixuinf2 () Arguments None public subroutine fixuinf1 () Arguments None public subroutine fixthetainf () Arguments None public subroutine masscorr () Arguments None public subroutine uoutletarea (area) Arguments Type Intent Optional Attributes Name real, intent(out) :: area public subroutine voutletarea (area) Arguments Type Intent Optional Attributes Name real, intent(out) :: area public subroutine fluidvolume (volume) Arguments Type Intent Optional Attributes Name real, intent(out) :: volume public subroutine calcfluidvolumes () Arguments None public subroutine coriolis () Arguments None public subroutine lstend () Arguments None public subroutine nudge () Arguments None","tags":"","loc":"module/modforces.html"},{"title":"modmpi – uDALES","text":"Uses mpi module~~modmpi~~UsesGraph module~modmpi modmpi mpi mpi module~modmpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~modmpi~~UsedByGraph module~modmpi modmpi proc~initglobal initglobal proc~initglobal->module~modmpi proc~readzincoord readzincoord proc~readzincoord->module~modmpi proc~zwallscalar zwallscalar proc~zwallscalar->module~modmpi module~initfac initfac proc~zwallscalar->module~initfac proc~poisson poisson proc~poisson->module~modmpi proc~iolet iolet proc~iolet->module~modmpi proc~fixthetainf fixthetainf proc~fixthetainf->module~modmpi proc~grwdamp grwdamp proc~grwdamp->module~modmpi proc~drivergen drivergen proc~drivergen->module~modmpi proc~calcreyn calcreyn proc~calcreyn->module~modmpi proc~createwalls createwalls proc~createwalls->module~modmpi proc~createwalls->module~initfac proc~diffv diffv proc~diffv->module~modmpi proc~inletgen inletgen proc~inletgen->module~modmpi proc~nearwall nearwall proc~nearwall->module~modmpi proc~nearwall->module~initfac proc~genstats genstats proc~genstats->module~modmpi proc~advecc_2nd advecc_2nd proc~advecc_2nd->module~modmpi proc~advecc_2nd->module~initfac proc~writestat_dims_nc writestat_dims_nc proc~writestat_dims_nc->module~modmpi proc~inletgennotemp inletgennotemp proc~inletgennotemp->module~modmpi proc~createmasks createmasks proc~createmasks->module~modmpi proc~cyclicqj cyclicqj proc~cyclicqj->module~modmpi proc~inlettop inlettop proc~inlettop->module~modmpi proc~closure closure proc~closure->module~modmpi proc~boundary boundary proc~boundary->module~modmpi proc~coriolis coriolis proc~coriolis->module~modmpi proc~fixuinf1 fixuinf1 proc~fixuinf1->module~modmpi proc~subgridnamelist subgridnamelist proc~subgridnamelist->module~modmpi proc~scalsirane scalSIRANE proc~scalsirane->module~modmpi proc~enthalpythickness enthalpythickness proc~enthalpythickness->module~modmpi proc~diffu diffu proc~diffu->module~modmpi proc~cyclicmj cyclicmj proc~cyclicmj->module~modmpi module~initfac->module~modmpi proc~writeinletfile writeinletfile proc~writeinletfile->module~modmpi proc~readinitfiles readinitfiles proc~readinitfiles->module~modmpi proc~diffe diffe proc~diffe->module~modmpi proc~bcpup bcpup proc~bcpup->module~modmpi proc~uoutletarea uoutletarea proc~uoutletarea->module~modmpi proc~checkinitvalues checkinitvalues proc~checkinitvalues->module~modmpi proc~diagfld diagfld proc~diagfld->module~modmpi proc~initstatsdump initstatsdump proc~initstatsdump->module~modmpi module~modstat_nc modstat_nc proc~initstatsdump->module~modstat_nc proc~momentumthicknessexp momentumthicknessexp proc~momentumthicknessexp->module~modmpi proc~initchecksim initchecksim proc~initchecksim->module~modmpi proc~voutletarea voutletarea proc~voutletarea->module~modmpi proc~wfuno wfuno proc~wfuno->module~modmpi proc~wfuno->module~initfac proc~advecu_2nd advecu_2nd proc~advecu_2nd->module~modmpi proc~ibmnorm ibmnorm proc~ibmnorm->module~modmpi proc~ibmnorm->module~initfac proc~detfreestream detfreestream proc~detfreestream->module~modmpi proc~calccourant calccourant proc~calccourant->module~modmpi proc~eb EB proc~eb->module~modmpi proc~eb->module~initfac proc~eb->module~modstat_nc proc~initfielddump initfielddump proc~initfielddump->module~modmpi proc~initfielddump->module~modstat_nc proc~createscals createscals proc~createscals->module~modmpi proc~createscals->module~initfac proc~writedriverfile writedriverfile proc~writedriverfile->module~modmpi proc~thermodynamics thermodynamics proc~thermodynamics->module~modmpi proc~forces forces proc~forces->module~modmpi proc~tqaver tqaver proc~tqaver->module~modmpi proc~diffw diffw proc~diffw->module~modmpi proc~initeb initEB proc~initeb->module~modmpi proc~initeb->module~initfac proc~initeb->module~modstat_nc proc~ywallfunplus ywallfunplus proc~ywallfunplus->module~modmpi proc~ywallfunplus->module~initfac proc~nudge nudge proc~nudge->module~modmpi proc~tkestatsdump tkestatsdump proc~tkestatsdump->module~modmpi proc~all_all_j2 ALL_ALL_j2 proc~all_all_j2->module~modmpi proc~tderive tderive proc~tderive->module~modmpi proc~ywallscalarmin ywallscalarmin proc~ywallscalarmin->module~modmpi proc~ywallscalarmin->module~initfac proc~readinletfile readinletfile proc~readinletfile->module~modmpi program~dalesurban DALESURBAN program~dalesurban->module~modmpi program~dalesurban->module~initfac module~modstatsdump modstatsdump program~dalesurban->module~modstatsdump program~dalesurban->module~modstat_nc proc~fillps fillps proc~fillps->module~modmpi proc~poisr poisr proc~poisr->module~modmpi proc~exitmodules exitmodules proc~exitmodules->module~modmpi proc~readrestartfiles readrestartfiles proc~readrestartfiles->module~modmpi module~modstatsdump->module~modmpi proc~bottom bottom proc~bottom->module~modmpi proc~scalsource scalsource proc~scalsource->module~modmpi proc~scalsource->module~initfac proc~cyclichj cyclichj proc~cyclichj->module~modmpi proc~startup startup proc~startup->module~modmpi module~modstatistics modstatistics module~modstatistics->module~modmpi proc~masscorr masscorr proc~masscorr->module~modmpi proc~initsubgrid initsubgrid proc~initsubgrid->module~modmpi proc~lstend lstend proc~lstend->module~modmpi proc~detfreestrtmp detfreestrtmp proc~detfreestrtmp->module~modmpi proc~bcp bcp proc~bcp->module~modmpi proc~fluidvolume fluidvolume proc~fluidvolume->module~modmpi proc~initstat_nc initstat_nc proc~initstat_nc->module~modmpi proc~fixuinf2 fixuinf2 proc~fixuinf2->module~modmpi proc~xwallscalar xwallscalar proc~xwallscalar->module~modmpi proc~xwallscalar->module~initfac proc~closurebc closurebc proc~closurebc->module~modmpi module~modstat_nc->module~modmpi proc~subgrid subgrid proc~subgrid->module~modmpi proc~solmpj solmpj proc~solmpj->module~modmpi proc~statsdump statsdump proc~statsdump->module~modmpi proc~statsdump->module~modstatistics proc~statsdump->module~modstat_nc proc~tstep_integrate tstep_integrate proc~tstep_integrate->module~modmpi proc~diffc diffc proc~diffc->module~modmpi proc~calcdiffnr calcdiffnr proc~calcdiffnr->module~modmpi proc~zwallfun zwallfun proc~zwallfun->module~modmpi proc~zwallfun->module~initfac proc~fielddump fielddump proc~fielddump->module~modmpi proc~fielddump->module~modstat_nc proc~initdriver initdriver proc~initdriver->module~modmpi proc~chkdiv chkdiv proc~chkdiv->module~modmpi proc~checksim checksim proc~checksim->module~modmpi proc~tstep_update tstep_update proc~tstep_update->module~modmpi proc~randomnize randomnize proc~randomnize->module~modmpi proc~wfmneutral wfmneutral proc~wfmneutral->module~modmpi proc~wfmneutral->module~initfac proc~intqh intqH proc~intqh->module~modmpi proc~intqh->module~initfac proc~readdriverfile readdriverfile proc~readdriverfile->module~modmpi proc~ywallscalarplus ywallscalarplus proc~ywallscalarplus->module~modmpi proc~ywallscalarplus->module~initfac proc~cyclicsj cyclicsj proc~cyclicsj->module~modmpi proc~all_all_j ALL_ALL_j proc~all_all_j->module~modmpi proc~wfgr wfGR proc~wfgr->module~modmpi proc~wfgr->module~initfac proc~initinlet initinlet proc~initinlet->module~modmpi proc~writerestartfiles writerestartfiles proc~writerestartfiles->module~modmpi proc~writerestartfiles->module~initfac proc~calclw calclw proc~calclw->module~initfac proc~ywallfunmin ywallfunmin proc~ywallfunmin->module~initfac proc~exitfielddump exitfielddump proc~exitfielddump->module~modstat_nc proc~xwallfun xwallfun proc~xwallfun->module~initfac proc~tkestats tkestats proc~tkestats->module~modstat_nc proc~updategr updateGR proc~updategr->module~initfac proc~exitstatsdump exitstatsdump proc~exitstatsdump->module~modstat_nc Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables comm3d nbrtop nbrbottom myid nprocs mpierr my_real CPU_program CPU_program0 cmyid Subroutines initmpi exitmpi barrou excj excjs slabsum avexy_ibm slabsumi avey_ibm sumy_ibm Variables Type Visibility Attributes Name Initial integer, public :: comm3d integer, public :: nbrtop integer, public :: nbrbottom integer, public :: myid integer, public :: nprocs integer, public :: mpierr integer, public :: my_real real, public :: CPU_program real, public :: CPU_program0 character(len=3), public :: cmyid Subroutines public subroutine initmpi () Arguments None public subroutine exitmpi () Arguments None public subroutine barrou () Arguments None public subroutine excj (a, sx, ex, sy, ey, sz, ez) Arguments Type Intent Optional Attributes Name real :: a (sx:ex,sy:ey,sz:ez) integer :: sx integer :: ex integer :: sy integer :: ey integer :: sz integer :: ez public subroutine excjs (a, sx, ex, sy, ey, sz, ez, ih, jh) Arguments Type Intent Optional Attributes Name real :: a (sx-ih:ex+ih,sy-jh:ey+jh,sz:ez) integer :: sx integer :: ex integer :: sy integer :: ey integer :: sz integer :: ez integer :: ih integer :: jh public subroutine slabsum (aver, ks, kf, var, ib, ie, jb, je, kb, ke, ibs, ies, jbs, jes, kbs, kes) Arguments Type Intent Optional Attributes Name real :: aver (ks:kf) integer :: ks integer :: kf real :: var (ib:ie,jb:je,kb:ke) integer :: ib integer :: ie integer :: jb integer :: je integer :: kb integer :: ke integer :: ibs integer :: ies integer :: jbs integer :: jes integer :: kbs integer :: kes public subroutine avexy_ibm (aver, var, ib, ie, jb, je, kb, ke, ih, jh, kh, II, IIs, lnan) Arguments Type Intent Optional Attributes Name real :: aver (kb:ke+kh) real :: var (ib:ie,jb:je,kb:ke+kh) integer :: ib integer :: ie integer :: jb integer :: je integer :: kb integer :: ke integer :: ih integer :: jh integer :: kh integer :: II (ib:ie,jb:je,kb:ke+kh) integer :: IIs (kb:ke+kh) logical :: lnan public subroutine slabsumi (aver, iis, iif, var, ib, ie, jb, je, kb, ke, ibs, ies, jbs, jes, kbs, kes) Arguments Type Intent Optional Attributes Name real :: aver (iis:iif) integer :: iis integer :: iif real :: var (ib:ie,jb:je,kb:ke) integer :: ib integer :: ie integer :: jb integer :: je integer :: kb integer :: ke integer :: ibs integer :: ies integer :: jbs integer :: jes integer :: kbs integer :: kes public subroutine avey_ibm (aver, var, ib, ie, jb, je, kb, ke, II, IIt) Arguments Type Intent Optional Attributes Name real :: aver (ib:ie,kb:ke) real :: var (ib:ie,jb:je,kb:ke) integer :: ib integer :: ie integer :: jb integer :: je integer :: kb integer :: ke integer :: II (ib:ie,jb:je,kb:ke) integer :: IIt (ib:ie,kb:ke) public subroutine sumy_ibm (sumy, var, ib, ie, jb, je, kb, ke, II) Arguments Type Intent Optional Attributes Name real :: sumy (ib:ie,kb:ke) real :: var (ib:ie,jb:je,kb:ke) integer :: ib integer :: ie integer :: jb integer :: je integer :: kb integer :: ke integer :: II (ib:ie,jb:je,kb:ke)","tags":"","loc":"module/modmpi.html"},{"title":"modchecksim – uDALES","text":"Uses modglobal module~~modchecksim~~UsesGraph module~modchecksim modchecksim module~modglobal modglobal module~modchecksim->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~modchecksim~~UsedByGraph module~modchecksim modchecksim program~dalesurban DALESURBAN program~dalesurban->module~modchecksim Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables tcheck tnext dtmn ndt Subroutines initchecksim checksim calccourant calcdiffnr calcreyn chkdiv Variables Type Visibility Attributes Name Initial real, private :: tcheck = 0. real, private :: tnext = 0. real, private :: dtmn = 0. real, private :: ndt = 0. Subroutines public subroutine initchecksim () Arguments None public subroutine checksim () Arguments None private subroutine calccourant () Arguments None private subroutine calcdiffnr () Arguments None private subroutine calcreyn () Arguments None private subroutine chkdiv () Arguments None","tags":"","loc":"module/modchecksim.html"},{"title":"modfields – uDALES","text":"Used by module~~modfields~~UsedByGraph module~modfields modfields proc~fixthetainf fixthetainf proc~fixthetainf->module~modfields proc~iolet iolet proc~iolet->module~modfields proc~grwdamp grwdamp proc~grwdamp->module~modfields proc~drivergen drivergen proc~drivergen->module~modfields proc~advecc_upw advecc_upw proc~advecc_upw->module~modfields proc~calcreyn calcreyn proc~calcreyn->module~modfields proc~createwalls createwalls proc~createwalls->module~modfields proc~diffv diffv proc~diffv->module~modfields proc~inletgen inletgen proc~inletgen->module~modfields proc~nearwall nearwall proc~nearwall->module~modfields proc~genstats genstats proc~genstats->module~modfields proc~advecc_2nd advecc_2nd proc~advecc_2nd->module~modfields proc~inletgennotemp inletgennotemp proc~inletgennotemp->module~modfields proc~fluxtopscal fluxtopscal proc~fluxtopscal->module~modfields proc~createmasks createmasks proc~createmasks->module~modfields proc~cyclicqj cyclicqj proc~cyclicqj->module~modfields proc~inlettop inlettop proc~inlettop->module~modfields proc~closure closure proc~closure->module~modfields proc~scalrec scalrec proc~scalrec->module~modfields proc~valuetopscal valuetopscal proc~valuetopscal->module~modfields proc~boundary boundary proc~boundary->module~modfields proc~chem chem proc~chem->module~modfields proc~coriolis coriolis proc~coriolis->module~modfields proc~fixuinf1 fixuinf1 proc~fixuinf1->module~modfields proc~calcfluidvolumes calcfluidvolumes proc~calcfluidvolumes->module~modfields proc~scalsirane scalSIRANE proc~scalsirane->module~modfields proc~diffu diffu proc~diffu->module~modfields proc~cyclicmj cyclicmj proc~cyclicmj->module~modfields proc~sources sources proc~sources->module~modfields proc~readinitfiles readinitfiles proc~readinitfiles->module~modfields proc~diffe diffe proc~diffe->module~modfields proc~bcpup bcpup proc~bcpup->module~modfields proc~uoutletarea uoutletarea proc~uoutletarea->module~modfields proc~tkestats tkestats proc~tkestats->module~modfields proc~diagfld diagfld proc~diagfld->module~modfields proc~initstatsdump initstatsdump proc~initstatsdump->module~modfields proc~advection advection proc~advection->module~modfields proc~cyclicmi cyclicmi proc~cyclicmi->module~modfields proc~advecw_2nd advecw_2nd proc~advecw_2nd->module~modfields proc~voutletarea voutletarea proc~voutletarea->module~modfields proc~advecu_2nd advecu_2nd proc~advecu_2nd->module~modfields proc~ibmnorm ibmnorm proc~ibmnorm->module~modfields proc~detfreestream detfreestream proc~detfreestream->module~modfields proc~calccourant calccourant proc~calccourant->module~modfields proc~initfielddump initfielddump proc~initfielddump->module~modfields proc~createscals createscals proc~createscals->module~modfields proc~writedriverfile writedriverfile proc~writedriverfile->module~modfields proc~iohi iohi proc~iohi->module~modfields proc~fromztop fromztop proc~fromztop->module~modfields proc~thermodynamics thermodynamics proc~thermodynamics->module~modfields proc~forces forces proc~forces->module~modfields proc~tqaver tqaver proc~tqaver->module~modfields proc~diffw diffw proc~diffw->module~modfields proc~ywallfunplus ywallfunplus proc~ywallfunplus->module~modfields proc~calthv calthv proc~calthv->module~modfields proc~nudge nudge proc~nudge->module~modfields proc~tkestatsdump tkestatsdump proc~tkestatsdump->module~modfields proc~tderive tderive proc~tderive->module~modfields proc~cyclicsi cyclicsi proc~cyclicsi->module~modfields proc~advecc_kappa advecc_kappa proc~advecc_kappa->module~modfields proc~fillps fillps proc~fillps->module~modfields proc~poisr poisr proc~poisr->module~modfields proc~exitmodules exitmodules proc~exitmodules->module~modfields proc~readrestartfiles readrestartfiles proc~readrestartfiles->module~modfields proc~bottom bottom proc~bottom->module~modfields proc~ibmwallfun ibmwallfun proc~ibmwallfun->module~modfields proc~scalsource scalsource proc~scalsource->module~modfields proc~cyclichj cyclichj proc~cyclichj->module~modfields proc~ioqi ioqi proc~ioqi->module~modfields proc~startup startup proc~startup->module~modfields proc~masscorr masscorr proc~masscorr->module~modfields proc~advecv_2nd advecv_2nd proc~advecv_2nd->module~modfields proc~lstend lstend proc~lstend->module~modfields proc~detfreestrtmp detfreestrtmp proc~detfreestrtmp->module~modfields proc~bcp bcp proc~bcp->module~modfields proc~fluidvolume fluidvolume proc~fluidvolume->module~modfields proc~fixuinf2 fixuinf2 proc~fixuinf2->module~modfields proc~xwallscalar xwallscalar proc~xwallscalar->module~modfields proc~calc_halflev calc_halflev proc~calc_halflev->module~modfields proc~cyclicqi cyclicqi proc~cyclicqi->module~modfields proc~subgrid subgrid proc~subgrid->module~modfields proc~statsdump statsdump proc~statsdump->module~modfields proc~tstep_integrate tstep_integrate proc~tstep_integrate->module~modfields proc~cyclichi cyclichi proc~cyclichi->module~modfields proc~zwallfun zwallfun proc~zwallfun->module~modfields proc~iosi iosi proc~iosi->module~modfields proc~fielddump fielddump proc~fielddump->module~modfields proc~initdriver initdriver proc~initdriver->module~modfields proc~chkdiv chkdiv proc~chkdiv->module~modfields proc~ywallfunmin ywallfunmin proc~ywallfunmin->module~modfields proc~tstep_update tstep_update proc~tstep_update->module~modfields proc~readdriverfile readdriverfile proc~readdriverfile->module~modfields proc~cyclicsj cyclicsj proc~cyclicsj->module~modfields proc~xwallfun xwallfun proc~xwallfun->module~modfields proc~initinlet initinlet proc~initinlet->module~modfields proc~writerestartfiles writerestartfiles proc~writerestartfiles->module~modfields module~modfielddump modfielddump module~modfielddump->module~modfields program~dalesurban DALESURBAN program~dalesurban->module~modfielddump Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables worksave um vm wm thlm e12m qtm u0 v0 w0 pres0 thl0 thl0h qt0h e120 qt0 up vp wp thlp e12p qtp svm sv0 svp svpp mindist shear momfluxb tfluxb qfluxb cth IIc IIu IIv IIw IIuw IIvw IIuv IIct IIwt IIuwt IIut IIvt IIcs IIus IIvs IIws IIuws IIvws IIuvs uyt uytik vyt wyt wytik thlyt qtyt thlytk sca1yt sca2yt sca3yt thlsgsyt qtsgsyt usgsyt wsgsyt sv1sgsyt sv2sgsyt sv3sgsyt uxyt vxyt wxyt thlxyt qtxyt pxyt usgsxyt thlsgsxyt vsgsxyt uwtik wthltk wqttk thlthlt qtqtt sv1sv1t sv2sv2t sv3sv3t sv4sv4t PSSt uutc vvtc wwtc vwtjk uvtij utik wtik vtjk wtjk utij vtij wmt thltk qttk thlt utc vtc wtc vmt umt sv1t sv2t sv3t sv4t sv1tk sv2tk sv3tk sv4tk wsv1tk wsv2tk wsv3tk wsv4tk sv1sgst sv2sgst sv3sgst sv4sgst qtt pt slice slice2 slice3 slice4 slice5 slice6 slice7 slice8 scar scarl uav vav wav thlav qtav qlav presav svav viscratioav umint vmint wmint thl2av ql2av qt2av sv2av uuav vvav wwav uvav uwav vwav thluav thlvav thlwav thlthlav qluav qlvav qlwav qtuav qtvav qtwav svuav svvav svwav upupav vpvpav wpwpav thlpthlpav qlpqlpav qtpqtpav svpsvpav upvpav upwpav vpwpav thlpupav thlpvpav thlpwpav qlpupav qlpvpav qlpwpav qtpupav qtpvpav qtpwpav svpupav svpvpav svpwpav uusgsav vvsgsav wwsgsav uwsgsav thlusgsav thlwsgsav qlusgsav qlwsgsav qtusgsav qtwsgsav svusgsav svwsgsav tkesgsav nusgsav strain2av disssgsav tvmx tvmy tvmz tpm ttmx ttmy ttmz tsgsmx1 tsgsmy1 tsgsmz1 tsgsmx2 tsgsmy2 tsgsmz2 t_vav t_sgsav t_pav t_tav p_tav p_bav d_sgsav tkeadv t_v t_sgs t_p t_t p_t p_b d_sgs adv ql0 thv0h whls presf presh exnf exnh thvf thvh rhof qt0av ql0av thl0av u0av v0av ug vg pgx pgy dpdxl dpdyl dthldxls dthldyls dqtdxls dqtdyls dqtdtls dudxls dudyls dvdxls dvdyls wfls ql0h dthvdz thlprof qtprof uprof vprof e12prof sv0av svprof qlprof thlpcar SW_up_TOA SW_dn_TOA LW_up_TOA LW_dn_TOA uout wout friction momthick displthick uouttot wouttot udef vdef vout vouttot thlsrcdt dgdt dpdx uoutarea voutarea fluidvol ncname ncstaty ncstatyt ncstattke ncstatxy ncstatxyt ncstatslice ncstatt wall Subroutines initfields exitfields Variables Type Visibility Attributes Name Initial real, public, allocatable :: worksave (:) real, public, allocatable :: um (:,:,:) real, public, allocatable :: vm (:,:,:) real, public, allocatable :: wm (:,:,:) real, public, allocatable :: thlm (:,:,:) real, public, allocatable :: e12m (:,:,:) real, public, allocatable :: qtm (:,:,:) real, public, allocatable, target :: u0 (:,:,:) real, public, allocatable, target :: v0 (:,:,:) real, public, allocatable, target :: w0 (:,:,:) real, public, allocatable, target :: pres0 (:,:,:) real, public, allocatable, target :: thl0 (:,:,:) real, public, allocatable :: thl0h (:,:,:) real, public, allocatable :: qt0h (:,:,:) real, public, allocatable :: e120 (:,:,:) real, public, allocatable, target :: qt0 (:,:,:) real, public, allocatable :: up (:,:,:) real, public, allocatable :: vp (:,:,:) real, public, allocatable :: wp (:,:,:) real, public, allocatable :: thlp (:,:,:) real, public, allocatable :: e12p (:,:,:) real, public, allocatable :: qtp (:,:,:) real, public, allocatable :: svm (:,:,:,:) real, public, allocatable, target :: sv0 (:,:,:,:) real, public, allocatable :: svp (:,:,:,:) real, public, allocatable :: svpp (:,:,:,:) real, public, allocatable :: mindist (:,:,:) real, public, allocatable :: shear (:,:,:,:) real, public, allocatable :: momfluxb (:,:,:) real, public, allocatable :: tfluxb (:,:,:) real, public, allocatable :: qfluxb (:,:,:) real, public, allocatable :: cth (:,:,:) integer, public, allocatable :: IIc (:,:,:) integer, public, allocatable :: IIu (:,:,:) integer, public, allocatable :: IIv (:,:,:) integer, public, allocatable :: IIw (:,:,:) integer, public, allocatable :: IIuw (:,:,:) integer, public, allocatable :: IIvw (:,:,:) integer, public, allocatable :: IIuv (:,:,:) integer, public, allocatable :: IIct (:,:) integer, public, allocatable :: IIwt (:,:) integer, public, allocatable :: IIuwt (:,:) integer, public, allocatable :: IIut (:,:) integer, public, allocatable :: IIvt (:,:) integer, public, allocatable :: IIcs (:) integer, public, allocatable :: IIus (:) integer, public, allocatable :: IIvs (:) integer, public, allocatable :: IIws (:) integer, public, allocatable :: IIuws (:) integer, public, allocatable :: IIvws (:) integer, public, allocatable :: IIuvs (:) real, public, allocatable :: uyt (:,:) real, public, allocatable :: uytik (:,:) real, public, allocatable :: vyt (:,:) real, public, allocatable :: wyt (:,:) real, public, allocatable :: wytik (:,:) real, public, allocatable :: thlyt (:,:) real, public, allocatable :: qtyt (:,:) real, public, allocatable :: thlytk (:,:) real, public, allocatable :: sca1yt (:,:) real, public, allocatable :: sca2yt (:,:) real, public, allocatable :: sca3yt (:,:) real, public, allocatable :: thlsgsyt (:,:) real, public, allocatable :: qtsgsyt (:,:) real, public, allocatable :: usgsyt (:,:) real, public, allocatable :: wsgsyt (:,:) real, public, allocatable :: sv1sgsyt (:,:) real, public, allocatable :: sv2sgsyt (:,:) real, public, allocatable :: sv3sgsyt (:,:) real, public, allocatable :: uxyt (:) real, public, allocatable :: vxyt (:) real, public, allocatable :: wxyt (:) real, public, allocatable :: thlxyt (:) real, public, allocatable :: qtxyt (:) real, public, allocatable :: pxyt (:) real, public, allocatable :: usgsxyt (:) real, public, allocatable :: thlsgsxyt (:) real, public, allocatable :: vsgsxyt (:) real, public, allocatable :: uwtik (:,:,:) real, public, allocatable :: wthltk (:,:,:) real, public, allocatable :: wqttk (:,:,:) real, public, allocatable :: thlthlt (:,:,:) real, public, allocatable :: qtqtt (:,:,:) real, public, allocatable :: sv1sv1t (:,:,:) real, public, allocatable :: sv2sv2t (:,:,:) real, public, allocatable :: sv3sv3t (:,:,:) real, public, allocatable :: sv4sv4t (:,:,:) real, public, allocatable :: PSSt (:,:,:) real, public, allocatable :: uutc (:,:,:) real, public, allocatable :: vvtc (:,:,:) real, public, allocatable :: wwtc (:,:,:) real, public, allocatable :: vwtjk (:,:,:) real, public, allocatable :: uvtij (:,:,:) real, public, allocatable :: utik (:,:,:) real, public, allocatable :: wtik (:,:,:) real, public, allocatable :: vtjk (:,:,:) real, public, allocatable :: wtjk (:,:,:) real, public, allocatable :: utij (:,:,:) real, public, allocatable :: vtij (:,:,:) real, public, allocatable :: wmt (:,:,:) real, public, allocatable :: thltk (:,:,:) real, public, allocatable :: qttk (:,:,:) real, public, allocatable :: thlt (:,:,:) real, public, allocatable :: utc (:,:,:) real, public, allocatable :: vtc (:,:,:) real, public, allocatable :: wtc (:,:,:) real, public, allocatable :: vmt (:,:,:) real, public, allocatable :: umt (:,:,:) real, public, allocatable :: sv1t (:,:,:) real, public, allocatable :: sv2t (:,:,:) real, public, allocatable :: sv3t (:,:,:) real, public, allocatable :: sv4t (:,:,:) real, public, allocatable :: sv1tk (:,:,:) real, public, allocatable :: sv2tk (:,:,:) real, public, allocatable :: sv3tk (:,:,:) real, public, allocatable :: sv4tk (:,:,:) real, public, allocatable :: wsv1tk (:,:,:) real, public, allocatable :: wsv2tk (:,:,:) real, public, allocatable :: wsv3tk (:,:,:) real, public, allocatable :: wsv4tk (:,:,:) real, public, allocatable :: sv1sgst (:,:,:) real, public, allocatable :: sv2sgst (:,:,:) real, public, allocatable :: sv3sgst (:,:,:) real, public, allocatable :: sv4sgst (:,:,:) real, public, allocatable :: qtt (:,:,:) real, public, allocatable :: pt (:,:,:) real, public, allocatable :: slice (:,:) real, public, allocatable :: slice2 (:,:) real, public, allocatable :: slice3 (:,:) real, public, allocatable :: slice4 (:,:) real, public, allocatable :: slice5 (:,:) real, public, allocatable :: slice6 (:,:) real, public, allocatable :: slice7 (:,:) real, public, allocatable :: slice8 (:,:) real, public, allocatable :: scar (:,:) real, public, allocatable :: scarl (:,:) real, public, allocatable :: uav (:,:,:) real, public, allocatable :: vav (:,:,:) real, public, allocatable :: wav (:,:,:) real, public, allocatable :: thlav (:,:,:) real, public, allocatable :: qtav (:,:,:) real, public, allocatable :: qlav (:,:,:) real, public, allocatable :: presav (:,:,:) real, public, allocatable :: svav (:,:,:,:) real, public, allocatable :: viscratioav (:,:,:) real, public, allocatable :: umint (:,:,:) real, public, allocatable :: vmint (:,:,:) real, public, allocatable :: wmint (:,:,:) real, public, allocatable :: thl2av (:,:,:) real, public, allocatable :: ql2av (:,:,:) real, public, allocatable :: qt2av (:,:,:) real, public, allocatable :: sv2av (:,:,:,:) real, public, allocatable :: uuav (:,:,:) real, public, allocatable :: vvav (:,:,:) real, public, allocatable :: wwav (:,:,:) real, public, allocatable :: uvav (:,:,:) real, public, allocatable :: uwav (:,:,:) real, public, allocatable :: vwav (:,:,:) real, public, allocatable :: thluav (:,:,:) real, public, allocatable :: thlvav (:,:,:) real, public, allocatable :: thlwav (:,:,:) real, public, allocatable :: thlthlav (:,:,:) real, public, allocatable :: qluav (:,:,:) real, public, allocatable :: qlvav (:,:,:) real, public, allocatable :: qlwav (:,:,:) real, public, allocatable :: qtuav (:,:,:) real, public, allocatable :: qtvav (:,:,:) real, public, allocatable :: qtwav (:,:,:) real, public, allocatable :: svuav (:,:,:,:) real, public, allocatable :: svvav (:,:,:,:) real, public, allocatable :: svwav (:,:,:,:) real, public, allocatable :: upupav (:,:,:) real, public, allocatable :: vpvpav (:,:,:) real, public, allocatable :: wpwpav (:,:,:) real, public, allocatable :: thlpthlpav (:,:,:) real, public, allocatable :: qlpqlpav (:,:,:) real, public, allocatable :: qtpqtpav (:,:,:) real, public, allocatable :: svpsvpav (:,:,:,:) real, public, allocatable :: upvpav (:,:,:) real, public, allocatable :: upwpav (:,:,:) real, public, allocatable :: vpwpav (:,:,:) real, public, allocatable :: thlpupav (:,:,:) real, public, allocatable :: thlpvpav (:,:,:) real, public, allocatable :: thlpwpav (:,:,:) real, public, allocatable :: qlpupav (:,:,:) real, public, allocatable :: qlpvpav (:,:,:) real, public, allocatable :: qlpwpav (:,:,:) real, public, allocatable :: qtpupav (:,:,:) real, public, allocatable :: qtpvpav (:,:,:) real, public, allocatable :: qtpwpav (:,:,:) real, public, allocatable :: svpupav (:,:,:,:) real, public, allocatable :: svpvpav (:,:,:,:) real, public, allocatable :: svpwpav (:,:,:,:) real, public, allocatable :: uusgsav (:,:,:) real, public, allocatable :: vvsgsav (:,:,:) real, public, allocatable :: wwsgsav (:,:,:) real, public, allocatable :: uwsgsav (:,:,:) real, public, allocatable :: thlusgsav (:,:,:) real, public, allocatable :: thlwsgsav (:,:,:) real, public, allocatable :: qlusgsav (:,:,:) real, public, allocatable :: qlwsgsav (:,:,:) real, public, allocatable :: qtusgsav (:,:,:) real, public, allocatable :: qtwsgsav (:,:,:) real, public, allocatable :: svusgsav (:,:,:,:) real, public, allocatable :: svwsgsav (:,:,:,:) real, public, allocatable :: tkesgsav (:,:,:) real, public, allocatable :: nusgsav (:,:,:) real, public, allocatable :: strain2av (:,:,:) real, public, allocatable :: disssgsav (:,:,:) real, public, allocatable :: tvmx (:,:,:) real, public, allocatable :: tvmy (:,:,:) real, public, allocatable :: tvmz (:,:,:) real, public, allocatable :: tpm (:,:,:) real, public, allocatable :: ttmx (:,:,:) real, public, allocatable :: ttmy (:,:,:) real, public, allocatable :: ttmz (:,:,:) real, public, allocatable :: tsgsmx1 (:,:,:) real, public, allocatable :: tsgsmy1 (:,:,:) real, public, allocatable :: tsgsmz1 (:,:,:) real, public, allocatable :: tsgsmx2 (:,:,:) real, public, allocatable :: tsgsmy2 (:,:,:) real, public, allocatable :: tsgsmz2 (:,:,:) real, public, allocatable :: t_vav (:,:,:) real, public, allocatable :: t_sgsav (:,:,:) real, public, allocatable :: t_pav (:,:,:) real, public, allocatable :: t_tav (:,:,:) real, public, allocatable :: p_tav (:,:,:) real, public, allocatable :: p_bav (:,:,:) real, public, allocatable :: d_sgsav (:,:,:) real, public, allocatable :: tkeadv (:,:,:) real, public, allocatable :: t_v (:) real, public, allocatable :: t_sgs (:) real, public, allocatable :: t_p (:) real, public, allocatable :: t_t (:) real, public, allocatable :: p_t (:) real, public, allocatable :: p_b (:) real, public, allocatable :: d_sgs (:) real, public, allocatable :: adv (:) real, public, allocatable, target :: ql0 (:,:,:) real, public, allocatable :: thv0h (:,:,:) real, public, allocatable :: whls (:) real, public, allocatable :: presf (:) real, public, allocatable :: presh (:) real, public, allocatable :: exnf (:) real, public, allocatable :: exnh (:) real, public, allocatable :: thvf (:) real, public, allocatable :: thvh (:) real, public, allocatable :: rhof (:) real, public, allocatable :: qt0av (:) real, public, allocatable :: ql0av (:) real, public, allocatable :: thl0av (:) real, public, allocatable :: u0av (:) real, public, allocatable :: v0av (:) real, public, allocatable :: ug (:) real, public, allocatable :: vg (:) real, public, allocatable :: pgx (:) real, public, allocatable :: pgy (:) real, public, allocatable :: dpdxl (:) real, public, allocatable :: dpdyl (:) real, public, allocatable :: dthldxls (:) real, public, allocatable :: dthldyls (:) real, public, allocatable :: dqtdxls (:) real, public, allocatable :: dqtdyls (:) real, public, allocatable :: dqtdtls (:) real, public, allocatable :: dudxls (:) real, public, allocatable :: dudyls (:) real, public, allocatable :: dvdxls (:) real, public, allocatable :: dvdyls (:) real, public, allocatable :: wfls (:) real, public, allocatable :: ql0h (:,:,:) real, public, allocatable :: dthvdz (:,:,:) real, public, allocatable :: thlprof (:) real, public, allocatable :: qtprof (:) real, public, allocatable :: uprof (:) real, public, allocatable :: vprof (:) real, public, allocatable :: e12prof (:) real, public, allocatable :: sv0av (:,:) real, public, allocatable :: svprof (:,:) real, public, allocatable :: qlprof (:) real, public, allocatable :: thlpcar (:) real, public, allocatable :: SW_up_TOA (:,:) real, public, allocatable :: SW_dn_TOA (:,:) real, public, allocatable :: LW_up_TOA (:,:) real, public, allocatable :: LW_dn_TOA (:,:) real, public, allocatable :: uout (:) real, public, allocatable :: wout (:) real, public, allocatable :: friction (:) real, public, allocatable :: momthick (:) real, public, allocatable :: displthick (:) real, public :: uouttot real, public :: wouttot real, public :: udef real, public :: vdef real, public, allocatable :: vout (:) real, public :: vouttot real, public :: thlsrcdt real, public :: dgdt real, public :: dpdx = 0. real, public :: uoutarea real, public :: voutarea real, public :: fluidvol character(len=80), public, allocatable :: ncname (:,:) character(len=80), public, allocatable :: ncstaty (:,:) character(len=80), public, allocatable :: ncstatyt (:,:) character(len=80), public, allocatable :: ncstattke (:,:) character(len=80), public, allocatable :: ncstatxy (:,:) character(len=80), public, allocatable :: ncstatxyt (:,:) character(len=80), public, allocatable :: ncstatslice (:,:) character(len=80), public, allocatable :: ncstatt (:,:) integer, public, allocatable :: wall (:,:,:,:) Subroutines public subroutine initfields () Arguments None public subroutine exitfields () Arguments None","tags":"","loc":"module/modfields.html"},{"title":"modEB – uDALES","text":"Uses modglobal module~~modeb~~UsesGraph module~modeb modEB module~modglobal modglobal module~modeb->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~modeb~~UsedByGraph module~modeb modEB program~dalesurban DALESURBAN program~dalesurban->module~modeb Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables nstatT nstatEB ncidT ncidEB nrecT nrecEB ncstatT ncstatEB Tname EBname tncstatT tncstatEB varsT varsEB Functions matinv3 matinv4 gaussji Subroutines intqH initEB calclw updateGR EB Variables Type Visibility Attributes Name Initial integer, public :: nstatT = 2 integer, public :: nstatEB = 5 integer, public :: ncidT integer, public :: ncidEB integer, public :: nrecT = 0 integer, public :: nrecEB = 0 character(len=80), public, allocatable :: ncstatT (:,:) character(len=80), public, allocatable :: ncstatEB (:,:) character(len=80), public :: Tname = \"facT.xxx.nc\" character(len=80), public :: EBname = 'facEB.xxx.nc' character(len=80), public, dimension(1,4) :: tncstatT character(len=80), public, dimension(1,4) :: tncstatEB real, public, allocatable :: varsT (:,:,:) real, public, allocatable :: varsEB (:,:) Functions public pure function matinv3 (A) result(B) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (3,3) Return Value real\n  (3,3) public pure function matinv4 (A) result(B) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (4,4) Return Value real\n  (4,4) public function gaussji (c, d, n) result(a) Arguments Type Intent Optional Attributes Name real, intent(in) :: c (n,n) real, intent(in) :: d (n,n) integer :: n Return Value real\n  (n,n) Subroutines public subroutine intqH () Arguments None public subroutine initEB () Arguments None public subroutine calclw () Arguments None public subroutine updateGR () Arguments None public subroutine EB () Arguments None","tags":"","loc":"module/modeb.html"},{"title":"moddriver – uDALES","text":"Uses modinletdata module~~moddriver~~UsesGraph module~moddriver moddriver module~modinletdata modinletdata module~moddriver->module~modinletdata Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~moddriver~~UsedByGraph module~moddriver moddriver proc~startup startup proc~startup->module~moddriver proc~readinitfiles readinitfiles proc~readinitfiles->module~moddriver proc~boundary boundary proc~boundary->module~moddriver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines initdriver drivergen writedriverfile readdriverfile exitdriver Subroutines public subroutine initdriver () Arguments None public subroutine drivergen () Arguments None public subroutine writedriverfile () Arguments None public subroutine readdriverfile () Arguments None public subroutine exitdriver () Arguments None","tags":"","loc":"module/moddriver.html"},{"title":"DALESURBAN – uDALES","text":"Uses modmpi modglobal modstartup modsave modboundary modthermodynamics modsubgrid modforces modpois modibm initfac modEB modchecksim modstat_nc modfielddump modstatsdump program~~dalesurban~~UsesGraph program~dalesurban DALESURBAN module~modstartup modstartup program~dalesurban->module~modstartup module~modibm modibm program~dalesurban->module~modibm module~modpois modpois program~dalesurban->module~modpois module~modmpi modmpi program~dalesurban->module~modmpi module~modboundary modboundary program~dalesurban->module~modboundary module~modsave modsave program~dalesurban->module~modsave module~modsubgrid modsubgrid program~dalesurban->module~modsubgrid module~modchecksim modchecksim program~dalesurban->module~modchecksim module~modforces modforces program~dalesurban->module~modforces module~modfielddump modfielddump program~dalesurban->module~modfielddump module~modstatsdump modstatsdump program~dalesurban->module~modstatsdump module~initfac initfac program~dalesurban->module~initfac module~modstat_nc modstat_nc program~dalesurban->module~modstat_nc module~modthermodynamics modthermodynamics program~dalesurban->module~modthermodynamics module~modglobal modglobal program~dalesurban->module~modglobal module~modeb modEB program~dalesurban->module~modeb module~modibmdata modibmdata module~modibm->module~modibmdata mpi mpi module~modmpi->mpi module~modsubgriddata modsubgriddata module~modsubgrid->module~modsubgriddata module~modchecksim->module~modglobal module~modfielddump->module~modglobal module~modfields modfields module~modfielddump->module~modfields module~modstatsdump->module~modmpi module~modstatsdump->module~modglobal module~initfac->module~modmpi module~initfac->module~modglobal netcdf netcdf module~initfac->netcdf module~modstat_nc->module~modmpi module~modstat_nc->netcdf module~modeb->module~modglobal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Calls program~~dalesurban~~CallsGraph program~dalesurban DALESURBAN proc~fixthetainf fixthetainf program~dalesurban->proc~fixthetainf proc~poisson poisson program~dalesurban->proc~poisson proc~fixuinf2 fixuinf2 program~dalesurban->proc~fixuinf2 proc~grwdamp grwdamp program~dalesurban->proc~grwdamp proc~initstat_nc initstat_nc program~dalesurban->proc~initstat_nc proc~exitstatsdump exitstatsdump program~dalesurban->proc~exitstatsdump proc~thermodynamics thermodynamics program~dalesurban->proc~thermodynamics proc~subgrid subgrid program~dalesurban->proc~subgrid proc~createwalls createwalls program~dalesurban->proc~createwalls proc~forces forces program~dalesurban->proc~forces proc~statsdump statsdump program~dalesurban->proc~statsdump proc~tstep_integrate tstep_integrate program~dalesurban->proc~tstep_integrate proc~initeb initEB program~dalesurban->proc~initeb proc~readfacetfiles readfacetfiles program~dalesurban->proc~readfacetfiles proc~exitfielddump exitfielddump program~dalesurban->proc~exitfielddump proc~nudge nudge program~dalesurban->proc~nudge proc~fielddump fielddump program~dalesurban->proc~fielddump proc~initstatsdump initstatsdump program~dalesurban->proc~initstatsdump proc~checksim checksim program~dalesurban->proc~checksim proc~advection advection program~dalesurban->proc~advection proc~initmpi initmpi program~dalesurban->proc~initmpi proc~initchecksim initchecksim program~dalesurban->proc~initchecksim proc~tstep_update tstep_update program~dalesurban->proc~tstep_update proc~exitmodules exitmodules program~dalesurban->proc~exitmodules proc~bottom bottom program~dalesurban->proc~bottom proc~ibmwallfun ibmwallfun program~dalesurban->proc~ibmwallfun proc~scalsource scalsource program~dalesurban->proc~scalsource proc~ibmnorm ibmnorm program~dalesurban->proc~ibmnorm proc~boundary boundary program~dalesurban->proc~boundary proc~writerestartfiles writerestartfiles program~dalesurban->proc~writerestartfiles proc~coriolis coriolis program~dalesurban->proc~coriolis proc~startup startup program~dalesurban->proc~startup proc~fixuinf1 fixuinf1 program~dalesurban->proc~fixuinf1 proc~eb EB program~dalesurban->proc~eb proc~initfielddump initfielddump program~dalesurban->proc~initfielddump proc~masscorr masscorr program~dalesurban->proc~masscorr proc~lstend lstend program~dalesurban->proc~lstend proc~tderive tderive proc~poisson->proc~tderive proc~fillps fillps proc~poisson->proc~fillps proc~poisr poisr proc~poisson->proc~poisr proc~solmpj solmpj proc~poisson->proc~solmpj proc~detfreestream detfreestream proc~fixuinf2->proc~detfreestream proc~diagfld diagfld proc~thermodynamics->proc~diagfld proc~calthv calthv proc~thermodynamics->proc~calthv proc~calc_halflev calc_halflev proc~thermodynamics->proc~calc_halflev proc~thermo thermo proc~thermodynamics->proc~thermo proc~diffv diffv proc~subgrid->proc~diffv proc~closure closure proc~subgrid->proc~closure proc~diffu diffu proc~subgrid->proc~diffu proc~diffw diffw proc~subgrid->proc~diffw ekh ekh proc~statsdump->ekh ekm ekm proc~statsdump->ekm proc~tkestatsdump tkestatsdump proc~statsdump->proc~tkestatsdump proc~writestat_1d_nc writestat_1D_nc proc~statsdump->proc~writestat_1d_nc interface~writestat_nc writestat_nc proc~statsdump->interface~writestat_nc proc~chem chem proc~tstep_integrate->proc~chem 13 13 proc~tstep_integrate->13 proc~gaussji gaussji proc~initeb->proc~gaussji proc~writestat_dims_nc writestat_dims_nc proc~initeb->proc~writestat_dims_nc proc~matinv4 matinv4 proc~initeb->proc~matinv4 proc~define_nc define_nc proc~initeb->proc~define_nc proc~open_nc open_nc proc~initeb->proc~open_nc proc~qsat qsat proc~readfacetfiles->proc~qsat mpi_bcast mpi_bcast proc~readfacetfiles->mpi_bcast nf90_inq_varid nf90_inq_varid proc~readfacetfiles->nf90_inq_varid nf90_get_var nf90_get_var proc~readfacetfiles->nf90_get_var nf90_open nf90_open proc~readfacetfiles->nf90_open proc~fielddump->interface~writestat_nc proc~initstatsdump->proc~writestat_dims_nc proc~initstatsdump->mpi_bcast proc~initstatsdump->proc~define_nc proc~initstatsdump->proc~open_nc proc~calccourant calccourant proc~checksim->proc~calccourant proc~calcdiffnr calcdiffnr proc~checksim->proc~calcdiffnr proc~chkdiv chkdiv proc~checksim->proc~chkdiv proc~advecc_2nd advecc_2nd proc~advection->proc~advecc_2nd proc~advecw_2nd advecw_2nd proc~advection->proc~advecw_2nd proc~advecu_2nd advecu_2nd proc~advection->proc~advecu_2nd proc~advecc_kappa advecc_kappa proc~advection->proc~advecc_kappa proc~advecv_2nd advecv_2nd proc~advection->proc~advecv_2nd mpi_wtime mpi_wtime proc~initmpi->mpi_wtime mpi_dims_create mpi_dims_create proc~initmpi->mpi_dims_create mpi_comm_rank mpi_comm_rank proc~initmpi->mpi_comm_rank mpi_comm_size mpi_comm_size proc~initmpi->mpi_comm_size mpi_cart_shift mpi_cart_shift proc~initmpi->mpi_cart_shift mpi_cart_create mpi_cart_create proc~initmpi->mpi_cart_create mpi_init mpi_init proc~initmpi->mpi_init proc~initchecksim->mpi_bcast mpi_allreduce mpi_allreduce proc~tstep_update->mpi_allreduce proc~exitglobal exitglobal proc~exitmodules->proc~exitglobal proc~exitsubgrid exitsubgrid proc~exitmodules->proc~exitsubgrid proc~exitthermodynamics exitthermodynamics proc~exitmodules->proc~exitthermodynamics proc~exitmpi exitmpi proc~exitmodules->proc~exitmpi proc~exitpois exitpois proc~exitmodules->proc~exitpois proc~exitfields exitfields proc~exitmodules->proc~exitfields proc~exitinlet exitinlet proc~exitmodules->proc~exitinlet proc~wfuno wfuno proc~bottom->proc~wfuno proc~wfmneutral wfmneutral proc~bottom->proc~wfmneutral proc~ywallfunplus ywallfunplus proc~ibmwallfun->proc~ywallfunplus proc~zwallfun zwallfun proc~ibmwallfun->proc~zwallfun proc~ywallfunmin ywallfunmin proc~ibmwallfun->proc~ywallfunmin proc~xwallfun xwallfun proc~ibmwallfun->proc~xwallfun proc~iolet iolet proc~boundary->proc~iolet proc~drivergen drivergen proc~boundary->proc~drivergen proc~inletgen inletgen proc~boundary->proc~inletgen proc~inletgennotemp inletgennotemp proc~boundary->proc~inletgennotemp proc~fluxtopscal fluxtopscal proc~boundary->proc~fluxtopscal proc~cyclicqj cyclicqj proc~boundary->proc~cyclicqj proc~inlettop inlettop proc~boundary->proc~inlettop proc~scalrec scalrec proc~boundary->proc~scalrec proc~fluxtop fluxtop proc~boundary->proc~fluxtop proc~valuetopscal valuetopscal proc~boundary->proc~valuetopscal proc~scalsirane scalSIRANE proc~boundary->proc~scalsirane proc~cyclicmj cyclicmj proc~boundary->proc~cyclicmj proc~cyclicmi cyclicmi proc~boundary->proc~cyclicmi proc~iohi iohi proc~boundary->proc~iohi proc~cyclicsi cyclicsi proc~boundary->proc~cyclicsi proc~cyclichj cyclichj proc~boundary->proc~cyclichj proc~ioqi ioqi proc~boundary->proc~ioqi proc~cyclicqi cyclicqi proc~boundary->proc~cyclicqi proc~cyclichi cyclichi proc~boundary->proc~cyclichi proc~iosi iosi proc~boundary->proc~iosi proc~valuetop valuetop proc~boundary->proc~valuetop proc~cyclicsj cyclicsj proc~boundary->proc~cyclicsj proc~initglobal initglobal proc~startup->proc~initglobal proc~createmasks createmasks proc~startup->proc~createmasks proc~initpois initpois proc~startup->proc~initpois proc~initfields initfields proc~startup->proc~initfields proc~calcfluidvolumes calcfluidvolumes proc~startup->proc~calcfluidvolumes proc~readinitfiles readinitfiles proc~startup->proc~readinitfiles proc~checkinitvalues checkinitvalues proc~startup->proc~checkinitvalues proc~initthermodynamics initthermodynamics proc~startup->proc~initthermodynamics proc~startup->mpi_bcast proc~createscals createscals proc~startup->proc~createscals proc~initboundary initboundary proc~startup->proc~initboundary proc~initsubgrid initsubgrid proc~startup->proc~initsubgrid proc~initdriver initdriver proc~startup->proc~initdriver proc~initinlet initinlet proc~startup->proc~initinlet proc~fixuinf1->proc~detfreestream proc~eb->proc~gaussji proc~calclw calclw proc~eb->proc~calclw proc~eb->mpi_bcast proc~writestat_2d_nc writestat_2D_nc proc~eb->proc~writestat_2d_nc proc~eb->proc~matinv4 proc~updategr updateGR proc~eb->proc~updategr proc~eb->proc~writestat_1d_nc proc~intqh intqH proc~eb->proc~intqh proc~eb->interface~writestat_nc proc~initfielddump->proc~writestat_dims_nc proc~initfielddump->mpi_bcast proc~initfielddump->proc~define_nc proc~initfielddump->proc~open_nc proc~masscorr->mpi_bcast proc~initglobal->mpi_bcast float float proc~initglobal->float proc~slabsum slabsum proc~iolet->proc~slabsum proc~writedriverfile writedriverfile proc~drivergen->proc~writedriverfile proc~inletgen->proc~writerestartfiles proc~enthalpythickness enthalpythickness proc~inletgen->proc~enthalpythickness proc~writeinletfile writeinletfile proc~inletgen->proc~writeinletfile wrec wrec proc~inletgen->wrec proc~readinletfile readinletfile proc~inletgen->proc~readinletfile proc~inletgen->proc~slabsum tinl tinl proc~inletgen->tinl proc~momentumthicknessexp momentumthicknessexp proc~inletgen->proc~momentumthicknessexp utav utav proc~inletgen->utav trec trec proc~inletgen->trec urec urec proc~inletgen->urec ttav ttav proc~inletgen->ttav uinl uinl proc~inletgen->uinl proc~blthicknesst blthicknesst proc~inletgen->proc~blthicknesst proc~dispthicknessexp dispthicknessexp proc~inletgen->proc~dispthicknessexp proc~writestat_dims_nc->nf90_inq_varid nf90_inquire_dimension nf90_inquire_dimension proc~writestat_dims_nc->nf90_inquire_dimension nf90_put_var nf90_put_var proc~writestat_dims_nc->nf90_put_var proc~inletgennotemp->proc~writerestartfiles proc~inletgennotemp->proc~writeinletfile proc~inletgennotemp->wrec proc~inletgennotemp->proc~readinletfile proc~inletgennotemp->proc~slabsum proc~inletgennotemp->proc~momentumthicknessexp proc~inletgennotemp->utav proc~inletgennotemp->urec proc~inletgennotemp->uinl proc~inletgennotemp->proc~blthicknesst proc~inletgennotemp->proc~dispthicknessexp proc~createmasks->mpi_allreduce proc~createmasks->mpi_bcast proc~excjs excjs proc~cyclicqj->proc~excjs proc~slabsumi slabsumi proc~inlettop->proc~slabsumi proc~closurebc closurebc proc~closure->proc~closurebc proc~fluidvolume fluidvolume proc~calcfluidvolumes->proc~fluidvolume proc~uoutletarea uoutletarea proc~calcfluidvolumes->proc~uoutletarea proc~voutletarea voutletarea proc~calcfluidvolumes->proc~voutletarea proc~cyclicmj->proc~excjs proc~exitmpi->mpi_wtime mpi_comm_free mpi_comm_free proc~exitmpi->mpi_comm_free mpi_finalize mpi_finalize proc~exitmpi->mpi_finalize proc~readinitfiles->proc~thermodynamics proc~readinitfiles->proc~boundary proc~readinitfiles->proc~drivergen proc~readinitfiles->mpi_bcast proc~readinitfiles->proc~calc_halflev proc~readinitfiles->proc~readinletfile proc~readinitfiles->proc~slabsum proc~randomnize randomnize proc~readinitfiles->proc~randomnize proc~readrestartfiles readrestartfiles proc~readinitfiles->proc~readrestartfiles proc~readdriverfile readdriverfile proc~readinitfiles->proc~readdriverfile proc~checkinitvalues->mpi_bcast proc~checkinitvalues->mpi_finalize proc~fromztop fromztop proc~diagfld->proc~fromztop proc~unoh unoh proc~wfuno->proc~unoh proc~detfreestream->mpi_allreduce proc~calccourant->mpi_allreduce proc~writestat_2d_nc->nf90_inq_varid proc~writestat_2d_nc->nf90_put_var nf90_sync nf90_sync proc~writestat_2d_nc->nf90_sync proc~define_nc->nf90_inq_varid nf90_def_var nf90_def_var proc~define_nc->nf90_def_var nf90_inq_dimid nf90_inq_dimid proc~define_nc->nf90_inq_dimid proc~nchandle_error nchandle_error proc~define_nc->proc~nchandle_error nf90_redef nf90_redef proc~define_nc->nf90_redef nf90_enddef nf90_enddef proc~define_nc->nf90_enddef nf90_put_att nf90_put_att proc~define_nc->nf90_put_att proc~ywallscalarplus ywallscalarplus proc~ywallfunplus->proc~ywallscalarplus proc~tkestatsdump->proc~excjs proc~updategr->proc~qsat proc~bcp bcp proc~tderive->proc~bcp proc~rlim rlim proc~advecc_kappa->proc~rlim proc~bcpup bcpup proc~fillps->proc~bcpup vrfftf vrfftf proc~poisr->vrfftf proc~all_all_j2 ALL_ALL_j2 proc~poisr->proc~all_all_j2 blktri blktri proc~poisr->blktri vrffti vrffti proc~poisr->vrffti proc~poisr->float vrfftb vrfftb proc~poisr->vrfftb proc~barrou barrou proc~poisr->proc~barrou proc~cyclichj->proc~excjs proc~writestat_1d_nc->nf90_inq_varid proc~writestat_1d_nc->nf90_put_var proc~writestat_1d_nc->nf90_sync proc~subgridnamelist subgridnamelist proc~initsubgrid->proc~subgridnamelist proc~solmpj->mpi_comm_rank proc~solmpj->mpi_comm_size rfftb rfftb proc~solmpj->rfftb rffti rffti proc~solmpj->rffti rfftf rfftf proc~solmpj->rfftf proc~all_all_j ALL_ALL_j proc~solmpj->proc~all_all_j proc~solmpj->float proc~calcdiffnr->mpi_allreduce proc~chkdiv->mpi_allreduce proc~ywallscalarmin ywallscalarmin proc~ywallfunmin->proc~ywallscalarmin proc~readzincoord readzincoord proc~initinlet->proc~readzincoord winl winl proc~initinlet->winl proc~initinlet->wrec proc~initinlet->tinl proc~initinlet->utav proc~initinlet->trec proc~initinlet->urec proc~initinlet->ttav proc~initinlet->uinl proc~open_nc->nf90_inq_varid proc~open_nc->nf90_get_var proc~open_nc->nf90_open proc~open_nc->nf90_def_var proc~open_nc->nf90_inq_dimid proc~open_nc->nf90_inquire_dimension nf90_create nf90_create proc~open_nc->nf90_create proc~open_nc->nf90_enddef proc~open_nc->nf90_sync proc~open_nc->nf90_put_att nf90_def_dim nf90_def_dim proc~open_nc->nf90_def_dim nf90_inquire nf90_inquire proc~open_nc->nf90_inquire interface~writestat_nc->proc~writestat_2d_nc interface~writestat_nc->proc~writestat_1d_nc proc~writestat_3d_nc writestat_3D_nc interface~writestat_nc->proc~writestat_3d_nc proc~writestat_3d_short_nc writestat_3D_short_nc interface~writestat_nc->proc~writestat_3d_short_nc proc~writestat_time_nc writestat_time_nc interface~writestat_nc->proc~writestat_time_nc proc~excj excj proc~bcp->proc~excj proc~readzincoord->mpi_bcast proc~closurebc->proc~excjs nf90_strerror nf90_strerror proc~nchandle_error->nf90_strerror proc~bcpup->proc~excjs proc~all_all_j2->proc~barrou mpi_alltoall mpi_alltoall proc~all_all_j2->mpi_alltoall proc~writestat_3d_nc->nf90_inq_varid proc~writestat_3d_nc->nf90_put_var proc~writestat_3d_nc->nf90_sync proc~readinletfile->proc~excjs proc~yinterpolate yinterpolate proc~readinletfile->proc~yinterpolate proc~slabsum->mpi_allreduce proc~slabsumi->mpi_allreduce proc~writestat_3d_short_nc->nf90_inq_varid proc~writestat_3d_short_nc->nf90_put_var proc~writestat_3d_short_nc->nf90_sync proc~voutletarea->mpi_bcast proc~zinterpolate2d zinterpolate2d proc~readrestartfiles->proc~zinterpolate2d proc~zinterpolatew1d zinterpolatew1d proc~readrestartfiles->proc~zinterpolatew1d proc~zinterpolate1d zinterpolate1d proc~readrestartfiles->proc~zinterpolate1d proc~zinterpolatet1d zinterpolatet1d proc~readrestartfiles->proc~zinterpolatet1d mpi_sendrecv mpi_sendrecv proc~excjs->mpi_sendrecv proc~all_all_j->mpi_alltoall mpi_barrier mpi_barrier proc~barrou->mpi_barrier proc~writestat_time_nc->nf90_inq_varid proc~writestat_time_nc->nf90_put_var proc~writestat_time_nc->nf90_sync proc~subgridnamelist->mpi_bcast proc~dispthicknessexp->utav proc~excj->mpi_sendrecv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code DALESURBAN Source Code program DALESURBAN !Version 48 !!---------------------------------------------------------------- !!     0.0    USE STATEMENTS FOR CORE MODULES !!---------------------------------------------------------------- use modmpi , only : myid , initmpi use modglobal , only : rk3step , timeleft , ib , jb , kb , ke use modstartup , only : startup , exitmodules use modsave , only : writerestartfiles use modboundary , only : boundary , grwdamp , tqaver use modthermodynamics , only : thermodynamics !  use modsurface,        only : surface use modsubgrid , only : subgrid use modforces , only : forces , coriolis , lstend , fixuinf1 , fixuinf2 , fixthetainf , nudge , masscorr use modpois , only : poisson use modibm , only : createwalls , ibmwallfun , ibmnorm , nearwall , bottom use initfac , only : readfacetfiles use modEB , only : initEB , EB !---------------------------------------------------------------- !     0.1     USE STATEMENTS FOR ADDONS STATISTICAL ROUTINES !---------------------------------------------------------------- use modchecksim , only : initchecksim , checksim use modstat_nc , only : initstat_nc use modfielddump , only : initfielddump , fielddump , exitfielddump use modstatsdump , only : initstatsdump , statsdump , exitstatsdump !tg3315 !use modbudget,       only : initbudget, budgetstat, exitbudget implicit none !---------------------------------------------------------------- !     1      READ NAMELISTS,INITIALISE GRID, CONSTANTS AND FIELDS !---------------------------------------------------------------- call initmpi write ( * , * ) \"done initmpi\" call startup write ( * , * ) \"done startup\" !--------------------------------------------------------- !      2     INITIALIZE STATISTICAL ROUTINES AND ADD-ONS !--------------------------------------------------------- call initchecksim call initstat_nc call initfielddump call initstatsdump !tg3315 call readfacetfiles call initEB write ( * , * ) \"done init stuff\" write ( 6 , * ) 'Determine immersed walls' call createwalls ! determine walls/blocks ! call nearwall       ! determine minimum distance and corresponding shear components, ils13 10.07.17, commented, not functional at the moment, not needed for vreman but for smag., fix in modibm write ( 6 , * ) 'Finished determining immersed walls' call boundary !ils13 22.06.2017 inserted boundary here to get values at ghost cells before iteration starts !  not necessary but abates the fact that temp field is randomised by randomisation of just velocity fields !  (because advection at start of time loop without being divergence free) !  call poisson !------------------------------------------------------ !   3.0   MAIN TIME LOOP !------------------------------------------------------ write ( * , * ) 'START myid ' , myid do while (( timeleft > 0 ) . or . ( rk3step < 3 )) call tstep_update !----------------------------------------------------- !   3.2   ADVECTION AND DIFFUSION !----------------------------------------------------- call advection ! now also includes predicted pressure gradient term call subgrid !----------------------------------------------------- !   3.3   THE SURFACE LAYER !----------------------------------------------------- call bottom !----------------------------------------------------- !   3.4   REMAINING TERMS !----------------------------------------------------- call coriolis !remaining terms of ns equation call forces !remaining terms of ns equation call lstend !large scale forcings call nudge ! nudge top cells of fields to enforce steady-state call ibmwallfun ! immersed boundary forcing: only shear forces. call masscorr ! correct pred. velocity pup to get correct mass flow call ibmnorm ! immersed boundary forcing: set normal velocities to zero call EB call scalsource ! adds continuous forces in specified region of domain !------------------------------------------------------ !   3.4   EXECUTE ADD ONS !------------------------------------------------------ call fixuinf2 call fixuinf1 !----------------------------------------------------------------------- !   3.5  PRESSURE FLUCTUATIONS, TIME INTEGRATION AND BOUNDARY CONDITIONS !----------------------------------------------------------------------- call grwdamp !damping at top of the model call poisson call tstep_integrate call boundary call fixthetainf !----------------------------------------------------- !   3.6   LIQUID WATER CONTENT AND DIAGNOSTIC FIELDS !----------------------------------------------------- call thermodynamics !----------------------------------------------------- !   3.7  WRITE RESTARTFILES AND DO STATISTICS !------------------------------------------------------ call checksim ! call writedatafiles   ! write data files for later analysis call writerestartfiles call fielddump call statsdump ! tg3315 end do !------------------------------------------------------- !             END OF TIME LOOP !------------------------------------------------------- !-------------------------------------------------------- !    4    FINALIZE ADD ONS AND THE MAIN PROGRAM !------------------------------------------------------- call exitfielddump call exitstatsdump !tg3315 call exitmodules end program DALESURBAN","tags":"","loc":"program/dalesurban.html"}]}